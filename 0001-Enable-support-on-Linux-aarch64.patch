From 8284ccb46900baebe97a622c9b8c6944f00513d6 Mon Sep 17 00:00:00 2001
From: Daniel Tsai <idaniel.twc@gmail.com>
Date: Sun, 20 Sep 2020 11:57:10 +0800
Subject: [PATCH] Enable support on Linux aarch64 Enable support on Linux
 aarch64 [2/2]

Update google_breakpad build script

Enable support on Linux aarch64 [1/2]

Update google breakpad to latest commit(9c4671f)
Update linux_syscall_support.h
---
 .../client/apple/Framework/BreakpadDefines.h  |    1 +
 .../google_breakpad/client/ios/Breakpad.h     |   67 +-
 .../google_breakpad/client/ios/Breakpad.mm    |  457 ++--
 .../ios/Breakpad.xcodeproj/project.pbxproj    |   30 +-
 .../client/ios/BreakpadController.h           |   38 +-
 .../client/ios/BreakpadController.mm          |  133 +-
 .../client/ios/exception_handler_no_mach.cc   |  262 ++
 .../client/ios/exception_handler_no_mach.h    |  179 ++
 .../ios_exception_minidump_generator.h        |   14 +-
 .../ios_exception_minidump_generator.mm       |   33 +-
 .../crash_generation_client.cc                |  107 +-
 .../crash_generation_client.h                 |   40 +-
 .../crash_generation_server.cc                |  147 +-
 .../linux/dump_writer_common/mapping_info.h   |   74 +
 .../dump_writer_common/raw_context_cpu.h      |   53 +
 .../linux/dump_writer_common/thread_info.cc   |  305 +++
 .../linux/dump_writer_common/thread_info.h    |   91 +
 .../dump_writer_common/ucontext_reader.cc     |  259 ++
 .../dump_writer_common/ucontext_reader.h      |   65 +
 .../client/linux/handler/exception_handler.cc |  258 +-
 .../client/linux/handler/exception_handler.h  |   48 +-
 .../handler/exception_handler_unittest.cc     |  184 +-
 .../linux/handler/microdump_extra_info.h      |   52 +
 .../linux/handler/minidump_descriptor.cc      |   26 +-
 .../linux/handler/minidump_descriptor.h       |  119 +-
 .../google_breakpad/client/linux/log/log.cc   |   38 +-
 .../google_breakpad/client/linux/log/log.h    |   14 +
 .../microdump_writer/microdump_writer.cc      |  664 +++++
 .../linux/microdump_writer/microdump_writer.h |   68 +
 .../microdump_writer_unittest.cc              |  421 ++++
 .../directory_reader_unittest.cc              |    2 +-
 .../linux/minidump_writer/line_reader.h       |    2 +-
 .../minidump_writer/line_reader_unittest.cc   |   14 +-
 .../minidump_writer/linux_core_dumper.cc      |   78 +-
 .../linux/minidump_writer/linux_core_dumper.h |    9 +-
 .../linux_core_dumper_unittest.cc             |   99 +-
 .../linux/minidump_writer/linux_dumper.cc     |  707 +++++-
 .../linux/minidump_writer/linux_dumper.h      |  226 +-
 .../linux_dumper_unittest_helper.cc           |   13 +-
 .../minidump_writer/linux_ptrace_dumper.cc    |   90 +-
 .../minidump_writer/linux_ptrace_dumper.h     |   13 +-
 .../linux_ptrace_dumper_unittest.cc           |  267 +-
 .../linux/minidump_writer/minidump_writer.cc  | 1039 +++-----
 .../linux/minidump_writer/minidump_writer.h   |   44 +-
 .../minidump_writer_unittest.cc               |  283 ++-
 .../minidump_writer_unittest_utils.cc         |    2 +-
 .../proc_cpuinfo_reader_unittest.cc           |    6 +-
 .../sender/google_crash_report_sender.cc      |    7 +-
 .../mac/Breakpad.xcodeproj/project.pbxproj    |  161 +-
 .../client/mac/Framework/Breakpad.h           |   27 +-
 .../client/mac/Framework/Breakpad.mm          |  273 ++-
 .../client/mac/Framework/OnDemandServer.h     |   14 +-
 .../client/mac/Framework/OnDemandServer.mm    |   14 +-
 .../client/mac/crash_generation/ConfigFile.h  |   26 +-
 .../client/mac/crash_generation/ConfigFile.mm |   30 +-
 .../client/mac/crash_generation/Inspector.h   |   19 +-
 .../client/mac/crash_generation/Inspector.mm  |   81 +-
 .../crash_generation_client.cc                |    2 +-
 .../crash_generation_server.cc                |   24 +-
 .../crash_generation_server.h                 |   32 +-
 .../client/mac/handler/breakpad_nlist_64.cc   |   92 +-
 .../client/mac/handler/breakpad_nlist_64.h    |   13 +-
 .../client/mac/handler/dynamic_images.cc      |   54 +-
 .../client/mac/handler/dynamic_images.h       |   28 +-
 .../client/mac/handler/exception_handler.cc   |   25 +-
 .../client/mac/handler/exception_handler.h    |   62 +-
 .../client/mac/handler/mach_vm_compat.h       |    4 -
 .../client/mac/handler/minidump_generator.cc  |  303 +--
 .../client/mac/handler/minidump_generator.h   |   95 +-
 .../minidump_test.xcodeproj/project.pbxproj   |   26 +-
 .../handler/testcases/DynamicImagesTests.cc   |    6 +-
 .../handler/testcases/breakpad_nlist_test.cc  |   12 +-
 .../handler/testcases/breakpad_nlist_test.h   |    2 +-
 .../client/mac/handler/ucontext_compat.h      |    4 +-
 .../client/mac/sender/Breakpad.xib            |    4 +-
 .../client/mac/sender/uploader.h              |   25 +
 .../client/mac/sender/uploader.mm             |  152 +-
 .../client/mac/testapp/crashInMain            |  Bin
 .../client/mac/testapp/crashduringload        |  Bin
 .../google_breakpad/client/mac/testapp/main.m |    2 +-
 .../mac/tests/crash_generation_server_test.cc |    8 +-
 .../mac/tests/exception_handler_test.cc       |   23 +-
 .../mac/tests/minidump_generator_test.cc      |    5 +-
 .../client/minidump_file_writer-inl.h         |    4 +-
 .../client/minidump_file_writer.cc            |  110 +-
 .../client/minidump_file_writer.h             |   46 +-
 .../client/minidump_file_writer_unittest.cc   |   19 +-
 .../client/solaris/handler/Makefile           |    7 +-
 .../solaris/handler/exception_handler.cc      |   22 +-
 .../solaris/handler/exception_handler.h       |   32 +-
 .../solaris/handler/exception_handler_test.cc |   14 +-
 .../solaris/handler/minidump_generator.cc     |  176 +-
 .../solaris/handler/minidump_generator.h      |    8 +-
 .../client/solaris/handler/minidump_test.cc   |    2 +-
 .../client/solaris/handler/solaris_lwp.cc     |   72 +-
 .../client/solaris/handler/solaris_lwp.h      |   16 +-
 .../client/windows/breakpad_client.gyp        |    5 +-
 .../windows/common/auto_critical_section.h    |    2 +-
 .../client/windows/common/ipc_protocol.h      |    4 +-
 .../windows/crash_generation/client_info.cc   |    6 +-
 .../windows/crash_generation/client_info.h    |    4 +-
 .../crash_generation/crash_generation.gyp     |    5 +-
 .../crash_generation_client.cc                |   16 +-
 .../crash_generation_server.cc                |   46 +-
 .../crash_generation_server.h                 |    4 +-
 .../crash_generation/minidump_generator.cc    |  354 ++-
 .../crash_generation/minidump_generator.h     |  146 +-
 .../windows/handler/exception_handler.cc      |  111 +-
 .../windows/handler/exception_handler.gyp     |    5 +-
 .../windows/handler/exception_handler.h       |   44 +-
 .../windows/sender/crash_report_sender.cc     |   18 +-
 .../windows/sender/crash_report_sender.gyp    |    5 +-
 .../windows/sender/crash_report_sender.h      |   20 +-
 .../crash_generation_app.cc                   |   30 +-
 .../crash_generation_app.gyp                  |    8 +-
 .../client/windows/unittests/client_tests.gyp |    9 +-
 .../unittests/crash_generation_server_test.cc |   11 +-
 .../client/windows/unittests/dump_analysis.cc |    6 +-
 .../unittests/exception_handler_death_test.cc |   43 +-
 .../exception_handler_nesting_test.cc         |    6 +-
 .../unittests/exception_handler_test.cc       |   24 +-
 .../client/windows/unittests/minidump_test.cc |   29 +-
 .../client/windows/unittests/testing.gyp      |   38 +-
 .../common/android/breakpad_getcontext.S      |  224 --
 .../android/breakpad_getcontext_unittest.cc   |   94 -
 .../common/android/include/asm-mips/README.md |    9 +
 .../common/android/include/asm-mips/asm.h     |  270 +++
 .../android/include/asm-mips/fpregdef.h       |  117 +
 .../common/android/include/asm-mips/regdef.h  |  125 +
 .../common/android/include/elf.h              |    8 +-
 .../common/android/include/link.h             |   22 +-
 .../common/android/include/sys/procfs.h       |   13 +-
 .../common/android/include/sys/ucontext.h     |  174 --
 .../common/android/include/sys/user.h         |  126 +-
 .../common/android/testing/include/wchar.h    |    4 +
 .../common/android/testing/pthread_fixes.h    |    7 +-
 .../google_breakpad/common/byte_cursor.h      |   49 +-
 .../common/byte_cursor_unittest.cc            |   12 +-
 .../google_breakpad/common/common.gyp         |  260 ++
 .../common/{convert_UTF.c => convert_UTF.cc}  |  317 ++-
 .../google_breakpad/common/convert_UTF.h      |   59 +-
 .../common/dwarf/bytereader-inl.h             |   86 +-
 .../common/dwarf/bytereader.cc                |   33 +-
 .../google_breakpad/common/dwarf/bytereader.h |   60 +-
 .../common/dwarf/bytereader_unittest.cc       |   50 +-
 .../common/dwarf/cfi_assembler.cc             |   20 +-
 .../common/dwarf/cfi_assembler.h              |   48 +-
 .../common/dwarf/dwarf2diehandler.cc          |   55 +-
 .../common/dwarf/dwarf2diehandler.h           |   68 +-
 .../common/dwarf/dwarf2diehandler_unittest.cc |   42 +-
 .../common/dwarf/dwarf2enums.h                |   75 +-
 .../common/dwarf/dwarf2reader.cc              | 1427 ++++++++---
 .../common/dwarf/dwarf2reader.h               |  728 ++++--
 .../common/dwarf/dwarf2reader_cfi_unittest.cc |  226 +-
 .../common/dwarf/dwarf2reader_die_unittest.cc |   63 +-
 .../dwarf/dwarf2reader_lineinfo_unittest.cc   |  187 ++
 .../common/dwarf/dwarf2reader_test_common.h   |   24 +-
 .../common/dwarf/elf_reader.cc                | 1274 ++++++++++
 .../google_breakpad/common/dwarf/elf_reader.h |  167 ++
 .../common/dwarf/functioninfo.cc              |   55 +-
 .../common/dwarf/functioninfo.h               |   41 +-
 .../common/dwarf/line_state_machine.h         |    8 +-
 .../google_breakpad/common/dwarf/types.h      |   18 +-
 .../common/dwarf_cfi_to_module.cc             |   52 +-
 .../common/dwarf_cfi_to_module.h              |   55 +-
 .../common/dwarf_cfi_to_module_unittest.cc    |   10 +-
 .../common/dwarf_cu_to_module.cc              |  636 +++--
 .../common/dwarf_cu_to_module.h               |  106 +-
 .../common/dwarf_cu_to_module_unittest.cc     |  324 ++-
 .../common/dwarf_line_to_module.cc            |   22 +-
 .../common/dwarf_line_to_module.h             |   24 +-
 .../common/dwarf_line_to_module_unittest.cc   |    8 +-
 .../common/dwarf_range_list_handler.cc        |   60 +
 .../common/dwarf_range_list_handler.h         |   79 +
 .../google_breakpad/common/language.cc        |  164 +-
 .../google_breakpad/common/language.h         |   21 +-
 .../common/linux/breakpad_getcontext.S        |  486 ++++
 .../breakpad_getcontext.h}                    |   20 +-
 .../linux/breakpad_getcontext_unittest.cc     |  194 ++
 .../google_breakpad/common/linux/crc32.cc     |   70 +
 .../google_breakpad/common/linux/crc32.h      |   53 +
 .../common/linux/dump_symbols.cc              |  588 +++--
 .../common/linux/dump_symbols.h               |   19 +-
 .../common/linux/dump_symbols_unittest.cc     |   80 +-
 .../common/linux/eintr_wrapper.h              |   13 +-
 .../common/linux/elf_core_dump.h              |    9 +-
 .../common/linux/elf_core_dump_unittest.cc    |   60 +-
 .../common/linux/elf_gnu_compat.h             |    5 +
 .../common/linux/elf_symbols_to_module.cc     |   32 +-
 .../common/linux/elf_symbols_to_module.h      |    6 +-
 .../linux/elf_symbols_to_module_unittest.cc   |    2 +-
 .../google_breakpad/common/linux/elfutils.cc  |  139 +-
 .../google_breakpad/common/linux/elfutils.h   |   57 +-
 .../google_breakpad/common/linux/file_id.cc   |  131 +-
 .../google_breakpad/common/linux/file_id.h    |   39 +-
 .../common/linux/file_id_unittest.cc          |  256 +-
 .../common/linux/google_crashdump_uploader.cc |   20 +-
 .../common/linux/google_crashdump_uploader.h  |   15 +-
 .../linux/google_crashdump_uploader_test.cc   |   23 +-
 .../common/linux/guid_creator.cc              |   99 +-
 .../common/linux/http_upload.cc               |   94 +-
 .../common/linux/http_upload.h                |   34 +-
 .../google_breakpad/common/linux/ignore_ret.h |    2 +-
 .../common/linux/libcurl_wrapper.cc           |  232 +-
 .../common/linux/libcurl_wrapper.h            |   61 +-
 .../common/linux/linux_libc_support.cc        |    2 +-
 .../common/linux/memory_mapped_file.cc        |   31 +-
 .../common/linux/memory_mapped_file.h         |    5 +-
 .../linux/memory_mapped_file_unittest.cc      |   54 +-
 .../common/linux/symbol_collector_client.cc   |  195 ++
 .../common/linux/symbol_collector_client.h    |   88 +
 .../common/linux/symbol_upload.cc             |  284 +++
 .../common/linux/symbol_upload.h              |   76 +
 .../google_breakpad/common/linux/synth_elf.cc |    8 +-
 .../google_breakpad/common/linux/synth_elf.h  |    6 +-
 .../common/linux/synth_elf_unittest.cc        |    6 +-
 .../common/linux/tests/crash_generator.cc     |   67 +-
 .../{android => linux}/ucontext_constants.h   |   77 +-
 .../common/long_string_dictionary.cc          |  178 ++
 .../common/long_string_dictionary.h           |   87 +
 .../common/long_string_dictionary_unittest.cc |  301 +++
 .../common/mac/Breakpad.xcconfig              |   12 +-
 .../google_breakpad/common/mac/GTMDefines.h   |   46 +-
 .../common/mac/GTMGarbageCollection.h         |   72 -
 .../google_breakpad/common/mac/GTMLogger.m    |    3 +-
 .../sys/signal.h => mac/HTTPGetRequest.h}     |   17 +-
 .../sys/stat.h => mac/HTTPGetRequest.m}       |   16 +-
 .../common/mac/HTTPMultipartUpload.h          |   52 +-
 .../common/mac/HTTPMultipartUpload.m          |  141 +-
 .../common/mac/HTTPPutRequest.h               |   51 +
 .../common/mac/HTTPPutRequest.m               |   62 +
 .../google_breakpad/common/mac/HTTPRequest.h  |   73 +
 .../google_breakpad/common/mac/HTTPRequest.m  |  213 ++
 .../common/mac/HTTPSimplePostRequest.h        |   57 +
 .../common/mac/HTTPSimplePostRequest.m        |   69 +
 .../google_breakpad/common/mac/MachIPC.h      |   22 +-
 .../google_breakpad/common/mac/MachIPC.mm     |   26 +-
 .../common/mac/SymbolCollectorClient.h        |  103 +
 .../common/mac/SymbolCollectorClient.m        |  268 ++
 .../common/mac/arch_utilities.cc              |  179 +-
 .../google_breakpad/common/mac/byteswap.h     |   25 +
 .../common/mac/{dump_syms.mm => dump_syms.cc} |  482 ++--
 .../google_breakpad/common/mac/dump_syms.h    |   69 +-
 .../common/mac/encoding_util.h                |   41 +
 .../common/mac/encoding_util.m                |   47 +
 .../google_breakpad/common/mac/file_id.cc     |    5 +-
 .../google_breakpad/common/mac/file_id.h      |    2 +-
 .../common/mac/launch_reporter.cc             |   84 +
 .../common/mac/launch_reporter.h              |   43 +
 .../google_breakpad/common/mac/macho_id.cc    |   70 +-
 .../google_breakpad/common/mac/macho_id.h     |   28 +-
 .../common/mac/macho_reader.cc                |  119 +-
 .../google_breakpad/common/mac/macho_reader.h |   69 +-
 .../common/mac/macho_reader_unittest.cc       |  116 +-
 .../common/mac/macho_utilities.cc             |   89 +-
 .../common/mac/macho_utilities.h              |   27 +-
 .../common/mac/macho_walker.cc                |   52 +-
 .../google_breakpad/common/mac/macho_walker.h |   26 +-
 .../common/mac/minidump_upload.m              |  135 ++
 .../common/mac/string_utilities.cc            |    4 +-
 .../common/mac/string_utilities.h             |    2 +-
 .../common/mac/super_fat_arch.h               |   88 +
 .../common/mac/testing/GTMSenTestCase.m       |   72 -
 src/MEGASync/google_breakpad/common/macros.h  |   45 +
 src/MEGASync/google_breakpad/common/md5.cc    |   22 +-
 src/MEGASync/google_breakpad/common/md5.h     |    2 +-
 .../common/{memory.h => memory_allocator.h}   |  104 +-
 ...ittest.cc => memory_allocator_unittest.cc} |   35 +-
 .../common/minidump_type_helper.h             |   56 +
 src/MEGASync/google_breakpad/common/module.cc |  170 +-
 src/MEGASync/google_breakpad/common/module.h  |  104 +-
 .../google_breakpad/common/module_unittest.cc |  286 ++-
 .../google_breakpad/common/path_helper.cc     |   55 +
 .../google_breakpad/common/path_helper.h      |   44 +
 .../common/simple_string_dictionary.h         |   81 +-
 .../simple_string_dictionary_unittest.cc      |   31 +
 .../common/solaris/dump_symbols.cc            |  149 +-
 .../common/solaris/dump_symbols.h             |    2 +-
 .../google_breakpad/common/solaris/file_id.cc |   36 +-
 .../common/solaris/guid_creator.cc            |    6 +-
 .../google_breakpad/common/stabs_reader.cc    |   26 +-
 .../google_breakpad/common/stabs_reader.h     |   41 +-
 .../common/stabs_reader_unittest.cc           |   36 +-
 .../google_breakpad/common/stabs_to_module.cc |   27 +-
 .../google_breakpad/common/stabs_to_module.h  |    6 +-
 .../common/stabs_to_module_unittest.cc        |   18 +-
 .../include/sgidefs.h => stdio_wrapper.h}     |   26 +-
 .../common/string_conversion.cc               |   58 +-
 .../common/string_conversion.h                |    8 +-
 .../common/string_conversion_unittest.cc      |   64 +
 .../google_breakpad/common/test_assembler.cc  |   48 +-
 .../google_breakpad/common/test_assembler.h   |   70 +-
 .../common/test_assembler_unittest.cc         |    8 +-
 .../common/tests/file_utils.cc                |    4 +
 .../google_breakpad/common/tests/file_utils.h |    3 +
 .../google_breakpad/common/unordered.h        |   62 +
 .../common/windows/common_windows.gyp         |   31 +-
 .../common/windows/dia_util.cc                |    2 +-
 .../google_breakpad/common/windows/dia_util.h |    5 +
 .../common/windows/guid_string.h              |    8 +-
 .../common/windows/http_upload.cc             |  704 +++---
 .../common/windows/http_upload.h              |  120 +-
 .../common/windows/module_info.h              |   75 +
 .../google_breakpad/common/windows/omap.cc    |   24 +-
 .../google_breakpad/common/windows/omap.h     |    6 +-
 .../common/windows/omap_internal.h            |    9 +-
 .../common/windows/omap_unittest.cc           |    3 +-
 .../common/windows/pdb_source_line_writer.cc  |  458 ++--
 .../common/windows/pdb_source_line_writer.h   |  119 +-
 .../common/windows/pe_source_line_writer.cc   |   77 +
 .../common/windows/pe_source_line_writer.h    |   69 +
 .../google_breakpad/common/windows/pe_util.cc |  407 ++++
 .../google_breakpad/common/windows/pe_util.h  |   78 +
 .../common/windows/string_utils-inl.h         |   28 +-
 .../common/windows/string_utils.cc            |   14 +-
 .../common/windows/symbol_collector_client.cc |  155 ++
 .../common/windows/symbol_collector_client.h  |   89 +
 .../google_breakpad/google_breakpad.pri       |    8 +-
 .../google_breakpad/common/breakpad_types.h   |   30 +-
 .../common/minidump_cpu_arm64.h               |   80 +-
 .../common/minidump_cpu_mips.h                |   38 +-
 .../google_breakpad/common/minidump_cpu_ppc.h |    5 +
 .../common/minidump_cpu_ppc64.h               |    5 +
 .../common/minidump_cpu_sparc.h               |    5 +
 .../common/minidump_exception_fuchsia.h       |   58 +
 .../common/minidump_exception_linux.h         |   38 +
 .../common/minidump_exception_mac.h           |    8 +-
 .../common/minidump_exception_win32.h         | 2155 ++++++++++++++++-
 .../google_breakpad/common/minidump_format.h  |  213 +-
 .../google_breakpad/common/minidump_size.h    |    6 +
 .../processor/basic_source_line_resolver.h    |   56 +-
 .../google_breakpad/processor/call_stack.h    |   12 +-
 .../google_breakpad/processor/code_module.h   |   12 +-
 .../google_breakpad/processor/code_modules.h  |   10 +
 .../google_breakpad/processor/dump_context.h  |  116 +
 .../google_breakpad/processor/dump_object.h   |   53 +
 .../processor/exception_record.h              |  124 +
 .../processor/exploitability.h                |    9 +
 .../google_breakpad/processor/memory_region.h |    3 +
 .../google_breakpad/processor/microdump.h     |  135 ++
 .../processor/microdump_processor.h           |   64 +
 .../google_breakpad/processor/minidump.h      |  468 +++-
 .../processor/minidump_processor.h            |   50 +-
 .../processor/proc_maps_linux.h               |   60 +
 .../processor/process_result.h                |   66 +
 .../google_breakpad/processor/process_state.h |   37 +-
 .../processor/source_line_resolver_base.h     |   40 +-
 .../source_line_resolver_interface.h          |   24 +-
 .../google_breakpad/processor/stack_frame.h   |    2 +-
 .../processor/stack_frame_symbolizer.h        |    8 +-
 .../google_breakpad/processor/stackwalker.h   |   36 +-
 .../processor/symbol_supplier.h               |   28 +-
 .../google_breakpad/processor/system_info.h   |   10 +-
 .../third_party/lss/linux_syscall_support.h   | 1412 +++++++++--
 354 files changed, 27327 insertions(+), 8381 deletions(-)
 create mode 100644 src/MEGASync/google_breakpad/client/ios/exception_handler_no_mach.cc
 create mode 100644 src/MEGASync/google_breakpad/client/ios/exception_handler_no_mach.h
 create mode 100644 src/MEGASync/google_breakpad/client/linux/dump_writer_common/mapping_info.h
 create mode 100644 src/MEGASync/google_breakpad/client/linux/dump_writer_common/raw_context_cpu.h
 create mode 100644 src/MEGASync/google_breakpad/client/linux/dump_writer_common/thread_info.cc
 create mode 100644 src/MEGASync/google_breakpad/client/linux/dump_writer_common/thread_info.h
 create mode 100644 src/MEGASync/google_breakpad/client/linux/dump_writer_common/ucontext_reader.cc
 create mode 100644 src/MEGASync/google_breakpad/client/linux/dump_writer_common/ucontext_reader.h
 create mode 100644 src/MEGASync/google_breakpad/client/linux/handler/microdump_extra_info.h
 create mode 100644 src/MEGASync/google_breakpad/client/linux/microdump_writer/microdump_writer.cc
 create mode 100644 src/MEGASync/google_breakpad/client/linux/microdump_writer/microdump_writer.h
 create mode 100644 src/MEGASync/google_breakpad/client/linux/microdump_writer/microdump_writer_unittest.cc
 mode change 100644 => 100755 src/MEGASync/google_breakpad/client/mac/testapp/crashInMain
 mode change 100644 => 100755 src/MEGASync/google_breakpad/client/mac/testapp/crashduringload
 delete mode 100644 src/MEGASync/google_breakpad/common/android/breakpad_getcontext.S
 delete mode 100644 src/MEGASync/google_breakpad/common/android/breakpad_getcontext_unittest.cc
 create mode 100644 src/MEGASync/google_breakpad/common/android/include/asm-mips/README.md
 create mode 100644 src/MEGASync/google_breakpad/common/android/include/asm-mips/asm.h
 create mode 100644 src/MEGASync/google_breakpad/common/android/include/asm-mips/fpregdef.h
 create mode 100644 src/MEGASync/google_breakpad/common/android/include/asm-mips/regdef.h
 delete mode 100644 src/MEGASync/google_breakpad/common/android/include/sys/ucontext.h
 create mode 100644 src/MEGASync/google_breakpad/common/common.gyp
 rename src/MEGASync/google_breakpad/common/{convert_UTF.c => convert_UTF.cc} (65%)
 create mode 100644 src/MEGASync/google_breakpad/common/dwarf/dwarf2reader_lineinfo_unittest.cc
 create mode 100644 src/MEGASync/google_breakpad/common/dwarf/elf_reader.cc
 create mode 100644 src/MEGASync/google_breakpad/common/dwarf/elf_reader.h
 create mode 100644 src/MEGASync/google_breakpad/common/dwarf_range_list_handler.cc
 create mode 100644 src/MEGASync/google_breakpad/common/dwarf_range_list_handler.h
 create mode 100644 src/MEGASync/google_breakpad/common/linux/breakpad_getcontext.S
 rename src/MEGASync/google_breakpad/common/{android/include/ucontext.h => linux/breakpad_getcontext.h} (82%)
 create mode 100644 src/MEGASync/google_breakpad/common/linux/breakpad_getcontext_unittest.cc
 create mode 100644 src/MEGASync/google_breakpad/common/linux/crc32.cc
 create mode 100644 src/MEGASync/google_breakpad/common/linux/crc32.h
 create mode 100644 src/MEGASync/google_breakpad/common/linux/symbol_collector_client.cc
 create mode 100644 src/MEGASync/google_breakpad/common/linux/symbol_collector_client.h
 create mode 100644 src/MEGASync/google_breakpad/common/linux/symbol_upload.cc
 create mode 100644 src/MEGASync/google_breakpad/common/linux/symbol_upload.h
 rename src/MEGASync/google_breakpad/common/{android => linux}/ucontext_constants.h (63%)
 create mode 100644 src/MEGASync/google_breakpad/common/long_string_dictionary.cc
 create mode 100644 src/MEGASync/google_breakpad/common/long_string_dictionary.h
 create mode 100644 src/MEGASync/google_breakpad/common/long_string_dictionary_unittest.cc
 delete mode 100644 src/MEGASync/google_breakpad/common/mac/GTMGarbageCollection.h
 rename src/MEGASync/google_breakpad/common/{android/include/sys/signal.h => mac/HTTPGetRequest.h} (86%)
 rename src/MEGASync/google_breakpad/common/{android/include/sys/stat.h => mac/HTTPGetRequest.m} (84%)
 create mode 100644 src/MEGASync/google_breakpad/common/mac/HTTPPutRequest.h
 create mode 100644 src/MEGASync/google_breakpad/common/mac/HTTPPutRequest.m
 create mode 100644 src/MEGASync/google_breakpad/common/mac/HTTPRequest.h
 create mode 100644 src/MEGASync/google_breakpad/common/mac/HTTPRequest.m
 create mode 100644 src/MEGASync/google_breakpad/common/mac/HTTPSimplePostRequest.h
 create mode 100644 src/MEGASync/google_breakpad/common/mac/HTTPSimplePostRequest.m
 create mode 100644 src/MEGASync/google_breakpad/common/mac/SymbolCollectorClient.h
 create mode 100644 src/MEGASync/google_breakpad/common/mac/SymbolCollectorClient.m
 rename src/MEGASync/google_breakpad/common/mac/{dump_syms.mm => dump_syms.cc} (60%)
 create mode 100644 src/MEGASync/google_breakpad/common/mac/encoding_util.h
 create mode 100644 src/MEGASync/google_breakpad/common/mac/encoding_util.m
 create mode 100644 src/MEGASync/google_breakpad/common/mac/launch_reporter.cc
 create mode 100644 src/MEGASync/google_breakpad/common/mac/launch_reporter.h
 create mode 100644 src/MEGASync/google_breakpad/common/mac/minidump_upload.m
 create mode 100644 src/MEGASync/google_breakpad/common/mac/super_fat_arch.h
 create mode 100644 src/MEGASync/google_breakpad/common/macros.h
 rename src/MEGASync/google_breakpad/common/{memory.h => memory_allocator.h} (65%)
 rename src/MEGASync/google_breakpad/common/{memory_unittest.cc => memory_allocator_unittest.cc} (72%)
 create mode 100644 src/MEGASync/google_breakpad/common/minidump_type_helper.h
 create mode 100644 src/MEGASync/google_breakpad/common/path_helper.cc
 create mode 100644 src/MEGASync/google_breakpad/common/path_helper.h
 rename src/MEGASync/google_breakpad/common/{android/include/sgidefs.h => stdio_wrapper.h} (73%)
 create mode 100644 src/MEGASync/google_breakpad/common/string_conversion_unittest.cc
 create mode 100644 src/MEGASync/google_breakpad/common/unordered.h
 create mode 100644 src/MEGASync/google_breakpad/common/windows/module_info.h
 create mode 100644 src/MEGASync/google_breakpad/common/windows/pe_source_line_writer.cc
 create mode 100644 src/MEGASync/google_breakpad/common/windows/pe_source_line_writer.h
 create mode 100644 src/MEGASync/google_breakpad/common/windows/pe_util.cc
 create mode 100644 src/MEGASync/google_breakpad/common/windows/pe_util.h
 create mode 100644 src/MEGASync/google_breakpad/common/windows/symbol_collector_client.cc
 create mode 100644 src/MEGASync/google_breakpad/common/windows/symbol_collector_client.h
 create mode 100644 src/MEGASync/google_breakpad/google_breakpad/common/minidump_exception_fuchsia.h
 create mode 100644 src/MEGASync/google_breakpad/google_breakpad/processor/dump_context.h
 create mode 100644 src/MEGASync/google_breakpad/google_breakpad/processor/dump_object.h
 create mode 100644 src/MEGASync/google_breakpad/google_breakpad/processor/exception_record.h
 create mode 100644 src/MEGASync/google_breakpad/google_breakpad/processor/microdump.h
 create mode 100644 src/MEGASync/google_breakpad/google_breakpad/processor/microdump_processor.h
 create mode 100644 src/MEGASync/google_breakpad/google_breakpad/processor/proc_maps_linux.h
 create mode 100644 src/MEGASync/google_breakpad/google_breakpad/processor/process_result.h

diff --git a/src/MEGASync/google_breakpad/client/apple/Framework/BreakpadDefines.h b/src/MEGASync/google_breakpad/client/apple/Framework/BreakpadDefines.h
index 8986cd1b..410a5a6f 100644
--- a/src/MEGASync/google_breakpad/client/apple/Framework/BreakpadDefines.h
+++ b/src/MEGASync/google_breakpad/client/apple/Framework/BreakpadDefines.h
@@ -62,6 +62,7 @@
 #define BREAKPAD_EMAIL                 "BreakpadEmail"
 #define BREAKPAD_SERVER_TYPE           "BreakpadServerType"
 #define BREAKPAD_SERVER_PARAMETER_DICT "BreakpadServerParameters"
+#define BREAKPAD_IN_PROCESS            "BreakpadInProcess"
 
 // The keys below are NOT user supplied, and are used internally.
 #define BREAKPAD_PROCESS_START_TIME       "BreakpadProcStartTime"
diff --git a/src/MEGASync/google_breakpad/client/ios/Breakpad.h b/src/MEGASync/google_breakpad/client/ios/Breakpad.h
index 3bec1a63..6c9b8bd6 100644
--- a/src/MEGASync/google_breakpad/client/ios/Breakpad.h
+++ b/src/MEGASync/google_breakpad/client/ios/Breakpad.h
@@ -37,7 +37,7 @@
 //
 // These files can then be uploaded to a server.
 
-typedef void *BreakpadRef;
+typedef void* BreakpadRef;
 
 #ifdef __cplusplus
 extern "C" {
@@ -60,7 +60,15 @@ extern "C" {
 typedef bool (*BreakpadFilterCallback)(int exception_type,
                                        int exception_code,
                                        mach_port_t crashing_thread,
-                                       void *context);
+                                       void* context);
+
+// Optional user-defined function that will be called after a network upload
+// of a crash report.
+// |report_id| will be the id returned by the server, or "ERR" if an error
+// occurred.
+// |error| will contain the error, or nil if no error occured.
+typedef void (*BreakpadUploadCompletionCallback)(NSString* report_id,
+                                                 NSError* error);
 
 // Create a new BreakpadRef object and install it as an exception
 // handler.  The |parameters| will typically be the contents of your
@@ -155,7 +163,7 @@ typedef bool (*BreakpadFilterCallback)(int exception_type,
 //                                   internal values.
 
 // Returns a new BreakpadRef object on success, NULL otherwise.
-BreakpadRef BreakpadCreate(NSDictionary *parameters);
+BreakpadRef BreakpadCreate(NSDictionary* parameters);
 
 // Uninstall and release the data associated with |ref|.
 void BreakpadRelease(BreakpadRef ref);
@@ -179,40 +187,73 @@ void BreakpadRelease(BreakpadRef ref);
 // TODO (nealsid): separate server parameter dictionary from the
 // dictionary used to configure Breakpad, and document limits for each
 // independently.
-void BreakpadSetKeyValue(BreakpadRef ref, NSString *key, NSString *value);
-NSString *BreakpadKeyValue(BreakpadRef ref, NSString *key);
-void BreakpadRemoveKeyValue(BreakpadRef ref, NSString *key);
+void BreakpadSetKeyValue(BreakpadRef ref, NSString* key, NSString* value);
+NSString* BreakpadKeyValue(BreakpadRef ref, NSString* key);
+void BreakpadRemoveKeyValue(BreakpadRef ref, NSString* key);
 
 // You can use this method to specify parameters that will be uploaded
 // to the crash server.  They will be automatically encoded as
 // necessary.  Note that as mentioned above there are limits on both
 // the number of keys and their length.
-void BreakpadAddUploadParameter(BreakpadRef ref, NSString *key,
-                                NSString *value);
+void BreakpadAddUploadParameter(BreakpadRef ref, NSString* key,
+                                NSString* value);
 
 // This method will remove a previously-added parameter from the
 // upload parameter set.
-void BreakpadRemoveUploadParameter(BreakpadRef ref, NSString *key);
+void BreakpadRemoveUploadParameter(BreakpadRef ref, NSString* key);
 
 // Method to handle uploading data to the server
 
 // Returns the number of crash reports waiting to send to the server.
 int BreakpadGetCrashReportCount(BreakpadRef ref);
 
+// Returns the next upload configuration. The report file is deleted.
+NSDictionary* BreakpadGetNextReportConfiguration(BreakpadRef ref);
+
+// Returns the date of the most recent crash report.
+NSDate* BreakpadGetDateOfMostRecentCrashReport(BreakpadRef ref);
+
 // Upload next report to the server.
 void BreakpadUploadNextReport(BreakpadRef ref);
 
+// Upload next report to the server.
+// |server_parameters| is additional server parameters to send.
+void BreakpadUploadNextReportWithParameters(
+    BreakpadRef ref,
+    NSDictionary* server_parameters,
+    BreakpadUploadCompletionCallback callback);
+
+// Upload a report to the server.
+// |server_parameters| is additional server parameters to send.
+// |configuration| is the configuration of the breakpad report to send.
+void BreakpadUploadReportWithParametersAndConfiguration(
+    BreakpadRef ref,
+    NSDictionary* server_parameters,
+    NSDictionary* configuration,
+    BreakpadUploadCompletionCallback callback);
+
+// Handles the network response of a breakpad upload. This function is needed if
+// the actual upload is done by the Breakpad client.
+// |configuration| is the configuration of the upload. It must contain the same
+// fields as the configuration passed to
+// BreakpadUploadReportWithParametersAndConfiguration.
+// |data| and |error| contain the network response.
+void BreakpadHandleNetworkResponse(BreakpadRef ref,
+                                   NSDictionary* configuration,
+                                   NSData* data,
+                                   NSError* error);
+
 // Upload a file to the server. |data| is the content of the file to sent.
 // |server_parameters| is additional server parameters to send.
-void BreakpadUploadData(BreakpadRef ref, NSData *data, NSString *name,
-                        NSDictionary *server_parameters);
+void BreakpadUploadData(BreakpadRef ref, NSData* data, NSString* name,
+                        NSDictionary* server_parameters);
 
 // Generate a breakpad minidump and configuration file in the dump directory.
 // The report will be available for uploading. The paths of the created files
 // are returned in the dictionary. |server_parameters| is additional server
 // parameters to add in the config file.
-NSDictionary *BreakpadGenerateReport(BreakpadRef ref,
-                                     NSDictionary *server_parameters);
+NSDictionary* BreakpadGenerateReport(BreakpadRef ref,
+                                     NSDictionary* server_parameters);
 
 #ifdef __cplusplus
 }
diff --git a/src/MEGASync/google_breakpad/client/ios/Breakpad.mm b/src/MEGASync/google_breakpad/client/ios/Breakpad.mm
index c46509e8..11c51746 100644
--- a/src/MEGASync/google_breakpad/client/ios/Breakpad.mm
+++ b/src/MEGASync/google_breakpad/client/ios/Breakpad.mm
@@ -31,20 +31,29 @@
 
 #import "client/ios/Breakpad.h"
 
+#include <assert.h>
 #import <Foundation/Foundation.h>
 #include <pthread.h>
 #include <sys/stat.h>
 #include <sys/sysctl.h>
+#include <TargetConditionals.h>
+
+#include <string>
 
 #import "client/ios/handler/ios_exception_minidump_generator.h"
 #import "client/mac/crash_generation/ConfigFile.h"
-#import "client/mac/handler/exception_handler.h"
 #import "client/mac/handler/minidump_generator.h"
-#import "client/mac/sender/uploader.h"
 #import "client/mac/handler/protected_memory_allocator.h"
-#import "common/simple_string_dictionary.h"
+#import "client/mac/sender/uploader.h"
+#import "common/long_string_dictionary.h"
 
-#ifndef __EXCEPTIONS
+#if !TARGET_OS_TV && !TARGET_OS_WATCH
+#import "client/mac/handler/exception_handler.h"
+#else
+#import "client/ios/exception_handler_no_mach.h"
+#endif  // !TARGET_OS_TV && !TARGET_OS_WATCH
+
+#if !defined(__EXCEPTIONS) || (__clang__ && !__has_feature(cxx_exceptions))
 // This file uses C++ try/catch (but shouldn't). Duplicate the macros from
 // <c++/4.2.1/exception_defines.h> allowing this file to work properly with
 // exceptions disabled even when other C++ libraries are used. #undef the try
@@ -58,7 +67,7 @@
 
 using google_breakpad::ConfigFile;
 using google_breakpad::EnsureDirectoryPathExists;
-using google_breakpad::SimpleStringDictionary;
+using google_breakpad::LongStringDictionary;
 
 //=============================================================================
 // We want any memory allocations which are used by breakpad during the
@@ -75,9 +84,9 @@ using google_breakpad::SimpleStringDictionary;
 // allocation of C++ objects.  Note that we don't use operator delete()
 // but instead call the objects destructor directly:  object->~ClassName();
 //
-ProtectedMemoryAllocator *gMasterAllocator = NULL;
-ProtectedMemoryAllocator *gKeyValueAllocator = NULL;
-ProtectedMemoryAllocator *gBreakpadAllocator = NULL;
+ProtectedMemoryAllocator* gMasterAllocator = NULL;
+ProtectedMemoryAllocator* gKeyValueAllocator = NULL;
+ProtectedMemoryAllocator* gBreakpadAllocator = NULL;
 
 // Mutex for thread-safe access to the key/value dictionary used by breakpad.
 // It's a global instead of an instance variable of Breakpad
@@ -91,48 +100,44 @@ pthread_mutex_t gDictionaryMutex;
 // ProtectedMemoryLocker will unprotect this block after taking the lock.
 // Its destructor will first re-protect the memory then release the lock.
 class ProtectedMemoryLocker {
-public:
-  // allocator may be NULL, in which case no Protect() or Unprotect() calls
-  // will be made, but a lock will still be taken
-  ProtectedMemoryLocker(pthread_mutex_t *mutex,
-                        ProtectedMemoryAllocator *allocator)
-  : mutex_(mutex), allocator_(allocator) {
+ public:
+  ProtectedMemoryLocker(pthread_mutex_t* mutex,
+                        ProtectedMemoryAllocator* allocator)
+      : mutex_(mutex),
+        allocator_(allocator) {
     // Lock the mutex
-    assert(pthread_mutex_lock(mutex_) == 0);
+    __attribute__((unused)) int rv = pthread_mutex_lock(mutex_);
+    assert(rv == 0);
 
     // Unprotect the memory
-    if (allocator_ ) {
-      allocator_->Unprotect();
-    }
+    allocator_->Unprotect();
   }
 
   ~ProtectedMemoryLocker() {
     // First protect the memory
-    if (allocator_) {
-      allocator_->Protect();
-    }
+    allocator_->Protect();
 
     // Then unlock the mutex
-    assert(pthread_mutex_unlock(mutex_) == 0);
-  };
+    __attribute__((unused)) int rv = pthread_mutex_unlock(mutex_);
+    assert(rv == 0);
+  }
 
-private:
-  //  Keep anybody from ever creating one of these things not on the stack.
-  ProtectedMemoryLocker() { }
+ private:
+  ProtectedMemoryLocker();
   ProtectedMemoryLocker(const ProtectedMemoryLocker&);
-  ProtectedMemoryLocker & operator=(ProtectedMemoryLocker&);
+  ProtectedMemoryLocker& operator=(const ProtectedMemoryLocker&);
 
-  pthread_mutex_t           *mutex_;
-  ProtectedMemoryAllocator  *allocator_;
+  pthread_mutex_t* mutex_;
+  ProtectedMemoryAllocator* allocator_;
 };
 
 //=============================================================================
 class Breakpad {
  public:
   // factory method
-  static Breakpad *Create(NSDictionary *parameters) {
+  static Breakpad* Create(NSDictionary* parameters) {
     // Allocate from our special allocation pool
-    Breakpad *breakpad =
+    Breakpad* breakpad =
       new (gBreakpadAllocator->Allocate(sizeof(Breakpad)))
         Breakpad();
 
@@ -150,53 +155,62 @@ class Breakpad {
 
   ~Breakpad();
 
-  void SetKeyValue(NSString *key, NSString *value);
-  NSString *KeyValue(NSString *key);
-  void RemoveKeyValue(NSString *key);
-  NSArray *CrashReportsToUpload();
-  NSString *NextCrashReportToUpload();
-  void UploadNextReport();
-  void UploadData(NSData *data, NSString *name,
-                  NSDictionary *server_parameters);
-  NSDictionary *GenerateReport(NSDictionary *server_parameters);
+  void SetKeyValue(NSString* key, NSString* value);
+  NSString* KeyValue(NSString* key);
+  void RemoveKeyValue(NSString* key);
+  NSArray* CrashReportsToUpload();
+  NSString* NextCrashReportToUpload();
+  NSDictionary* NextCrashReportConfiguration();
+  NSDictionary* FixedUpCrashReportConfiguration(NSDictionary* configuration);
+  NSDate* DateOfMostRecentCrashReport();
+  void UploadNextReport(NSDictionary* server_parameters);
+  void UploadReportWithConfiguration(NSDictionary* configuration,
+                                     NSDictionary* server_parameters,
+                                     BreakpadUploadCompletionCallback callback);
+  void UploadData(NSData* data, NSString* name,
+                  NSDictionary* server_parameters);
+  void HandleNetworkResponse(NSDictionary* configuration,
+                             NSData* data,
+                             NSError* error);
+  NSDictionary* GenerateReport(NSDictionary* server_parameters);
 
  private:
   Breakpad()
     : handler_(NULL),
       config_params_(NULL) {}
 
-  bool Initialize(NSDictionary *parameters);
+  bool Initialize(NSDictionary* parameters);
 
-  bool ExtractParameters(NSDictionary *parameters);
+  bool ExtractParameters(NSDictionary* parameters);
 
   // Dispatches to HandleMinidump()
-  static bool HandleMinidumpCallback(const char *dump_dir,
-                                     const char *minidump_id,
-                                     void *context, bool succeeded);
+  static bool HandleMinidumpCallback(const char* dump_dir,
+                                     const char* minidump_id,
+                                     void* context, bool succeeded);
 
-  bool HandleMinidump(const char *dump_dir,
-                      const char *minidump_id);
+  bool HandleMinidump(const char* dump_dir,
+                      const char* minidump_id);
 
   // NSException handler
-  static void UncaughtExceptionHandler(NSException *exception);
+  static void UncaughtExceptionHandler(NSException* exception);
 
   // Handle an uncaught NSException.
-  void HandleUncaughtException(NSException *exception);
+  void HandleUncaughtException(NSException* exception);
 
   // Since ExceptionHandler (w/o namespace) is defined as typedef in OSX's
   // MachineExceptions.h, we have to explicitly name the handler.
-  google_breakpad::ExceptionHandler *handler_; // The actual handler (STRONG)
+  google_breakpad::ExceptionHandler* handler_; // The actual handler (STRONG)
 
-  SimpleStringDictionary  *config_params_; // Create parameters (STRONG)
+  LongStringDictionary* config_params_; // Create parameters (STRONG)
 
   ConfigFile config_file_;
 
   // A static reference to the current Breakpad instance. Used for handling
   // NSException.
-  static Breakpad *current_breakpad_;
+  static Breakpad* current_breakpad_;
 };
 
-Breakpad *Breakpad::current_breakpad_ = NULL;
+Breakpad* Breakpad::current_breakpad_ = NULL;
 
 #pragma mark -
 #pragma mark Helper functions
@@ -207,14 +221,14 @@ Breakpad *Breakpad::current_breakpad_ = NULL;
 //=============================================================================
 static BOOL IsDebuggerActive() {
   BOOL result = NO;
-  NSUserDefaults *stdDefaults = [NSUserDefaults standardUserDefaults];
+  NSUserDefaults* stdDefaults = [NSUserDefaults standardUserDefaults];
 
   // We check both defaults and the environment variable here
 
   BOOL ignoreDebugger = [stdDefaults boolForKey:@IGNORE_DEBUGGER];
 
   if (!ignoreDebugger) {
-    char *ignoreDebuggerStr = getenv(IGNORE_DEBUGGER);
+    char* ignoreDebuggerStr = getenv(IGNORE_DEBUGGER);
     ignoreDebugger =
         (ignoreDebuggerStr ? strtol(ignoreDebuggerStr, NULL, 10) : 0) != 0;
   }
@@ -226,7 +240,7 @@ static BOOL IsDebuggerActive() {
     size_t actualSize;
 
     if (sysctl(mib, mibSize, NULL, &actualSize, NULL, 0) == 0) {
-      struct kinfo_proc *info = (struct kinfo_proc *)malloc(actualSize);
+      struct kinfo_proc* info = (struct kinfo_proc*)malloc(actualSize);
 
       if (info) {
         // This comes from looking at the Darwin xnu Kernel
@@ -242,10 +256,10 @@ static BOOL IsDebuggerActive() {
 }
 
 //=============================================================================
-bool Breakpad::HandleMinidumpCallback(const char *dump_dir,
-                                      const char *minidump_id,
-                                      void *context, bool succeeded) {
-  Breakpad *breakpad = (Breakpad *)context;
+bool Breakpad::HandleMinidumpCallback(const char* dump_dir,
+                                      const char* minidump_id,
+                                      void* context, bool succeeded) {
+  Breakpad* breakpad = (Breakpad*)context;
 
   // If our context is damaged or something, just return false to indicate that
   // the handler should continue without us.
@@ -256,10 +270,11 @@ bool Breakpad::HandleMinidumpCallback(const char *dump_dir,
 }
 
 //=============================================================================
-void Breakpad::UncaughtExceptionHandler(NSException *exception) {
+void Breakpad::UncaughtExceptionHandler(NSException* exception) {
   NSSetUncaughtExceptionHandler(NULL);
   if (current_breakpad_) {
     current_breakpad_->HandleUncaughtException(exception);
+    BreakpadRelease(current_breakpad_);
   }
 }
 
@@ -267,7 +282,7 @@ void Breakpad::UncaughtExceptionHandler(NSException *exception) {
 #pragma mark -
 
 //=============================================================================
-bool Breakpad::Initialize(NSDictionary *parameters) {
+bool Breakpad::Initialize(NSDictionary* parameters) {
   // Initialize
   current_breakpad_ = this;
   config_params_ = NULL;
@@ -302,7 +317,7 @@ Breakpad::~Breakpad() {
   // since they were allocated by ProtectedMemoryAllocator objects.
   //
   if (config_params_) {
-    config_params_->~SimpleStringDictionary();
+    config_params_->~LongStringDictionary();
   }
 
   if (handler_)
@@ -310,21 +325,21 @@ Breakpad::~Breakpad() {
 }
 
 //=============================================================================
-bool Breakpad::ExtractParameters(NSDictionary *parameters) {
-  NSString *serverType = [parameters objectForKey:@BREAKPAD_SERVER_TYPE];
-  NSString *display = [parameters objectForKey:@BREAKPAD_PRODUCT_DISPLAY];
-  NSString *product = [parameters objectForKey:@BREAKPAD_PRODUCT];
-  NSString *version = [parameters objectForKey:@BREAKPAD_VERSION];
-  NSString *urlStr = [parameters objectForKey:@BREAKPAD_URL];
-  NSString *vendor =
+bool Breakpad::ExtractParameters(NSDictionary* parameters) {
+  NSString* serverType = [parameters objectForKey:@BREAKPAD_SERVER_TYPE];
+  NSString* display = [parameters objectForKey:@BREAKPAD_PRODUCT_DISPLAY];
+  NSString* product = [parameters objectForKey:@BREAKPAD_PRODUCT];
+  NSString* version = [parameters objectForKey:@BREAKPAD_VERSION];
+  NSString* urlStr = [parameters objectForKey:@BREAKPAD_URL];
+  NSString* vendor =
       [parameters objectForKey:@BREAKPAD_VENDOR];
   // We check both parameters and the environment variable here.
-  char *envVarDumpSubdirectory = getenv(BREAKPAD_DUMP_DIRECTORY);
-  NSString *dumpSubdirectory = envVarDumpSubdirectory ?
+  char* envVarDumpSubdirectory = getenv(BREAKPAD_DUMP_DIRECTORY);
+  NSString* dumpSubdirectory = envVarDumpSubdirectory ?
       [NSString stringWithUTF8String:envVarDumpSubdirectory] :
           [parameters objectForKey:@BREAKPAD_DUMP_DIRECTORY];
 
-  NSDictionary *serverParameters =
+  NSDictionary* serverParameters =
       [parameters objectForKey:@BREAKPAD_SERVER_PARAMETER_DICT];
 
   if (!product)
@@ -337,7 +352,7 @@ bool Breakpad::ExtractParameters(NSDictionary *parameters) {
     }
   }
 
-  if (!version)
+  if (!version.length)  // Default nil or empty string to CFBundleVersion
     version = [parameters objectForKey:@"CFBundleVersion"];
 
   if (!vendor) {
@@ -345,7 +360,7 @@ bool Breakpad::ExtractParameters(NSDictionary *parameters) {
   }
 
   if (!dumpSubdirectory) {
-    NSString *cachePath =
+    NSString* cachePath =
         [NSSearchPathForDirectoriesInDomains(NSCachesDirectory,
                                              NSUserDomainMask,
                                              YES)
@@ -370,10 +385,10 @@ bool Breakpad::ExtractParameters(NSDictionary *parameters) {
   }
 
   config_params_ =
-      new (gKeyValueAllocator->Allocate(sizeof(SimpleStringDictionary)) )
-        SimpleStringDictionary();
+      new (gKeyValueAllocator->Allocate(sizeof(LongStringDictionary)))
+          LongStringDictionary();
 
-  SimpleStringDictionary &dictionary = *config_params_;
+  LongStringDictionary& dictionary = *config_params_;
 
   dictionary.SetKeyValue(BREAKPAD_SERVER_TYPE,     [serverType UTF8String]);
   dictionary.SetKeyValue(BREAKPAD_PRODUCT_DISPLAY, [display UTF8String]);
@@ -392,8 +407,8 @@ bool Breakpad::ExtractParameters(NSDictionary *parameters) {
 
   if (serverParameters) {
     // For each key-value pair, call BreakpadAddUploadParameter()
-    NSEnumerator *keyEnumerator = [serverParameters keyEnumerator];
-    NSString *aParameter;
+    NSEnumerator* keyEnumerator = [serverParameters keyEnumerator];
+    NSString* aParameter;
     while ((aParameter = [keyEnumerator nextObject])) {
       BreakpadAddUploadParameter(this, aParameter,
 				 [serverParameters objectForKey:aParameter]);
@@ -403,7 +418,7 @@ bool Breakpad::ExtractParameters(NSDictionary *parameters) {
 }
 
 //=============================================================================
-void Breakpad::SetKeyValue(NSString *key, NSString *value) {
+void Breakpad::SetKeyValue(NSString* key, NSString* value) {
   // We allow nil values. This is the same as removing the keyvalue.
   if (!config_params_ || !key)
     return;
@@ -412,69 +427,139 @@ void Breakpad::SetKeyValue(NSString *key, NSString *value) {
 }
 
 //=============================================================================
-NSString *Breakpad::KeyValue(NSString *key) {
+NSString* Breakpad::KeyValue(NSString* key) {
   if (!config_params_ || !key)
     return nil;
 
-  const char *value = config_params_->GetValueForKey([key UTF8String]);
-  return value ? [NSString stringWithUTF8String:value] : nil;
+  const std::string value = config_params_->GetValueForKey([key UTF8String]);
+  return value.empty() ? nil : [NSString stringWithUTF8String:value.c_str()];
 }
 
 //=============================================================================
-void Breakpad::RemoveKeyValue(NSString *key) {
+void Breakpad::RemoveKeyValue(NSString* key) {
   if (!config_params_ || !key) return;
 
   config_params_->RemoveKey([key UTF8String]);
 }
 
 //=============================================================================
-NSArray *Breakpad::CrashReportsToUpload() {
-  NSString *directory = KeyValue(@BREAKPAD_DUMP_DIRECTORY);
+NSArray* Breakpad::CrashReportsToUpload() {
+  NSString* directory = KeyValue(@BREAKPAD_DUMP_DIRECTORY);
   if (!directory)
     return nil;
-  NSArray *dirContents = [[NSFileManager defaultManager]
+  NSArray* dirContents = [[NSFileManager defaultManager]
       contentsOfDirectoryAtPath:directory error:nil];
-  NSArray *configs = [dirContents filteredArrayUsingPredicate:[NSPredicate
+  NSArray* configs = [dirContents filteredArrayUsingPredicate:[NSPredicate
       predicateWithFormat:@"self BEGINSWITH 'Config-'"]];
   return configs;
 }
 
 //=============================================================================
-NSString *Breakpad::NextCrashReportToUpload() {
-  NSString *directory = KeyValue(@BREAKPAD_DUMP_DIRECTORY);
+NSString* Breakpad::NextCrashReportToUpload() {
+  NSString* directory = KeyValue(@BREAKPAD_DUMP_DIRECTORY);
   if (!directory)
     return nil;
-  NSString *config = [CrashReportsToUpload() lastObject];
+  NSString* config = [CrashReportsToUpload() lastObject];
   if (!config)
     return nil;
   return [NSString stringWithFormat:@"%@/%@", directory, config];
 }
 
 //=============================================================================
-void Breakpad::UploadNextReport() {
-  NSString *configFile = NextCrashReportToUpload();
-  if (configFile) {
-    Uploader *uploader = [[[Uploader alloc]
-        initWithConfigFile:[configFile UTF8String]] autorelease];
-    if (uploader)
-      [uploader report];
+NSDictionary* Breakpad::NextCrashReportConfiguration() {
+  NSDictionary* configuration = [Uploader readConfigurationDataFromFile:NextCrashReportToUpload()];
+  return FixedUpCrashReportConfiguration(configuration);
+}
+
+//=============================================================================
+NSDictionary* Breakpad::FixedUpCrashReportConfiguration(NSDictionary* configuration) {
+  NSMutableDictionary* fixedConfiguration = [[configuration mutableCopy] autorelease];
+  // kReporterMinidumpDirectoryKey can become stale because the app's data container path includes
+  // an UUID that is not guaranteed to stay the same over time.
+  [fixedConfiguration setObject:KeyValue(@BREAKPAD_DUMP_DIRECTORY)
+                    forKey:@kReporterMinidumpDirectoryKey];
+  return fixedConfiguration;
+}
+
+//=============================================================================
+NSDate* Breakpad::DateOfMostRecentCrashReport() {
+  NSString* directory = KeyValue(@BREAKPAD_DUMP_DIRECTORY);
+  if (!directory) {
+    return nil;
+  }
+  NSFileManager* fileManager = [NSFileManager defaultManager];
+  NSArray* dirContents = [fileManager contentsOfDirectoryAtPath:directory error:nil];
+  NSArray* dumps = [dirContents filteredArrayUsingPredicate:[NSPredicate
+      predicateWithFormat:@"self ENDSWITH '.dmp'"]];
+  NSDate* mostRecentCrashReportDate = nil;
+  for (NSString* dump in dumps) {
+    NSString* filePath = [directory stringByAppendingPathComponent:dump];
+    NSDate* crashReportDate =
+        [[fileManager attributesOfItemAtPath:filePath error:nil] fileCreationDate];
+    if (!mostRecentCrashReportDate) {
+      mostRecentCrashReportDate = crashReportDate;
+    } else if (crashReportDate) {
+      mostRecentCrashReportDate = [mostRecentCrashReportDate laterDate:crashReportDate];
+    }
   }
+  return mostRecentCrashReportDate;
 }
 
 //=============================================================================
-void Breakpad::UploadData(NSData *data, NSString *name,
-                          NSDictionary *server_parameters) {
-  NSMutableDictionary *config = [NSMutableDictionary dictionary];
+void Breakpad::HandleNetworkResponse(NSDictionary* configuration,
+                                     NSData* data,
+                                     NSError* error) {
+  Uploader* uploader = [[[Uploader alloc]
+      initWithConfig:configuration] autorelease];
+  [uploader handleNetworkResponse:data withError:error];
+}
+
+//=============================================================================
+void Breakpad::UploadReportWithConfiguration(
+    NSDictionary* configuration,
+    NSDictionary* server_parameters,
+    BreakpadUploadCompletionCallback callback) {
+  Uploader* uploader = [[[Uploader alloc]
+      initWithConfig:configuration] autorelease];
+  if (!uploader)
+    return;
+  for (NSString* key in server_parameters) {
+    [uploader addServerParameter:[server_parameters objectForKey:key]
+                          forKey:key];
+  }
+  if (callback) {
+    [uploader setUploadCompletionBlock:^(NSString* report_id, NSError* error) {
+      dispatch_async(dispatch_get_main_queue(), ^{
+        callback(report_id, error);
+      });
+    }];
+  }
+  [uploader report];
+}
 
-  SimpleStringDictionary::Iterator it(*config_params_);
-  while (const SimpleStringDictionary::Entry *next = it.Next()) {
+//=============================================================================
+void Breakpad::UploadNextReport(NSDictionary* server_parameters) {
+  NSDictionary* configuration = NextCrashReportConfiguration();
+  if (configuration) {
+    return UploadReportWithConfiguration(configuration, server_parameters,
+                                         nullptr);
+  }
+}
+
+//=============================================================================
+void Breakpad::UploadData(NSData* data, NSString* name,
+                          NSDictionary* server_parameters) {
+  NSMutableDictionary* config = [NSMutableDictionary dictionary];
+
+  LongStringDictionary::Iterator it(*config_params_);
+  while (const LongStringDictionary::Entry* next = it.Next()) {
     [config setValue:[NSString stringWithUTF8String:next->value]
               forKey:[NSString stringWithUTF8String:next->key]];
   }
 
-  Uploader *uploader =
+  Uploader* uploader =
       [[[Uploader alloc] initWithConfig:config] autorelease];
-  for (NSString *key in server_parameters) {
+  for (NSString* key in server_parameters) {
     [uploader addServerParameter:[server_parameters objectForKey:key]
                           forKey:key];
   }
@@ -482,11 +567,11 @@ void Breakpad::UploadData(NSData *data, NSString *name,
 }
 
 //=============================================================================
-NSDictionary *Breakpad::GenerateReport(NSDictionary *server_parameters) {
-  NSString *dumpDirAsNSString = KeyValue(@BREAKPAD_DUMP_DIRECTORY);
+NSDictionary* Breakpad::GenerateReport(NSDictionary* server_parameters) {
+  NSString* dumpDirAsNSString = KeyValue(@BREAKPAD_DUMP_DIRECTORY);
   if (!dumpDirAsNSString)
     return nil;
-  const char *dumpDir = [dumpDirAsNSString UTF8String];
+  const char* dumpDir = [dumpDirAsNSString UTF8String];
 
   google_breakpad::MinidumpGenerator generator(mach_task_self(),
                                                MACH_PORT_NULL);
@@ -496,8 +581,8 @@ NSDictionary *Breakpad::GenerateReport(NSDictionary *server_parameters) {
   if (!success)
     return nil;
 
-  SimpleStringDictionary params = *config_params_;
-  for (NSString *key in server_parameters) {
+  LongStringDictionary params = *config_params_;
+  for (NSString* key in server_parameters) {
     params.SetKeyValue([key UTF8String],
                        [[server_parameters objectForKey:key] UTF8String]);
   }
@@ -505,8 +590,8 @@ NSDictionary *Breakpad::GenerateReport(NSDictionary *server_parameters) {
   config_file.WriteFile(dumpDir, &params, dumpDir, dumpId.c_str());
 
   // Handle results.
-  NSMutableDictionary *result = [NSMutableDictionary dictionary];
-  NSString *dumpFullPath = [NSString stringWithUTF8String:dumpFilename.c_str()];
+  NSMutableDictionary* result = [NSMutableDictionary dictionary];
+  NSString* dumpFullPath = [NSString stringWithUTF8String:dumpFilename.c_str()];
   [result setValue:dumpFullPath
             forKey:@BREAKPAD_OUTPUT_DUMP_FILE];
   [result setValue:[NSString stringWithUTF8String:config_file.GetFilePath()]
@@ -515,8 +600,8 @@ NSDictionary *Breakpad::GenerateReport(NSDictionary *server_parameters) {
 }
 
 //=============================================================================
-bool Breakpad::HandleMinidump(const char *dump_dir,
-                              const char *minidump_id) {
+bool Breakpad::HandleMinidump(const char* dump_dir,
+                              const char* minidump_id) {
   config_file_.WriteFile(dump_dir,
                          config_params_,
                          dump_dir,
@@ -528,10 +613,10 @@ bool Breakpad::HandleMinidump(const char *dump_dir,
 }
 
 //=============================================================================
-void Breakpad::HandleUncaughtException(NSException *exception) {
+void Breakpad::HandleUncaughtException(NSException* exception) {
   // Generate the minidump.
   google_breakpad::IosExceptionMinidumpGenerator generator(exception);
-  const char *minidump_path =
+  const std::string minidump_path =
       config_params_->GetValueForKey(BREAKPAD_DUMP_DIRECTORY);
   std::string minidump_id;
   std::string minidump_filename = generator.UniqueNameInDirectory(minidump_path,
@@ -544,7 +629,7 @@ void Breakpad::HandleUncaughtException(NSException *exception) {
   // 2- If the application crash while trying to handle this exception, a usual
   //    report will be generated. This report must not contain these special
   //    keys.
-  SimpleStringDictionary params = *config_params_;
+  LongStringDictionary params = *config_params_;
   params.SetKeyValue(BREAKPAD_SERVER_PARAMETER_PREFIX "type", "exception");
   params.SetKeyValue(BREAKPAD_SERVER_PARAMETER_PREFIX "exceptionName",
                      [[exception name] UTF8String]);
@@ -553,9 +638,9 @@ void Breakpad::HandleUncaughtException(NSException *exception) {
 
   // And finally write the config file.
   ConfigFile config_file;
-  config_file.WriteFile(minidump_path,
+  config_file.WriteFile(minidump_path.c_str(),
                         &params,
-                        minidump_path,
+                        minidump_path.c_str(),
                         minidump_id.c_str());
 }
 
@@ -565,7 +650,7 @@ void Breakpad::HandleUncaughtException(NSException *exception) {
 #pragma mark Public API
 
 //=============================================================================
-BreakpadRef BreakpadCreate(NSDictionary *parameters) {
+BreakpadRef BreakpadCreate(NSDictionary* parameters) {
   try {
     // This is confusing.  Our two main allocators for breakpad memory are:
     //    - gKeyValueAllocator for the key/value memory
@@ -583,9 +668,9 @@ BreakpadRef BreakpadCreate(NSDictionary *parameters) {
 
     gKeyValueAllocator =
         new (gMasterAllocator->Allocate(sizeof(ProtectedMemoryAllocator)))
-            ProtectedMemoryAllocator(sizeof(SimpleStringDictionary));
+            ProtectedMemoryAllocator(sizeof(LongStringDictionary));
 
-    // Create a mutex for use in accessing the SimpleStringDictionary
+    // Create a mutex for use in accessing the LongStringDictionary
     int mutexResult = pthread_mutex_init(&gDictionaryMutex, NULL);
     if (mutexResult == 0) {
 
@@ -605,8 +690,8 @@ BreakpadRef BreakpadCreate(NSDictionary *parameters) {
               ProtectedMemoryAllocator(breakpad_pool_size);
 
       // Stack-based autorelease pool for Breakpad::Create() obj-c code.
-      NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
-      Breakpad *breakpad = Breakpad::Create(parameters);
+      NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];
+      Breakpad* breakpad = Breakpad::Create(parameters);
 
       if (breakpad) {
         // Make read-only to protect against memory smashers
@@ -646,7 +731,7 @@ BreakpadRef BreakpadCreate(NSDictionary *parameters) {
 //=============================================================================
 void BreakpadRelease(BreakpadRef ref) {
   try {
-    Breakpad *breakpad = (Breakpad *)ref;
+    Breakpad* breakpad = (Breakpad*)ref;
 
     if (gMasterAllocator) {
       gMasterAllocator->Unprotect();
@@ -679,10 +764,10 @@ void BreakpadRelease(BreakpadRef ref) {
 }
 
 //=============================================================================
-void BreakpadSetKeyValue(BreakpadRef ref, NSString *key, NSString *value) {
+void BreakpadSetKeyValue(BreakpadRef ref, NSString* key, NSString* value) {
   try {
     // Not called at exception time
-    Breakpad *breakpad = (Breakpad *)ref;
+    Breakpad* breakpad = (Breakpad*)ref;
 
     if (breakpad && key && gKeyValueAllocator) {
       ProtectedMemoryLocker locker(&gDictionaryMutex, gKeyValueAllocator);
@@ -695,20 +780,20 @@ void BreakpadSetKeyValue(BreakpadRef ref, NSString *key, NSString *value) {
 }
 
 void BreakpadAddUploadParameter(BreakpadRef ref,
-                                NSString *key,
-                                NSString *value) {
+                                NSString* key,
+                                NSString* value) {
   // The only difference, internally, between an upload parameter and
   // a key value one that is set with BreakpadSetKeyValue is that we
   // prepend the keyname with a special prefix.  This informs the
   // crash sender that the parameter should be sent along with the
   // POST of the crash dump upload.
   try {
-    Breakpad *breakpad = (Breakpad *)ref;
+    Breakpad* breakpad = (Breakpad*)ref;
 
     if (breakpad && key && gKeyValueAllocator) {
       ProtectedMemoryLocker locker(&gDictionaryMutex, gKeyValueAllocator);
 
-      NSString *prefixedKey = [@BREAKPAD_SERVER_PARAMETER_PREFIX
+      NSString* prefixedKey = [@BREAKPAD_SERVER_PARAMETER_PREFIX
 				stringByAppendingString:key];
       breakpad->SetKeyValue(prefixedKey, value);
     }
@@ -718,15 +803,15 @@ void BreakpadAddUploadParameter(BreakpadRef ref,
 }
 
 void BreakpadRemoveUploadParameter(BreakpadRef ref,
-                                   NSString *key) {
+                                   NSString* key) {
   try {
     // Not called at exception time
-    Breakpad *breakpad = (Breakpad *)ref;
+    Breakpad* breakpad = (Breakpad*)ref;
 
     if (breakpad && key && gKeyValueAllocator) {
       ProtectedMemoryLocker locker(&gDictionaryMutex, gKeyValueAllocator);
 
-      NSString *prefixedKey = [NSString stringWithFormat:@"%@%@",
+      NSString* prefixedKey = [NSString stringWithFormat:@"%@%@",
                                         @BREAKPAD_SERVER_PARAMETER_PREFIX, key];
       breakpad->RemoveKeyValue(prefixedKey);
     }
@@ -735,12 +820,12 @@ void BreakpadRemoveUploadParameter(BreakpadRef ref,
   }
 }
 //=============================================================================
-NSString *BreakpadKeyValue(BreakpadRef ref, NSString *key) {
-  NSString *value = nil;
+NSString* BreakpadKeyValue(BreakpadRef ref, NSString* key) {
+  NSString* value = nil;
 
   try {
     // Not called at exception time
-    Breakpad *breakpad = (Breakpad *)ref;
+    Breakpad* breakpad = (Breakpad*)ref;
 
     if (!breakpad || !key || !gKeyValueAllocator)
       return nil;
@@ -756,10 +841,10 @@ NSString *BreakpadKeyValue(BreakpadRef ref, NSString *key) {
 }
 
 //=============================================================================
-void BreakpadRemoveKeyValue(BreakpadRef ref, NSString *key) {
+void BreakpadRemoveKeyValue(BreakpadRef ref, NSString* key) {
   try {
     // Not called at exception time
-    Breakpad *breakpad = (Breakpad *)ref;
+    Breakpad* breakpad = (Breakpad*)ref;
 
     if (breakpad && key && gKeyValueAllocator) {
       ProtectedMemoryLocker locker(&gDictionaryMutex, gKeyValueAllocator);
@@ -775,10 +860,10 @@ void BreakpadRemoveKeyValue(BreakpadRef ref, NSString *key) {
 int BreakpadGetCrashReportCount(BreakpadRef ref) {
   try {
     // Not called at exception time
-    Breakpad *breakpad = (Breakpad *)ref;
+    Breakpad* breakpad = (Breakpad*)ref;
 
     if (breakpad) {
-       return [breakpad->CrashReportsToUpload() count];
+       return static_cast<int>([breakpad->CrashReportsToUpload() count]);
     }
   } catch(...) {    // don't let exceptions leave this C API
     fprintf(stderr, "BreakpadGetCrashReportCount() : error\n");
@@ -788,24 +873,92 @@ int BreakpadGetCrashReportCount(BreakpadRef ref) {
 
 //=============================================================================
 void BreakpadUploadNextReport(BreakpadRef ref) {
+  BreakpadUploadNextReportWithParameters(ref, nil, nullptr);
+}
+
+//=============================================================================
+NSDictionary* BreakpadGetNextReportConfiguration(BreakpadRef ref) {
   try {
-    // Not called at exception time
-    Breakpad *breakpad = (Breakpad *)ref;
+    Breakpad* breakpad = (Breakpad*)ref;
+    if (breakpad)
+      return breakpad->NextCrashReportConfiguration();
+  } catch(...) {    // don't let exceptions leave this C API
+    fprintf(stderr, "BreakpadGetNextReportConfiguration() : error\n");
+  }
+  return nil;
+}
 
+//=============================================================================
+NSDate* BreakpadGetDateOfMostRecentCrashReport(BreakpadRef ref) {
+  try {
+    Breakpad* breakpad = (Breakpad*)ref;
     if (breakpad) {
-       breakpad->UploadNextReport();
+      return breakpad->DateOfMostRecentCrashReport();
     }
+  } catch (...) {    // don't let exceptions leave this C API
+    fprintf(stderr, "BreakpadGetDateOfMostRecentCrashReport() : error\n");
+  }
+  return nil;
+}
+
+//=============================================================================
+void BreakpadUploadReportWithParametersAndConfiguration(
+    BreakpadRef ref,
+    NSDictionary* server_parameters,
+    NSDictionary* configuration,
+    BreakpadUploadCompletionCallback callback) {
+  try {
+    Breakpad* breakpad = (Breakpad*)ref;
+    if (!breakpad || !configuration)
+      return;
+    breakpad->UploadReportWithConfiguration(configuration, server_parameters,
+                                            callback);
+  } catch(...) {    // don't let exceptions leave this C API
+    fprintf(stderr,
+        "BreakpadUploadReportWithParametersAndConfiguration() : error\n");
+  }
+}
+
+//=============================================================================
+void BreakpadUploadNextReportWithParameters(
+    BreakpadRef ref,
+    NSDictionary* server_parameters,
+    BreakpadUploadCompletionCallback callback) {
+  try {
+    Breakpad* breakpad = (Breakpad*)ref;
+    if (!breakpad)
+      return;
+    NSDictionary* configuration = breakpad->NextCrashReportConfiguration();
+    if (!configuration)
+      return;
+    return BreakpadUploadReportWithParametersAndConfiguration(
+        ref, server_parameters, configuration, callback);
+  } catch(...) {    // don't let exceptions leave this C API
+    fprintf(stderr, "BreakpadUploadNextReportWithParameters() : error\n");
+  }
+}
+
+void BreakpadHandleNetworkResponse(BreakpadRef ref,
+                                   NSDictionary* configuration,
+                                   NSData* data,
+                                   NSError* error) {
+  try {
+    // Not called at exception time
+    Breakpad* breakpad = (Breakpad*)ref;
+    if (breakpad && configuration)
+      breakpad->HandleNetworkResponse(configuration,data, error);
+
   } catch(...) {    // don't let exceptions leave this C API
-    fprintf(stderr, "BreakpadUploadNextReport() : error\n");
+    fprintf(stderr, "BreakpadHandleNetworkResponse() : error\n");
   }
 }
 
 //=============================================================================
-void BreakpadUploadData(BreakpadRef ref, NSData *data, NSString *name,
-                        NSDictionary *server_parameters) {
+void BreakpadUploadData(BreakpadRef ref, NSData* data, NSString* name,
+                        NSDictionary* server_parameters) {
   try {
     // Not called at exception time
-    Breakpad *breakpad = (Breakpad *)ref;
+    Breakpad* breakpad = (Breakpad*)ref;
 
     if (breakpad) {
       breakpad->UploadData(data, name, server_parameters);
@@ -816,11 +969,11 @@ void BreakpadUploadData(BreakpadRef ref, NSData *data, NSString *name,
 }
 
 //=============================================================================
-NSDictionary *BreakpadGenerateReport(BreakpadRef ref,
-                                     NSDictionary *server_parameters) {
+NSDictionary* BreakpadGenerateReport(BreakpadRef ref,
+                                     NSDictionary* server_parameters) {
   try {
     // Not called at exception time
-    Breakpad *breakpad = (Breakpad *)ref;
+    Breakpad* breakpad = (Breakpad*)ref;
 
     if (breakpad) {
       return breakpad->GenerateReport(server_parameters);
diff --git a/src/MEGASync/google_breakpad/client/ios/Breakpad.xcodeproj/project.pbxproj b/src/MEGASync/google_breakpad/client/ios/Breakpad.xcodeproj/project.pbxproj
index 10888c8f..2ed66d53 100644
--- a/src/MEGASync/google_breakpad/client/ios/Breakpad.xcodeproj/project.pbxproj
+++ b/src/MEGASync/google_breakpad/client/ios/Breakpad.xcodeproj/project.pbxproj
@@ -31,7 +31,7 @@
 		16C7CE18147D4A4300776EAD /* minidump_file_writer-inl.h in Headers */ = {isa = PBXBuildFile; fileRef = 16C7CC04147D4A4300776EAD /* minidump_file_writer-inl.h */; };
 		16C7CE19147D4A4300776EAD /* minidump_file_writer.cc in Sources */ = {isa = PBXBuildFile; fileRef = 16C7CC05147D4A4300776EAD /* minidump_file_writer.cc */; };
 		16C7CE1A147D4A4300776EAD /* minidump_file_writer.h in Headers */ = {isa = PBXBuildFile; fileRef = 16C7CC06147D4A4300776EAD /* minidump_file_writer.h */; };
-		16C7CE40147D4A4300776EAD /* convert_UTF.c in Sources */ = {isa = PBXBuildFile; fileRef = 16C7CC4A147D4A4300776EAD /* convert_UTF.c */; };
+		16C7CE40147D4A4300776EAD /* convert_UTF.cc in Sources */ = {isa = PBXBuildFile; fileRef = 16C7CC4A147D4A4300776EAD /* convert_UTF.cc */; };
 		16C7CE41147D4A4300776EAD /* convert_UTF.h in Headers */ = {isa = PBXBuildFile; fileRef = 16C7CC4B147D4A4300776EAD /* convert_UTF.h */; };
 		16C7CE78147D4A4300776EAD /* GTMLogger.h in Headers */ = {isa = PBXBuildFile; fileRef = 16C7CC88147D4A4300776EAD /* GTMLogger.h */; };
 		16C7CE79147D4A4300776EAD /* GTMLogger.m in Sources */ = {isa = PBXBuildFile; fileRef = 16C7CC89147D4A4300776EAD /* GTMLogger.m */; };
@@ -57,6 +57,8 @@
 		1EEEB6101720821900F7E689 /* simple_string_dictionary.h in Headers */ = {isa = PBXBuildFile; fileRef = 1EEEB60D1720821900F7E689 /* simple_string_dictionary.h */; };
 		AA747D9F0F9514B9006C5449 /* Breakpad_Prefix.pch in Headers */ = {isa = PBXBuildFile; fileRef = AA747D9E0F9514B9006C5449 /* Breakpad_Prefix.pch */; };
 		AACBBE4A0F95108600F1A2B1 /* Foundation.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = AACBBE490F95108600F1A2B1 /* Foundation.framework */; };
+		CF6D547D1F9E6FFE00E95174 /* long_string_dictionary.cc in Sources */ = {isa = PBXBuildFile; fileRef = CF6D547C1F9E6FFE00E95174 /* long_string_dictionary.cc */; };
+		CF706DC11F7C6EFB002C54C7 /* long_string_dictionary.h in Headers */ = {isa = PBXBuildFile; fileRef = CF706DC01F7C6EFB002C54C7 /* long_string_dictionary.h */; };
 /* End PBXBuildFile section */
 
 /* Begin PBXFileReference section */
@@ -85,7 +87,7 @@
 		16C7CC05147D4A4300776EAD /* minidump_file_writer.cc */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = minidump_file_writer.cc; sourceTree = "<group>"; };
 		16C7CC06147D4A4300776EAD /* minidump_file_writer.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = minidump_file_writer.h; sourceTree = "<group>"; };
 		16C7CC07147D4A4300776EAD /* minidump_file_writer_unittest.cc */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = minidump_file_writer_unittest.cc; sourceTree = "<group>"; };
-		16C7CC4A147D4A4300776EAD /* convert_UTF.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = convert_UTF.c; sourceTree = "<group>"; };
+		16C7CC4A147D4A4300776EAD /* convert_UTF.cc */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = convert_UTF.cc; sourceTree = "<group>"; };
 		16C7CC4B147D4A4300776EAD /* convert_UTF.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = convert_UTF.h; sourceTree = "<group>"; };
 		16C7CC88147D4A4300776EAD /* GTMLogger.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GTMLogger.h; sourceTree = "<group>"; };
 		16C7CC89147D4A4300776EAD /* GTMLogger.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GTMLogger.m; sourceTree = "<group>"; };
@@ -111,6 +113,8 @@
 		1EEEB60D1720821900F7E689 /* simple_string_dictionary.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = simple_string_dictionary.h; sourceTree = "<group>"; };
 		AA747D9E0F9514B9006C5449 /* Breakpad_Prefix.pch */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Breakpad_Prefix.pch; sourceTree = SOURCE_ROOT; };
 		AACBBE490F95108600F1A2B1 /* Foundation.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Foundation.framework; path = System/Library/Frameworks/Foundation.framework; sourceTree = SDKROOT; };
+		CF6D547C1F9E6FFE00E95174 /* long_string_dictionary.cc */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = long_string_dictionary.cc; sourceTree = "<group>"; };
+		CF706DC01F7C6EFB002C54C7 /* long_string_dictionary.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = long_string_dictionary.h; sourceTree = "<group>"; };
 		D2AAC07E0554694100DB518D /* libBreakpad.a */ = {isa = PBXFileReference; explicitFileType = archive.ar; includeInIndex = 0; path = libBreakpad.a; sourceTree = BUILT_PRODUCTS_DIR; };
 /* End PBXFileReference section */
 
@@ -264,9 +268,11 @@
 		16C7CC47147D4A4300776EAD /* common */ = {
 			isa = PBXGroup;
 			children = (
+				CF706DC01F7C6EFB002C54C7 /* long_string_dictionary.h */,
+				CF6D547C1F9E6FFE00E95174 /* long_string_dictionary.cc */,
 				1EEEB60C1720821900F7E689 /* simple_string_dictionary.cc */,
 				1EEEB60D1720821900F7E689 /* simple_string_dictionary.h */,
-				16C7CC4A147D4A4300776EAD /* convert_UTF.c */,
+				16C7CC4A147D4A4300776EAD /* convert_UTF.cc */,
 				16C7CC4B147D4A4300776EAD /* convert_UTF.h */,
 				16C7CC82147D4A4300776EAD /* mac */,
 				16C7CCA4147D4A4300776EAD /* md5.cc */,
@@ -339,6 +345,7 @@
 				16C7CEA8147D4A4300776EAD /* string_conversion.h in Headers */,
 				16BFA67014E195E9009704F8 /* ios_exception_minidump_generator.h in Headers */,
 				16C92FAD150DF8330053D7BA /* BreakpadController.h in Headers */,
+				CF706DC11F7C6EFB002C54C7 /* long_string_dictionary.h in Headers */,
 				1EEEB6101720821900F7E689 /* simple_string_dictionary.h in Headers */,
 				14569323182CE2C10029C465 /* mach_vm_compat.h in Headers */,
 			);
@@ -370,6 +377,7 @@
 		0867D690FE84028FC02AAC07 /* Project object */ = {
 			isa = PBXProject;
 			attributes = {
+				LastUpgradeCheck = 0510;
 			};
 			buildConfigurationList = 1DEB922208733DC00010E9CD /* Build configuration list for PBXProject "Breakpad" */;
 			compatibilityVersion = "Xcode 3.2";
@@ -415,8 +423,9 @@
 				16C7CDFC147D4A4300776EAD /* minidump_generator.cc in Sources */,
 				16C7CDFE147D4A4300776EAD /* protected_memory_allocator.cc in Sources */,
 				16C7CE09147D4A4300776EAD /* uploader.mm in Sources */,
+				CF6D547D1F9E6FFE00E95174 /* long_string_dictionary.cc in Sources */,
 				16C7CE19147D4A4300776EAD /* minidump_file_writer.cc in Sources */,
-				16C7CE40147D4A4300776EAD /* convert_UTF.c in Sources */,
+				16C7CE40147D4A4300776EAD /* convert_UTF.cc in Sources */,
 				16C7CE79147D4A4300776EAD /* GTMLogger.m in Sources */,
 				16C7CE7B147D4A4300776EAD /* HTTPMultipartUpload.m in Sources */,
 				16C7CE83147D4A4300776EAD /* file_id.cc in Sources */,
@@ -439,7 +448,7 @@
 			isa = XCBuildConfiguration;
 			buildSettings = {
 				ALWAYS_SEARCH_USER_PATHS = NO;
-				ARCHS = "$(ARCHS_STANDARD_INCLUDING_64_BIT)";
+				CLANG_CXX_LIBRARY = "libc++";
 				COPY_PHASE_STRIP = NO;
 				DSTROOT = /tmp/Breakpad.dst;
 				FRAMEWORK_SEARCH_PATHS = (
@@ -471,7 +480,7 @@
 			isa = XCBuildConfiguration;
 			buildSettings = {
 				ALWAYS_SEARCH_USER_PATHS = NO;
-				ARCHS = "$(ARCHS_STANDARD_INCLUDING_64_BIT)";
+				CLANG_CXX_LIBRARY = "libc++";
 				DSTROOT = /tmp/Breakpad.dst;
 				FRAMEWORK_SEARCH_PATHS = (
 					"$(inherited)",
@@ -499,7 +508,7 @@
 		1DEB922308733DC00010E9CD /* Debug */ = {
 			isa = XCBuildConfiguration;
 			buildSettings = {
-				ARCHS = "$(ARCHS_STANDARD_INCLUDING_64_BIT)";
+				CLANG_CXX_LANGUAGE_STANDARD = "c++0x";
 				CLANG_WARN_SUSPICIOUS_IMPLICIT_CONVERSION = YES;
 				GCC_C_LANGUAGE_STANDARD = c99;
 				GCC_OPTIMIZATION_LEVEL = 0;
@@ -517,15 +526,18 @@
 					../../client/apple/Framework,
 					../../common/mac,
 				);
+				IPHONEOS_DEPLOYMENT_TARGET = 5.0;
+				ONLY_ACTIVE_ARCH = YES;
 				OTHER_LDFLAGS = "-ObjC";
 				SDKROOT = iphoneos;
+				WARNING_CFLAGS = "-Wundef";
 			};
 			name = Debug;
 		};
 		1DEB922408733DC00010E9CD /* Release */ = {
 			isa = XCBuildConfiguration;
 			buildSettings = {
-				ARCHS = "$(ARCHS_STANDARD_INCLUDING_64_BIT)";
+				CLANG_CXX_LANGUAGE_STANDARD = "c++0x";
 				CLANG_WARN_SUSPICIOUS_IMPLICIT_CONVERSION = YES;
 				GCC_C_LANGUAGE_STANDARD = c99;
 				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
@@ -542,8 +554,10 @@
 					../../client/apple/Framework,
 					../../common/mac,
 				);
+				IPHONEOS_DEPLOYMENT_TARGET = 5.0;
 				OTHER_LDFLAGS = "-ObjC";
 				SDKROOT = iphoneos;
+				WARNING_CFLAGS = "-Wundef";
 			};
 			name = Release;
 		};
diff --git a/src/MEGASync/google_breakpad/client/ios/BreakpadController.h b/src/MEGASync/google_breakpad/client/ios/BreakpadController.h
index be072ea9..6c70c202 100644
--- a/src/MEGASync/google_breakpad/client/ios/BreakpadController.h
+++ b/src/MEGASync/google_breakpad/client/ios/BreakpadController.h
@@ -62,6 +62,13 @@
   // The interval to wait between two uploads. Value is 0 if no upload must be
   // done.
   int uploadIntervalInSeconds_;
+
+  // The dictionary that contains additional server parameters to send when
+  // uploading crash reports.
+  NSDictionary* uploadTimeParameters_;
+
+  // The callback to call on report upload completion.
+  BreakpadUploadCompletionCallback uploadCompleteCallback_;
 }
 
 // Singleton.
@@ -84,10 +91,17 @@
 // will prevent uploads.
 - (void)setUploadInterval:(int)intervalInSeconds;
 
-// Specify a parameter that will be uploaded to the crash server. See
-// |BreakpadAddUploadParameter|.
+// Set additional server parameters to send when uploading crash reports.
+- (void)setParametersToAddAtUploadTime:(NSDictionary*)uploadTimeParameters;
+
+// Specify an upload parameter that will be added to the crash report when a
+// crash report is generated. See |BreakpadAddUploadParameter|.
 - (void)addUploadParameter:(NSString*)value forKey:(NSString*)key;
 
+// Sets the callback to be called after uploading a crash report to the server.
+// Only the latest callback registered will be called.
+- (void)setUploadCallback:(BreakpadUploadCompletionCallback)callback;
+
 // Remove a previously-added parameter from the upload parameter set. See
 // |BreakpadRemoveUploadParameter|.
 - (void)removeUploadParameterForKey:(NSString*)key;
@@ -105,6 +119,9 @@
 // Unregisters the crash handlers.
 - (void)stop;
 
+// Returns whether or not the controller is started.
+- (BOOL)isStarted;
+
 // Enables or disables uploading of crash reports, but does not stop the
 // BreakpadController.
 - (void)setUploadingEnabled:(BOOL)enabled;
@@ -115,6 +132,23 @@
 // Get the number of crash reports waiting to upload.
 - (void)getCrashReportCount:(void(^)(int))callback;
 
+// Get the next report to upload.
+// - If upload is disabled, callback will be called with (nil, -1).
+// - If a delay is to be waited before sending, callback will be called with
+//   (nil, n), with n (> 0) being the number of seconds to wait.
+// - if no delay is needed, callback will be called with (0, configuration),
+//   configuration being next report to upload, or nil if none is pending.
+- (void)getNextReportConfigurationOrSendDelay:
+    (void(^)(NSDictionary*, int))callback;
+
+// Get the date of the most recent crash report.
+- (void)getDateOfMostRecentCrashReport:(void(^)(NSDate *))callback;
+
+// Sends synchronously the report specified by |configuration|. This method is
+// NOT thread safe and must be called from the breakpad thread.
+- (void)threadUnsafeSendReportWithConfiguration:(NSDictionary*)configuration
+                                withBreakpadRef:(BreakpadRef)ref;
+
 @end
 
 #endif  // CLIENT_IOS_HANDLER_IOS_BREAKPAD_CONTROLLER_H_
diff --git a/src/MEGASync/google_breakpad/client/ios/BreakpadController.mm b/src/MEGASync/google_breakpad/client/ios/BreakpadController.mm
index 9a6dd814..01fb5f13 100644
--- a/src/MEGASync/google_breakpad/client/ios/BreakpadController.mm
+++ b/src/MEGASync/google_breakpad/client/ios/BreakpadController.mm
@@ -93,11 +93,12 @@ NSString* GetPlatform() {
 @implementation BreakpadController
 
 + (BreakpadController*)sharedInstance {
-  @synchronized(self) {
-    static BreakpadController* sharedInstance_ =
-        [[BreakpadController alloc] initSingleton];
-    return sharedInstance_;
-  }
+  static dispatch_once_t onceToken;
+  static BreakpadController* sharedInstance ;
+  dispatch_once(&onceToken, ^{
+      sharedInstance = [[BreakpadController alloc] initSingleton];
+  });
+  return sharedInstance;
 }
 
 - (id)init {
@@ -120,6 +121,7 @@ NSString* GetPlatform() {
   assert(!breakpadRef_);
   dispatch_release(queue_);
   [configuration_ release];
+  [uploadTimeParameters_ release];
   [super dealloc];
 }
 
@@ -154,6 +156,22 @@ NSString* GetPlatform() {
   });
 }
 
+- (BOOL)isStarted {
+  return started_;
+}
+
+// This method must be called from the breakpad queue.
+- (void)threadUnsafeSendReportWithConfiguration:(NSDictionary*)configuration
+                                withBreakpadRef:(BreakpadRef)ref {
+  NSAssert(started_, @"The controller must be started before "
+                     "threadUnsafeSendReportWithConfiguration is called");
+  if (breakpadRef_) {
+    BreakpadUploadReportWithParametersAndConfiguration(
+        breakpadRef_, uploadTimeParameters_, configuration,
+        uploadCompleteCallback_);
+  }
+}
+
 - (void)setUploadingEnabled:(BOOL)enabled {
   NSAssert(started_,
       @"The controller must be started before setUploadingEnabled is called");
@@ -166,10 +184,9 @@ NSString* GetPlatform() {
         enableUploads_ = YES;
         [self sendStoredCrashReports];
       } else {
+        // disable the enableUpload_ flag.
+        // sendDelay checks this flag and disables the upload of logs by sendStoredCrashReports
         enableUploads_ = NO;
-        [NSObject cancelPreviousPerformRequestsWithTarget:self
-            selector:@selector(sendStoredCrashReports)
-            object:nil];
       }
   });
 }
@@ -178,7 +195,7 @@ NSString* GetPlatform() {
   NSAssert(!started_,
       @"The controller must not be started when updateConfiguration is called");
   [configuration_ addEntriesFromDictionary:configuration];
-  NSString* uploadInterval =
+  NSString *uploadInterval =
       [configuration_ valueForKey:@BREAKPAD_REPORT_INTERVAL];
   if (uploadInterval)
     [self setUploadInterval:[uploadInterval intValue]];
@@ -189,9 +206,10 @@ NSString* GetPlatform() {
       @"The controller must not be started when resetConfiguration is called");
   [configuration_ autorelease];
   configuration_ = [[[NSBundle mainBundle] infoDictionary] mutableCopy];
-  NSString* uploadInterval =
+  NSString *uploadInterval =
       [configuration_ valueForKey:@BREAKPAD_REPORT_INTERVAL];
   [self setUploadInterval:[uploadInterval intValue]];
+  [self setParametersToAddAtUploadTime:nil];
 }
 
 - (void)setUploadingURL:(NSString*)url {
@@ -209,6 +227,13 @@ NSString* GetPlatform() {
     uploadIntervalInSeconds_ = 0;
 }
 
+- (void)setParametersToAddAtUploadTime:(NSDictionary*)uploadTimeParameters {
+  NSAssert(!started_, @"The controller must not be started when "
+                      "setParametersToAddAtUploadTime is called");
+  [uploadTimeParameters_ autorelease];
+  uploadTimeParameters_ = [uploadTimeParameters copy];
+}
+
 - (void)addUploadParameter:(NSString*)value forKey:(NSString*)key {
   NSAssert(started_,
       @"The controller must be started before addUploadParameter is called");
@@ -218,6 +243,15 @@ NSString* GetPlatform() {
   });
 }
 
+- (void)setUploadCallback:(BreakpadUploadCompletionCallback)callback {
+  NSAssert(started_,
+           @"The controller must not be started before setUploadCallback is "
+            "called");
+  dispatch_async(queue_, ^{
+    uploadCompleteCallback_ = callback;
+  });
+}
+
 - (void)removeUploadParameterForKey:(NSString*)key {
   NSAssert(started_, @"The controller must be started before "
                      "removeUploadParameterForKey is called");
@@ -228,10 +262,8 @@ NSString* GetPlatform() {
 }
 
 - (void)withBreakpadRef:(void(^)(BreakpadRef))callback {
-  NSAssert(started_,
-      @"The controller must be started before withBreakpadRef is called");
   dispatch_async(queue_, ^{
-      callback(breakpadRef_);
+      callback(started_ ? breakpadRef_ : NULL);
   });
 }
 
@@ -251,6 +283,37 @@ NSString* GetPlatform() {
   });
 }
 
+- (void)getNextReportConfigurationOrSendDelay:
+    (void(^)(NSDictionary*, int))callback {
+  NSAssert(started_, @"The controller must be started before "
+                     "getNextReportConfigurationOrSendDelay is called");
+  dispatch_async(queue_, ^{
+      if (!breakpadRef_) {
+        callback(nil, -1);
+        return;
+      }
+      int delay = [self sendDelay];
+      if (delay != 0) {
+        callback(nil, delay);
+        return;
+      }
+      [self reportWillBeSent];
+      callback(BreakpadGetNextReportConfiguration(breakpadRef_), 0);
+  });
+}
+
+- (void)getDateOfMostRecentCrashReport:(void(^)(NSDate *))callback {
+  NSAssert(started_, @"The controller must be started before "
+           "getDateOfMostRecentCrashReport is called");
+  dispatch_async(queue_, ^{
+    if (!breakpadRef_) {
+      callback(nil);
+      return;
+    }
+    callback(BreakpadGetDateOfMostRecentCrashReport(breakpadRef_));
+  });
+}
+
 #pragma mark -
 
 - (int)sendDelay {
@@ -277,33 +340,35 @@ NSString* GetPlatform() {
   [userDefaults synchronize];
 }
 
+// This method must be called from the breakpad queue.
 - (void)sendStoredCrashReports {
-  dispatch_async(queue_, ^{
-      if (BreakpadGetCrashReportCount(breakpadRef_) == 0)
-        return;
+  if (BreakpadGetCrashReportCount(breakpadRef_) == 0)
+    return;
 
-      int timeToWait = [self sendDelay];
+  int timeToWait = [self sendDelay];
 
-      // Unable to ever send report.
-      if (timeToWait == -1)
-        return;
+  // Unable to ever send report.
+  if (timeToWait == -1)
+    return;
 
-      // A report can be sent now.
-      if (timeToWait == 0) {
-        [self reportWillBeSent];
-        BreakpadUploadNextReport(breakpadRef_);
+  // A report can be sent now.
+  if (timeToWait == 0) {
+    [self reportWillBeSent];
+    BreakpadUploadNextReportWithParameters(breakpadRef_, uploadTimeParameters_,
+                                           uploadCompleteCallback_);
 
-        // If more reports must be sent, make sure this method is called again.
-        if (BreakpadGetCrashReportCount(breakpadRef_) > 0)
-          timeToWait = uploadIntervalInSeconds_;
-      }
+    // If more reports must be sent, make sure this method is called again.
+    if (BreakpadGetCrashReportCount(breakpadRef_) > 0)
+      timeToWait = uploadIntervalInSeconds_;
+  }
 
-      // A report must be sent later.
-      if (timeToWait > 0)
-        [self performSelector:@selector(sendStoredCrashReports)
-                   withObject:nil
-                   afterDelay:timeToWait];
-  });
+  // A report must be sent later.
+  if (timeToWait > 0) {
+    dispatch_time_t delay = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(timeToWait * NSEC_PER_SEC));
+    dispatch_after(delay, queue_, ^{
+        [self sendStoredCrashReports];
+    });
+  }
 }
 
 @end
diff --git a/src/MEGASync/google_breakpad/client/ios/exception_handler_no_mach.cc b/src/MEGASync/google_breakpad/client/ios/exception_handler_no_mach.cc
new file mode 100644
index 00000000..cb26449d
--- /dev/null
+++ b/src/MEGASync/google_breakpad/client/ios/exception_handler_no_mach.cc
@@ -0,0 +1,262 @@
+// Copyright (c) 2006, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include <signal.h>
+#include <TargetConditionals.h>
+
+#include "client/mac/handler/minidump_generator.h"
+#include "client/ios/exception_handler_no_mach.h"
+
+#ifndef USE_PROTECTED_ALLOCATIONS
+#if TARGET_OS_TV
+#define USE_PROTECTED_ALLOCATIONS 1
+#else
+#define USE_PROTECTED_ALLOCATIONS 0
+#endif
+#endif
+
+// If USE_PROTECTED_ALLOCATIONS is activated then the
+// gBreakpadAllocator needs to be setup in other code
+// ahead of time.  Please see ProtectedMemoryAllocator.h
+// for more details.
+#if USE_PROTECTED_ALLOCATIONS
+  #include "client/mac/handler/protected_memory_allocator.h"
+  extern ProtectedMemoryAllocator* gBreakpadAllocator;
+#endif
+
+namespace google_breakpad {
+
+const int kExceptionSignals[] = {
+   // Core-generating signals.
+  SIGABRT, SIGBUS, SIGFPE, SIGILL, SIGQUIT, SIGSEGV, SIGSYS, SIGTRAP, SIGEMT,
+  SIGXCPU, SIGXFSZ,
+  // Non-core-generating but terminating signals.
+  SIGALRM, SIGHUP, SIGINT, SIGPIPE, SIGPROF, SIGTERM, SIGUSR1, SIGUSR2,
+  SIGVTALRM, SIGXCPU, SIGXFSZ, SIGIO,
+};
+const int kNumHandledSignals =
+    sizeof(kExceptionSignals) / sizeof(kExceptionSignals[0]);
+struct scoped_ptr<struct sigaction> old_handlers[kNumHandledSignals];
+
+static union {
+#if USE_PROTECTED_ALLOCATIONS
+#if defined PAGE_MAX_SIZE
+  char protected_buffer[PAGE_MAX_SIZE] __attribute__((aligned(PAGE_MAX_SIZE)));
+#else
+  char protected_buffer[PAGE_SIZE] __attribute__((aligned(PAGE_SIZE)));
+#endif  // defined PAGE_MAX_SIZE
+#endif  // USE_PROTECTED_ALLOCATIONS
+  google_breakpad::ExceptionHandler* handler;
+} gProtectedData;
+
+ExceptionHandler::ExceptionHandler(const string& dump_path,
+                                   FilterCallback filter,
+                                   MinidumpCallback callback,
+                                   void* callback_context,
+                                   bool install_handler,
+                                   const char* port_name)
+    : dump_path_(),
+      filter_(filter),
+      callback_(callback),
+      callback_context_(callback_context),
+      directCallback_(NULL),
+      installed_exception_handler_(false),
+      is_in_teardown_(false) {
+  // This will update to the ID and C-string pointers
+  set_dump_path(dump_path);
+  MinidumpGenerator::GatherSystemInformation();
+  Setup();
+}
+
+// special constructor if we want to bypass minidump writing and
+// simply get a callback with the exception information
+ExceptionHandler::ExceptionHandler(DirectCallback callback,
+                                   void* callback_context,
+                                   bool install_handler)
+    : dump_path_(),
+      filter_(NULL),
+      callback_(NULL),
+      callback_context_(callback_context),
+      directCallback_(callback),
+      installed_exception_handler_(false),
+      is_in_teardown_(false) {
+  MinidumpGenerator::GatherSystemInformation();
+  Setup();
+}
+
+ExceptionHandler::~ExceptionHandler() {
+  Teardown();
+}
+
+bool ExceptionHandler::WriteMinidumpWithException(
+    int exception_type,
+    int exception_code,
+    int exception_subcode,
+    breakpad_ucontext_t* task_context,
+    mach_port_t thread_name,
+    bool exit_after_write,
+    bool report_current_thread) {
+  bool result = false;
+
+#if !TARGET_OS_TV
+  exit_after_write = false;
+#endif  // !TARGET_OS_TV
+
+  if (directCallback_) {
+    if (directCallback_(callback_context_,
+                        exception_type,
+                        exception_code,
+                        exception_subcode,
+                        thread_name) ) {
+      if (exit_after_write)
+        _exit(exception_type);
+    }
+  } else {
+    string minidump_id;
+
+    // Putting the MinidumpGenerator in its own context will ensure that the
+    // destructor is executed, closing the newly created minidump file.
+    if (!dump_path_.empty()) {
+      MinidumpGenerator md(mach_task_self(),
+                           report_current_thread ? MACH_PORT_NULL :
+                                                   mach_thread_self());
+      md.SetTaskContext(task_context);
+      if (exception_type && exception_code) {
+        // If this is a real exception, give the filter (if any) a chance to
+        // decide if this should be sent.
+        if (filter_ && !filter_(callback_context_))
+          return false;
+
+        md.SetExceptionInformation(exception_type, exception_code,
+                                   exception_subcode, thread_name);
+      }
+
+      result = md.Write(next_minidump_path_c_);
+    }
+
+    // Call user specified callback (if any)
+    if (callback_) {
+      // If the user callback returned true and we're handling an exception
+      // (rather than just writing out the file), then we should exit without
+      // forwarding the exception to the next handler.
+      if (callback_(dump_path_c_, next_minidump_id_c_, callback_context_,
+                    result)) {
+        if (exit_after_write)
+          _exit(exception_type);
+      }
+    }
+  }
+
+  return result;
+}
+
+// static
+void ExceptionHandler::SignalHandler(int sig, siginfo_t* info, void* uc) {
+#if USE_PROTECTED_ALLOCATIONS
+  if (gBreakpadAllocator)
+    gBreakpadAllocator->Unprotect();
+#endif
+  gProtectedData.handler->WriteMinidumpWithException(
+      EXC_SOFTWARE,
+      MD_EXCEPTION_CODE_MAC_ABORT,
+      0,
+      static_cast<breakpad_ucontext_t*>(uc),
+      mach_thread_self(),
+      true,
+      true);
+#if USE_PROTECTED_ALLOCATIONS
+  if (gBreakpadAllocator)
+    gBreakpadAllocator->Protect();
+#endif
+}
+
+bool ExceptionHandler::InstallHandlers() {
+  // If a handler is already installed, something is really wrong.
+  if (gProtectedData.handler != NULL)
+    return false;
+  for (int i = 0; i < kNumHandledSignals; ++i) {
+    struct sigaction sa;
+    memset(&sa, 0, sizeof(sa));
+    sigemptyset(&sa.sa_mask);
+    sigaddset(&sa.sa_mask, kExceptionSignals[i]);
+    sa.sa_sigaction = ExceptionHandler::SignalHandler;
+    sa.sa_flags = SA_ONSTACK | SA_SIGINFO;
+
+    if (sigaction(kExceptionSignals[i], &sa, old_handlers[i].get()) == -1) {
+      return false;
+    }
+  }
+  gProtectedData.handler = this;
+#if USE_PROTECTED_ALLOCATIONS
+  assert(((size_t)(gProtectedData.protected_buffer) & PAGE_MASK) == 0);
+  mprotect(gProtectedData.protected_buffer, PAGE_SIZE, PROT_READ);
+#endif  // USE_PROTECTED_ALLOCATIONS
+  installed_exception_handler_ = true;
+  return true;
+}
+
+bool ExceptionHandler::UninstallHandlers() {
+  for (int i = 0; i < kNumHandledSignals; ++i) {
+    if (old_handlers[i].get()) {
+      sigaction(kExceptionSignals[i], old_handlers[i].get(), NULL);
+      old_handlers[i].reset();
+    }
+  }
+#if USE_PROTECTED_ALLOCATIONS
+  mprotect(gProtectedData.protected_buffer, PAGE_SIZE, PROT_READ | PROT_WRITE);
+#endif  // USE_PROTECTED_ALLOCATIONS
+  gProtectedData.handler = NULL;
+  installed_exception_handler_ = false;
+  return true;
+}
+
+bool ExceptionHandler::Setup() {
+  if (!InstallHandlers())
+    return false;
+  return true;
+}
+
+bool ExceptionHandler::Teardown() {
+  is_in_teardown_ = true;
+
+  if (!UninstallHandlers())
+    return false;
+
+  return true;
+}
+
+void ExceptionHandler::UpdateNextID() {
+  next_minidump_path_ =
+    (MinidumpGenerator::UniqueNameInDirectory(dump_path_, &next_minidump_id_));
+
+  next_minidump_path_c_ = next_minidump_path_.c_str();
+  next_minidump_id_c_ = next_minidump_id_.c_str();
+}
+
+}  // namespace google_breakpad
diff --git a/src/MEGASync/google_breakpad/client/ios/exception_handler_no_mach.h b/src/MEGASync/google_breakpad/client/ios/exception_handler_no_mach.h
new file mode 100644
index 00000000..ec598dcf
--- /dev/null
+++ b/src/MEGASync/google_breakpad/client/ios/exception_handler_no_mach.h
@@ -0,0 +1,179 @@
+// Copyright (c) 2006, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef CLIENT_IOS_HANDLER_EXCEPTION_HANDLER_NO_MACH_H__
+#define CLIENT_IOS_HANDLER_EXCEPTION_HANDLER_NO_MACH_H__
+
+#include <mach/mach.h>
+#include <TargetConditionals.h>
+
+#include <string>
+
+#include "client/mac/handler/ucontext_compat.h"
+#include "common/scoped_ptr.h"
+
+namespace google_breakpad {
+
+using std::string;
+
+class ExceptionHandler {
+ public:
+  // A callback function to run before Breakpad performs any substantial
+  // processing of an exception.  A FilterCallback is called before writing
+  // a minidump.  context is the parameter supplied by the user as
+  // callback_context when the handler was created.
+  //
+  // If a FilterCallback returns true, Breakpad will continue processing,
+  // attempting to write a minidump.  If a FilterCallback returns false, Breakpad
+  // will immediately report the exception as unhandled without writing a
+  // minidump, allowing another handler the opportunity to handle it.
+  typedef bool (*FilterCallback)(void* context);
+
+  // A callback function to run after the minidump has been written.
+  // |minidump_id| is a unique id for the dump, so the minidump
+  // file is <dump_dir>/<minidump_id>.dmp.
+  // |context| is the value passed into the constructor.
+  // |succeeded| indicates whether a minidump file was successfully written.
+  // Return true if the exception was fully handled and breakpad should exit.
+  // Return false to allow any other exception handlers to process the
+  // exception.
+  typedef bool (*MinidumpCallback)(const char* dump_dir,
+                                   const char* minidump_id,
+                                   void* context, bool succeeded);
+
+  // A callback function which will be called directly if an exception occurs.
+  // This bypasses the minidump file writing and simply gives the client
+  // the exception information.
+  typedef bool (*DirectCallback)(void* context,
+                                 int exception_type,
+                                 int exception_code,
+                                 int exception_subcode,
+                                 mach_port_t thread_name);
+
+  // Creates a new ExceptionHandler instance to handle writing minidumps.
+  // Minidump files will be written to dump_path, and the optional callback
+  // is called after writing the dump file, as described above.
+  // If install_handler is true, then a minidump will be written whenever
+  // an unhandled exception occurs.  If it is false, minidumps will only
+  // be written when WriteMinidump is called.
+  // If port_name is non-NULL, attempt to perform out-of-process dump generation
+  // If port_name is NULL, in-process dump generation will be used.
+  ExceptionHandler(const string& dump_path,
+                   FilterCallback filter, MinidumpCallback callback,
+                   void* callback_context, bool install_handler,
+                   const char* port_name);
+
+  // A special constructor if we want to bypass minidump writing and
+  // simply get a callback with the exception information.
+  ExceptionHandler(DirectCallback callback,
+                   void* callback_context,
+                   bool install_handler);
+
+  ~ExceptionHandler();
+
+  // Get and set the minidump path.
+  string dump_path() const { return dump_path_; }
+  void set_dump_path(const string& dump_path) {
+    dump_path_ = dump_path;
+    dump_path_c_ = dump_path_.c_str();
+    UpdateNextID();  // Necessary to put dump_path_ in next_minidump_path_.
+  }
+
+ private:
+  // Install the SIG exception handlers.
+  bool InstallHandlers();
+
+  // Uninstall the SIG exception handlers.
+  bool UninstallHandlers();
+
+  // Setup the handler thread, and if |install_handler| is true, install the
+  // mach exception port handler
+  bool Setup();
+
+  // Uninstall the mach exception handler (if any) and terminate the helper
+  // thread
+  bool Teardown();
+
+  // All minidump writing goes through this one routine.
+  // |task_context| can be NULL. If not, it will be used to retrieve the
+  // context of the current thread, instead of using |thread_get_state|.
+  bool WriteMinidumpWithException(int exception_type,
+                                  int exception_code,
+                                  int exception_subcode,
+                                  breakpad_ucontext_t* task_context,
+                                  mach_port_t thread_name,
+                                  bool exit_after_write,
+                                  bool report_current_thread);
+
+  // Signal handler for SIG exceptions.
+  static void SignalHandler(int sig, siginfo_t* info, void* uc);
+
+  // disallow copy ctor and operator=
+  explicit ExceptionHandler(const ExceptionHandler&);
+  void operator=(const ExceptionHandler&);
+
+  // Generates a new ID and stores it in next_minidump_id_, and stores the
+  // path of the next minidump to be written in next_minidump_path_.
+  void UpdateNextID();
+
+  // The destination directory for the minidump
+  string dump_path_;
+
+  // The basename of the next minidump w/o extension
+  string next_minidump_id_;
+
+  // The full path to the next minidump to be written, including extension
+  string next_minidump_path_;
+
+  // Pointers to the UTF-8 versions of above
+  const char* dump_path_c_;
+  const char* next_minidump_id_c_;
+  const char* next_minidump_path_c_;
+
+  // The callback function and pointer to be passed back after the minidump
+  // has been written
+  FilterCallback filter_;
+  MinidumpCallback callback_;
+  void* callback_context_;
+
+  // The callback function to be passed back when we don't want a minidump
+  // file to be written
+  DirectCallback directCallback_;
+
+  // True, if we've installed the exception handler
+  bool installed_exception_handler_;
+
+  // True, if we're in the process of uninstalling the exception handler and
+  // the thread.
+  bool is_in_teardown_;
+};
+
+}  // namespace google_breakpad
+
+#endif  // CLIENT_IOS_HANDLER_EXCEPTION_HANDLER_NO_MACH_H__
diff --git a/src/MEGASync/google_breakpad/client/ios/handler/ios_exception_minidump_generator.h b/src/MEGASync/google_breakpad/client/ios/handler/ios_exception_minidump_generator.h
index 21133e63..e48444a7 100644
--- a/src/MEGASync/google_breakpad/client/ios/handler/ios_exception_minidump_generator.h
+++ b/src/MEGASync/google_breakpad/client/ios/handler/ios_exception_minidump_generator.h
@@ -41,12 +41,12 @@ namespace google_breakpad {
 
 class IosExceptionMinidumpGenerator : public MinidumpGenerator {
  public:
-  explicit IosExceptionMinidumpGenerator(NSException *exception);
+  explicit IosExceptionMinidumpGenerator(NSException* exception);
   virtual ~IosExceptionMinidumpGenerator();
 
  protected:
-  virtual bool WriteExceptionStream(MDRawDirectory *exception_stream);
-  virtual bool WriteThreadStream(mach_port_t thread_id, MDRawThread *thread);
+  virtual bool WriteExceptionStream(MDRawDirectory* exception_stream);
+  virtual bool WriteThreadStream(mach_port_t thread_id, MDRawThread* thread);
 
  private:
 
@@ -57,16 +57,16 @@ class IosExceptionMinidumpGenerator : public MinidumpGenerator {
   uintptr_t GetLRFromException();
 
   // Write a virtual thread context for the crashing site.
-  bool WriteCrashingContext(MDLocationDescriptor *register_location);
+  bool WriteCrashingContext(MDLocationDescriptor* register_location);
   // Per-CPU implementations of the above method.
 #ifdef HAS_ARM_SUPPORT
-  bool WriteCrashingContextARM(MDLocationDescriptor *register_location);
+  bool WriteCrashingContextARM(MDLocationDescriptor* register_location);
 #endif
 #ifdef HAS_ARM64_SUPPORT
-  bool WriteCrashingContextARM64(MDLocationDescriptor *register_location);
+  bool WriteCrashingContextARM64(MDLocationDescriptor* register_location);
 #endif
 
-  NSArray *return_addresses_;
+  NSArray* return_addresses_;
 };
 
 }  // namespace google_breakpad
diff --git a/src/MEGASync/google_breakpad/client/ios/handler/ios_exception_minidump_generator.mm b/src/MEGASync/google_breakpad/client/ios/handler/ios_exception_minidump_generator.mm
index 290ac6c5..2a5d76d7 100644
--- a/src/MEGASync/google_breakpad/client/ios/handler/ios_exception_minidump_generator.mm
+++ b/src/MEGASync/google_breakpad/client/ios/handler/ios_exception_minidump_generator.mm
@@ -43,15 +43,16 @@
 
 namespace {
 
-const uintptr_t kExpectedFinalFp = sizeof(uintptr_t);
-const uintptr_t kExpectedFinalSp = 0;
 const int kExceptionType = EXC_SOFTWARE;
 const int kExceptionCode = MD_EXCEPTION_CODE_MAC_NS_EXCEPTION;
 
 #if defined(HAS_ARM_SUPPORT) || defined(HAS_ARM64_SUPPORT)
+const uintptr_t kExpectedFinalFp = sizeof(uintptr_t);
+const uintptr_t kExpectedFinalSp = 0;
+
 // Append the given value to the sp position of the stack represented
 // by memory.
-void AppendToMemory(uint8_t *memory, uintptr_t sp, uintptr_t data) {
+void AppendToMemory(uint8_t* memory, uintptr_t sp, uintptr_t data) {
   memcpy(memory + sp, &data, sizeof(data));
 }
 #endif
@@ -61,7 +62,7 @@ void AppendToMemory(uint8_t *memory, uintptr_t sp, uintptr_t data) {
 namespace google_breakpad {
 
 IosExceptionMinidumpGenerator::IosExceptionMinidumpGenerator(
-    NSException *exception)
+    NSException* exception)
     : MinidumpGenerator(mach_task_self(), 0) {
   return_addresses_ = [[exception callStackReturnAddresses] retain];
   SetExceptionInformation(kExceptionType,
@@ -75,7 +76,7 @@ IosExceptionMinidumpGenerator::~IosExceptionMinidumpGenerator() {
 }
 
 bool IosExceptionMinidumpGenerator::WriteCrashingContext(
-    MDLocationDescriptor *register_location) {
+    MDLocationDescriptor* register_location) {
 #ifdef HAS_ARM_SUPPORT
   return WriteCrashingContextARM(register_location);
 #elif defined(HAS_ARM64_SUPPORT)
@@ -88,12 +89,12 @@ bool IosExceptionMinidumpGenerator::WriteCrashingContext(
 
 #ifdef HAS_ARM_SUPPORT
 bool IosExceptionMinidumpGenerator::WriteCrashingContextARM(
-    MDLocationDescriptor *register_location) {
+    MDLocationDescriptor* register_location) {
   TypedMDRVA<MDRawContextARM> context(&writer_);
   if (!context.Allocate())
     return false;
   *register_location = context.location();
-  MDRawContextARM *context_ptr = context.get();
+  MDRawContextARM* context_ptr = context.get();
   memset(context_ptr, 0, sizeof(MDRawContextARM));
   context_ptr->context_flags = MD_CONTEXT_ARM_FULL;
   context_ptr->iregs[MD_CONTEXT_ARM_REG_IOS_FP] = kExpectedFinalFp;  // FP
@@ -106,14 +107,14 @@ bool IosExceptionMinidumpGenerator::WriteCrashingContextARM(
 
 #ifdef HAS_ARM64_SUPPORT
 bool IosExceptionMinidumpGenerator::WriteCrashingContextARM64(
-    MDLocationDescriptor *register_location) {
-  TypedMDRVA<MDRawContextARM64> context(&writer_);
+    MDLocationDescriptor* register_location) {
+  TypedMDRVA<MDRawContextARM64_Old> context(&writer_);
   if (!context.Allocate())
     return false;
   *register_location = context.location();
-  MDRawContextARM64 *context_ptr = context.get();
+  MDRawContextARM64_Old* context_ptr = context.get();
   memset(context_ptr, 0, sizeof(*context_ptr));
-  context_ptr->context_flags = MD_CONTEXT_ARM64_FULL;
+  context_ptr->context_flags = MD_CONTEXT_ARM64_FULL_OLD;
   context_ptr->iregs[MD_CONTEXT_ARM64_REG_FP] = kExpectedFinalFp;      // FP
   context_ptr->iregs[MD_CONTEXT_ARM64_REG_SP] = kExpectedFinalSp;      // SP
   context_ptr->iregs[MD_CONTEXT_ARM64_REG_LR] = GetLRFromException();  // LR
@@ -131,7 +132,7 @@ uintptr_t IosExceptionMinidumpGenerator::GetLRFromException() {
 }
 
 bool IosExceptionMinidumpGenerator::WriteExceptionStream(
-    MDRawDirectory *exception_stream) {
+    MDRawDirectory* exception_stream) {
 #if defined(HAS_ARM_SUPPORT) || defined(HAS_ARM64_SUPPORT)
   TypedMDRVA<MDRawExceptionStream> exception(&writer_);
 
@@ -140,7 +141,7 @@ bool IosExceptionMinidumpGenerator::WriteExceptionStream(
 
   exception_stream->stream_type = MD_EXCEPTION_STREAM;
   exception_stream->location = exception.location();
-  MDRawExceptionStream *exception_ptr = exception.get();
+  MDRawExceptionStream* exception_ptr = exception.get();
   exception_ptr->thread_id = pthread_mach_thread_np(pthread_self());
 
   // This naming is confusing, but it is the proper translation from
@@ -159,12 +160,14 @@ bool IosExceptionMinidumpGenerator::WriteExceptionStream(
 }
 
 bool IosExceptionMinidumpGenerator::WriteThreadStream(mach_port_t thread_id,
-                                                      MDRawThread *thread) {
+                                                      MDRawThread* thread) {
 #if defined(HAS_ARM_SUPPORT) || defined(HAS_ARM64_SUPPORT)
   if (pthread_mach_thread_np(pthread_self()) != thread_id)
     return MinidumpGenerator::WriteThreadStream(thread_id, thread);
 
   size_t frame_count = [return_addresses_ count];
+  if (frame_count == 0)
+    return false;
   UntypedMDRVA memory(&writer_);
   size_t pointer_size = sizeof(uintptr_t);
   size_t frame_record_size = 2 * pointer_size;
@@ -175,7 +178,7 @@ bool IosExceptionMinidumpGenerator::WriteThreadStream(mach_port_t thread_id,
   uintptr_t sp = stack_size - pointer_size;
   uintptr_t fp = 0;
   uintptr_t lr = 0;
-  for (int current_frame = frame_count - 1;
+  for (size_t current_frame = frame_count - 1;
        current_frame > 0;
        --current_frame) {
     AppendToMemory(stack_memory.get(), sp, lr);
diff --git a/src/MEGASync/google_breakpad/client/linux/crash_generation/crash_generation_client.cc b/src/MEGASync/google_breakpad/client/linux/crash_generation/crash_generation_client.cc
index 6ede7791..d8bfbbad 100644
--- a/src/MEGASync/google_breakpad/client/linux/crash_generation/crash_generation_client.cc
+++ b/src/MEGASync/google_breakpad/client/linux/crash_generation/crash_generation_client.cc
@@ -27,66 +27,79 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
+#include "client/linux/crash_generation/crash_generation_client.h"
+
 #include <stdio.h>
 #include <sys/socket.h>
 #include <sys/types.h>
 
 #include <algorithm>
 
-#include "client/linux/crash_generation/crash_generation_client.h"
 #include "common/linux/eintr_wrapper.h"
 #include "common/linux/ignore_ret.h"
-#include "common/linux/linux_libc_support.h"
 #include "third_party/lss/linux_syscall_support.h"
 
 namespace google_breakpad {
 
-bool
-CrashGenerationClient::RequestDump(const void* blob, size_t blob_size)
-{
-  int fds[2];
-  sys_socketpair(AF_UNIX, SOCK_STREAM, 0, fds);
-  static const unsigned kControlMsgSize = CMSG_SPACE(sizeof(int));
-
-  struct kernel_msghdr msg;
-  my_memset(&msg, 0, sizeof(struct kernel_msghdr));
-  struct kernel_iovec iov[1];
-  iov[0].iov_base = const_cast<void*>(blob);
-  iov[0].iov_len = blob_size;
-
-  msg.msg_iov = iov;
-  msg.msg_iovlen = sizeof(iov) / sizeof(iov[0]);
-  char cmsg[kControlMsgSize];
-  my_memset(cmsg, 0, kControlMsgSize);
-  msg.msg_control = cmsg;
-  msg.msg_controllen = sizeof(cmsg);
-
-  struct cmsghdr* hdr = CMSG_FIRSTHDR(&msg);
-  hdr->cmsg_level = SOL_SOCKET;
-  hdr->cmsg_type = SCM_RIGHTS;
-  hdr->cmsg_len = CMSG_LEN(sizeof(int));
-  int* p = reinterpret_cast<int*>(CMSG_DATA(hdr));
-  *p = fds[1];
-
-  ssize_t ret = HANDLE_EINTR(sys_sendmsg(server_fd_, &msg, 0));
-  sys_close(fds[1]);
-  if (ret <= 0)
-    return false;
-
-  // wait for an ACK from the server
-  char b;
-  IGNORE_RET(HANDLE_EINTR(sys_read(fds[0], &b, 1)));
-
-  return true;
-}
+namespace {
+
+class CrashGenerationClientImpl : public CrashGenerationClient {
+ public:
+  explicit CrashGenerationClientImpl(int server_fd) : server_fd_(server_fd) {}
+  virtual ~CrashGenerationClientImpl() {}
+
+  virtual bool RequestDump(const void* blob, size_t blob_size) {
+    int fds[2];
+    if (sys_pipe(fds) < 0)
+      return false;
+    static const unsigned kControlMsgSize = CMSG_SPACE(sizeof(int));
+
+    struct kernel_iovec iov;
+    iov.iov_base = const_cast<void*>(blob);
+    iov.iov_len = blob_size;
+
+    struct kernel_msghdr msg = { 0 };
+    msg.msg_iov = &iov;
+    msg.msg_iovlen = 1;
+    char cmsg[kControlMsgSize] = "";
+    msg.msg_control = cmsg;
+    msg.msg_controllen = sizeof(cmsg);
 
-//static
-CrashGenerationClient*
-CrashGenerationClient::TryCreate(int server_fd)
-{
-  if (0 > server_fd)
+    struct cmsghdr* hdr = CMSG_FIRSTHDR(&msg);
+    hdr->cmsg_level = SOL_SOCKET;
+    hdr->cmsg_type = SCM_RIGHTS;
+    hdr->cmsg_len = CMSG_LEN(sizeof(int));
+    int* p = reinterpret_cast<int*>(CMSG_DATA(hdr));
+    *p = fds[1];
+
+    ssize_t ret = HANDLE_EINTR(sys_sendmsg(server_fd_, &msg, 0));
+    sys_close(fds[1]);
+    if (ret < 0) {
+      sys_close(fds[0]);
+      return false;
+    }
+
+    // Wait for an ACK from the server.
+    char b;
+    IGNORE_RET(HANDLE_EINTR(sys_read(fds[0], &b, 1)));
+    sys_close(fds[0]);
+
+    return true;
+  }
+
+ private:
+  int server_fd_;
+
+  DISALLOW_COPY_AND_ASSIGN(CrashGenerationClientImpl);
+};
+
+}  // namespace
+
+// static
+CrashGenerationClient* CrashGenerationClient::TryCreate(int server_fd) {
+  if (server_fd < 0)
     return NULL;
-  return new CrashGenerationClient(server_fd);
+  return new CrashGenerationClientImpl(server_fd);
 }
 
-}
+}  // namespace google_breakpad
diff --git a/src/MEGASync/google_breakpad/client/linux/crash_generation/crash_generation_client.h b/src/MEGASync/google_breakpad/client/linux/crash_generation/crash_generation_client.h
index 7139dff4..4e68424a 100644
--- a/src/MEGASync/google_breakpad/client/linux/crash_generation/crash_generation_client.h
+++ b/src/MEGASync/google_breakpad/client/linux/crash_generation/crash_generation_client.h
@@ -30,40 +30,36 @@
 #ifndef CLIENT_LINUX_CRASH_GENERATION_CRASH_GENERATION_CLIENT_H_
 #define CLIENT_LINUX_CRASH_GENERATION_CRASH_GENERATION_CLIENT_H_
 
+#include "common/basictypes.h"
+
 #include <stddef.h>
 
 namespace google_breakpad {
 
+// CrashGenerationClient is an interface for implementing out-of-process crash
+// dumping.  The default implementation, accessed via the TryCreate() factory,
+// works in conjunction with the CrashGenerationServer to generate a minidump
+// via a remote process.
 class CrashGenerationClient {
-public:
-  ~CrashGenerationClient()
-  {
-  }
+ public:
+  CrashGenerationClient() {}
+  virtual ~CrashGenerationClient() {}
 
-  // Request the crash server to generate a dump.  |blob| is a hack,
-  // see exception_handler.h and minidump_writer.h
-  //
-  // Return true if the dump was successful; false otherwise.
-  bool RequestDump(const void* blob, size_t blob_size);
+  // Request the crash server to generate a dump.  |blob| is an opaque
+  // CrashContext pointer from exception_handler.h.
+  // Returns true if the dump was successful; false otherwise.
+  virtual bool RequestDump(const void* blob, size_t blob_size) = 0;
 
-  // Return a new CrashGenerationClient if |server_fd| is valid and
+  // Returns a new CrashGenerationClient if |server_fd| is valid and
   // connects to a CrashGenerationServer.  Otherwise, return NULL.
   // The returned CrashGenerationClient* is owned by the caller of
   // this function.
   static CrashGenerationClient* TryCreate(int server_fd);
 
-private:
-  CrashGenerationClient(int server_fd) : server_fd_(server_fd)
-  {
-  }
-
-  int server_fd_;
-
-  // prevent copy construction and assignment
-  CrashGenerationClient(const CrashGenerationClient&);
-  CrashGenerationClient& operator=(const CrashGenerationClient&);
+ private:
+  DISALLOW_COPY_AND_ASSIGN(CrashGenerationClient);
 };
 
-} // namespace google_breakpad
+}  // namespace google_breakpad
 
-#endif // CLIENT_LINUX_CRASH_GENERATION_CRASH_GENERATION_CLIENT_H_
+#endif  // CLIENT_LINUX_CRASH_GENERATION_CRASH_GENERATION_CLIENT_H_
diff --git a/src/MEGASync/google_breakpad/client/linux/crash_generation/crash_generation_server.cc b/src/MEGASync/google_breakpad/client/linux/crash_generation/crash_generation_server.cc
index 8ec95038..8332f59d 100644
--- a/src/MEGASync/google_breakpad/client/linux/crash_generation/crash_generation_server.cc
+++ b/src/MEGASync/google_breakpad/client/linux/crash_generation/crash_generation_server.cc
@@ -51,116 +51,6 @@
 
 static const char kCommandQuit = 'x';
 
-static bool
-GetInodeForFileDescriptor(ino_t* inode_out, int fd)
-{
-  assert(inode_out);
-
-  struct stat buf;
-  if (fstat(fd, &buf) < 0)
-    return false;
-
-  if (!S_ISSOCK(buf.st_mode))
-    return false;
-
-  *inode_out = buf.st_ino;
-  return true;
-}
-
-// expected prefix of the target of the /proc/self/fd/%d link for a socket
-static const char kSocketLinkPrefix[] = "socket:[";
-
-// Parse a symlink in /proc/pid/fd/$x and return the inode number of the
-// socket.
-//   inode_out: (output) set to the inode number on success
-//   path: e.g. /proc/1234/fd/5 (must be a UNIX domain socket descriptor)
-static bool
-GetInodeForProcPath(ino_t* inode_out, const char* path)
-{
-  assert(inode_out);
-  assert(path);
-
-  char buf[PATH_MAX];
-  if (!google_breakpad::SafeReadLink(path, buf)) {
-    return false;
-  }
-
-  if (0 != memcmp(kSocketLinkPrefix, buf, sizeof(kSocketLinkPrefix) - 1)) {
-    return false;
-  }
-
-  char* endptr;
-  const uint64_t inode_ul =
-      strtoull(buf + sizeof(kSocketLinkPrefix) - 1, &endptr, 10);
-  if (*endptr != ']')
-    return false;
-
-  if (inode_ul == ULLONG_MAX) {
-    return false;
-  }
-
-  *inode_out = inode_ul;
-  return true;
-}
-
-static bool
-FindProcessHoldingSocket(pid_t* pid_out, ino_t socket_inode)
-{
-  assert(pid_out);
-  bool already_found = false;
-
-  DIR* proc = opendir("/proc");
-  if (!proc) {
-    return false;
-  }
-
-  std::vector<pid_t> pids;
-
-  struct dirent* dent;
-  while ((dent = readdir(proc))) {
-    char* endptr;
-    const unsigned long int pid_ul = strtoul(dent->d_name, &endptr, 10);
-    if (pid_ul == ULONG_MAX || '\0' != *endptr)
-      continue;
-    pids.push_back(pid_ul);
-  }
-  closedir(proc);
-
-  for (std::vector<pid_t>::const_iterator
-       i = pids.begin(); i != pids.end(); ++i) {
-    const pid_t current_pid = *i;
-    char buf[PATH_MAX];
-    snprintf(buf, sizeof(buf), "/proc/%d/fd", current_pid);
-    DIR* fd = opendir(buf);
-    if (!fd)
-      continue;
-
-    while ((dent = readdir(fd))) {
-      if (snprintf(buf, sizeof(buf), "/proc/%d/fd/%s", current_pid,
-                   dent->d_name) >= static_cast<int>(sizeof(buf))) {
-        continue;
-      }
-
-      ino_t fd_inode;
-      if (GetInodeForProcPath(&fd_inode, buf)
-          && fd_inode == socket_inode) {
-        if (already_found) {
-          closedir(fd);
-          return false;
-        }
-
-        already_found = true;
-        *pid_out = current_pid;
-        break;
-      }
-    }
-
-    closedir(fd);
-  }
-
-  return already_found;
-}
-
 namespace google_breakpad {
 
 CrashGenerationServer::CrashGenerationServer(
@@ -233,6 +123,9 @@ CrashGenerationServer::Stop()
   void* dummy;
   pthread_join(thread_, &dummy);
 
+  close(control_pipe_in_);
+  close(control_pipe_out_);
+
   started_ = false;
 }
 
@@ -336,7 +229,7 @@ CrashGenerationServer::ClientEvent(short revents)
   // Walk the control payload and extract the file descriptor and validated pid.
   pid_t crashing_pid = -1;
   int signal_fd = -1;
-  for (struct cmsghdr *hdr = CMSG_FIRSTHDR(&msg); hdr;
+  for (struct cmsghdr* hdr = CMSG_FIRSTHDR(&msg); hdr;
        hdr = CMSG_NXTHDR(&msg, hdr)) {
     if (hdr->cmsg_level != SOL_SOCKET)
       continue;
@@ -355,35 +248,18 @@ CrashGenerationServer::ClientEvent(short revents)
         signal_fd = reinterpret_cast<int*>(CMSG_DATA(hdr))[0];
       }
     } else if (hdr->cmsg_type == SCM_CREDENTIALS) {
-      const struct ucred *cred =
+      const struct ucred* cred =
           reinterpret_cast<struct ucred*>(CMSG_DATA(hdr));
       crashing_pid = cred->pid;
     }
   }
 
   if (crashing_pid == -1 || signal_fd == -1) {
-    if (signal_fd)
+    if (signal_fd != -1)
       close(signal_fd);
     return true;
   }
 
-  // Kernel bug workaround (broken in 2.6.30 at least):
-  // The kernel doesn't translate PIDs in SCM_CREDENTIALS across PID
-  // namespaces. Thus |crashing_pid| might be garbage from our point of view.
-  // In the future we can remove this workaround, but we have to wait a couple
-  // of years to be sure that it's worked its way out into the world.
-
-  ino_t inode_number;
-  if (!GetInodeForFileDescriptor(&inode_number, signal_fd)) {
-    close(signal_fd);
-    return true;
-  }
-
-  if (!FindProcessHoldingSocket(&crashing_pid, inode_number - 1)) {
-    close(signal_fd);
-    return true;
-  }
-
   string minidump_filename;
   if (!MakeMinidumpFilename(minidump_filename))
     return true;
@@ -402,14 +278,7 @@ CrashGenerationServer::ClientEvent(short revents)
   }
 
   // Send the done signal to the process: it can exit now.
-  memset(&msg, 0, sizeof(msg));
-  struct iovec done_iov;
-  done_iov.iov_base = const_cast<char*>("\x42");
-  done_iov.iov_len = 1;
-  msg.msg_iov = &done_iov;
-  msg.msg_iovlen = 1;
-
-  HANDLE_EINTR(sendmsg(signal_fd, &msg, MSG_DONTWAIT | MSG_NOSIGNAL));
+  // (Closing this will make the child's sys_read unblock and return 0.)
   close(signal_fd);
 
   return true;
@@ -455,7 +324,7 @@ CrashGenerationServer::MakeMinidumpFilename(string& outFilename)
 
 // static
 void*
-CrashGenerationServer::ThreadMain(void *arg)
+CrashGenerationServer::ThreadMain(void* arg)
 {
   reinterpret_cast<CrashGenerationServer*>(arg)->Run();
   return NULL;
diff --git a/src/MEGASync/google_breakpad/client/linux/dump_writer_common/mapping_info.h b/src/MEGASync/google_breakpad/client/linux/dump_writer_common/mapping_info.h
new file mode 100644
index 00000000..c09e48ab
--- /dev/null
+++ b/src/MEGASync/google_breakpad/client/linux/dump_writer_common/mapping_info.h
@@ -0,0 +1,74 @@
+// Copyright (c) 2014, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef CLIENT_LINUX_DUMP_WRITER_COMMON_MAPPING_INFO_H_
+#define CLIENT_LINUX_DUMP_WRITER_COMMON_MAPPING_INFO_H_
+
+#include <limits.h>
+#include <list>
+#include <stdint.h>
+
+#include "google_breakpad/common/minidump_format.h"
+
+namespace google_breakpad {
+
+// One of these is produced for each mapping in the process (i.e. line in
+// /proc/$x/maps).
+struct MappingInfo {
+  // On Android, relocation packing can mean that the reported start
+  // address of the mapping must be adjusted by a bias in order to
+  // compensate for the compression of the relocation section. The
+  // following two members hold (after LateInit) the adjusted mapping
+  // range. See crbug.com/606972 for more information.
+  uintptr_t start_addr;
+  size_t size;
+  // When Android relocation packing causes |start_addr| and |size| to
+  // be modified with a load bias, we need to remember the unbiased
+  // address range. The following structure holds the original mapping
+  // address range as reported by the operating system.
+  struct {
+    uintptr_t start_addr;
+    uintptr_t end_addr;
+  } system_mapping_info;
+  size_t offset;  // offset into the backed file.
+  bool exec;  // true if the mapping has the execute bit set.
+  char name[NAME_MAX];
+};
+
+struct MappingEntry {
+  MappingInfo first;
+  uint8_t second[sizeof(MDGUID)];
+};
+
+// A list of <MappingInfo, GUID>
+typedef std::list<MappingEntry> MappingList;
+
+}  // namespace google_breakpad
+
+#endif  // CLIENT_LINUX_DUMP_WRITER_COMMON_MAPPING_INFO_H_
diff --git a/src/MEGASync/google_breakpad/client/linux/dump_writer_common/raw_context_cpu.h b/src/MEGASync/google_breakpad/client/linux/dump_writer_common/raw_context_cpu.h
new file mode 100644
index 00000000..07d9171a
--- /dev/null
+++ b/src/MEGASync/google_breakpad/client/linux/dump_writer_common/raw_context_cpu.h
@@ -0,0 +1,53 @@
+// Copyright (c) 2014, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef CLIENT_LINUX_DUMP_WRITER_COMMON_RAW_CONTEXT_CPU_H
+#define CLIENT_LINUX_DUMP_WRITER_COMMON_RAW_CONTEXT_CPU_H
+
+#include "google_breakpad/common/minidump_format.h"
+
+namespace google_breakpad {
+
+#if defined(__i386__)
+typedef MDRawContextX86 RawContextCPU;
+#elif defined(__x86_64)
+typedef MDRawContextAMD64 RawContextCPU;
+#elif defined(__ARM_EABI__)
+typedef MDRawContextARM RawContextCPU;
+#elif defined(__aarch64__)
+typedef MDRawContextARM64_Old RawContextCPU;
+#elif defined(__mips__)
+typedef MDRawContextMIPS RawContextCPU;
+#else
+#error "This code has not been ported to your platform yet."
+#endif
+
+}  // namespace google_breakpad
+
+#endif  // CLIENT_LINUX_DUMP_WRITER_COMMON_RAW_CONTEXT_CPU_H
diff --git a/src/MEGASync/google_breakpad/client/linux/dump_writer_common/thread_info.cc b/src/MEGASync/google_breakpad/client/linux/dump_writer_common/thread_info.cc
new file mode 100644
index 00000000..aae1dc13
--- /dev/null
+++ b/src/MEGASync/google_breakpad/client/linux/dump_writer_common/thread_info.cc
@@ -0,0 +1,305 @@
+// Copyright (c) 2014, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "client/linux/dump_writer_common/thread_info.h"
+
+#include <string.h>
+#include <assert.h>
+
+#include "common/linux/linux_libc_support.h"
+#include "google_breakpad/common/minidump_format.h"
+
+namespace {
+
+#if defined(__i386__)
+// Write a uint16_t to memory
+//   out: memory location to write to
+//   v: value to write.
+void U16(void* out, uint16_t v) {
+  my_memcpy(out, &v, sizeof(v));
+}
+
+// Write a uint32_t to memory
+//   out: memory location to write to
+//   v: value to write.
+void U32(void* out, uint32_t v) {
+  my_memcpy(out, &v, sizeof(v));
+}
+#endif
+
+}
+
+namespace google_breakpad {
+
+#if defined(__i386__)
+
+uintptr_t ThreadInfo::GetInstructionPointer() const {
+  return regs.eip;
+}
+
+void ThreadInfo::FillCPUContext(RawContextCPU* out) const {
+  out->context_flags = MD_CONTEXT_X86_ALL;
+
+  out->dr0 = dregs[0];
+  out->dr1 = dregs[1];
+  out->dr2 = dregs[2];
+  out->dr3 = dregs[3];
+  // 4 and 5 deliberatly omitted because they aren't included in the minidump
+  // format.
+  out->dr6 = dregs[6];
+  out->dr7 = dregs[7];
+
+  out->gs = regs.xgs;
+  out->fs = regs.xfs;
+  out->es = regs.xes;
+  out->ds = regs.xds;
+
+  out->edi = regs.edi;
+  out->esi = regs.esi;
+  out->ebx = regs.ebx;
+  out->edx = regs.edx;
+  out->ecx = regs.ecx;
+  out->eax = regs.eax;
+
+  out->ebp = regs.ebp;
+  out->eip = regs.eip;
+  out->cs = regs.xcs;
+  out->eflags = regs.eflags;
+  out->esp = regs.esp;
+  out->ss = regs.xss;
+
+  out->float_save.control_word = fpregs.cwd;
+  out->float_save.status_word = fpregs.swd;
+  out->float_save.tag_word = fpregs.twd;
+  out->float_save.error_offset = fpregs.fip;
+  out->float_save.error_selector = fpregs.fcs;
+  out->float_save.data_offset = fpregs.foo;
+  out->float_save.data_selector = fpregs.fos;
+
+  // 8 registers * 10 bytes per register.
+  my_memcpy(out->float_save.register_area, fpregs.st_space, 10 * 8);
+
+  // This matches the Intel fpsave format.
+  U16(out->extended_registers + 0, fpregs.cwd);
+  U16(out->extended_registers + 2, fpregs.swd);
+  U16(out->extended_registers + 4, fpregs.twd);
+  U16(out->extended_registers + 6, fpxregs.fop);
+  U32(out->extended_registers + 8, fpxregs.fip);
+  U16(out->extended_registers + 12, fpxregs.fcs);
+  U32(out->extended_registers + 16, fpregs.foo);
+  U16(out->extended_registers + 20, fpregs.fos);
+  U32(out->extended_registers + 24, fpxregs.mxcsr);
+
+  my_memcpy(out->extended_registers + 32, &fpxregs.st_space, 128);
+  my_memcpy(out->extended_registers + 160, &fpxregs.xmm_space, 128);
+}
+
+#elif defined(__x86_64)
+
+uintptr_t ThreadInfo::GetInstructionPointer() const {
+  return regs.rip;
+}
+
+void ThreadInfo::FillCPUContext(RawContextCPU* out) const {
+  out->context_flags = MD_CONTEXT_AMD64_FULL |
+                       MD_CONTEXT_AMD64_SEGMENTS;
+
+  out->cs = regs.cs;
+
+  out->ds = regs.ds;
+  out->es = regs.es;
+  out->fs = regs.fs;
+  out->gs = regs.gs;
+
+  out->ss = regs.ss;
+  out->eflags = regs.eflags;
+
+  out->dr0 = dregs[0];
+  out->dr1 = dregs[1];
+  out->dr2 = dregs[2];
+  out->dr3 = dregs[3];
+  // 4 and 5 deliberatly omitted because they aren't included in the minidump
+  // format.
+  out->dr6 = dregs[6];
+  out->dr7 = dregs[7];
+
+  out->rax = regs.rax;
+  out->rcx = regs.rcx;
+  out->rdx = regs.rdx;
+  out->rbx = regs.rbx;
+
+  out->rsp = regs.rsp;
+
+  out->rbp = regs.rbp;
+  out->rsi = regs.rsi;
+  out->rdi = regs.rdi;
+  out->r8 = regs.r8;
+  out->r9 = regs.r9;
+  out->r10 = regs.r10;
+  out->r11 = regs.r11;
+  out->r12 = regs.r12;
+  out->r13 = regs.r13;
+  out->r14 = regs.r14;
+  out->r15 = regs.r15;
+
+  out->rip = regs.rip;
+
+  out->flt_save.control_word = fpregs.cwd;
+  out->flt_save.status_word = fpregs.swd;
+  out->flt_save.tag_word = fpregs.ftw;
+  out->flt_save.error_opcode = fpregs.fop;
+  out->flt_save.error_offset = fpregs.rip;
+  out->flt_save.error_selector = 0;  // We don't have this.
+  out->flt_save.data_offset = fpregs.rdp;
+  out->flt_save.data_selector = 0;   // We don't have this.
+  out->flt_save.mx_csr = fpregs.mxcsr;
+  out->flt_save.mx_csr_mask = fpregs.mxcr_mask;
+
+  my_memcpy(&out->flt_save.float_registers, &fpregs.st_space, 8 * 16);
+  my_memcpy(&out->flt_save.xmm_registers, &fpregs.xmm_space, 16 * 16);
+}
+
+#elif defined(__ARM_EABI__)
+
+uintptr_t ThreadInfo::GetInstructionPointer() const {
+  return regs.uregs[15];
+}
+
+void ThreadInfo::FillCPUContext(RawContextCPU* out) const {
+  out->context_flags = MD_CONTEXT_ARM_FULL;
+
+  for (int i = 0; i < MD_CONTEXT_ARM_GPR_COUNT; ++i)
+    out->iregs[i] = regs.uregs[i];
+  // No CPSR register in ThreadInfo(it's not accessible via ptrace)
+  out->cpsr = 0;
+#if !defined(__ANDROID__)
+  out->float_save.fpscr = fpregs.fpsr |
+    (static_cast<uint64_t>(fpregs.fpcr) << 32);
+  // TODO: sort this out, actually collect floating point registers
+  my_memset(&out->float_save.regs, 0, sizeof(out->float_save.regs));
+  my_memset(&out->float_save.extra, 0, sizeof(out->float_save.extra));
+#endif
+}
+
+#elif defined(__aarch64__)
+
+uintptr_t ThreadInfo::GetInstructionPointer() const {
+  return regs.pc;
+}
+
+void ThreadInfo::FillCPUContext(RawContextCPU* out) const {
+  out->context_flags = MD_CONTEXT_ARM64_FULL_OLD;
+
+  out->cpsr = static_cast<uint32_t>(regs.pstate);
+  for (int i = 0; i < MD_CONTEXT_ARM64_REG_SP; ++i)
+    out->iregs[i] = regs.regs[i];
+  out->iregs[MD_CONTEXT_ARM64_REG_SP] = regs.sp;
+  out->iregs[MD_CONTEXT_ARM64_REG_PC] = regs.pc;
+
+  out->float_save.fpsr = fpregs.fpsr;
+  out->float_save.fpcr = fpregs.fpcr;
+  my_memcpy(&out->float_save.regs, &fpregs.vregs,
+      MD_FLOATINGSAVEAREA_ARM64_FPR_COUNT * 16);
+}
+
+#elif defined(__mips__)
+
+uintptr_t ThreadInfo::GetInstructionPointer() const {
+  return mcontext.pc;
+}
+
+void ThreadInfo::FillCPUContext(RawContextCPU* out) const {
+#if _MIPS_SIM == _ABI64
+  out->context_flags = MD_CONTEXT_MIPS64_FULL;
+#elif _MIPS_SIM == _ABIO32
+  out->context_flags = MD_CONTEXT_MIPS_FULL;
+#else
+# error "This mips ABI is currently not supported (n32)"
+#endif
+
+  for (int i = 0; i < MD_CONTEXT_MIPS_GPR_COUNT; ++i)
+    out->iregs[i] = mcontext.gregs[i];
+
+  out->mdhi = mcontext.mdhi;
+  out->mdlo = mcontext.mdlo;
+  out->dsp_control = mcontext.dsp;
+
+  out->hi[0] = mcontext.hi1;
+  out->lo[0] = mcontext.lo1;
+  out->hi[1] = mcontext.hi2;
+  out->lo[1] = mcontext.lo2;
+  out->hi[2] = mcontext.hi3;
+  out->lo[2] = mcontext.lo3;
+
+  out->epc = mcontext.pc;
+  out->badvaddr = 0; // Not stored in mcontext
+  out->status = 0; // Not stored in mcontext
+  out->cause = 0; // Not stored in mcontext
+
+  for (int i = 0; i < MD_FLOATINGSAVEAREA_MIPS_FPR_COUNT; ++i)
+    out->float_save.regs[i] = mcontext.fpregs.fp_r.fp_fregs[i]._fp_fregs;
+
+  out->float_save.fpcsr = mcontext.fpc_csr;
+#if _MIPS_SIM == _ABIO32
+  out->float_save.fir = mcontext.fpc_eir;
+#endif
+}
+#endif  // __mips__
+
+void ThreadInfo::GetGeneralPurposeRegisters(void** gp_regs, size_t* size) {
+  assert(gp_regs || size);
+#if defined(__mips__)
+  if (gp_regs)
+    *gp_regs = mcontext.gregs;
+  if (size)
+    *size = sizeof(mcontext.gregs);
+#else
+  if (gp_regs)
+    *gp_regs = &regs;
+  if (size)
+    *size = sizeof(regs);
+#endif
+}
+
+void ThreadInfo::GetFloatingPointRegisters(void** fp_regs, size_t* size) {
+  assert(fp_regs || size);
+#if defined(__mips__)
+  if (fp_regs)
+    *fp_regs = &mcontext.fpregs;
+  if (size)
+    *size = sizeof(mcontext.fpregs);
+#else
+  if (fp_regs)
+    *fp_regs = &fpregs;
+  if (size)
+    *size = sizeof(fpregs);
+#endif
+}
+
+}  // namespace google_breakpad
diff --git a/src/MEGASync/google_breakpad/client/linux/dump_writer_common/thread_info.h b/src/MEGASync/google_breakpad/client/linux/dump_writer_common/thread_info.h
new file mode 100644
index 00000000..fb216fa6
--- /dev/null
+++ b/src/MEGASync/google_breakpad/client/linux/dump_writer_common/thread_info.h
@@ -0,0 +1,91 @@
+// Copyright (c) 2014, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef CLIENT_LINUX_DUMP_WRITER_COMMON_THREAD_INFO_H_
+#define CLIENT_LINUX_DUMP_WRITER_COMMON_THREAD_INFO_H_
+
+#include <sys/ucontext.h>
+#include <sys/user.h>
+
+#include "client/linux/dump_writer_common/raw_context_cpu.h"
+#include "common/memory_allocator.h"
+#include "google_breakpad/common/minidump_format.h"
+
+namespace google_breakpad {
+
+#if defined(__i386) || defined(__x86_64)
+typedef __typeof__(((struct user*) 0)->u_debugreg[0]) debugreg_t;
+#endif
+
+// We produce one of these structures for each thread in the crashed process.
+struct ThreadInfo {
+  pid_t tgid;   // thread group id
+  pid_t ppid;   // parent process
+
+  uintptr_t stack_pointer;  // thread stack pointer
+
+
+#if defined(__i386) || defined(__x86_64)
+  user_regs_struct regs;
+  user_fpregs_struct fpregs;
+  static const unsigned kNumDebugRegisters = 8;
+  debugreg_t dregs[8];
+#if defined(__i386)
+  user_fpxregs_struct fpxregs;
+#endif  // defined(__i386)
+
+#elif defined(__ARM_EABI__)
+  // Mimicking how strace does this(see syscall.c, search for GETREGS)
+  struct user_regs regs;
+  struct user_fpregs fpregs;
+#elif defined(__aarch64__)
+  // Use the structures defined in <sys/user.h>
+  struct user_regs_struct regs;
+  struct user_fpsimd_struct fpregs;
+#elif defined(__mips__)
+  // Use the structure defined in <sys/ucontext.h>.
+  mcontext_t mcontext;
+#endif
+
+  // Returns the instruction pointer (platform-dependent impl.).
+  uintptr_t GetInstructionPointer() const;
+
+  // Fills a RawContextCPU using the context in the ThreadInfo object.
+  void FillCPUContext(RawContextCPU* out) const;
+
+  // Returns the pointer and size of general purpose register area.
+  void GetGeneralPurposeRegisters(void** gp_regs, size_t* size);
+
+  // Returns the pointer and size of float point register area.
+  void GetFloatingPointRegisters(void** fp_regs, size_t* size);
+};
+
+}  // namespace google_breakpad
+
+#endif  // CLIENT_LINUX_DUMP_WRITER_COMMON_THREAD_INFO_H_
diff --git a/src/MEGASync/google_breakpad/client/linux/dump_writer_common/ucontext_reader.cc b/src/MEGASync/google_breakpad/client/linux/dump_writer_common/ucontext_reader.cc
new file mode 100644
index 00000000..6eec1be2
--- /dev/null
+++ b/src/MEGASync/google_breakpad/client/linux/dump_writer_common/ucontext_reader.cc
@@ -0,0 +1,259 @@
+// Copyright (c) 2014, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "client/linux/dump_writer_common/ucontext_reader.h"
+
+#include "common/linux/linux_libc_support.h"
+#include "google_breakpad/common/minidump_format.h"
+
+namespace google_breakpad {
+
+// Minidump defines register structures which are different from the raw
+// structures which we get from the kernel. These are platform specific
+// functions to juggle the ucontext_t and user structures into minidump format.
+
+#if defined(__i386__)
+
+uintptr_t UContextReader::GetStackPointer(const ucontext_t* uc) {
+  return uc->uc_mcontext.gregs[REG_ESP];
+}
+
+uintptr_t UContextReader::GetInstructionPointer(const ucontext_t* uc) {
+  return uc->uc_mcontext.gregs[REG_EIP];
+}
+
+void UContextReader::FillCPUContext(RawContextCPU* out, const ucontext_t* uc,
+                                    const fpstate_t* fp) {
+  const greg_t* regs = uc->uc_mcontext.gregs;
+
+  out->context_flags = MD_CONTEXT_X86_FULL |
+                       MD_CONTEXT_X86_FLOATING_POINT;
+
+  out->gs = regs[REG_GS];
+  out->fs = regs[REG_FS];
+  out->es = regs[REG_ES];
+  out->ds = regs[REG_DS];
+
+  out->edi = regs[REG_EDI];
+  out->esi = regs[REG_ESI];
+  out->ebx = regs[REG_EBX];
+  out->edx = regs[REG_EDX];
+  out->ecx = regs[REG_ECX];
+  out->eax = regs[REG_EAX];
+
+  out->ebp = regs[REG_EBP];
+  out->eip = regs[REG_EIP];
+  out->cs = regs[REG_CS];
+  out->eflags = regs[REG_EFL];
+  out->esp = regs[REG_UESP];
+  out->ss = regs[REG_SS];
+
+  out->float_save.control_word = fp->cw;
+  out->float_save.status_word = fp->sw;
+  out->float_save.tag_word = fp->tag;
+  out->float_save.error_offset = fp->ipoff;
+  out->float_save.error_selector = fp->cssel;
+  out->float_save.data_offset = fp->dataoff;
+  out->float_save.data_selector = fp->datasel;
+
+  // 8 registers * 10 bytes per register.
+  my_memcpy(out->float_save.register_area, fp->_st, 10 * 8);
+}
+
+#elif defined(__x86_64)
+
+uintptr_t UContextReader::GetStackPointer(const ucontext_t* uc) {
+  return uc->uc_mcontext.gregs[REG_RSP];
+}
+
+uintptr_t UContextReader::GetInstructionPointer(const ucontext_t* uc) {
+  return uc->uc_mcontext.gregs[REG_RIP];
+}
+
+void UContextReader::FillCPUContext(RawContextCPU* out, const ucontext_t* uc,
+                                    const fpstate_t* fpregs) {
+  const greg_t* regs = uc->uc_mcontext.gregs;
+
+  out->context_flags = MD_CONTEXT_AMD64_FULL;
+
+  out->cs = regs[REG_CSGSFS] & 0xffff;
+
+  out->fs = (regs[REG_CSGSFS] >> 32) & 0xffff;
+  out->gs = (regs[REG_CSGSFS] >> 16) & 0xffff;
+
+  out->eflags = regs[REG_EFL];
+
+  out->rax = regs[REG_RAX];
+  out->rcx = regs[REG_RCX];
+  out->rdx = regs[REG_RDX];
+  out->rbx = regs[REG_RBX];
+
+  out->rsp = regs[REG_RSP];
+  out->rbp = regs[REG_RBP];
+  out->rsi = regs[REG_RSI];
+  out->rdi = regs[REG_RDI];
+  out->r8 = regs[REG_R8];
+  out->r9 = regs[REG_R9];
+  out->r10 = regs[REG_R10];
+  out->r11 = regs[REG_R11];
+  out->r12 = regs[REG_R12];
+  out->r13 = regs[REG_R13];
+  out->r14 = regs[REG_R14];
+  out->r15 = regs[REG_R15];
+
+  out->rip = regs[REG_RIP];
+
+  out->flt_save.control_word = fpregs->cwd;
+  out->flt_save.status_word = fpregs->swd;
+  out->flt_save.tag_word = fpregs->ftw;
+  out->flt_save.error_opcode = fpregs->fop;
+  out->flt_save.error_offset = fpregs->rip;
+  out->flt_save.data_offset = fpregs->rdp;
+  out->flt_save.error_selector = 0;  // We don't have this.
+  out->flt_save.data_selector = 0;  // We don't have this.
+  out->flt_save.mx_csr = fpregs->mxcsr;
+  out->flt_save.mx_csr_mask = fpregs->mxcr_mask;
+  my_memcpy(&out->flt_save.float_registers, &fpregs->_st, 8 * 16);
+  my_memcpy(&out->flt_save.xmm_registers, &fpregs->_xmm, 16 * 16);
+}
+
+#elif defined(__ARM_EABI__)
+
+uintptr_t UContextReader::GetStackPointer(const ucontext_t* uc) {
+  return uc->uc_mcontext.arm_sp;
+}
+
+uintptr_t UContextReader::GetInstructionPointer(const ucontext_t* uc) {
+  return uc->uc_mcontext.arm_pc;
+}
+
+void UContextReader::FillCPUContext(RawContextCPU* out, const ucontext_t* uc) {
+  out->context_flags = MD_CONTEXT_ARM_FULL;
+
+  out->iregs[0] = uc->uc_mcontext.arm_r0;
+  out->iregs[1] = uc->uc_mcontext.arm_r1;
+  out->iregs[2] = uc->uc_mcontext.arm_r2;
+  out->iregs[3] = uc->uc_mcontext.arm_r3;
+  out->iregs[4] = uc->uc_mcontext.arm_r4;
+  out->iregs[5] = uc->uc_mcontext.arm_r5;
+  out->iregs[6] = uc->uc_mcontext.arm_r6;
+  out->iregs[7] = uc->uc_mcontext.arm_r7;
+  out->iregs[8] = uc->uc_mcontext.arm_r8;
+  out->iregs[9] = uc->uc_mcontext.arm_r9;
+  out->iregs[10] = uc->uc_mcontext.arm_r10;
+
+  out->iregs[11] = uc->uc_mcontext.arm_fp;
+  out->iregs[12] = uc->uc_mcontext.arm_ip;
+  out->iregs[13] = uc->uc_mcontext.arm_sp;
+  out->iregs[14] = uc->uc_mcontext.arm_lr;
+  out->iregs[15] = uc->uc_mcontext.arm_pc;
+
+  out->cpsr = uc->uc_mcontext.arm_cpsr;
+
+  // TODO: fix this after fixing ExceptionHandler
+  out->float_save.fpscr = 0;
+  my_memset(&out->float_save.regs, 0, sizeof(out->float_save.regs));
+  my_memset(&out->float_save.extra, 0, sizeof(out->float_save.extra));
+}
+
+#elif defined(__aarch64__)
+
+uintptr_t UContextReader::GetStackPointer(const ucontext_t* uc) {
+  return uc->uc_mcontext.sp;
+}
+
+uintptr_t UContextReader::GetInstructionPointer(const ucontext_t* uc) {
+  return uc->uc_mcontext.pc;
+}
+
+void UContextReader::FillCPUContext(RawContextCPU* out, const ucontext_t* uc,
+                                    const struct fpsimd_context* fpregs) {
+  out->context_flags = MD_CONTEXT_ARM64_FULL_OLD;
+
+  out->cpsr = static_cast<uint32_t>(uc->uc_mcontext.pstate);
+  for (int i = 0; i < MD_CONTEXT_ARM64_REG_SP; ++i)
+    out->iregs[i] = uc->uc_mcontext.regs[i];
+  out->iregs[MD_CONTEXT_ARM64_REG_SP] = uc->uc_mcontext.sp;
+  out->iregs[MD_CONTEXT_ARM64_REG_PC] = uc->uc_mcontext.pc;
+
+  out->float_save.fpsr = fpregs->fpsr;
+  out->float_save.fpcr = fpregs->fpcr;
+  my_memcpy(&out->float_save.regs, &fpregs->vregs,
+      MD_FLOATINGSAVEAREA_ARM64_FPR_COUNT * 16);
+}
+
+#elif defined(__mips__)
+
+uintptr_t UContextReader::GetStackPointer(const ucontext_t* uc) {
+  return uc->uc_mcontext.gregs[MD_CONTEXT_MIPS_REG_SP];
+}
+
+uintptr_t UContextReader::GetInstructionPointer(const ucontext_t* uc) {
+  return uc->uc_mcontext.pc;
+}
+
+void UContextReader::FillCPUContext(RawContextCPU* out, const ucontext_t* uc) {
+#if _MIPS_SIM == _ABI64
+  out->context_flags = MD_CONTEXT_MIPS64_FULL;
+#elif _MIPS_SIM == _ABIO32
+  out->context_flags = MD_CONTEXT_MIPS_FULL;
+#else
+#error "This mips ABI is currently not supported (n32)"
+#endif
+
+  for (int i = 0; i < MD_CONTEXT_MIPS_GPR_COUNT; ++i)
+    out->iregs[i] = uc->uc_mcontext.gregs[i];
+
+  out->mdhi = uc->uc_mcontext.mdhi;
+  out->mdlo = uc->uc_mcontext.mdlo;
+
+  out->hi[0] = uc->uc_mcontext.hi1;
+  out->hi[1] = uc->uc_mcontext.hi2;
+  out->hi[2] = uc->uc_mcontext.hi3;
+  out->lo[0] = uc->uc_mcontext.lo1;
+  out->lo[1] = uc->uc_mcontext.lo2;
+  out->lo[2] = uc->uc_mcontext.lo3;
+  out->dsp_control = uc->uc_mcontext.dsp;
+
+  out->epc = uc->uc_mcontext.pc;
+  out->badvaddr = 0;  // Not reported in signal context.
+  out->status = 0;  // Not reported in signal context.
+  out->cause = 0;  // Not reported in signal context.
+
+  for (int i = 0; i < MD_FLOATINGSAVEAREA_MIPS_FPR_COUNT; ++i)
+    out->float_save.regs[i] = uc->uc_mcontext.fpregs.fp_r.fp_dregs[i];
+
+  out->float_save.fpcsr = uc->uc_mcontext.fpc_csr;
+#if _MIPS_SIM == _ABIO32
+  out->float_save.fir = uc->uc_mcontext.fpc_eir;  // Unused.
+#endif
+}
+#endif
+
+}  // namespace google_breakpad
diff --git a/src/MEGASync/google_breakpad/client/linux/dump_writer_common/ucontext_reader.h b/src/MEGASync/google_breakpad/client/linux/dump_writer_common/ucontext_reader.h
new file mode 100644
index 00000000..7d410088
--- /dev/null
+++ b/src/MEGASync/google_breakpad/client/linux/dump_writer_common/ucontext_reader.h
@@ -0,0 +1,65 @@
+// Copyright (c) 2014, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef CLIENT_LINUX_DUMP_WRITER_COMMON_UCONTEXT_READER_H
+#define CLIENT_LINUX_DUMP_WRITER_COMMON_UCONTEXT_READER_H
+
+#include <sys/ucontext.h>
+#include <sys/user.h>
+
+#include "client/linux/dump_writer_common/raw_context_cpu.h"
+#include "client/linux/minidump_writer/minidump_writer.h"
+#include "common/memory_allocator.h"
+#include "google_breakpad/common/minidump_format.h"
+
+namespace google_breakpad {
+
+// Wraps platform-dependent implementations of accessors to ucontext_t structs.
+struct UContextReader {
+  static uintptr_t GetStackPointer(const ucontext_t* uc);
+
+  static uintptr_t GetInstructionPointer(const ucontext_t* uc);
+
+  // Juggle a arch-specific ucontext_t into a minidump format
+  //   out: the minidump structure
+  //   info: the collection of register structures.
+#if defined(__i386__) || defined(__x86_64)
+  static void FillCPUContext(RawContextCPU* out, const ucontext_t* uc,
+                             const fpstate_t* fp);
+#elif defined(__aarch64__)
+  static void FillCPUContext(RawContextCPU* out, const ucontext_t* uc,
+                             const struct fpsimd_context* fpregs);
+#else
+  static void FillCPUContext(RawContextCPU* out, const ucontext_t* uc);
+#endif
+};
+
+}  // namespace google_breakpad
+
+#endif  // CLIENT_LINUX_DUMP_WRITER_COMMON_UCONTEXT_READER_H
diff --git a/src/MEGASync/google_breakpad/client/linux/handler/exception_handler.cc b/src/MEGASync/google_breakpad/client/linux/handler/exception_handler.cc
index c21480bc..ca353c40 100644
--- a/src/MEGASync/google_breakpad/client/linux/handler/exception_handler.cc
+++ b/src/MEGASync/google_breakpad/client/linux/handler/exception_handler.cc
@@ -68,6 +68,7 @@
 #include <errno.h>
 #include <fcntl.h>
 #include <linux/limits.h>
+#include <pthread.h>
 #include <sched.h>
 #include <signal.h>
 #include <stdio.h>
@@ -77,7 +78,6 @@
 #include <sys/wait.h>
 #include <unistd.h>
 
-#include <sys/signal.h>
 #include <sys/ucontext.h>
 #include <sys/user.h>
 #include <ucontext.h>
@@ -87,9 +87,11 @@
 #include <vector>
 
 #include "common/basictypes.h"
+#include "common/linux/breakpad_getcontext.h"
 #include "common/linux/linux_libc_support.h"
-#include "common/memory.h"
+#include "common/memory_allocator.h"
 #include "client/linux/log/log.h"
+#include "client/linux/microdump_writer/microdump_writer.h"
 #include "client/linux/minidump_writer/linux_dumper.h"
 #include "client/linux/minidump_writer/minidump_writer.h"
 #include "common/linux/eintr_wrapper.h"
@@ -103,14 +105,6 @@
 #define PR_SET_PTRACER 0x59616d61
 #endif
 
-#if !defined(__GLIBC__) || ((__GLIBC__ < 2) || ((__GLIBC__ == 2) && (__GLIBC_MINOR__ < 30 )))
-// A wrapper for the tgkill syscall: send a signal to a specific thread.
-static int tgkill(pid_t tgid, pid_t tid, int sig) {
-  return syscall(__NR_tgkill, tgid, tid, sig);
-  return 0;
-}
-#endif
-
 namespace google_breakpad {
 
 namespace {
@@ -118,7 +112,7 @@ namespace {
 // all these signals must be Core (see man 7 signal) because we rethrow the
 // signal after handling it and expect that it'll be fatal.
 const int kExceptionSignals[] = {
-  SIGSEGV, SIGABRT, SIGFPE, SIGILL, SIGBUS
+  SIGSEGV, SIGABRT, SIGFPE, SIGILL, SIGBUS, SIGTRAP
 };
 const int kNumHandledSignals =
     sizeof(kExceptionSignals) / sizeof(kExceptionSignals[0]);
@@ -144,13 +138,13 @@ void InstallAlternateStackLocked() {
   // SIGSTKSZ may be too small to prevent the signal handlers from overrunning
   // the alternative stack. Ensure that the size of the alternative stack is
   // large enough.
-  static const unsigned kSigStackSize = std::max(8192, SIGSTKSZ);
+  static const unsigned kSigStackSize = std::max(16384, SIGSTKSZ);
 
   // Only set an alternative stack if there isn't already one, or if the current
   // one is too small.
   if (sys_sigaltstack(NULL, &old_stack) == -1 || !old_stack.ss_sp ||
       old_stack.ss_size < kSigStackSize) {
-    new_stack.ss_sp = malloc(kSigStackSize);
+    new_stack.ss_sp = calloc(1, kSigStackSize);
     new_stack.ss_size = kSigStackSize;
 
     if (sys_sigaltstack(&new_stack, NULL) == -1) {
@@ -188,13 +182,38 @@ void RestoreAlternateStackLocked() {
   stack_installed = false;
 }
 
-}  // namespace
+void InstallDefaultHandler(int sig) {
+#if defined(__ANDROID__)
+  // Android L+ expose signal and sigaction symbols that override the system
+  // ones. There is a bug in these functions where a request to set the handler
+  // to SIG_DFL is ignored. In that case, an infinite loop is entered as the
+  // signal is repeatedly sent to breakpad's signal handler.
+  // To work around this, directly call the system's sigaction.
+  struct kernel_sigaction sa;
+  memset(&sa, 0, sizeof(sa));
+  sys_sigemptyset(&sa.sa_mask);
+  sa.sa_handler_ = SIG_DFL;
+  sa.sa_flags = SA_RESTART;
+  sys_rt_sigaction(sig, &sa, NULL, sizeof(kernel_sigset_t));
+#else
+  signal(sig, SIG_DFL);
+#endif
+}
+
+// The global exception handler stack. This is needed because there may exist
+// multiple ExceptionHandler instances in a process. Each will have itself
+// registered in this stack.
+std::vector<ExceptionHandler*>* g_handler_stack_ = NULL;
+pthread_mutex_t g_handler_stack_mutex_ = PTHREAD_MUTEX_INITIALIZER;
 
-// We can stack multiple exception handlers. In that case, this is the global
-// which holds the stack.
-std::vector<ExceptionHandler*>* ExceptionHandler::handler_stack_ = NULL;
-pthread_mutex_t ExceptionHandler::handler_stack_mutex_ =
-    PTHREAD_MUTEX_INITIALIZER;
+// sizeof(CrashContext) can be too big w.r.t the size of alternatate stack
+// for SignalHandler(). Keep the crash context as a .bss field. Exception
+// handlers are serialized by the |g_handler_stack_mutex_| and at most one at a
+// time can use |g_crash_context_|.
+ExceptionHandler::CrashContext g_crash_context_;
+
+FirstChanceHandler g_first_chance_handler_ = nullptr;
+}  // namespace
 
 // Runs before crashing: normal context.
 ExceptionHandler::ExceptionHandler(const MinidumpDescriptor& descriptor,
@@ -211,31 +230,44 @@ ExceptionHandler::ExceptionHandler(const MinidumpDescriptor& descriptor,
   if (server_fd >= 0)
     crash_generation_client_.reset(CrashGenerationClient::TryCreate(server_fd));
 
-  if (!IsOutOfProcess() && !minidump_descriptor_.IsFD())
+  if (!IsOutOfProcess() && !minidump_descriptor_.IsFD() &&
+      !minidump_descriptor_.IsMicrodumpOnConsole())
     minidump_descriptor_.UpdatePath();
 
-  pthread_mutex_lock(&handler_stack_mutex_);
-  if (!handler_stack_)
-    handler_stack_ = new std::vector<ExceptionHandler*>;
+#if defined(__ANDROID__)
+  if (minidump_descriptor_.IsMicrodumpOnConsole())
+    logger::initializeCrashLogWriter();
+#endif
+
+  pthread_mutex_lock(&g_handler_stack_mutex_);
+
+  // Pre-fault the crash context struct. This is to avoid failing due to OOM
+  // if handling an exception when the process ran out of virtual memory.
+  memset(&g_crash_context_, 0, sizeof(g_crash_context_));
+
+  if (!g_handler_stack_)
+    g_handler_stack_ = new std::vector<ExceptionHandler*>;
   if (install_handler) {
     InstallAlternateStackLocked();
     InstallHandlersLocked();
   }
-  handler_stack_->push_back(this);
-  pthread_mutex_unlock(&handler_stack_mutex_);
+  g_handler_stack_->push_back(this);
+  pthread_mutex_unlock(&g_handler_stack_mutex_);
 }
 
 // Runs before crashing: normal context.
 ExceptionHandler::~ExceptionHandler() {
-  pthread_mutex_lock(&handler_stack_mutex_);
+  pthread_mutex_lock(&g_handler_stack_mutex_);
   std::vector<ExceptionHandler*>::iterator handler =
-      std::find(handler_stack_->begin(), handler_stack_->end(), this);
-  handler_stack_->erase(handler);
-  if (handler_stack_->empty()) {
+      std::find(g_handler_stack_->begin(), g_handler_stack_->end(), this);
+  g_handler_stack_->erase(handler);
+  if (g_handler_stack_->empty()) {
+    delete g_handler_stack_;
+    g_handler_stack_ = NULL;
     RestoreAlternateStackLocked();
     RestoreHandlersLocked();
   }
-  pthread_mutex_unlock(&handler_stack_mutex_);
+  pthread_mutex_unlock(&g_handler_stack_mutex_);
 }
 
 // Runs before crashing: normal context.
@@ -280,7 +312,7 @@ void ExceptionHandler::RestoreHandlersLocked() {
 
   for (int i = 0; i < kNumHandledSignals; ++i) {
     if (sigaction(kExceptionSignals[i], &old_handlers[i], NULL) == -1) {
-      signal(kExceptionSignals[i], SIG_DFL);
+      InstallDefaultHandler(kExceptionSignals[i]);
     }
   }
   handlers_installed = false;
@@ -294,8 +326,20 @@ void ExceptionHandler::RestoreHandlersLocked() {
 // Runs on the crashing thread.
 // static
 void ExceptionHandler::SignalHandler(int sig, siginfo_t* info, void* uc) {
+
+  // Give the first chance handler a chance to recover from this signal
+  //
+  // This is primarily used by V8. V8 uses guard regions to guarantee memory
+  // safety in WebAssembly. This means some signals might be expected if they
+  // originate from Wasm code while accessing the guard region. We give V8 the
+  // chance to handle and recover from these signals first.
+  if (g_first_chance_handler_ != nullptr &&
+      g_first_chance_handler_(sig, info, uc)) {
+    return;
+  }
+
   // All the exception signals are blocked at this point.
-  pthread_mutex_lock(&handler_stack_mutex_);
+  pthread_mutex_lock(&g_handler_stack_mutex_);
 
   // Sometimes, Breakpad runs inside a process where some other buggy code
   // saves and restores signal handlers temporarily with 'signal'
@@ -309,6 +353,7 @@ void ExceptionHandler::SignalHandler(int sig, siginfo_t* info, void* uc) {
   // will call the function with the right arguments.
   struct sigaction cur_handler;
   if (sigaction(sig, NULL, &cur_handler) == 0 &&
+      cur_handler.sa_sigaction == SignalHandler &&
       (cur_handler.sa_flags & SA_SIGINFO) == 0) {
     // Reset signal handler with the right flags.
     sigemptyset(&cur_handler.sa_mask);
@@ -320,15 +365,15 @@ void ExceptionHandler::SignalHandler(int sig, siginfo_t* info, void* uc) {
     if (sigaction(sig, &cur_handler, NULL) == -1) {
       // When resetting the handler fails, try to reset the
       // default one to avoid an infinite loop here.
-      signal(sig, SIG_DFL);
+      InstallDefaultHandler(sig);
     }
-    pthread_mutex_unlock(&handler_stack_mutex_);
+    pthread_mutex_unlock(&g_handler_stack_mutex_);
     return;
   }
 
   bool handled = false;
-  for (int i = handler_stack_->size() - 1; !handled && i >= 0; --i) {
-    handled = (*handler_stack_)[i]->HandleSignal(sig, info, uc);
+  for (int i = g_handler_stack_->size() - 1; !handled && i >= 0; --i) {
+    handled = (*g_handler_stack_)[i]->HandleSignal(sig, info, uc);
   }
 
   // Upon returning from this signal handler, sig will become unmasked and then
@@ -337,19 +382,20 @@ void ExceptionHandler::SignalHandler(int sig, siginfo_t* info, void* uc) {
   // previously installed handler. Then, when the signal is retriggered, it will
   // be delivered to the appropriate handler.
   if (handled) {
-    signal(sig, SIG_DFL);
+    InstallDefaultHandler(sig);
   } else {
     RestoreHandlersLocked();
   }
 
-  pthread_mutex_unlock(&handler_stack_mutex_);
+  pthread_mutex_unlock(&g_handler_stack_mutex_);
 
-  if (info->si_pid || sig == SIGABRT) {
+  // info->si_code <= 0 iff SI_FROMUSER (SI_FROMKERNEL otherwise).
+  if (info->si_code <= 0 || sig == SIGABRT) {
     // This signal was triggered by somebody sending us the signal with kill().
     // In order to retrigger it, we have to queue a new signal by calling
     // kill() ourselves.  The special case (si_pid == 0 && sig == SIGABRT) is
     // due to the kernel sending a SIGABRT from a user request via SysRQ.
-    if (tgkill(getpid(), syscall(__NR_gettid), sig) < 0) {
+    if (sys_tgkill(getpid(), syscall(__NR_gettid), sig) < 0) {
       // If we failed to kill ourselves (e.g. because a sandbox disallows us
       // to do so), we instead resort to terminating our process. This will
       // result in an incorrect exit code.
@@ -373,12 +419,17 @@ struct ThreadArgument {
 // This is the entry function for the cloned process. We are in a compromised
 // context here: see the top of the file.
 // static
-int ExceptionHandler::ThreadEntry(void *arg) {
-  const ThreadArgument *thread_arg = reinterpret_cast<ThreadArgument*>(arg);
+int ExceptionHandler::ThreadEntry(void* arg) {
+  const ThreadArgument* thread_arg = reinterpret_cast<ThreadArgument*>(arg);
+
+  // Close the write end of the pipe. This allows us to fail if the parent dies
+  // while waiting for the continue signal.
+  sys_close(thread_arg->handler->fdes[1]);
 
   // Block here until the crashing process unblocks us when
   // we're allowed to use ptrace
   thread_arg->handler->WaitForContinueSignal();
+  sys_close(thread_arg->handler->fdes[0]);
 
   return thread_arg->handler->DoDump(thread_arg->pid, thread_arg->context,
                                      thread_arg->context_size) == false;
@@ -386,7 +437,7 @@ int ExceptionHandler::ThreadEntry(void *arg) {
 
 // This function runs in a compromised context: see the top of the file.
 // Runs on the crashing thread.
-bool ExceptionHandler::HandleSignal(int, siginfo_t* info, void* uc) {
+bool ExceptionHandler::HandleSignal(int /*sig*/, siginfo_t* info, void* uc) {
   if (filter_ && !filter_(callback_context_))
     return false;
 
@@ -397,34 +448,43 @@ bool ExceptionHandler::HandleSignal(int, siginfo_t* info, void* uc) {
   if (signal_trusted || (signal_pid_trusted && info->si_pid == getpid())) {
     sys_prctl(PR_SET_DUMPABLE, 1, 0, 0, 0);
   }
-  CrashContext context;
-  memcpy(&context.siginfo, info, sizeof(siginfo_t));
-  memcpy(&context.context, uc, sizeof(ucontext_t));
-#if !defined(__ARM_EABI__) && !defined(__mips__)
+
+  // Fill in all the holes in the struct to make Valgrind happy.
+  memset(&g_crash_context_, 0, sizeof(g_crash_context_));
+  memcpy(&g_crash_context_.siginfo, info, sizeof(siginfo_t));
+  memcpy(&g_crash_context_.context, uc, sizeof(ucontext_t));
+#if defined(__aarch64__)
+  ucontext_t* uc_ptr = (ucontext_t*)uc;
+  struct fpsimd_context* fp_ptr =
+      (struct fpsimd_context*)&uc_ptr->uc_mcontext.__reserved;
+  if (fp_ptr->head.magic == FPSIMD_MAGIC) {
+    memcpy(&g_crash_context_.float_state, fp_ptr,
+           sizeof(g_crash_context_.float_state));
+  }
+#elif !defined(__ARM_EABI__) && !defined(__mips__)
   // FP state is not part of user ABI on ARM Linux.
-  // In case of MIPS Linux FP state is already part of struct ucontext
+  // In case of MIPS Linux FP state is already part of ucontext_t
   // and 'float_state' is not a member of CrashContext.
-  ucontext_t *uc_ptr = (ucontext_t*)uc;
+  ucontext_t* uc_ptr = (ucontext_t*)uc;
   if (uc_ptr->uc_mcontext.fpregs) {
-    memcpy(&context.float_state,
-           uc_ptr->uc_mcontext.fpregs,
-           sizeof(context.float_state));
+    memcpy(&g_crash_context_.float_state, uc_ptr->uc_mcontext.fpregs,
+           sizeof(g_crash_context_.float_state));
   }
 #endif
-  context.tid = syscall(__NR_gettid);
+  g_crash_context_.tid = syscall(__NR_gettid);
   if (crash_handler_ != NULL) {
-    if (crash_handler_(&context, sizeof(context), callback_context_)) {
+    if (crash_handler_(&g_crash_context_, sizeof(g_crash_context_),
+                       callback_context_)) {
       return true;
     }
   }
-  return GenerateDump(&context);
+  return GenerateDump(&g_crash_context_);
 }
 
 // This is a public interface to HandleSignal that allows the client to
 // generate a crash dump. This function may run in a compromised context.
 bool ExceptionHandler::SimulateSignalDelivery(int sig) {
-  siginfo_t siginfo;
-  memset(&siginfo, 0, sizeof(siginfo_t));
+  siginfo_t siginfo = {};
   // Mimic a trusted signal to allow tracing the process (see
   // ExceptionHandler::HandleSignal().
   siginfo.si_code = SI_USER;
@@ -435,7 +495,7 @@ bool ExceptionHandler::SimulateSignalDelivery(int sig) {
 }
 
 // This function may run in a compromised context: see the top of the file.
-bool ExceptionHandler::GenerateDump(CrashContext *context) {
+bool ExceptionHandler::GenerateDump(CrashContext* context) {
   if (IsOutOfProcess())
     return crash_generation_client_->RequestDump(context, sizeof(*context));
 
@@ -443,7 +503,7 @@ bool ExceptionHandler::GenerateDump(CrashContext *context) {
   // of caution than smash it into random locations.
   static const unsigned kChildStackSize = 16000;
   PageAllocator allocator;
-  uint8_t* stack = (uint8_t*) allocator.Alloc(kChildStackSize);
+  uint8_t* stack = reinterpret_cast<uint8_t*>(allocator.Alloc(kChildStackSize));
   if (!stack)
     return false;
   // clone() needs the top-most address. (scrub just to be safe)
@@ -461,31 +521,37 @@ bool ExceptionHandler::GenerateDump(CrashContext *context) {
   // kernels, but we need to know the PID of the cloned process before we
   // can do this. Create a pipe here which we can use to block the
   // cloned process after creating it, until we have explicitly enabled ptrace
-  if (sys_pipe(fdes) == -1)
-  {
+  if (sys_pipe(fdes) == -1) {
     // Creating the pipe failed. We'll log an error but carry on anyway,
     // as we'll probably still get a useful crash report. All that will happen
     // is the write() and read() calls will fail with EBADF
-    static const char no_pipe_msg[] = "ExceptionHandler::GenerateDump \
-                                       sys_pipe failed:";
+    static const char no_pipe_msg[] = "ExceptionHandler::GenerateDump "
+                                      "sys_pipe failed:";
     logger::write(no_pipe_msg, sizeof(no_pipe_msg) - 1);
     logger::write(strerror(errno), strlen(strerror(errno)));
     logger::write("\n", 1);
+
+    // Ensure fdes[0] and fdes[1] are invalid file descriptors.
+    fdes[0] = fdes[1] = -1;
   }
 
   const pid_t child = sys_clone(
-      ThreadEntry, stack, CLONE_FILES | CLONE_FS | CLONE_UNTRACED,
-      &thread_arg, NULL, NULL, NULL);
+      ThreadEntry, stack, CLONE_FS | CLONE_UNTRACED, &thread_arg, NULL, NULL,
+      NULL);
+  if (child == -1) {
+    sys_close(fdes[0]);
+    sys_close(fdes[1]);
+    return false;
+  }
 
-  int r, status;
+  // Close the read end of the pipe.
+  sys_close(fdes[0]);
   // Allow the child to ptrace us
   sys_prctl(PR_SET_PTRACER, child, 0, 0, 0);
   SendContinueSignalToChild();
-  do {
-    r = sys_waitpid(child, &status, __WALL);
-  } while (r == -1 && errno == EINTR);
+  int status = 0;
+  const int r = HANDLE_EINTR(sys_waitpid(child, &status, __WALL));
 
-  sys_close(fdes[0]);
   sys_close(fdes[1]);
 
   if (r == -1) {
@@ -506,10 +572,9 @@ void ExceptionHandler::SendContinueSignalToChild() {
   static const char okToContinueMessage = 'a';
   int r;
   r = HANDLE_EINTR(sys_write(fdes[1], &okToContinueMessage, sizeof(char)));
-  if (r == -1)
-  {
-    static const char msg[] = "ExceptionHandler::SendContinueSignalToChild \
-                               sys_write failed:";
+  if (r == -1) {
+    static const char msg[] = "ExceptionHandler::SendContinueSignalToChild "
+                              "sys_write failed:";
     logger::write(msg, sizeof(msg) - 1);
     logger::write(strerror(errno), strlen(strerror(errno)));
     logger::write("\n", 1);
@@ -522,10 +587,9 @@ void ExceptionHandler::WaitForContinueSignal() {
   int r;
   char receivedMessage;
   r = HANDLE_EINTR(sys_read(fdes[0], &receivedMessage, sizeof(char)));
-  if (r == -1)
-  {
-    static const char msg[] = "ExceptionHandler::WaitForContinueSignal \
-                               sys_read failed:";
+  if (r == -1) {
+    static const char msg[] = "ExceptionHandler::WaitForContinueSignal "
+                              "sys_read failed:";
     logger::write(msg, sizeof(msg) - 1);
     logger::write(strerror(errno), strlen(strerror(errno)));
     logger::write("\n", 1);
@@ -536,6 +600,22 @@ void ExceptionHandler::WaitForContinueSignal() {
 // Runs on the cloned process.
 bool ExceptionHandler::DoDump(pid_t crashing_process, const void* context,
                               size_t context_size) {
+  const bool may_skip_dump =
+      minidump_descriptor_.skip_dump_if_principal_mapping_not_referenced();
+  const uintptr_t principal_mapping_address =
+      minidump_descriptor_.address_within_principal_mapping();
+  const bool sanitize_stacks = minidump_descriptor_.sanitize_stacks();
+  if (minidump_descriptor_.IsMicrodumpOnConsole()) {
+    return google_breakpad::WriteMicrodump(
+        crashing_process,
+        context,
+        context_size,
+        mapping_list_,
+        may_skip_dump,
+        principal_mapping_address,
+        sanitize_stacks,
+        *minidump_descriptor_.microdump_extra_info());
+  }
   if (minidump_descriptor_.IsFD()) {
     return google_breakpad::WriteMinidump(minidump_descriptor_.fd(),
                                           minidump_descriptor_.size_limit(),
@@ -543,7 +623,10 @@ bool ExceptionHandler::DoDump(pid_t crashing_process, const void* context,
                                           context,
                                           context_size,
                                           mapping_list_,
-                                          app_memory_list_);
+                                          app_memory_list_,
+                                          may_skip_dump,
+                                          principal_mapping_address,
+                                          sanitize_stacks);
   }
   return google_breakpad::WriteMinidump(minidump_descriptor_.path(),
                                         minidump_descriptor_.size_limit(),
@@ -551,7 +634,10 @@ bool ExceptionHandler::DoDump(pid_t crashing_process, const void* context,
                                         context,
                                         context_size,
                                         mapping_list_,
-                                        app_memory_list_);
+                                        app_memory_list_,
+                                        may_skip_dump,
+                                        principal_mapping_address,
+                                        sanitize_stacks);
 }
 
 // static
@@ -571,7 +657,8 @@ bool ExceptionHandler::WriteMinidump(const string& dump_path,
 __attribute__((optimize("no-omit-frame-pointer")))
 #endif
 bool ExceptionHandler::WriteMinidump() {
-  if (!IsOutOfProcess() && !minidump_descriptor_.IsFD()) {
+  if (!IsOutOfProcess() && !minidump_descriptor_.IsFD() &&
+      !minidump_descriptor_.IsMicrodumpOnConsole()) {
     // Update the path of the minidump so that this can be called multiple times
     // and new files are created for each minidump.  This is done before the
     // generation happens, as clients may want to access the MinidumpDescriptor
@@ -614,7 +701,7 @@ bool ExceptionHandler::WriteMinidump() {
   }
 #endif
 
-#if !defined(__ARM_EABI__) && !defined(__mips__)
+#if !defined(__ARM_EABI__) && !defined(__aarch64__) && !defined(__mips__)
   // FPU state is not part of ARM EABI ucontext_t.
   memcpy(&context.float_state, context.context.uc_mcontext.fpregs,
          sizeof(context.float_state));
@@ -633,6 +720,9 @@ bool ExceptionHandler::WriteMinidump() {
 #elif defined(__arm__)
   context.siginfo.si_addr =
       reinterpret_cast<void*>(context.context.uc_mcontext.arm_pc);
+#elif defined(__aarch64__)
+  context.siginfo.si_addr =
+      reinterpret_cast<void*>(context.context.uc_mcontext.pc);
 #elif defined(__mips__)
   context.siginfo.si_addr =
       reinterpret_cast<void*>(context.context.uc_mcontext.pc);
@@ -700,4 +790,8 @@ bool ExceptionHandler::WriteMinidumpForChild(pid_t child,
   return callback ? callback(descriptor, callback_context, true) : true;
 }
 
+void SetFirstChanceExceptionHandler(FirstChanceHandler callback) {
+  g_first_chance_handler_ = callback;
+}
+
 }  // namespace google_breakpad
diff --git a/src/MEGASync/google_breakpad/client/linux/handler/exception_handler.h b/src/MEGASync/google_breakpad/client/linux/handler/exception_handler.h
index 33220d83..f80843ea 100644
--- a/src/MEGASync/google_breakpad/client/linux/handler/exception_handler.h
+++ b/src/MEGASync/google_breakpad/client/linux/handler/exception_handler.h
@@ -30,15 +30,13 @@
 #ifndef CLIENT_LINUX_HANDLER_EXCEPTION_HANDLER_H_
 #define CLIENT_LINUX_HANDLER_EXCEPTION_HANDLER_H_
 
-#include <string>
-#include <vector>
-
-#include <pthread.h>
 #include <signal.h>
 #include <stdint.h>
 #include <stdio.h>
 #include <sys/ucontext.h>
 
+#include <string>
+
 #include "client/linux/crash_generation/crash_generation_client.h"
 #include "client/linux/handler/minidump_descriptor.h"
 #include "client/linux/minidump_writer/minidump_writer.h"
@@ -84,7 +82,7 @@ class ExceptionHandler {
   // attempting to write a minidump.  If a FilterCallback returns false,
   // Breakpad  will immediately report the exception as unhandled without
   // writing a minidump, allowing another handler the opportunity to handle it.
-  typedef bool (*FilterCallback)(void *context);
+  typedef bool (*FilterCallback)(void* context);
 
   // A callback function to run after the minidump has been written.
   // |descriptor| contains the file descriptor or file path containing the
@@ -129,7 +127,7 @@ class ExceptionHandler {
   ExceptionHandler(const MinidumpDescriptor& descriptor,
                    FilterCallback filter,
                    MinidumpCallback callback,
-                   void *callback_context,
+                   void* callback_context,
                    bool install_handler,
                    const int server_fd);
   ~ExceptionHandler();
@@ -146,6 +144,10 @@ class ExceptionHandler {
     crash_handler_ = callback;
   }
 
+  void set_crash_generation_client(CrashGenerationClient* client) {
+    crash_generation_client_.reset(client);
+  }
+
   // Writes a minidump immediately.  This can be used to capture the execution
   // state independently of a crash.
   // Returns true on success.
@@ -192,15 +194,15 @@ class ExceptionHandler {
     ucontext_t context;
 #if !defined(__ARM_EABI__) && !defined(__mips__)
     // #ifdef this out because FP state is not part of user ABI for Linux ARM.
-    // In case of MIPS Linux FP state is already part of struct ucontext
-    // so 'float_state' is not required.
-    struct _libc_fpstate float_state;
+    // In case of MIPS Linux FP state is already part of ucontext_t so
+    // 'float_state' is not required.
+    fpstate_t float_state;
 #endif
   };
 
   // Returns whether out-of-process dump generation is used or not.
   bool IsOutOfProcess() const {
-      return crash_generation_client_.get() != NULL;
+    return crash_generation_client_.get() != NULL;
   }
 
   // Add information about a memory mapping. This can be used if
@@ -221,6 +223,10 @@ class ExceptionHandler {
 
   // Force signal handling for the specified signal.
   bool SimulateSignalDelivery(int sig);
+
+  // Report a crash signal from an SA_SIGINFO signal handler.
+  bool HandleSignal(int sig, siginfo_t* info, void* uc);
+
  private:
   // Save the old signal handlers and install new ones.
   static bool InstallHandlersLocked();
@@ -228,12 +234,11 @@ class ExceptionHandler {
   static void RestoreHandlersLocked();
 
   void PreresolveSymbols();
-  bool GenerateDump(CrashContext *context);
+  bool GenerateDump(CrashContext* context);
   void SendContinueSignalToChild();
   void WaitForContinueSignal();
 
   static void SignalHandler(int sig, siginfo_t* info, void* uc);
-  bool HandleSignal(int sig, siginfo_t* info, void* uc);
   static int ThreadEntry(void* arg);
   bool DoDump(pid_t crashing_process, const void* context,
               size_t context_size);
@@ -246,20 +251,18 @@ class ExceptionHandler {
 
   MinidumpDescriptor minidump_descriptor_;
 
-  HandlerCallback crash_handler_;
-
-  // The global exception handler stack. This is need becuase there may exist
-  // multiple ExceptionHandler instances in a process. Each will have itself
-  // registered in this stack.
-  static std::vector<ExceptionHandler*> *handler_stack_;
-  static pthread_mutex_t handler_stack_mutex_;
+  // Must be volatile. The compiler is unaware of the code which runs in
+  // the signal handler which reads this variable. Without volatile the
+  // compiler is free to optimise away writes to this variable which it
+  // believes are never read.
+  volatile HandlerCallback crash_handler_;
 
   // We need to explicitly enable ptrace of parent processes on some
   // kernels, but we need to know the PID of the cloned process before we
   // can do this. We create a pipe which we can use to block the
-  // cloned process after creating it, until we have explicitly enabled 
+  // cloned process after creating it, until we have explicitly enabled
   // ptrace. This is used to store the file descriptors for the pipe
-  int fdes[2];
+  int fdes[2] = {-1, -1};
 
   // Callers can add extra info about mappings for cases where the
   // dumper code cannot extract enough information from /proc/<pid>/maps.
@@ -270,6 +273,9 @@ class ExceptionHandler {
   AppMemoryList app_memory_list_;
 };
 
+typedef bool (*FirstChanceHandler)(int, siginfo_t*, void*);
+void SetFirstChanceExceptionHandler(FirstChanceHandler callback);
+
 }  // namespace google_breakpad
 
 #endif  // CLIENT_LINUX_HANDLER_EXCEPTION_HANDLER_H_
diff --git a/src/MEGASync/google_breakpad/client/linux/handler/exception_handler_unittest.cc b/src/MEGASync/google_breakpad/client/linux/handler/exception_handler_unittest.cc
index 976f9f41..35dcbfd4 100644
--- a/src/MEGASync/google_breakpad/client/linux/handler/exception_handler_unittest.cc
+++ b/src/MEGASync/google_breakpad/client/linux/handler/exception_handler_unittest.cc
@@ -27,11 +27,12 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
+#include <poll.h>
+#include <pthread.h>
 #include <stdint.h>
 #include <unistd.h>
 #include <signal.h>
 #include <sys/mman.h>
-#include <sys/poll.h>
 #include <sys/socket.h>
 #include <sys/uio.h>
 #include <sys/wait.h>
@@ -45,7 +46,6 @@
 #include "client/linux/handler/exception_handler.h"
 #include "client/linux/minidump_writer/minidump_writer.h"
 #include "common/linux/eintr_wrapper.h"
-#include "common/linux/file_id.h"
 #include "common/linux/ignore_ret.h"
 #include "common/linux/linux_libc_support.h"
 #include "common/tests/auto_tempdir.h"
@@ -80,7 +80,11 @@ void FlushInstructionCache(const char* memory, uint32_t memory_size) {
   // Provided by Android's <unistd.h>
   long begin = reinterpret_cast<long>(memory);
   long end = begin + static_cast<long>(memory_size);
+#if _MIPS_SIM == _ABIO32
   cacheflush(begin, end, 0);
+#else
+  syscall(__NR_cacheflush, begin, end, ICACHE);
+#endif
 # elif defined(__linux__)
   // See http://www.linux-mips.org/wiki/Cacheflush_Syscall.
   cacheflush(const_cast<char*>(memory), memory_size, ICACHE);
@@ -90,10 +94,6 @@ void FlushInstructionCache(const char* memory, uint32_t memory_size) {
 #endif
 }
 
-// Length of a formatted GUID string =
-// sizeof(MDGUID) * 2 + 4 (for dashes) + 1 (null terminator)
-const int kGUIDStringSize = 37;
-
 void sigchld_handler(int signo) { }
 
 int CreateTMPFile(const string& dir, string* path) {
@@ -193,6 +193,20 @@ static bool DoneCallback(const MinidumpDescriptor& descriptor,
 
 #ifndef ADDRESS_SANITIZER
 
+// This is a replacement for "*reinterpret_cast<volatile int*>(NULL) = 0;"
+// It is needed because GCC is allowed to assume that the program will
+// not execute any undefined behavior (UB) operation. Further, when GCC
+// observes that UB statement is reached, it can assume that all statements
+// leading to the UB one are never executed either, and can completely
+// optimize them out. In the case of ExceptionHandlerTest::ExternalDumper,
+// GCC-4.9 optimized out the entire set up of ExceptionHandler, causing
+// test failure.
+volatile int* p_null;  // external linkage, so GCC can't tell that it
+                       // remains NULL. Volatile just for a good measure.
+static void DoNullPointerDereference() {
+  *p_null = 1;
+}
+
 void ChildCrash(bool use_fd) {
   AutoTempDir temp_dir;
   int fds[2] = {0};
@@ -219,7 +233,7 @@ void ChildCrash(bool use_fd) {
                                            true, -1));
       }
       // Crash with the exception handler in scope.
-      *reinterpret_cast<volatile int*>(NULL) = 0;
+      DoNullPointerDereference();
     }
   }
   if (!use_fd)
@@ -244,7 +258,65 @@ TEST(ExceptionHandlerTest, ChildCrashWithFD) {
   ASSERT_NO_FATAL_FAILURE(ChildCrash(true));
 }
 
-#endif  // !ADDRESS_SANITIZER
+#if !defined(__ANDROID_API__) || __ANDROID_API__ >= __ANDROID_API_N__
+static void* SleepFunction(void* unused) {
+  while (true) usleep(1000000);
+  return NULL;
+}
+
+static void* CrashFunction(void* b_ptr) {
+  pthread_barrier_t* b = reinterpret_cast<pthread_barrier_t*>(b_ptr);
+  pthread_barrier_wait(b);
+  DoNullPointerDereference();
+  return NULL;
+}
+
+// Tests that concurrent crashes do not enter a loop by alternately triggering
+// the signal handler.
+TEST(ExceptionHandlerTest, ParallelChildCrashesDontHang) {
+  AutoTempDir temp_dir;
+  const pid_t child = fork();
+  if (child == 0) {
+    google_breakpad::scoped_ptr<ExceptionHandler> handler(
+      new ExceptionHandler(MinidumpDescriptor(temp_dir.path()), NULL, NULL,
+                            NULL, true, -1));
+
+    // We start a number of threads to make sure handling the signal takes
+    // enough time for the second thread to enter the signal handler.
+    int num_sleep_threads = 100;
+    google_breakpad::scoped_array<pthread_t> sleep_threads(
+        new pthread_t[num_sleep_threads]);
+    for (int i = 0; i < num_sleep_threads; ++i) {
+      ASSERT_EQ(0, pthread_create(&sleep_threads[i], NULL, SleepFunction,
+                                  NULL));
+    }
+
+    int num_crash_threads = 2;
+    google_breakpad::scoped_array<pthread_t> crash_threads(
+        new pthread_t[num_crash_threads]);
+    // Barrier to synchronize crashing both threads at the same time.
+    pthread_barrier_t b;
+    ASSERT_EQ(0, pthread_barrier_init(&b, NULL, num_crash_threads + 1));
+    for (int i = 0; i < num_crash_threads; ++i) {
+      ASSERT_EQ(0, pthread_create(&crash_threads[i], NULL, CrashFunction, &b));
+    }
+    pthread_barrier_wait(&b);
+    for (int i = 0; i < num_crash_threads; ++i) {
+      ASSERT_EQ(0, pthread_join(crash_threads[i], NULL));
+    }
+  }
+
+  // Wait a while until the child should have crashed.
+  usleep(1000000);
+  // Kill the child if it is still running.
+  kill(child, SIGKILL);
+
+  // If the child process terminated by itself, it will have returned SIGSEGV.
+  // If however it got stuck in a loop, it will have been killed by the
+  // SIGKILL.
+  ASSERT_NO_FATAL_FAILURE(WaitForProcessToTerminate(child, SIGSEGV));
+}
+#endif  // !defined(__ANDROID_API__) || __ANDROID_API__ >= __ANDROID_API_N__
 
 static bool DoneCallbackReturnFalse(const MinidumpDescriptor& descriptor,
                                     void* context,
@@ -287,15 +359,13 @@ static bool InstallRaiseSIGKILL() {
   return sigaction(SIGSEGV, &sa, NULL) != -1;
 }
 
-#ifndef ADDRESS_SANITIZER
-
 static void CrashWithCallbacks(ExceptionHandler::FilterCallback filter,
                                ExceptionHandler::MinidumpCallback done,
                                string path) {
   ExceptionHandler handler(
       MinidumpDescriptor(path), filter, done, NULL, true, -1);
   // Crash with the exception handler in scope.
-  *reinterpret_cast<volatile int*>(NULL) = 0;
+  DoNullPointerDereference();
 }
 
 TEST(ExceptionHandlerTest, RedeliveryOnFilterCallbackFalse) {
@@ -351,6 +421,10 @@ TEST(ExceptionHandlerTest, RedeliveryToDefaultHandler) {
 
   const pid_t child = fork();
   if (child == 0) {
+    // Custom signal handlers, which may have been installed by a test launcher,
+    // are undesirable in this child.
+    signal(SIGSEGV, SIG_DFL);
+
     CrashWithCallbacks(FilterCallbackReturnFalse, NULL, temp_dir.path());
   }
 
@@ -386,7 +460,7 @@ TEST(ExceptionHandlerTest, RedeliveryOnBadSignalHandlerFlag) {
               reinterpret_cast<void*>(SIG_ERR));
 
     // Crash with the exception handler in scope.
-    *reinterpret_cast<volatile int*>(NULL) = 0;
+    DoNullPointerDereference();
   }
   // SIGKILL means Breakpad's signal handler didn't crash.
   ASSERT_NO_FATAL_FAILURE(WaitForProcessToTerminate(child, SIGKILL));
@@ -456,6 +530,29 @@ TEST(ExceptionHandlerTest, StackedHandlersUnhandledToBottom) {
   ASSERT_NO_FATAL_FAILURE(WaitForProcessToTerminate(child, SIGKILL));
 }
 
+namespace {
+const int kSimpleFirstChanceReturnStatus = 42;
+bool SimpleFirstChanceHandler(int, siginfo_t*, void*) {
+  _exit(kSimpleFirstChanceReturnStatus);
+}
+}
+
+TEST(ExceptionHandlerTest, FirstChanceHandlerRuns) {
+  AutoTempDir temp_dir;
+
+  const pid_t child = fork();
+  if (child == 0) {
+    ExceptionHandler handler(
+        MinidumpDescriptor(temp_dir.path()), NULL, NULL, NULL, true, -1);
+    google_breakpad::SetFirstChanceExceptionHandler(SimpleFirstChanceHandler);
+    DoNullPointerDereference();
+  }
+  int status;
+  ASSERT_NE(HANDLE_EINTR(waitpid(child, &status, 0)), -1);
+  ASSERT_TRUE(WIFEXITED(status));
+  ASSERT_EQ(kSimpleFirstChanceReturnStatus, WEXITSTATUS(status));
+}
+
 #endif  // !ADDRESS_SANITIZER
 
 const unsigned char kIllegalInstruction[] = {
@@ -756,8 +853,13 @@ TEST(ExceptionHandlerTest, InstructionPointerMemoryNullPointer) {
                              true, -1);
     // Try calling a NULL pointer.
     typedef void (*void_function)(void);
-    void_function memory_function = reinterpret_cast<void_function>(NULL);
+    // Volatile markings are needed to keep Clang from generating invalid
+    // opcodes.  See http://crbug.com/498354 for details.
+    volatile void_function memory_function =
+      reinterpret_cast<void_function>(NULL);
     memory_function();
+    // not reached
+    exit(1);
   }
   close(fds[1]);
 
@@ -771,17 +873,37 @@ TEST(ExceptionHandlerTest, InstructionPointerMemoryNullPointer) {
   ASSERT_GT(st.st_size, 0);
 
   // Read the minidump. Locate the exception record and the
-  // memory list, and then ensure that there is a memory region
+  // memory list, and then ensure that there is no memory region
   // in the memory list that covers the instruction pointer from
   // the exception record.
   Minidump minidump(minidump_path);
   ASSERT_TRUE(minidump.Read());
 
   MinidumpException* exception = minidump.GetException();
-  MinidumpMemoryList* memory_list = minidump.GetMemoryList();
   ASSERT_TRUE(exception);
+
+  MinidumpContext* exception_context = exception->GetContext();
+  ASSERT_TRUE(exception_context);
+
+  uint64_t instruction_pointer;
+  ASSERT_TRUE(exception_context->GetInstructionPointer(&instruction_pointer));
+  EXPECT_EQ(instruction_pointer, 0u);
+
+  MinidumpMemoryList* memory_list = minidump.GetMemoryList();
   ASSERT_TRUE(memory_list);
-  ASSERT_EQ(static_cast<unsigned int>(1), memory_list->region_count());
+
+  unsigned int region_count = memory_list->region_count();
+  ASSERT_GE(region_count, 1u);
+
+  for (unsigned int region_index = 0;
+       region_index < region_count;
+       ++region_index) {
+    MinidumpMemoryRegion* region =
+        memory_list->GetMemoryRegionAtIndex(region_index);
+    uint64_t region_base = region->GetBase();
+    EXPECT_FALSE(instruction_pointer >= region_base &&
+                 instruction_pointer < region_base + region->GetSize());
+  }
 
   unlink(minidump_path.c_str());
 }
@@ -798,19 +920,7 @@ TEST(ExceptionHandlerTest, ModuleInfo) {
     0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
     0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF
   };
-  char module_identifier_buffer[kGUIDStringSize];
-  FileID::ConvertIdentifierToString(kModuleGUID,
-                                    module_identifier_buffer,
-                                    sizeof(module_identifier_buffer));
-  string module_identifier(module_identifier_buffer);
-  // Strip out dashes
-  size_t pos;
-  while ((pos = module_identifier.find('-')) != string::npos) {
-    module_identifier.erase(pos, 1);
-  }
-  // And append a zero, because module IDs include an "age" field
-  // which is always zero on Linux.
-  module_identifier += "0";
+  const string module_identifier = "33221100554477668899AABBCCDDEEFF0";
 
   // Get some memory.
   char* memory =
@@ -855,6 +965,8 @@ TEST(ExceptionHandlerTest, ModuleInfo) {
   unlink(minidump_desc.path());
 }
 
+#ifndef ADDRESS_SANITIZER
+
 static const unsigned kControlMsgSize =
     CMSG_SPACE(sizeof(int)) + CMSG_SPACE(sizeof(struct ucred));
 
@@ -882,7 +994,7 @@ CrashHandler(const void* crash_context, size_t crash_context_size,
   msg.msg_control = cmsg;
   msg.msg_controllen = sizeof(cmsg);
 
-  struct cmsghdr *hdr = CMSG_FIRSTHDR(&msg);
+  struct cmsghdr* hdr = CMSG_FIRSTHDR(&msg);
   hdr->cmsg_level = SOL_SOCKET;
   hdr->cmsg_type = SCM_RIGHTS;
   hdr->cmsg_len = CMSG_LEN(sizeof(int));
@@ -891,7 +1003,7 @@ CrashHandler(const void* crash_context, size_t crash_context_size,
   hdr->cmsg_level = SOL_SOCKET;
   hdr->cmsg_type = SCM_CREDENTIALS;
   hdr->cmsg_len = CMSG_LEN(sizeof(struct ucred));
-  struct ucred *cred = reinterpret_cast<struct ucred*>(CMSG_DATA(hdr));
+  struct ucred* cred = reinterpret_cast<struct ucred*>(CMSG_DATA(hdr));
   cred->uid = getuid();
   cred->gid = getgid();
   cred->pid = getpid();
@@ -907,8 +1019,6 @@ CrashHandler(const void* crash_context, size_t crash_context_size,
   return true;
 }
 
-#ifndef ADDRESS_SANITIZER
-
 TEST(ExceptionHandlerTest, ExternalDumper) {
   int fds[2];
   ASSERT_NE(socketpair(AF_UNIX, SOCK_DGRAM, 0, fds), -1);
@@ -922,7 +1032,7 @@ TEST(ExceptionHandlerTest, ExternalDumper) {
     ExceptionHandler handler(MinidumpDescriptor("/tmp1"), NULL, NULL,
                              reinterpret_cast<void*>(fds[1]), true, -1);
     handler.set_crash_handler(CrashHandler);
-    *reinterpret_cast<volatile int*>(NULL) = 0;
+    DoNullPointerDereference();
   }
   close(fds[1]);
   struct msghdr msg = {0};
@@ -941,12 +1051,12 @@ TEST(ExceptionHandlerTest, ExternalDumper) {
   const ssize_t n = HANDLE_EINTR(recvmsg(fds[0], &msg, 0));
   ASSERT_EQ(static_cast<ssize_t>(kCrashContextSize), n);
   ASSERT_EQ(kControlMsgSize, msg.msg_controllen);
-  ASSERT_EQ(static_cast<typeof(msg.msg_flags)>(0), msg.msg_flags);
+  ASSERT_EQ(static_cast<__typeof__(msg.msg_flags)>(0), msg.msg_flags);
   ASSERT_EQ(0, close(fds[0]));
 
   pid_t crashing_pid = -1;
   int signal_fd = -1;
-  for (struct cmsghdr *hdr = CMSG_FIRSTHDR(&msg); hdr;
+  for (struct cmsghdr* hdr = CMSG_FIRSTHDR(&msg); hdr;
        hdr = CMSG_NXTHDR(&msg, hdr)) {
     if (hdr->cmsg_level != SOL_SOCKET)
       continue;
@@ -956,7 +1066,7 @@ TEST(ExceptionHandlerTest, ExternalDumper) {
       ASSERT_EQ(sizeof(int), len);
       signal_fd = *(reinterpret_cast<int*>(CMSG_DATA(hdr)));
     } else if (hdr->cmsg_type == SCM_CREDENTIALS) {
-      const struct ucred *cred =
+      const struct ucred* cred =
           reinterpret_cast<struct ucred*>(CMSG_DATA(hdr));
       crashing_pid = cred->pid;
     }
diff --git a/src/MEGASync/google_breakpad/client/linux/handler/microdump_extra_info.h b/src/MEGASync/google_breakpad/client/linux/handler/microdump_extra_info.h
new file mode 100644
index 00000000..bf01f0c7
--- /dev/null
+++ b/src/MEGASync/google_breakpad/client/linux/handler/microdump_extra_info.h
@@ -0,0 +1,52 @@
+// Copyright 2015 Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef CLIENT_LINUX_HANDLER_MICRODUMP_EXTRA_INFO_H_
+#define CLIENT_LINUX_HANDLER_MICRODUMP_EXTRA_INFO_H_
+
+namespace google_breakpad {
+
+struct MicrodumpExtraInfo {
+  // Strings pointed to by this struct are not copied, and are
+  // expected to remain valid for the lifetime of the process.
+  const char* build_fingerprint;
+  const char* product_info;
+  const char* gpu_fingerprint;
+  const char* process_type;
+
+  MicrodumpExtraInfo()
+      : build_fingerprint(NULL),
+        product_info(NULL),
+        gpu_fingerprint(NULL),
+        process_type(NULL) {}
+};
+
+}
+
+#endif  // CLIENT_LINUX_HANDLER_MICRODUMP_EXTRA_INFO_H_
diff --git a/src/MEGASync/google_breakpad/client/linux/handler/minidump_descriptor.cc b/src/MEGASync/google_breakpad/client/linux/handler/minidump_descriptor.cc
index c4618adc..bd94474e 100644
--- a/src/MEGASync/google_breakpad/client/linux/handler/minidump_descriptor.cc
+++ b/src/MEGASync/google_breakpad/client/linux/handler/minidump_descriptor.cc
@@ -35,11 +35,22 @@
 
 namespace google_breakpad {
 
+//static
+const MinidumpDescriptor::MicrodumpOnConsole
+    MinidumpDescriptor::kMicrodumpOnConsole = {};
+
 MinidumpDescriptor::MinidumpDescriptor(const MinidumpDescriptor& descriptor)
-    : fd_(descriptor.fd_),
+    : mode_(descriptor.mode_),
+      fd_(descriptor.fd_),
       directory_(descriptor.directory_),
       c_path_(NULL),
-      size_limit_(descriptor.size_limit_) {
+      size_limit_(descriptor.size_limit_),
+      address_within_principal_mapping_(
+          descriptor.address_within_principal_mapping_),
+      skip_dump_if_principal_mapping_not_referenced_(
+          descriptor.skip_dump_if_principal_mapping_not_referenced_),
+      sanitize_stacks_(descriptor.sanitize_stacks_),
+      microdump_extra_info_(descriptor.microdump_extra_info_) {
   // The copy constructor is not allowed to be called on a MinidumpDescriptor
   // with a valid path_, as getting its c_path_ would require the heap which
   // can cause problems in compromised environments.
@@ -50,6 +61,7 @@ MinidumpDescriptor& MinidumpDescriptor::operator=(
     const MinidumpDescriptor& descriptor) {
   assert(descriptor.path_.empty());
 
+  mode_ = descriptor.mode_;
   fd_ = descriptor.fd_;
   directory_ = descriptor.directory_;
   path_.clear();
@@ -59,11 +71,17 @@ MinidumpDescriptor& MinidumpDescriptor::operator=(
     UpdatePath();
   }
   size_limit_ = descriptor.size_limit_;
+  address_within_principal_mapping_ =
+      descriptor.address_within_principal_mapping_;
+  skip_dump_if_principal_mapping_not_referenced_ =
+      descriptor.skip_dump_if_principal_mapping_not_referenced_;
+  sanitize_stacks_ = descriptor.sanitize_stacks_;
+  microdump_extra_info_ = descriptor.microdump_extra_info_;
   return *this;
 }
 
 void MinidumpDescriptor::UpdatePath() {
-  assert(fd_ == -1 && !directory_.empty());
+  assert(mode_ == kWriteMinidumpToFile && !directory_.empty());
 
   GUID guid;
   char guid_str[kGUIDStringLength + 1];
@@ -72,7 +90,7 @@ void MinidumpDescriptor::UpdatePath() {
   }
 
   path_.clear();
-  path_ = directory_ + "/" + guid_str + ".dmp";  
+  path_ = directory_ + "/" + guid_str + ".dmp";
   c_path_ = path_.c_str();
 }
 
diff --git a/src/MEGASync/google_breakpad/client/linux/handler/minidump_descriptor.h b/src/MEGASync/google_breakpad/client/linux/handler/minidump_descriptor.h
index 9ffe622b..c7e4f2b3 100644
--- a/src/MEGASync/google_breakpad/client/linux/handler/minidump_descriptor.h
+++ b/src/MEGASync/google_breakpad/client/linux/handler/minidump_descriptor.h
@@ -35,37 +35,65 @@
 
 #include <string>
 
+#include "client/linux/handler/microdump_extra_info.h"
 #include "common/using_std_string.h"
 
-// The MinidumpDescriptor describes how to access a minidump: it can contain
-// either a file descriptor or a path.
-// Note that when using files, it is created with the path to a directory.
-// The actual path where the minidump is generated is created by this class.
+// This class describes how a crash dump should be generated, either:
+// - Writing a full minidump to a file in a given directory (the actual path,
+//   inside the directory, is determined by this class).
+// - Writing a full minidump to a given fd.
+// - Writing a reduced microdump to the console (logcat on Android).
 namespace google_breakpad {
 
 class MinidumpDescriptor {
  public:
-  MinidumpDescriptor() : fd_(-1), size_limit_(-1) {}
+  struct MicrodumpOnConsole {};
+  static const MicrodumpOnConsole kMicrodumpOnConsole;
+
+  MinidumpDescriptor()
+      : mode_(kUninitialized),
+        fd_(-1),
+        size_limit_(-1),
+        address_within_principal_mapping_(0),
+        skip_dump_if_principal_mapping_not_referenced_(false) {}
 
   explicit MinidumpDescriptor(const string& directory)
-      : fd_(-1),
+      : mode_(kWriteMinidumpToFile),
+        fd_(-1),
         directory_(directory),
         c_path_(NULL),
-        size_limit_(-1) {
+        size_limit_(-1),
+        address_within_principal_mapping_(0),
+        skip_dump_if_principal_mapping_not_referenced_(false),
+        sanitize_stacks_(false) {
     assert(!directory.empty());
   }
 
   explicit MinidumpDescriptor(int fd)
-      : fd_(fd),
+      : mode_(kWriteMinidumpToFd),
+        fd_(fd),
         c_path_(NULL),
-        size_limit_(-1) {
+        size_limit_(-1),
+        address_within_principal_mapping_(0),
+        skip_dump_if_principal_mapping_not_referenced_(false),
+        sanitize_stacks_(false) {
     assert(fd != -1);
   }
 
+  explicit MinidumpDescriptor(const MicrodumpOnConsole&)
+      : mode_(kWriteMicrodumpToConsole),
+        fd_(-1),
+        size_limit_(-1),
+        address_within_principal_mapping_(0),
+        skip_dump_if_principal_mapping_not_referenced_(false),
+        sanitize_stacks_(false) {}
+
   explicit MinidumpDescriptor(const MinidumpDescriptor& descriptor);
   MinidumpDescriptor& operator=(const MinidumpDescriptor& descriptor);
 
-  bool IsFD() const { return fd_ != -1; }
+  static MinidumpDescriptor getMicrodumpDescriptor();
+
+  bool IsFD() const { return mode_ == kWriteMinidumpToFd; }
 
   int fd() const { return fd_; }
 
@@ -73,6 +101,10 @@ class MinidumpDescriptor {
 
   const char* path() const { return c_path_; }
 
+  bool IsMicrodumpOnConsole() const {
+    return mode_ == kWriteMicrodumpToConsole;
+  }
+
   // Updates the path so it is unique.
   // Should be called from a normal context: this methods uses the heap.
   void UpdatePath();
@@ -80,19 +112,86 @@ class MinidumpDescriptor {
   off_t size_limit() const { return size_limit_; }
   void set_size_limit(off_t limit) { size_limit_ = limit; }
 
+  uintptr_t address_within_principal_mapping() const {
+    return address_within_principal_mapping_;
+  }
+  void set_address_within_principal_mapping(
+      uintptr_t address_within_principal_mapping) {
+    address_within_principal_mapping_ = address_within_principal_mapping;
+  }
+
+  bool skip_dump_if_principal_mapping_not_referenced() {
+    return skip_dump_if_principal_mapping_not_referenced_;
+  }
+  void set_skip_dump_if_principal_mapping_not_referenced(
+      bool skip_dump_if_principal_mapping_not_referenced) {
+    skip_dump_if_principal_mapping_not_referenced_ =
+        skip_dump_if_principal_mapping_not_referenced;
+  }
+
+  bool sanitize_stacks() const { return sanitize_stacks_; }
+  void set_sanitize_stacks(bool sanitize_stacks) {
+    sanitize_stacks_ = sanitize_stacks;
+  }
+
+  MicrodumpExtraInfo* microdump_extra_info() {
+    assert(IsMicrodumpOnConsole());
+    return &microdump_extra_info_;
+  }
+
  private:
+  enum DumpMode {
+    kUninitialized = 0,
+    kWriteMinidumpToFile,
+    kWriteMinidumpToFd,
+    kWriteMicrodumpToConsole
+  };
+
+  // Specifies the dump mode (see DumpMode).
+  DumpMode mode_;
+
   // The file descriptor where the minidump is generated.
   int fd_;
 
   // The directory where the minidump should be generated.
   string directory_;
+
   // The full path to the generated minidump.
   string path_;
+
   // The C string of |path_|. Precomputed so it can be access from a compromised
   // context.
   const char* c_path_;
 
   off_t size_limit_;
+
+  // This member points somewhere into the main module for this
+  // process (the module that is considerered interesting for the
+  // purposes of debugging crashes).
+  uintptr_t address_within_principal_mapping_;
+
+  // If set, threads that do not reference the address range
+  // associated with |address_within_principal_mapping_| will not have their
+  // stacks logged.
+  bool skip_dump_if_principal_mapping_not_referenced_;
+
+  // If set, stacks are sanitized to remove PII. This involves
+  // overwriting any pointer-aligned words that are not either
+  // pointers into a process mapping or small integers (+/-4096). This
+  // leaves enough information to unwind stacks, and preserve some
+  // register values, but elides strings and other program data.
+  bool sanitize_stacks_;
+
+  // The extra microdump data (e.g. product name/version, build
+  // fingerprint, gpu fingerprint) that should be appended to the dump
+  // (microdump only). Microdumps don't have the ability of appending
+  // extra metadata after the dump is generated (as opposite to
+  // minidumps MIME fields), therefore the extra data must be provided
+  // upfront. Any memory pointed to by members of the
+  // MicrodumpExtraInfo struct must be valid for the lifetime of the
+  // process (read: the caller has to guarantee that it is stored in
+  // global static storage.)
+  MicrodumpExtraInfo microdump_extra_info_;
 };
 
 }  // namespace google_breakpad
diff --git a/src/MEGASync/google_breakpad/client/linux/log/log.cc b/src/MEGASync/google_breakpad/client/linux/log/log.cc
index 18635913..31879409 100644
--- a/src/MEGASync/google_breakpad/client/linux/log/log.cc
+++ b/src/MEGASync/google_breakpad/client/linux/log/log.cc
@@ -31,15 +31,51 @@
 
 #if defined(__ANDROID__)
 #include <android/log.h>
+#include <dlfcn.h>
 #else
 #include "third_party/lss/linux_syscall_support.h"
 #endif
 
 namespace logger {
 
+#if defined(__ANDROID__)
+namespace {
+
+// __android_log_buf_write() is not exported in the NDK and is being used by
+// dynamic runtime linking. Its declaration is taken from Android's
+// system/core/include/log/log.h.
+using AndroidLogBufferWriteFunc = int (*)(int bufID, int prio, const char* tag,
+                                          const char* text);
+const int kAndroidCrashLogId = 4;  // From LOG_ID_CRASH in log.h.
+const char kAndroidLogTag[] = "google-breakpad";
+
+bool g_crash_log_initialized = false;
+AndroidLogBufferWriteFunc g_android_log_buf_write = nullptr;
+
+}  // namespace
+
+void initializeCrashLogWriter() {
+  if (g_crash_log_initialized)
+    return;
+  g_android_log_buf_write = reinterpret_cast<AndroidLogBufferWriteFunc>(
+      dlsym(RTLD_DEFAULT, "__android_log_buf_write"));
+  g_crash_log_initialized = true;
+}
+
+int writeToCrashLog(const char* buf) {
+  // Try writing to the crash log ring buffer. If not available, fall back to
+  // the standard log buffer.
+  if (g_android_log_buf_write) {
+    return g_android_log_buf_write(kAndroidCrashLogId, ANDROID_LOG_FATAL,
+                                   kAndroidLogTag, buf);
+  }
+  return __android_log_write(ANDROID_LOG_FATAL, kAndroidLogTag, buf);
+}
+#endif
+
 int write(const char* buf, size_t nbytes) {
 #if defined(__ANDROID__)
-  return __android_log_write(ANDROID_LOG_WARN, "google-breakpad", buf);
+  return __android_log_write(ANDROID_LOG_WARN, kAndroidLogTag, buf);
 #else
   return sys_write(2, buf, nbytes);
 #endif
diff --git a/src/MEGASync/google_breakpad/client/linux/log/log.h b/src/MEGASync/google_breakpad/client/linux/log/log.h
index a50e30dc..f94bbd5f 100644
--- a/src/MEGASync/google_breakpad/client/linux/log/log.h
+++ b/src/MEGASync/google_breakpad/client/linux/log/log.h
@@ -36,6 +36,20 @@ namespace logger {
 
 int write(const char* buf, size_t nbytes);
 
+// In the case of Android the log can be written to the default system log
+// (default behavior of write() above, or to the crash log (see
+// writeToCrashLog() below).
+#if defined(__ANDROID__)
+
+// The logger must be initialized in a non-compromised context.
+void initializeCrashLogWriter();
+
+// Once initialized, writeToCrashLog is safe to use in a compromised context,
+// even if the initialization failed, in which case this will silently fall
+// back on write().
+int writeToCrashLog(const char* buf);
+#endif
+
 }  // namespace logger
 
 #endif  // CLIENT_LINUX_LOG_LOG_H_
diff --git a/src/MEGASync/google_breakpad/client/linux/microdump_writer/microdump_writer.cc b/src/MEGASync/google_breakpad/client/linux/microdump_writer/microdump_writer.cc
new file mode 100644
index 00000000..fa3c1713
--- /dev/null
+++ b/src/MEGASync/google_breakpad/client/linux/microdump_writer/microdump_writer.cc
@@ -0,0 +1,664 @@
+// Copyright (c) 2014, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// This translation unit generates microdumps into the console (logcat on
+// Android). See crbug.com/410294 for more info and design docs.
+
+#include "client/linux/microdump_writer/microdump_writer.h"
+
+#include <limits>
+
+#include <sys/utsname.h>
+
+#include "client/linux/dump_writer_common/thread_info.h"
+#include "client/linux/dump_writer_common/ucontext_reader.h"
+#include "client/linux/handler/exception_handler.h"
+#include "client/linux/handler/microdump_extra_info.h"
+#include "client/linux/log/log.h"
+#include "client/linux/minidump_writer/linux_ptrace_dumper.h"
+#include "common/linux/file_id.h"
+#include "common/linux/linux_libc_support.h"
+#include "common/memory_allocator.h"
+
+namespace {
+
+using google_breakpad::auto_wasteful_vector;
+using google_breakpad::ExceptionHandler;
+using google_breakpad::kDefaultBuildIdSize;
+using google_breakpad::LinuxDumper;
+using google_breakpad::LinuxPtraceDumper;
+using google_breakpad::MappingInfo;
+using google_breakpad::MappingList;
+using google_breakpad::MicrodumpExtraInfo;
+using google_breakpad::RawContextCPU;
+using google_breakpad::ThreadInfo;
+using google_breakpad::UContextReader;
+
+const size_t kLineBufferSize = 2048;
+
+#if !defined(__LP64__)
+// The following are only used by DumpFreeSpace, so need to be compiled
+// in conditionally in the same way.
+
+template <typename Dst, typename Src>
+Dst saturated_cast(Src src) {
+  if (src >= std::numeric_limits<Dst>::max())
+    return std::numeric_limits<Dst>::max();
+  if (src <= std::numeric_limits<Dst>::min())
+    return std::numeric_limits<Dst>::min();
+  return static_cast<Dst>(src);
+}
+
+int Log2Floor(uint64_t n) {
+  // Copied from chromium src/base/bits.h
+  if (n == 0)
+    return -1;
+  int log = 0;
+  uint64_t value = n;
+  for (int i = 5; i >= 0; --i) {
+    int shift = (1 << i);
+    uint64_t x = value >> shift;
+    if (x != 0) {
+      value = x;
+      log += shift;
+    }
+  }
+  assert(value == 1u);
+  return log;
+}
+
+bool MappingsAreAdjacent(const MappingInfo& a, const MappingInfo& b) {
+  // Because of load biasing, we can end up with a situation where two
+  // mappings actually overlap. So we will define adjacency to also include a
+  // b start address that lies within a's address range (including starting
+  // immediately after a).
+  // Because load biasing only ever moves the start address backwards, the end
+  // address should still increase.
+  return a.start_addr <= b.start_addr && a.start_addr + a.size >= b.start_addr;
+}
+
+bool MappingLessThan(const MappingInfo* a, const MappingInfo* b) {
+  // Return true if mapping a is before mapping b.
+  // For the same reason (load biasing) we compare end addresses, which - unlike
+  // start addresses - will not have been modified.
+  return a->start_addr + a->size < b->start_addr + b->size;
+}
+
+size_t NextOrderedMapping(
+    const google_breakpad::wasteful_vector<MappingInfo*>& mappings,
+    size_t curr) {
+  // Find the mapping that directly follows mappings[curr].
+  // If no such mapping exists, return |invalid| to indicate this.
+  const size_t invalid = std::numeric_limits<size_t>::max();
+  size_t best = invalid;
+  for (size_t next = 0; next < mappings.size(); ++next) {
+    if (MappingLessThan(mappings[curr], mappings[next]) &&
+        (best == invalid || MappingLessThan(mappings[next], mappings[best]))) {
+      best = next;
+    }
+  }
+  return best;
+}
+
+#endif  // !__LP64__
+
+class MicrodumpWriter {
+ public:
+  MicrodumpWriter(const ExceptionHandler::CrashContext* context,
+                  const MappingList& mappings,
+                  bool skip_dump_if_principal_mapping_not_referenced,
+                  uintptr_t address_within_principal_mapping,
+                  bool sanitize_stack,
+                  const MicrodumpExtraInfo& microdump_extra_info,
+                  LinuxDumper* dumper)
+      : ucontext_(context ? &context->context : NULL),
+#if !defined(__ARM_EABI__) && !defined(__mips__)
+        float_state_(context ? &context->float_state : NULL),
+#endif
+        dumper_(dumper),
+        mapping_list_(mappings),
+        skip_dump_if_principal_mapping_not_referenced_(
+            skip_dump_if_principal_mapping_not_referenced),
+        address_within_principal_mapping_(address_within_principal_mapping),
+        sanitize_stack_(sanitize_stack),
+        microdump_extra_info_(microdump_extra_info),
+        log_line_(NULL),
+        stack_copy_(NULL),
+        stack_len_(0),
+        stack_lower_bound_(0),
+        stack_pointer_(0) {
+    log_line_ = reinterpret_cast<char*>(Alloc(kLineBufferSize));
+    if (log_line_)
+      log_line_[0] = '\0';  // Clear out the log line buffer.
+  }
+
+  ~MicrodumpWriter() { dumper_->ThreadsResume(); }
+
+  bool Init() {
+    // In the exceptional case where the system was out of memory and there
+    // wasn't even room to allocate the line buffer, bail out. There is nothing
+    // useful we can possibly achieve without the ability to Log. At least let's
+    // try to not crash.
+    if (!dumper_->Init() || !log_line_)
+      return false;
+    return dumper_->ThreadsSuspend() && dumper_->LateInit();
+  }
+
+  void Dump() {
+    CaptureResult stack_capture_result = CaptureCrashingThreadStack(-1);
+    if (stack_capture_result == CAPTURE_UNINTERESTING) {
+      LogLine("Microdump skipped (uninteresting)");
+      return;
+    }
+
+    LogLine("-----BEGIN BREAKPAD MICRODUMP-----");
+    DumpProductInformation();
+    DumpOSInformation();
+    DumpProcessType();
+    DumpCrashReason();
+    DumpGPUInformation();
+#if !defined(__LP64__)
+    DumpFreeSpace();
+#endif
+    if (stack_capture_result == CAPTURE_OK)
+      DumpThreadStack();
+    DumpCPUState();
+    DumpMappings();
+    LogLine("-----END BREAKPAD MICRODUMP-----");
+  }
+
+ private:
+  enum CaptureResult { CAPTURE_OK, CAPTURE_FAILED, CAPTURE_UNINTERESTING };
+
+  // Writes one line to the system log.
+  void LogLine(const char* msg) {
+#if defined(__ANDROID__)
+    logger::writeToCrashLog(msg);
+#else
+    logger::write(msg, my_strlen(msg));
+    logger::write("\n", 1);
+#endif
+  }
+
+  // Stages the given string in the current line buffer.
+  void LogAppend(const char* str) {
+    my_strlcat(log_line_, str, kLineBufferSize);
+  }
+
+  // As above (required to take precedence over template specialization below).
+  void LogAppend(char* str) {
+    LogAppend(const_cast<const char*>(str));
+  }
+
+  // Stages the hex repr. of the given int type in the current line buffer.
+  template<typename T>
+  void LogAppend(T value) {
+    // Make enough room to hex encode the largest int type + NUL.
+    static const char HEX[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
+                               'A', 'B', 'C', 'D', 'E', 'F'};
+    char hexstr[sizeof(T) * 2 + 1];
+    for (int i = sizeof(T) * 2 - 1; i >= 0; --i, value >>= 4)
+      hexstr[i] = HEX[static_cast<uint8_t>(value) & 0x0F];
+    hexstr[sizeof(T) * 2] = '\0';
+    LogAppend(hexstr);
+  }
+
+  // Stages the buffer content hex-encoded in the current line buffer.
+  void LogAppend(const void* buf, size_t length) {
+    const uint8_t* ptr = reinterpret_cast<const uint8_t*>(buf);
+    for (size_t i = 0; i < length; ++i, ++ptr)
+      LogAppend(*ptr);
+  }
+
+  // Writes out the current line buffer on the system log.
+  void LogCommitLine() {
+    LogLine(log_line_);
+    log_line_[0] = 0;
+  }
+
+  CaptureResult CaptureCrashingThreadStack(int max_stack_len) {
+    stack_pointer_ = UContextReader::GetStackPointer(ucontext_);
+
+    if (!dumper_->GetStackInfo(reinterpret_cast<const void**>(&stack_lower_bound_),
+                               &stack_len_, stack_pointer_)) {
+      return CAPTURE_FAILED;
+    }
+
+    if (max_stack_len >= 0 &&
+        stack_len_ > static_cast<size_t>(max_stack_len)) {
+      stack_len_ = max_stack_len;
+    }
+
+    stack_copy_ = reinterpret_cast<uint8_t*>(Alloc(stack_len_));
+    dumper_->CopyFromProcess(stack_copy_, dumper_->crash_thread(),
+                             reinterpret_cast<const void*>(stack_lower_bound_),
+                             stack_len_);
+
+    if (!skip_dump_if_principal_mapping_not_referenced_) return CAPTURE_OK;
+
+    const MappingInfo* principal_mapping =
+        dumper_->FindMappingNoBias(address_within_principal_mapping_);
+    if (!principal_mapping) return CAPTURE_UNINTERESTING;
+
+    uintptr_t low_addr = principal_mapping->system_mapping_info.start_addr;
+    uintptr_t high_addr = principal_mapping->system_mapping_info.end_addr;
+    uintptr_t pc = UContextReader::GetInstructionPointer(ucontext_);
+    if (low_addr <= pc && pc <= high_addr) return CAPTURE_OK;
+
+    if (dumper_->StackHasPointerToMapping(stack_copy_, stack_len_,
+                                          stack_pointer_ - stack_lower_bound_,
+                                          *principal_mapping)) {
+      return CAPTURE_OK;
+    }
+    return CAPTURE_UNINTERESTING;
+  }
+
+  void DumpProductInformation() {
+    LogAppend("V ");
+    if (microdump_extra_info_.product_info) {
+      LogAppend(microdump_extra_info_.product_info);
+    } else {
+      LogAppend("UNKNOWN:0.0.0.0");
+    }
+    LogCommitLine();
+  }
+
+  void DumpProcessType() {
+    LogAppend("P ");
+    if (microdump_extra_info_.process_type) {
+      LogAppend(microdump_extra_info_.process_type);
+    } else {
+      LogAppend("UNKNOWN");
+    }
+    LogCommitLine();
+  }
+
+  void DumpCrashReason() {
+    LogAppend("R ");
+    LogAppend(dumper_->crash_signal());
+    LogAppend(" ");
+    LogAppend(dumper_->GetCrashSignalString());
+    LogAppend(" ");
+    LogAppend(dumper_->crash_address());
+    LogCommitLine();
+  }
+
+  void DumpOSInformation() {
+    const uint8_t n_cpus = static_cast<uint8_t>(sysconf(_SC_NPROCESSORS_CONF));
+
+#if defined(__ANDROID__)
+    const char kOSId[] = "A";
+#else
+    const char kOSId[] = "L";
+#endif
+
+// Dump the runtime architecture. On multiarch devices it might not match the
+// hw architecture (the one returned by uname()), for instance in the case of
+// a 32-bit app running on a aarch64 device.
+#if defined(__aarch64__)
+    const char kArch[] = "arm64";
+#elif defined(__ARMEL__)
+    const char kArch[] = "arm";
+#elif defined(__x86_64__)
+    const char kArch[] = "x86_64";
+#elif defined(__i386__)
+    const char kArch[] = "x86";
+#elif defined(__mips__)
+# if _MIPS_SIM == _ABIO32
+    const char kArch[] = "mips";
+# elif _MIPS_SIM == _ABI64
+    const char kArch[] = "mips64";
+# else
+#  error "This mips ABI is currently not supported (n32)"
+#endif
+#else
+#error "This code has not been ported to your platform yet"
+#endif
+
+    LogAppend("O ");
+    LogAppend(kOSId);
+    LogAppend(" ");
+    LogAppend(kArch);
+    LogAppend(" ");
+    LogAppend(n_cpus);
+    LogAppend(" ");
+
+    // Dump the HW architecture (e.g., armv7l, aarch64).
+    struct utsname uts;
+    const bool has_uts_info = (uname(&uts) == 0);
+    const char* hwArch = has_uts_info ? uts.machine : "unknown_hw_arch";
+    LogAppend(hwArch);
+    LogAppend(" ");
+
+    // If the client has attached a build fingerprint to the MinidumpDescriptor
+    // use that one. Otherwise try to get some basic info from uname().
+    if (microdump_extra_info_.build_fingerprint) {
+      LogAppend(microdump_extra_info_.build_fingerprint);
+    } else if (has_uts_info) {
+      LogAppend(uts.release);
+      LogAppend(" ");
+      LogAppend(uts.version);
+    } else {
+      LogAppend("no build fingerprint available");
+    }
+    LogCommitLine();
+  }
+
+  void DumpGPUInformation() {
+    LogAppend("G ");
+    if (microdump_extra_info_.gpu_fingerprint) {
+      LogAppend(microdump_extra_info_.gpu_fingerprint);
+    } else {
+      LogAppend("UNKNOWN");
+    }
+    LogCommitLine();
+  }
+
+  void DumpThreadStack() {
+    if (sanitize_stack_) {
+      dumper_->SanitizeStackCopy(stack_copy_, stack_len_, stack_pointer_,
+                                 stack_pointer_ - stack_lower_bound_);
+    }
+
+    LogAppend("S 0 ");
+    LogAppend(stack_pointer_);
+    LogAppend(" ");
+    LogAppend(stack_lower_bound_);
+    LogAppend(" ");
+    LogAppend(stack_len_);
+    LogCommitLine();
+
+    const size_t STACK_DUMP_CHUNK_SIZE = 384;
+    for (size_t stack_off = 0; stack_off < stack_len_;
+         stack_off += STACK_DUMP_CHUNK_SIZE) {
+      LogAppend("S ");
+      LogAppend(stack_lower_bound_ + stack_off);
+      LogAppend(" ");
+      LogAppend(stack_copy_ + stack_off,
+                std::min(STACK_DUMP_CHUNK_SIZE, stack_len_ - stack_off));
+      LogCommitLine();
+    }
+  }
+
+  void DumpCPUState() {
+    RawContextCPU cpu;
+    my_memset(&cpu, 0, sizeof(RawContextCPU));
+#if !defined(__ARM_EABI__) && !defined(__mips__)
+    UContextReader::FillCPUContext(&cpu, ucontext_, float_state_);
+#else
+    UContextReader::FillCPUContext(&cpu, ucontext_);
+#endif
+    LogAppend("C ");
+    LogAppend(&cpu, sizeof(cpu));
+    LogCommitLine();
+  }
+
+  // If there is caller-provided information about this mapping
+  // in the mapping_list_ list, return true. Otherwise, return false.
+  bool HaveMappingInfo(const MappingInfo& mapping) {
+    for (MappingList::const_iterator iter = mapping_list_.begin();
+         iter != mapping_list_.end();
+         ++iter) {
+      // Ignore any mappings that are wholly contained within
+      // mappings in the mapping_info_ list.
+      if (mapping.start_addr >= iter->first.start_addr &&
+          (mapping.start_addr + mapping.size) <=
+              (iter->first.start_addr + iter->first.size)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  // Dump information about the provided |mapping|. If |identifier| is non-NULL,
+  // use it instead of calculating a file ID from the mapping.
+  void DumpModule(const MappingInfo& mapping,
+                  bool member,
+                  unsigned int mapping_id,
+                  const uint8_t* identifier) {
+
+    auto_wasteful_vector<uint8_t, kDefaultBuildIdSize> identifier_bytes(
+        dumper_->allocator());
+
+    if (identifier) {
+      // GUID was provided by caller.
+      identifier_bytes.insert(identifier_bytes.end(),
+                              identifier,
+                              identifier + sizeof(MDGUID));
+    } else {
+      dumper_->ElfFileIdentifierForMapping(
+          mapping,
+          member,
+          mapping_id,
+          identifier_bytes);
+    }
+
+    // Copy as many bytes of |identifier| as will fit into a MDGUID
+    MDGUID module_identifier = {0};
+    memcpy(&module_identifier, &identifier_bytes[0],
+           std::min(sizeof(MDGUID), identifier_bytes.size()));
+
+    char file_name[NAME_MAX];
+    char file_path[NAME_MAX];
+    dumper_->GetMappingEffectiveNameAndPath(
+        mapping, file_path, sizeof(file_path), file_name, sizeof(file_name));
+
+    LogAppend("M ");
+    LogAppend(static_cast<uintptr_t>(mapping.start_addr));
+    LogAppend(" ");
+    LogAppend(mapping.offset);
+    LogAppend(" ");
+    LogAppend(mapping.size);
+    LogAppend(" ");
+    LogAppend(module_identifier.data1);
+    LogAppend(module_identifier.data2);
+    LogAppend(module_identifier.data3);
+    LogAppend(module_identifier.data4[0]);
+    LogAppend(module_identifier.data4[1]);
+    LogAppend(module_identifier.data4[2]);
+    LogAppend(module_identifier.data4[3]);
+    LogAppend(module_identifier.data4[4]);
+    LogAppend(module_identifier.data4[5]);
+    LogAppend(module_identifier.data4[6]);
+    LogAppend(module_identifier.data4[7]);
+    LogAppend("0 ");  // Age is always 0 on Linux.
+    LogAppend(file_name);
+    LogCommitLine();
+  }
+
+#if !defined(__LP64__)
+  void DumpFreeSpace() {
+    const MappingInfo* stack_mapping = nullptr;
+    ThreadInfo info;
+    if (dumper_->GetThreadInfoByIndex(dumper_->GetMainThreadIndex(), &info)) {
+      stack_mapping = dumper_->FindMappingNoBias(info.stack_pointer);
+    }
+
+    const google_breakpad::wasteful_vector<MappingInfo*>& mappings =
+        dumper_->mappings();
+    if (mappings.size() == 0) return;
+
+    // This is complicated by the fact that mappings is not in order. It should
+    // be mostly in order, however the mapping that contains the entry point for
+    // the process is always at the front of the vector.
+
+    static const int HBITS = sizeof(size_t) * 8;
+    size_t hole_histogram[HBITS];
+    my_memset(hole_histogram, 0, sizeof(hole_histogram));
+
+    // Find the lowest address mapping.
+    size_t curr = 0;
+    for (size_t i = 1; i < mappings.size(); ++i) {
+      if (mappings[i]->start_addr < mappings[curr]->start_addr) curr = i;
+    }
+
+    uintptr_t lo_addr = mappings[curr]->start_addr;
+
+    size_t hole_cnt = 0;
+    size_t hole_max = 0;
+    size_t hole_sum = 0;
+
+    while (true) {
+      // Skip to the end of an adjacent run of mappings. This is an optimization
+      // for the fact that mappings is mostly sorted.
+      while (curr != mappings.size() - 1 &&
+             MappingsAreAdjacent(*mappings[curr], *mappings[curr + 1])) {
+        ++curr;
+      }
+
+      if (mappings[curr] == stack_mapping) {
+        // Because we can't determine the top of userspace mappable
+        // memory we treat the start of the process stack as the top
+        // of the allocatable address space. Once we reach
+        // |stack_mapping| we are done scanning for free space regions.
+        break;
+      }
+
+      size_t next = NextOrderedMapping(mappings, curr);
+      if (next == std::numeric_limits<size_t>::max())
+        break;
+
+      uintptr_t hole_lo = mappings[curr]->start_addr + mappings[curr]->size;
+      uintptr_t hole_hi = mappings[next]->start_addr;
+
+      if (hole_hi > hole_lo) {
+        size_t hole_sz = hole_hi - hole_lo;
+        hole_sum += hole_sz;
+        hole_max = std::max(hole_sz, hole_max);
+        ++hole_cnt;
+        ++hole_histogram[Log2Floor(hole_sz)];
+      }
+      curr = next;
+    }
+
+    uintptr_t hi_addr = mappings[curr]->start_addr + mappings[curr]->size;
+
+    LogAppend("H ");
+    LogAppend(lo_addr);
+    LogAppend(" ");
+    LogAppend(hi_addr);
+    LogAppend(" ");
+    LogAppend(saturated_cast<uint16_t>(hole_cnt));
+    LogAppend(" ");
+    LogAppend(hole_max);
+    LogAppend(" ");
+    LogAppend(hole_sum);
+    for (unsigned int i = 0; i < HBITS; ++i) {
+      if (!hole_histogram[i]) continue;
+      LogAppend(" ");
+      LogAppend(saturated_cast<uint8_t>(i));
+      LogAppend(":");
+      LogAppend(saturated_cast<uint8_t>(hole_histogram[i]));
+    }
+    LogCommitLine();
+  }
+#endif
+
+  // Write information about the mappings in effect.
+  void DumpMappings() {
+    // First write all the mappings from the dumper
+    for (unsigned i = 0; i < dumper_->mappings().size(); ++i) {
+      const MappingInfo& mapping = *dumper_->mappings()[i];
+      if (mapping.name[0] == 0 ||  // only want modules with filenames.
+          !mapping.exec ||  // only want executable mappings.
+          mapping.size < 4096 || // too small to get a signature for.
+          HaveMappingInfo(mapping)) {
+        continue;
+      }
+
+      DumpModule(mapping, true, i, NULL);
+    }
+    // Next write all the mappings provided by the caller
+    for (MappingList::const_iterator iter = mapping_list_.begin();
+         iter != mapping_list_.end();
+         ++iter) {
+      DumpModule(iter->first, false, 0, iter->second);
+    }
+  }
+
+  void* Alloc(unsigned bytes) { return dumper_->allocator()->Alloc(bytes); }
+
+  const ucontext_t* const ucontext_;
+#if !defined(__ARM_EABI__) && !defined(__mips__)
+  const google_breakpad::fpstate_t* const float_state_;
+#endif
+  LinuxDumper* dumper_;
+  const MappingList& mapping_list_;
+  bool skip_dump_if_principal_mapping_not_referenced_;
+  uintptr_t address_within_principal_mapping_;
+  bool sanitize_stack_;
+  const MicrodumpExtraInfo microdump_extra_info_;
+  char* log_line_;
+
+  // The local copy of crashed process stack memory, beginning at
+  // |stack_lower_bound_|.
+  uint8_t* stack_copy_;
+
+  // The length of crashed process stack copy.
+  size_t stack_len_;
+
+  // The address of the page containing the stack pointer in the
+  // crashed process. |stack_lower_bound_| <= |stack_pointer_|
+  uintptr_t stack_lower_bound_;
+
+  // The stack pointer of the crashed thread.
+  uintptr_t stack_pointer_;
+};
+}  // namespace
+
+namespace google_breakpad {
+
+bool WriteMicrodump(pid_t crashing_process,
+                    const void* blob,
+                    size_t blob_size,
+                    const MappingList& mappings,
+                    bool skip_dump_if_principal_mapping_not_referenced,
+                    uintptr_t address_within_principal_mapping,
+                    bool sanitize_stack,
+                    const MicrodumpExtraInfo& microdump_extra_info) {
+  LinuxPtraceDumper dumper(crashing_process);
+  const ExceptionHandler::CrashContext* context = NULL;
+  if (blob) {
+    if (blob_size != sizeof(ExceptionHandler::CrashContext))
+      return false;
+    context = reinterpret_cast<const ExceptionHandler::CrashContext*>(blob);
+    dumper.SetCrashInfoFromSigInfo(context->siginfo);
+    dumper.set_crash_thread(context->tid);
+  }
+  MicrodumpWriter writer(context, mappings,
+                         skip_dump_if_principal_mapping_not_referenced,
+                         address_within_principal_mapping, sanitize_stack,
+                         microdump_extra_info, &dumper);
+  if (!writer.Init())
+    return false;
+  writer.Dump();
+  return true;
+}
+
+}  // namespace google_breakpad
diff --git a/src/MEGASync/google_breakpad/client/linux/microdump_writer/microdump_writer.h b/src/MEGASync/google_breakpad/client/linux/microdump_writer/microdump_writer.h
new file mode 100644
index 00000000..a1e53df6
--- /dev/null
+++ b/src/MEGASync/google_breakpad/client/linux/microdump_writer/microdump_writer.h
@@ -0,0 +1,68 @@
+// Copyright (c) 2014, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef CLIENT_LINUX_MINIDUMP_WRITER_MICRODUMP_WRITER_H_
+#define CLIENT_LINUX_MINIDUMP_WRITER_MICRODUMP_WRITER_H_
+
+#include <stdint.h>
+#include <sys/types.h>
+
+#include "client/linux/dump_writer_common/mapping_info.h"
+
+namespace google_breakpad {
+
+struct MicrodumpExtraInfo;
+
+// Writes a microdump (a reduced dump containing only the state of the crashing
+// thread) on the console (logcat on Android). These functions do not malloc nor
+// use libc functions which may. Thus, it can be used in contexts where the
+// state of the heap may be corrupt.
+// Args:
+//   crashing_process: the pid of the crashing process. This must be trusted.
+//   blob: a blob of data from the crashing process. See exception_handler.h
+//   blob_size: the length of |blob| in bytes.
+//   mappings: a list of additional mappings provided by the application.
+//   build_fingerprint: a (optional) C string which determines the OS
+//     build fingerprint (e.g., aosp/occam/mako:5.1.1/LMY47W/1234:eng/dev-keys).
+//   product_info: a (optional) C string which determines the product name and
+//     version (e.g., WebView:42.0.2311.136).
+//
+// Returns true iff successful.
+bool WriteMicrodump(pid_t crashing_process,
+                    const void* blob,
+                    size_t blob_size,
+                    const MappingList& mappings,
+                    bool skip_dump_if_main_module_not_referenced,
+                    uintptr_t address_within_main_module,
+                    bool sanitize_stack,
+                    const MicrodumpExtraInfo& microdump_extra_info);
+
+}  // namespace google_breakpad
+
+#endif  // CLIENT_LINUX_MINIDUMP_WRITER_MICRODUMP_WRITER_H_
diff --git a/src/MEGASync/google_breakpad/client/linux/microdump_writer/microdump_writer_unittest.cc b/src/MEGASync/google_breakpad/client/linux/microdump_writer/microdump_writer_unittest.cc
new file mode 100644
index 00000000..6339ac0c
--- /dev/null
+++ b/src/MEGASync/google_breakpad/client/linux/microdump_writer/microdump_writer_unittest.cc
@@ -0,0 +1,421 @@
+// Copyright (c) 2014 Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include <ctype.h>
+#include <sys/syscall.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <ucontext.h>
+
+#include <sstream>
+#include <string>
+
+#include "breakpad_googletest_includes.h"
+#include "client/linux/handler/exception_handler.h"
+#include "client/linux/handler/microdump_extra_info.h"
+#include "client/linux/microdump_writer/microdump_writer.h"
+#include "common/linux/breakpad_getcontext.h"
+#include "common/linux/eintr_wrapper.h"
+#include "common/linux/ignore_ret.h"
+#include "common/scoped_ptr.h"
+#include "common/tests/auto_tempdir.h"
+#include "common/using_std_string.h"
+
+using namespace google_breakpad;
+
+extern "C" {
+extern char __executable_start;
+extern char __etext;
+}
+
+namespace {
+
+typedef testing::Test MicrodumpWriterTest;
+
+MicrodumpExtraInfo MakeMicrodumpExtraInfo(
+    const char* build_fingerprint,
+    const char* product_info,
+    const char* gpu_fingerprint) {
+  MicrodumpExtraInfo info;
+  info.build_fingerprint = build_fingerprint;
+  info.product_info = product_info;
+  info.gpu_fingerprint = gpu_fingerprint;
+  info.process_type = "Browser";
+  return info;
+}
+
+bool ContainsMicrodump(const std::string& buf) {
+  return std::string::npos != buf.find("-----BEGIN BREAKPAD MICRODUMP-----") &&
+         std::string::npos != buf.find("-----END BREAKPAD MICRODUMP-----");
+}
+
+const char kIdentifiableString[] = "_IDENTIFIABLE_";
+const uintptr_t kCrashAddress = 0xdeaddeadu;
+
+void CrashAndGetMicrodump(const MappingList& mappings,
+                          const MicrodumpExtraInfo& microdump_extra_info,
+                          std::string* microdump,
+                          bool skip_dump_if_principal_mapping_not_referenced = false,
+                          uintptr_t address_within_principal_mapping = 0,
+                          bool sanitize_stack = false) {
+  int fds[2];
+  ASSERT_NE(-1, pipe(fds));
+
+  AutoTempDir temp_dir;
+  string stderr_file = temp_dir.path() + "/stderr.log";
+  int err_fd = open(stderr_file.c_str(), O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);
+  ASSERT_NE(-1, err_fd);
+
+  char identifiable_string[sizeof(kIdentifiableString)];
+
+  // This string should not appear in the resulting microdump if it
+  // has been sanitized.
+  strcpy(identifiable_string, kIdentifiableString);
+  // Force the strcpy to not be optimized away.
+  IGNORE_RET(write(STDOUT_FILENO, identifiable_string, 0));
+
+  const pid_t child = fork();
+  if (child == 0) {
+    close(fds[1]);
+    char b;
+    IGNORE_RET(HANDLE_EINTR(read(fds[0], &b, sizeof(b))));
+    close(fds[0]);
+    syscall(__NR_exit);
+  }
+  close(fds[0]);
+
+  ExceptionHandler::CrashContext context;
+  memset(&context, 0, sizeof(context));
+  // Pretend the current context is the child context (which is
+  // approximately right) so that we have a valid stack pointer, and
+  // can fetch child stack data via ptrace.
+  getcontext(&context.context);
+  // Set a non-zero tid to avoid tripping asserts.
+  context.tid = child;
+  context.siginfo.si_signo = MD_EXCEPTION_CODE_LIN_DUMP_REQUESTED;
+  context.siginfo.si_addr = reinterpret_cast<void*>(kCrashAddress);
+
+  // Redirect temporarily stderr to the stderr.log file.
+  int save_err = dup(STDERR_FILENO);
+  ASSERT_NE(-1, save_err);
+  ASSERT_NE(-1, dup2(err_fd, STDERR_FILENO));
+
+  ASSERT_TRUE(WriteMicrodump(child, &context, sizeof(context), mappings,
+                             skip_dump_if_principal_mapping_not_referenced,
+                             address_within_principal_mapping, sanitize_stack,
+                             microdump_extra_info));
+
+  // Revert stderr back to the console.
+  dup2(save_err, STDERR_FILENO);
+  close(save_err);
+
+  // Read back the stderr file and check for the microdump marker.
+  fsync(err_fd);
+  lseek(err_fd, 0, SEEK_SET);
+
+  microdump->clear();
+  char buf[1024];
+
+  while (true) {
+    int bytes_read = IGNORE_EINTR(read(err_fd, buf, 1024));
+    if (bytes_read <= 0) break;
+    microdump->append(buf, buf + bytes_read);
+  }
+  close(err_fd);
+  close(fds[1]);
+}
+
+void ExtractMicrodumpStackContents(const string& microdump_content,
+                                   string* result) {
+  std::istringstream iss(microdump_content);
+  result->clear();
+  for (string line; std::getline(iss, line);) {
+    if (line.find("S ") == 0) {
+      std::istringstream stack_data(line);
+      std::string key;
+      std::string addr;
+      std::string data;
+      stack_data >> key >> addr >> data;
+      EXPECT_TRUE((data.size() & 1u) == 0u);
+      result->reserve(result->size() + data.size() / 2);
+      for (size_t i = 0; i < data.size(); i += 2) {
+        std::string byte = data.substr(i, 2);
+        result->push_back(static_cast<char>(strtoul(byte.c_str(), NULL, 16)));
+      }
+    }
+  }
+}
+
+void CheckMicrodumpContents(const string& microdump_content,
+                            const MicrodumpExtraInfo& expected_info) {
+  std::istringstream iss(microdump_content);
+  bool did_find_os_info = false;
+  bool did_find_product_info = false;
+  bool did_find_process_type = false;
+  bool did_find_crash_reason = false;
+  bool did_find_gpu_info = false;
+  for (string line; std::getline(iss, line);) {
+    if (line.find("O ") == 0) {
+      std::istringstream os_info_tokens(line);
+      string token;
+      os_info_tokens.ignore(2); // Ignore the "O " preamble.
+      // Check the OS descriptor char (L=Linux, A=Android).
+      os_info_tokens >> token;
+      ASSERT_TRUE(token == "L" || token == "A");
+
+      os_info_tokens >> token; // HW architecture.
+      os_info_tokens >> token; // Number of cpus.
+      for (size_t i = 0; i < token.size(); ++i)
+        ASSERT_TRUE(isxdigit(token[i]));
+      os_info_tokens >> token; // SW architecture.
+
+      // Check that the build fingerprint is in the right place.
+      os_info_tokens >> token;
+      ASSERT_FALSE(os_info_tokens.fail());
+      if (expected_info.build_fingerprint)
+        ASSERT_EQ(expected_info.build_fingerprint, token);
+      did_find_os_info = true;
+    } else if (line.find("P ") == 0) {
+      if (expected_info.process_type)
+        ASSERT_EQ(string("P ") + expected_info.process_type, line);
+      did_find_process_type = true;
+    } else if (line.find("R ") == 0) {
+      std::istringstream crash_reason_tokens(line);
+      string token;
+      unsigned crash_reason;
+      string crash_reason_str;
+      uintptr_t crash_address;
+      crash_reason_tokens.ignore(2); // Ignore the "R " preamble.
+      crash_reason_tokens >> std::hex >> crash_reason >> crash_reason_str >>
+          crash_address;
+      ASSERT_FALSE(crash_reason_tokens.fail());
+      ASSERT_EQ(MD_EXCEPTION_CODE_LIN_DUMP_REQUESTED, crash_reason);
+      ASSERT_EQ("DUMP_REQUESTED", crash_reason_str);
+      ASSERT_EQ(kCrashAddress, crash_address);
+      did_find_crash_reason = true;
+    } else if (line.find("V ") == 0) {
+      if (expected_info.product_info)
+        ASSERT_EQ(string("V ") + expected_info.product_info, line);
+      did_find_product_info = true;
+    } else if (line.find("G ") == 0) {
+      if (expected_info.gpu_fingerprint)
+        ASSERT_EQ(string("G ") + expected_info.gpu_fingerprint, line);
+      did_find_gpu_info = true;
+    }
+  }
+  ASSERT_TRUE(did_find_os_info);
+  ASSERT_TRUE(did_find_product_info);
+  ASSERT_TRUE(did_find_process_type);
+  ASSERT_TRUE(did_find_crash_reason);
+  ASSERT_TRUE(did_find_gpu_info);
+}
+
+bool MicrodumpStackContains(const string& microdump_content,
+                            const string& expected_content) {
+  string result;
+  ExtractMicrodumpStackContents(microdump_content, &result);
+  return result.find(kIdentifiableString) != string::npos;
+}
+
+void CheckMicrodumpContents(const string& microdump_content,
+                            const string& expected_fingerprint,
+                            const string& expected_product_info,
+                            const string& expected_gpu_fingerprint) {
+  CheckMicrodumpContents(
+      microdump_content,
+      MakeMicrodumpExtraInfo(expected_fingerprint.c_str(),
+                             expected_product_info.c_str(),
+                             expected_gpu_fingerprint.c_str()));
+}
+
+TEST(MicrodumpWriterTest, BasicWithMappings) {
+  // Push some extra mapping to check the MappingList logic.
+  const uint32_t memory_size = sysconf(_SC_PAGESIZE);
+  const char* kMemoryName = "libfoo.so";
+  const uint8_t kModuleGUID[sizeof(MDGUID)] = {
+     0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
+     0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF
+  };
+
+  MappingInfo info;
+  info.start_addr = memory_size;
+  info.size = memory_size;
+  info.offset = 42;
+  strcpy(info.name, kMemoryName);
+
+  MappingList mappings;
+  MappingEntry mapping;
+  mapping.first = info;
+  memcpy(mapping.second, kModuleGUID, sizeof(MDGUID));
+  mappings.push_back(mapping);
+
+  std::string buf;
+  CrashAndGetMicrodump(mappings, MicrodumpExtraInfo(), &buf);
+  ASSERT_TRUE(ContainsMicrodump(buf));
+
+#ifdef __LP64__
+  ASSERT_NE(std::string::npos,
+            buf.find("M 0000000000001000 000000000000002A 0000000000001000 "
+                     "33221100554477668899AABBCCDDEEFF0 libfoo.so"));
+#else
+  ASSERT_NE(std::string::npos,
+            buf.find("M 00001000 0000002A 00001000 "
+                     "33221100554477668899AABBCCDDEEFF0 libfoo.so"));
+#endif
+
+  // In absence of a product info in the minidump, the writer should just write
+  // an unknown marker.
+  ASSERT_NE(std::string::npos, buf.find("V UNKNOWN:0.0.0.0"));
+}
+
+// Ensure that no output occurs if the interest region is set, but
+// doesn't overlap anything on the stack.
+TEST(MicrodumpWriterTest, NoOutputIfUninteresting) {
+  const char kProductInfo[] = "MockProduct:42.0.2311.99";
+  const char kBuildFingerprint[] =
+      "aosp/occam/mako:5.1.1/LMY47W/12345678:userdegbug/dev-keys";
+  const char kGPUFingerprint[] =
+      "Qualcomm;Adreno (TM) 330;OpenGL ES 3.0 V@104.0 AU@  (GIT@Id3510ff6dc)";
+  const MicrodumpExtraInfo kMicrodumpExtraInfo(
+      MakeMicrodumpExtraInfo(kBuildFingerprint, kProductInfo, kGPUFingerprint));
+
+  std::string buf;
+  MappingList no_mappings;
+
+  CrashAndGetMicrodump(no_mappings, kMicrodumpExtraInfo, &buf, true, 0);
+  ASSERT_FALSE(ContainsMicrodump(buf));
+}
+
+// Ensure that stack content does not contain an identifiable string if the
+// stack is sanitized.
+TEST(MicrodumpWriterTest, StringRemovedBySanitization) {
+  const char kProductInfo[] = "MockProduct:42.0.2311.99";
+  const char kBuildFingerprint[] =
+      "aosp/occam/mako:5.1.1/LMY47W/12345678:userdegbug/dev-keys";
+  const char kGPUFingerprint[] =
+      "Qualcomm;Adreno (TM) 330;OpenGL ES 3.0 V@104.0 AU@  (GIT@Id3510ff6dc)";
+
+  const MicrodumpExtraInfo kMicrodumpExtraInfo(
+      MakeMicrodumpExtraInfo(kBuildFingerprint, kProductInfo, kGPUFingerprint));
+
+  std::string buf;
+  MappingList no_mappings;
+
+  CrashAndGetMicrodump(no_mappings, kMicrodumpExtraInfo, &buf, false, 0u, true);
+  ASSERT_TRUE(ContainsMicrodump(buf));
+  ASSERT_FALSE(MicrodumpStackContains(buf, kIdentifiableString));
+}
+
+// Ensure that stack content does contain an identifiable string if the
+// stack is not sanitized.
+TEST(MicrodumpWriterTest, StringPresentIfNotSanitized) {
+  const char kProductInfo[] = "MockProduct:42.0.2311.99";
+  const char kBuildFingerprint[] =
+      "aosp/occam/mako:5.1.1/LMY47W/12345678:userdegbug/dev-keys";
+  const char kGPUFingerprint[] =
+      "Qualcomm;Adreno (TM) 330;OpenGL ES 3.0 V@104.0 AU@  (GIT@Id3510ff6dc)";
+
+  const MicrodumpExtraInfo kMicrodumpExtraInfo(
+      MakeMicrodumpExtraInfo(kBuildFingerprint, kProductInfo, kGPUFingerprint));
+
+  std::string buf;
+  MappingList no_mappings;
+
+  CrashAndGetMicrodump(no_mappings, kMicrodumpExtraInfo, &buf, false, 0u, false);
+  ASSERT_TRUE(ContainsMicrodump(buf));
+  ASSERT_TRUE(MicrodumpStackContains(buf, kIdentifiableString));
+}
+
+// Ensure that output occurs if the interest region is set, and
+// does overlap something on the stack.
+TEST(MicrodumpWriterTest, OutputIfInteresting) {
+  const char kProductInfo[] = "MockProduct:42.0.2311.99";
+  const char kBuildFingerprint[] =
+      "aosp/occam/mako:5.1.1/LMY47W/12345678:userdegbug/dev-keys";
+  const char kGPUFingerprint[] =
+      "Qualcomm;Adreno (TM) 330;OpenGL ES 3.0 V@104.0 AU@  (GIT@Id3510ff6dc)";
+
+  const MicrodumpExtraInfo kMicrodumpExtraInfo(
+      MakeMicrodumpExtraInfo(kBuildFingerprint, kProductInfo, kGPUFingerprint));
+
+  std::string buf;
+  MappingList no_mappings;
+
+  CrashAndGetMicrodump(no_mappings, kMicrodumpExtraInfo, &buf, true,
+                       reinterpret_cast<uintptr_t>(CrashAndGetMicrodump));
+  ASSERT_TRUE(ContainsMicrodump(buf));
+}
+
+// Ensure that the product info and build fingerprint metadata show up in the
+// final microdump if present.
+TEST(MicrodumpWriterTest, BuildFingerprintAndProductInfo) {
+  const char kProductInfo[] = "MockProduct:42.0.2311.99";
+  const char kBuildFingerprint[] =
+      "aosp/occam/mako:5.1.1/LMY47W/12345678:userdegbug/dev-keys";
+  const char kGPUFingerprint[] =
+      "Qualcomm;Adreno (TM) 330;OpenGL ES 3.0 V@104.0 AU@  (GIT@Id3510ff6dc)";
+  const MicrodumpExtraInfo kMicrodumpExtraInfo(
+      MakeMicrodumpExtraInfo(kBuildFingerprint, kProductInfo, kGPUFingerprint));
+  std::string buf;
+  MappingList no_mappings;
+
+  CrashAndGetMicrodump(no_mappings, kMicrodumpExtraInfo, &buf);
+  ASSERT_TRUE(ContainsMicrodump(buf));
+  CheckMicrodumpContents(buf, kMicrodumpExtraInfo);
+}
+
+TEST(MicrodumpWriterTest, NoProductInfo) {
+  const char kBuildFingerprint[] = "foobar";
+  const char kGPUFingerprint[] = "bazqux";
+  std::string buf;
+  MappingList no_mappings;
+
+  const MicrodumpExtraInfo kMicrodumpExtraInfoNoProductInfo(
+      MakeMicrodumpExtraInfo(kBuildFingerprint, NULL, kGPUFingerprint));
+
+  CrashAndGetMicrodump(no_mappings, kMicrodumpExtraInfoNoProductInfo, &buf);
+  ASSERT_TRUE(ContainsMicrodump(buf));
+  CheckMicrodumpContents(buf, kBuildFingerprint, "UNKNOWN:0.0.0.0",
+                         kGPUFingerprint);
+}
+
+TEST(MicrodumpWriterTest, NoGPUInfo) {
+  const char kProductInfo[] = "bazqux";
+  const char kBuildFingerprint[] = "foobar";
+  std::string buf;
+  MappingList no_mappings;
+
+  const MicrodumpExtraInfo kMicrodumpExtraInfoNoGPUInfo(
+      MakeMicrodumpExtraInfo(kBuildFingerprint, kProductInfo, NULL));
+
+  CrashAndGetMicrodump(no_mappings, kMicrodumpExtraInfoNoGPUInfo, &buf);
+  ASSERT_TRUE(ContainsMicrodump(buf));
+  CheckMicrodumpContents(buf, kBuildFingerprint, kProductInfo, "UNKNOWN");
+}
+}  // namespace
diff --git a/src/MEGASync/google_breakpad/client/linux/minidump_writer/directory_reader_unittest.cc b/src/MEGASync/google_breakpad/client/linux/minidump_writer/directory_reader_unittest.cc
index 326f9e36..7292a636 100644
--- a/src/MEGASync/google_breakpad/client/linux/minidump_writer/directory_reader_unittest.cc
+++ b/src/MEGASync/google_breakpad/client/linux/minidump_writer/directory_reader_unittest.cc
@@ -47,7 +47,7 @@ typedef testing::Test DirectoryReaderTest;
 TEST(DirectoryReaderTest, CompareResults) {
   std::set<string> dent_set;
 
-  DIR *const dir = opendir("/proc/self");
+  DIR* const dir = opendir("/proc/self");
   ASSERT_TRUE(dir != NULL);
 
   struct dirent* dent;
diff --git a/src/MEGASync/google_breakpad/client/linux/minidump_writer/line_reader.h b/src/MEGASync/google_breakpad/client/linux/minidump_writer/line_reader.h
index 779cfeb6..9fc4b7cc 100644
--- a/src/MEGASync/google_breakpad/client/linux/minidump_writer/line_reader.h
+++ b/src/MEGASync/google_breakpad/client/linux/minidump_writer/line_reader.h
@@ -61,7 +61,7 @@ class LineReader {
   //
   // One must call |PopLine| after this function, otherwise you'll continue to
   // get the same line over and over.
-  bool GetNextLine(const char **line, unsigned *len) {
+  bool GetNextLine(const char** line, unsigned* len) {
     for (;;) {
       if (buf_used_ == 0 && hit_eof_)
         return false;
diff --git a/src/MEGASync/google_breakpad/client/linux/minidump_writer/line_reader_unittest.cc b/src/MEGASync/google_breakpad/client/linux/minidump_writer/line_reader_unittest.cc
index 29686f04..e1ac445a 100644
--- a/src/MEGASync/google_breakpad/client/linux/minidump_writer/line_reader_unittest.cc
+++ b/src/MEGASync/google_breakpad/client/linux/minidump_writer/line_reader_unittest.cc
@@ -59,7 +59,7 @@ TEST(LineReaderTest, EmptyFile) {
   ASSERT_TRUE(file.IsOk());
   LineReader reader(file.GetFd());
 
-  const char *line;
+  const char* line;
   unsigned len;
   ASSERT_FALSE(reader.GetNextLine(&line, &len));
 }
@@ -69,7 +69,7 @@ TEST(LineReaderTest, OneLineTerminated) {
   ASSERT_TRUE(file.IsOk());
   LineReader reader(file.GetFd());
 
-  const char *line;
+  const char* line;
   unsigned int len;
   ASSERT_TRUE(reader.GetNextLine(&line, &len));
   ASSERT_EQ((unsigned int)1, len);
@@ -85,7 +85,7 @@ TEST(LineReaderTest, OneLine) {
   ASSERT_TRUE(file.IsOk());
   LineReader reader(file.GetFd());
 
-  const char *line;
+  const char* line;
   unsigned len;
   ASSERT_TRUE(reader.GetNextLine(&line, &len));
   ASSERT_EQ((unsigned)1, len);
@@ -101,7 +101,7 @@ TEST(LineReaderTest, TwoLinesTerminated) {
   ASSERT_TRUE(file.IsOk());
   LineReader reader(file.GetFd());
 
-  const char *line;
+  const char* line;
   unsigned len;
   ASSERT_TRUE(reader.GetNextLine(&line, &len));
   ASSERT_EQ((unsigned)1, len);
@@ -123,7 +123,7 @@ TEST(LineReaderTest, TwoLines) {
   ASSERT_TRUE(file.IsOk());
   LineReader reader(file.GetFd());
 
-  const char *line;
+  const char* line;
   unsigned len;
   ASSERT_TRUE(reader.GetNextLine(&line, &len));
   ASSERT_EQ((unsigned)1, len);
@@ -147,7 +147,7 @@ TEST(LineReaderTest, MaxLength) {
   ASSERT_TRUE(file.IsOk());
   LineReader reader(file.GetFd());
 
-  const char *line;
+  const char* line;
   unsigned len;
   ASSERT_TRUE(reader.GetNextLine(&line, &len));
   ASSERT_EQ(sizeof(l), len);
@@ -163,7 +163,7 @@ TEST(LineReaderTest, TooLong) {
   ASSERT_TRUE(file.IsOk());
   LineReader reader(file.GetFd());
 
-  const char *line;
+  const char* line;
   unsigned len;
   ASSERT_FALSE(reader.GetNextLine(&line, &len));
 }
diff --git a/src/MEGASync/google_breakpad/client/linux/minidump_writer/linux_core_dumper.cc b/src/MEGASync/google_breakpad/client/linux/minidump_writer/linux_core_dumper.cc
index f5b19d10..41506898 100644
--- a/src/MEGASync/google_breakpad/client/linux/minidump_writer/linux_core_dumper.cc
+++ b/src/MEGASync/google_breakpad/client/linux/minidump_writer/linux_core_dumper.cc
@@ -38,15 +38,21 @@
 #include <stdio.h>
 #include <string.h>
 #include <sys/procfs.h>
+#if defined(__mips__) && defined(__ANDROID__)
+// To get register definitions.
+#include <asm/reg.h>
+#endif
 
+#include "common/linux/elf_gnu_compat.h"
 #include "common/linux/linux_libc_support.h"
 
 namespace google_breakpad {
 
 LinuxCoreDumper::LinuxCoreDumper(pid_t pid,
                                  const char* core_path,
-                                 const char* procfs_path)
-    : LinuxDumper(pid),
+                                 const char* procfs_path,
+                                 const char* root_prefix)
+    : LinuxDumper(pid, root_prefix),
       core_path_(core_path),
       procfs_path_(procfs_path),
       thread_infos_(&allocator_, 8) {
@@ -74,7 +80,7 @@ bool LinuxCoreDumper::BuildProcPath(char* path, pid_t pid,
   return true;
 }
 
-void LinuxCoreDumper::CopyFromProcess(void* dest, pid_t child,
+bool LinuxCoreDumper::CopyFromProcess(void* dest, pid_t child,
                                       const void* src, size_t length) {
   ElfCoreDump::Addr virtual_address = reinterpret_cast<ElfCoreDump::Addr>(src);
   // TODO(benchan): Investigate whether the data to be copied could span
@@ -84,7 +90,9 @@ void LinuxCoreDumper::CopyFromProcess(void* dest, pid_t child,
     // If the data segment is not found in the core dump, fill the result
     // with marker characters.
     memset(dest, 0xab, length);
+    return false;
   }
+  return true;
 }
 
 bool LinuxCoreDumper::GetThreadInfoByIndex(size_t index, ThreadInfo* info) {
@@ -99,9 +107,11 @@ bool LinuxCoreDumper::GetThreadInfoByIndex(size_t index, ThreadInfo* info) {
   memcpy(&stack_pointer, &info->regs.rsp, sizeof(info->regs.rsp));
 #elif defined(__ARM_EABI__)
   memcpy(&stack_pointer, &info->regs.ARM_sp, sizeof(info->regs.ARM_sp));
+#elif defined(__aarch64__)
+  memcpy(&stack_pointer, &info->regs.sp, sizeof(info->regs.sp));
 #elif defined(__mips__)
-  stack_pointer = 
-      reinterpret_cast<uint8_t*>(info->regs.regs[MD_CONTEXT_MIPS_REG_SP]);
+  stack_pointer =
+      reinterpret_cast<uint8_t*>(info->mcontext.gregs[MD_CONTEXT_MIPS_REG_SP]);
 #else
 #error "This code hasn't been ported to your platform yet."
 #endif
@@ -122,7 +132,7 @@ bool LinuxCoreDumper::ThreadsResume() {
 }
 
 bool LinuxCoreDumper::EnumerateThreads() {
-  if (!mapped_core_file_.Map(core_path_)) {
+  if (!mapped_core_file_.Map(core_path_, 0)) {
     fprintf(stderr, "Could not map core dump file into memory\n");
     return false;
   }
@@ -156,6 +166,7 @@ bool LinuxCoreDumper::EnumerateThreads() {
     //   -------------------------------------------------------------------
     //   1st thread       CORE          NT_PRSTATUS
     //   process-wide     CORE          NT_PRPSINFO
+    //   process-wide     CORE          NT_SIGINFO
     //   process-wide     CORE          NT_AUXV
     //   1st thread       CORE          NT_FPREGSET
     //   1st thread       LINUX         NT_PRXFPREG
@@ -186,16 +197,71 @@ bool LinuxCoreDumper::EnumerateThreads() {
         memset(&info, 0, sizeof(ThreadInfo));
         info.tgid = status->pr_pgrp;
         info.ppid = status->pr_ppid;
+#if defined(__mips__)
+#if defined(__ANDROID__)
+        for (int i = EF_R0; i <= EF_R31; i++)
+          info.mcontext.gregs[i - EF_R0] = status->pr_reg[i];
+#else  // __ANDROID__
+        for (int i = EF_REG0; i <= EF_REG31; i++)
+          info.mcontext.gregs[i - EF_REG0] = status->pr_reg[i];
+#endif  // __ANDROID__
+        info.mcontext.mdlo = status->pr_reg[EF_LO];
+        info.mcontext.mdhi = status->pr_reg[EF_HI];
+        info.mcontext.pc = status->pr_reg[EF_CP0_EPC];
+#else  // __mips__
         memcpy(&info.regs, status->pr_reg, sizeof(info.regs));
+#endif  // __mips__
         if (first_thread) {
           crash_thread_ = pid;
           crash_signal_ = status->pr_info.si_signo;
+          crash_signal_code_ = status->pr_info.si_code;
         }
         first_thread = false;
         threads_.push_back(pid);
         thread_infos_.push_back(info);
         break;
       }
+      case NT_SIGINFO: {
+        if (description.length() != sizeof(siginfo_t)) {
+          fprintf(stderr, "Found NT_SIGINFO descriptor of unexpected size\n");
+          return false;
+        }
+
+        const siginfo_t* info =
+            reinterpret_cast<const siginfo_t*>(description.data());
+
+        // Set crash_address when si_addr is valid for the signal.
+        switch (info->si_signo) {
+          case MD_EXCEPTION_CODE_LIN_SIGBUS:
+          case MD_EXCEPTION_CODE_LIN_SIGFPE:
+          case MD_EXCEPTION_CODE_LIN_SIGILL:
+          case MD_EXCEPTION_CODE_LIN_SIGSEGV:
+          case MD_EXCEPTION_CODE_LIN_SIGSYS:
+          case MD_EXCEPTION_CODE_LIN_SIGTRAP:
+            crash_address_ = reinterpret_cast<uintptr_t>(info->si_addr);
+            break;
+        }
+
+        // Set crash_exception_info for common signals.  Since exception info is
+        // unsigned, but some of these fields might be signed, we always cast.
+        switch (info->si_signo) {
+          case MD_EXCEPTION_CODE_LIN_SIGKILL:
+            set_crash_exception_info({
+              static_cast<uint64_t>(info->si_pid),
+              static_cast<uint64_t>(info->si_uid),
+            });
+            break;
+          case MD_EXCEPTION_CODE_LIN_SIGSYS:
+#ifdef si_syscall
+            set_crash_exception_info({
+              static_cast<uint64_t>(info->si_syscall),
+              static_cast<uint64_t>(info->si_arch),
+            });
+#endif
+            break;
+        }
+        break;
+      }
 #if defined(__i386) || defined(__x86_64)
       case NT_FPREGSET: {
         if (thread_infos_.empty())
diff --git a/src/MEGASync/google_breakpad/client/linux/minidump_writer/linux_core_dumper.h b/src/MEGASync/google_breakpad/client/linux/minidump_writer/linux_core_dumper.h
index edb9e738..8a7c924b 100644
--- a/src/MEGASync/google_breakpad/client/linux/minidump_writer/linux_core_dumper.h
+++ b/src/MEGASync/google_breakpad/client/linux/minidump_writer/linux_core_dumper.h
@@ -47,7 +47,9 @@ class LinuxCoreDumper : public LinuxDumper {
   // its proc files at |procfs_path|. If |procfs_path| is a copy of
   // /proc/<pid>, it should contain the following files:
   //     auxv, cmdline, environ, exe, maps, status
-  LinuxCoreDumper(pid_t pid, const char* core_path, const char* procfs_path);
+  // See LinuxDumper for the purpose of |root_prefix|.
+  LinuxCoreDumper(pid_t pid, const char* core_path, const char* procfs_path,
+                  const char* root_prefix = "");
 
   // Implements LinuxDumper::BuildProcPath().
   // Builds a proc path for a certain pid for a node (/proc/<pid>/<node>).
@@ -68,8 +70,9 @@ class LinuxCoreDumper : public LinuxDumper {
   // Copies content of |length| bytes from a given process |child|,
   // starting from |src|, into |dest|. This method extracts the content
   // the core dump and fills |dest| with a sequence of marker bytes
-  // if the expected data is not found in the core dump.
-  virtual void CopyFromProcess(void* dest, pid_t child, const void* src,
+  // if the expected data is not found in the core dump. Returns true if
+  // the expected data is found in the core dump.
+  virtual bool CopyFromProcess(void* dest, pid_t child, const void* src,
                                size_t length);
 
   // Implements LinuxDumper::GetThreadInfoByIndex().
diff --git a/src/MEGASync/google_breakpad/client/linux/minidump_writer/linux_core_dumper_unittest.cc b/src/MEGASync/google_breakpad/client/linux/minidump_writer/linux_core_dumper_unittest.cc
index 7aef4c0d..77448031 100644
--- a/src/MEGASync/google_breakpad/client/linux/minidump_writer/linux_core_dumper_unittest.cc
+++ b/src/MEGASync/google_breakpad/client/linux/minidump_writer/linux_core_dumper_unittest.cc
@@ -39,6 +39,16 @@
 
 using namespace google_breakpad;
 
+TEST(LinuxCoreDumperTest, GetMappingAbsolutePath) {
+  const LinuxCoreDumper dumper(getpid(), "core", "/tmp", "/mnt/root");
+  const MappingInfo mapping = {0, 0, {0, 0}, 0, false, "/usr/lib/libc.so"};
+
+  char path[PATH_MAX];
+  dumper.GetMappingAbsolutePath(mapping, path);
+
+  EXPECT_STREQ("/mnt/root/usr/lib/libc.so", path);
+}
+
 TEST(LinuxCoreDumperTest, BuildProcPath) {
   const pid_t pid = getpid();
   const char procfs_path[] = "/procfs_copy";
@@ -74,18 +84,23 @@ TEST(LinuxCoreDumperTest, VerifyDumpWithMultipleThreads) {
   const unsigned kCrashThread = 1;
   const int kCrashSignal = SIGABRT;
   pid_t child_pid;
-  // TODO(benchan): Revert to use ASSERT_TRUE once the flakiness in
-  // CrashGenerator is identified and fixed.
-  if (!crash_generator.CreateChildCrash(kNumOfThreads, kCrashThread,
-                                        kCrashSignal, &child_pid)) {
-    fprintf(stderr, "LinuxCoreDumperTest.VerifyDumpWithMultipleThreads test "
-            "is skipped due to no core dump generated\n");
-    return;
-  }
+  ASSERT_TRUE(crash_generator.CreateChildCrash(kNumOfThreads, kCrashThread,
+                                               kCrashSignal, &child_pid));
 
   const string core_file = crash_generator.GetCoreFilePath();
   const string procfs_path = crash_generator.GetDirectoryOfProcFilesCopy();
+
+#if defined(__ANDROID__)
+  struct stat st;
+  if (stat(core_file.c_str(), &st) != 0) {
+    fprintf(stderr, "LinuxCoreDumperTest.VerifyDumpWithMultipleThreads test is "
+            "skipped due to no core file being generated\n");
+    return;
+  }
+#endif
+
   LinuxCoreDumper dumper(child_pid, core_file.c_str(), procfs_path.c_str());
+
   EXPECT_TRUE(dumper.Init());
 
   EXPECT_TRUE(dumper.IsPostMortem());
@@ -94,14 +109,18 @@ TEST(LinuxCoreDumperTest, VerifyDumpWithMultipleThreads) {
   EXPECT_TRUE(dumper.ThreadsSuspend());
   EXPECT_TRUE(dumper.ThreadsResume());
 
-  // LinuxCoreDumper cannot determine the crash address and thus it always
+  // Linux does not set the crash address with SIGABRT, so make sure it always
   // sets the crash address to 0.
   EXPECT_EQ(0U, dumper.crash_address());
   EXPECT_EQ(kCrashSignal, dumper.crash_signal());
   EXPECT_EQ(crash_generator.GetThreadId(kCrashThread),
             dumper.crash_thread());
 
-  EXPECT_EQ(kNumOfThreads, dumper.threads().size());
+#if defined(THREAD_SANITIZER)
+  EXPECT_GE(dumper.threads().size(), kNumOfThreads);
+#else
+  EXPECT_EQ(dumper.threads().size(), kNumOfThreads);
+#endif
   for (unsigned i = 0; i < kNumOfThreads; ++i) {
     ThreadInfo info;
     EXPECT_TRUE(dumper.GetThreadInfoByIndex(i, &info));
@@ -111,3 +130,63 @@ TEST(LinuxCoreDumperTest, VerifyDumpWithMultipleThreads) {
     EXPECT_EQ(getpid(), info.ppid);
   }
 }
+
+TEST(LinuxCoreDumperTest, VerifyExceptionDetails) {
+  CrashGenerator crash_generator;
+  if (!crash_generator.HasDefaultCorePattern()) {
+    fprintf(stderr, "LinuxCoreDumperTest.VerifyDumpWithMultipleThreads test "
+            "is skipped due to non-default core pattern\n");
+    return;
+  }
+
+#ifndef si_syscall
+  fprintf(stderr, "LinuxCoreDumperTest.VerifyDumpWithMultipleThreads test is "
+          "skipped due to old kernel/C library headers\n");
+  return;
+#endif
+
+  const unsigned kNumOfThreads = 2;
+  const unsigned kCrashThread = 1;
+  const int kCrashSignal = SIGSYS;
+  pid_t child_pid;
+  ASSERT_TRUE(crash_generator.CreateChildCrash(kNumOfThreads, kCrashThread,
+                                               kCrashSignal, &child_pid));
+
+  const string core_file = crash_generator.GetCoreFilePath();
+  const string procfs_path = crash_generator.GetDirectoryOfProcFilesCopy();
+
+#if defined(__ANDROID__)
+  struct stat st;
+  if (stat(core_file.c_str(), &st) != 0) {
+    fprintf(stderr, "LinuxCoreDumperTest.VerifyExceptionDetails test is "
+            "skipped due to no core file being generated\n");
+    return;
+  }
+#endif
+
+  LinuxCoreDumper dumper(child_pid, core_file.c_str(), procfs_path.c_str());
+
+  EXPECT_TRUE(dumper.Init());
+
+  EXPECT_TRUE(dumper.IsPostMortem());
+
+#if defined(__ANDROID__)
+  // TODO: For some reason, Android doesn't seem to pass this.
+  if (!dumper.crash_address()) {
+    fprintf(stderr, "LinuxCoreDumperTest.VerifyExceptionDetails test is "
+            "skipped due to missing signal details on Android\n");
+    return;
+  }
+#endif
+
+  // Check the exception details.
+  EXPECT_NE(0U, dumper.crash_address());
+  EXPECT_EQ(kCrashSignal, dumper.crash_signal());
+  EXPECT_EQ(crash_generator.GetThreadId(kCrashThread),
+            dumper.crash_thread());
+
+  // We check the length, but not the actual fields.  We sent SIGSYS ourselves
+  // instead of the kernel, so the extended fields are garbage.
+  const std::vector<uint64_t> info(dumper.crash_exception_info());
+  EXPECT_EQ(2U, info.size());
+}
diff --git a/src/MEGASync/google_breakpad/client/linux/minidump_writer/linux_dumper.cc b/src/MEGASync/google_breakpad/client/linux/minidump_writer/linux_dumper.cc
index e09da916..7fd6532a 100644
--- a/src/MEGASync/google_breakpad/client/linux/minidump_writer/linux_dumper.cc
+++ b/src/MEGASync/google_breakpad/client/linux/minidump_writer/linux_dumper.cc
@@ -38,18 +38,37 @@
 #include "client/linux/minidump_writer/linux_dumper.h"
 
 #include <assert.h>
+#include <elf.h>
 #include <fcntl.h>
 #include <limits.h>
 #include <stddef.h>
 #include <string.h>
 
 #include "client/linux/minidump_writer/line_reader.h"
+#include "common/linux/elfutils.h"
 #include "common/linux/file_id.h"
 #include "common/linux/linux_libc_support.h"
 #include "common/linux/memory_mapped_file.h"
 #include "common/linux/safe_readlink.h"
+#include "google_breakpad/common/minidump_exception_linux.h"
 #include "third_party/lss/linux_syscall_support.h"
 
+#if defined(__ANDROID__)
+
+// Android packed relocations definitions are not yet available from the
+// NDK header files, so we have to provide them manually here.
+#ifndef DT_LOOS
+#define DT_LOOS 0x6000000d
+#endif
+#ifndef DT_ANDROID_REL
+static const int DT_ANDROID_REL = DT_LOOS + 2;
+#endif
+#ifndef DT_ANDROID_RELA
+static const int DT_ANDROID_RELA = DT_LOOS + 4;
+#endif
+
+#endif  // __ANDROID __
+
 static const char kMappedFileUnsafePrefix[] = "/dev/";
 static const char kDeletedSuffix[] = " (deleted)";
 
@@ -66,17 +85,210 @@ inline static bool IsMappedFileOpenUnsafe(
 
 namespace google_breakpad {
 
+namespace {
+
+bool MappingContainsAddress(const MappingInfo& mapping, uintptr_t address) {
+  return mapping.system_mapping_info.start_addr <= address &&
+         address < mapping.system_mapping_info.end_addr;
+}
+
+#if defined(__CHROMEOS__)
+
+// Recover memory mappings before writing dump on ChromeOS
+//
+// On Linux, breakpad relies on /proc/[pid]/maps to associate symbols from
+// addresses. ChromeOS' hugepage implementation replaces some segments with
+// anonymous private pages, which is a restriction of current implementation
+// in Linux kernel at the time of writing. Thus, breakpad can no longer
+// symbolize addresses from those text segments replaced with hugepages.
+//
+// This postprocess tries to recover the mappings. Because hugepages are always
+// inserted in between some .text sections, it tries to infer the names and
+// offsets of the segments, by looking at segments immediately precede and
+// succeed them.
+//
+// For example, a text segment before hugepage optimization
+//   02001000-03002000 r-xp /opt/google/chrome/chrome
+//
+// can be broken into
+//   02001000-02200000 r-xp /opt/google/chrome/chrome
+//   02200000-03000000 r-xp
+//   03000000-03002000 r-xp /opt/google/chrome/chrome
+//
+// For more details, see:
+// crbug.com/628040 ChromeOS' use of hugepages confuses crash symbolization
+
+// Copied from CrOS' hugepage implementation, which is unlikely to change.
+// The hugepage size is 2M.
+const unsigned int kHpageShift = 21;
+const size_t kHpageSize = (1 << kHpageShift);
+const size_t kHpageMask = (~(kHpageSize - 1));
+
+// Find and merge anonymous r-xp segments with surrounding named segments.
+// There are two cases:
+
+// Case 1: curr, next
+//   curr is anonymous
+//   curr is r-xp
+//   curr.size >= 2M
+//   curr.size is a multiple of 2M.
+//   next is backed by some file.
+//   curr and next are contiguous.
+//   offset(next) == sizeof(curr)
+void TryRecoverMappings(MappingInfo* curr, MappingInfo* next) {
+  // Merged segments are marked with size = 0.
+  if (curr->size == 0 || next->size == 0)
+    return;
+
+  if (curr->size >= kHpageSize &&
+      curr->exec &&
+      (curr->size & kHpageMask) == curr->size &&
+      (curr->start_addr & kHpageMask) == curr->start_addr &&
+      curr->name[0] == '\0' &&
+      next->name[0] != '\0' &&
+      curr->start_addr + curr->size == next->start_addr &&
+      curr->size == next->offset) {
+
+    // matched
+    my_strlcpy(curr->name, next->name, NAME_MAX);
+    if (next->exec) {
+      // (curr, next)
+      curr->size += next->size;
+      next->size = 0;
+    }
+  }
+}
+
+// Case 2: prev, curr, next
+//   curr is anonymous
+//   curr is r-xp
+//   curr.size >= 2M
+//   curr.size is a multiple of 2M.
+//   next and prev are backed by the same file.
+//   prev, curr and next are contiguous.
+//   offset(next) == offset(prev) + sizeof(prev) + sizeof(curr)
+void TryRecoverMappings(MappingInfo* prev, MappingInfo* curr,
+                        MappingInfo* next) {
+  // Merged segments are marked with size = 0.
+  if (prev->size == 0 || curr->size == 0 || next->size == 0)
+    return;
+
+  if (curr->size >= kHpageSize &&
+      curr->exec &&
+      (curr->size & kHpageMask) == curr->size &&
+      (curr->start_addr & kHpageMask) == curr->start_addr &&
+      curr->name[0] == '\0' &&
+      next->name[0] != '\0' &&
+      curr->start_addr + curr->size == next->start_addr &&
+      prev->start_addr + prev->size == curr->start_addr &&
+      my_strncmp(prev->name, next->name, NAME_MAX) == 0 &&
+      next->offset == prev->offset + prev->size + curr->size) {
+
+    // matched
+    my_strlcpy(curr->name, prev->name, NAME_MAX);
+    if (prev->exec) {
+      curr->offset = prev->offset;
+      curr->start_addr = prev->start_addr;
+      if (next->exec) {
+        // (prev, curr, next)
+        curr->size += prev->size + next->size;
+        prev->size = 0;
+        next->size = 0;
+      } else {
+        // (prev, curr), next
+        curr->size += prev->size;
+        prev->size = 0;
+      }
+    } else {
+      curr->offset = prev->offset + prev->size;
+      if (next->exec) {
+        // prev, (curr, next)
+        curr->size += next->size;
+        next->size = 0;
+      } else {
+        // prev, curr, next
+      }
+    }
+  }
+}
+
+// mappings_ is sorted excepted for the first entry.
+// This function tries to merge segemnts into the first entry,
+// then check for other sorted entries.
+// See LinuxDumper::EnumerateMappings().
+void CrOSPostProcessMappings(wasteful_vector<MappingInfo*>& mappings) {
+  // Find the candidate "next" to first segment, which is the only one that
+  // could be out-of-order.
+  size_t l = 1;
+  size_t r = mappings.size();
+  size_t next = mappings.size();
+  while (l < r) {
+    int m = (l + r) / 2;
+    if (mappings[m]->start_addr > mappings[0]->start_addr)
+      r = next = m;
+    else
+      l = m + 1;
+  }
+
+  // Shows the range that contains the entry point is
+  // [first_start_addr, first_end_addr)
+  size_t first_start_addr = mappings[0]->start_addr;
+  size_t first_end_addr = mappings[0]->start_addr + mappings[0]->size;
+
+  // Put the out-of-order segment in order.
+  std::rotate(mappings.begin(), mappings.begin() + 1, mappings.begin() + next);
+
+  // Iterate through normal, sorted cases.
+  // Normal case 1.
+  for (size_t i = 0; i < mappings.size() - 1; i++)
+    TryRecoverMappings(mappings[i], mappings[i + 1]);
+
+  // Normal case 2.
+  for (size_t i = 0; i < mappings.size() - 2; i++)
+    TryRecoverMappings(mappings[i], mappings[i + 1], mappings[i + 2]);
+
+  // Collect merged (size == 0) segments.
+  size_t f, e;
+  for (f = e = 0; e < mappings.size(); e++)
+    if (mappings[e]->size > 0)
+      mappings[f++] = mappings[e];
+  mappings.resize(f);
+
+  // The entry point is in the first mapping. We want to find the location
+  // of the entry point after merging segment. To do this, we want to find
+  // the mapping that covers the first mapping from the original mapping list.
+  // If the mapping is not in the beginning, we move it to the begining via
+  // a right rotate by using reverse iterators.
+  for (l = 0; l < mappings.size(); l++) {
+    if (mappings[l]->start_addr <= first_start_addr
+        && (mappings[l]->start_addr + mappings[l]->size >= first_end_addr))
+      break;
+  }
+  if (l > 0) {
+    r = mappings.size();
+    std::rotate(mappings.rbegin() + r - l - 1, mappings.rbegin() + r - l,
+                mappings.rend());
+  }
+}
+
+#endif  // __CHROMEOS__
+
+}  // namespace
+
 // All interesting auvx entry types are below AT_SYSINFO_EHDR
 #define AT_MAX AT_SYSINFO_EHDR
 
-LinuxDumper::LinuxDumper(pid_t pid)
+LinuxDumper::LinuxDumper(pid_t pid, const char* root_prefix)
     : pid_(pid),
+      root_prefix_(root_prefix),
       crash_address_(0),
       crash_signal_(0),
+      crash_signal_code_(0),
       crash_thread_(pid),
       threads_(&allocator_, 8),
       mappings_(&allocator_),
       auxv_(&allocator_, AT_MAX + 1) {
+  assert(root_prefix_ && my_strlen(root_prefix_) < PATH_MAX);
   // The passed-in size to the constructor (above) is only a hint.
   // Must call .resize() to do actual initialization of the elements.
   auxv_.resize(AT_MAX + 1);
@@ -89,13 +301,24 @@ bool LinuxDumper::Init() {
   return ReadAuxv() && EnumerateThreads() && EnumerateMappings();
 }
 
+bool LinuxDumper::LateInit() {
+#if defined(__ANDROID__)
+  LatePostprocessMappings();
+#endif
+
+#if defined(__CHROMEOS__)
+  CrOSPostProcessMappings(mappings_);
+#endif
+
+  return true;
+}
+
 bool
 LinuxDumper::ElfFileIdentifierForMapping(const MappingInfo& mapping,
                                          bool member,
                                          unsigned int mapping_id,
-                                         uint8_t identifier[sizeof(MDGUID)]) {
+                                         wasteful_vector<uint8_t>& identifier) {
   assert(!member || mapping_id < mappings_.size());
-  my_memset(identifier, 0, sizeof(MDGUID));
   if (IsMappedFileOpenUnsafe(mapping))
     return false;
 
@@ -113,29 +336,182 @@ LinuxDumper::ElfFileIdentifierForMapping(const MappingInfo& mapping,
     return FileID::ElfFileIdentifierFromMappedFile(linux_gate, identifier);
   }
 
-  char filename[NAME_MAX];
-  size_t filename_len = my_strlen(mapping.name);
-  assert(filename_len < NAME_MAX);
-  if (filename_len >= NAME_MAX)
+  char filename[PATH_MAX];
+  if (!GetMappingAbsolutePath(mapping, filename))
     return false;
-  my_memcpy(filename, mapping.name, filename_len);
-  filename[filename_len] = '\0';
   bool filename_modified = HandleDeletedFileInMapping(filename);
 
-  MemoryMappedFile mapped_file(filename);
-  if (!mapped_file.data())  // Should probably check if size >= ElfW(Ehdr)?
+  MemoryMappedFile mapped_file(filename, mapping.offset);
+  if (!mapped_file.data() || mapped_file.size() < SELFMAG)
     return false;
 
   bool success =
       FileID::ElfFileIdentifierFromMappedFile(mapped_file.data(), identifier);
   if (success && member && filename_modified) {
-    mappings_[mapping_id]->name[filename_len -
+    mappings_[mapping_id]->name[my_strlen(mapping.name) -
                                 sizeof(kDeletedSuffix) + 1] = '\0';
   }
 
   return success;
 }
 
+void LinuxDumper::SetCrashInfoFromSigInfo(const siginfo_t& siginfo) {
+  set_crash_address(reinterpret_cast<uintptr_t>(siginfo.si_addr));
+  set_crash_signal(siginfo.si_signo);
+  set_crash_signal_code(siginfo.si_code);
+}
+
+const char* LinuxDumper::GetCrashSignalString() const {
+  switch (static_cast<unsigned int>(crash_signal_)) {
+    case MD_EXCEPTION_CODE_LIN_SIGHUP:
+      return "SIGHUP";
+    case MD_EXCEPTION_CODE_LIN_SIGINT:
+      return "SIGINT";
+    case MD_EXCEPTION_CODE_LIN_SIGQUIT:
+      return "SIGQUIT";
+    case MD_EXCEPTION_CODE_LIN_SIGILL:
+      return "SIGILL";
+    case MD_EXCEPTION_CODE_LIN_SIGTRAP:
+      return "SIGTRAP";
+    case MD_EXCEPTION_CODE_LIN_SIGABRT:
+      return "SIGABRT";
+    case MD_EXCEPTION_CODE_LIN_SIGBUS:
+      return "SIGBUS";
+    case MD_EXCEPTION_CODE_LIN_SIGFPE:
+      return "SIGFPE";
+    case MD_EXCEPTION_CODE_LIN_SIGKILL:
+      return "SIGKILL";
+    case MD_EXCEPTION_CODE_LIN_SIGUSR1:
+      return "SIGUSR1";
+    case MD_EXCEPTION_CODE_LIN_SIGSEGV:
+      return "SIGSEGV";
+    case MD_EXCEPTION_CODE_LIN_SIGUSR2:
+      return "SIGUSR2";
+    case MD_EXCEPTION_CODE_LIN_SIGPIPE:
+      return "SIGPIPE";
+    case MD_EXCEPTION_CODE_LIN_SIGALRM:
+      return "SIGALRM";
+    case MD_EXCEPTION_CODE_LIN_SIGTERM:
+      return "SIGTERM";
+    case MD_EXCEPTION_CODE_LIN_SIGSTKFLT:
+      return "SIGSTKFLT";
+    case MD_EXCEPTION_CODE_LIN_SIGCHLD:
+      return "SIGCHLD";
+    case MD_EXCEPTION_CODE_LIN_SIGCONT:
+      return "SIGCONT";
+    case MD_EXCEPTION_CODE_LIN_SIGSTOP:
+      return "SIGSTOP";
+    case MD_EXCEPTION_CODE_LIN_SIGTSTP:
+      return "SIGTSTP";
+    case MD_EXCEPTION_CODE_LIN_SIGTTIN:
+      return "SIGTTIN";
+    case MD_EXCEPTION_CODE_LIN_SIGTTOU:
+      return "SIGTTOU";
+    case MD_EXCEPTION_CODE_LIN_SIGURG:
+      return "SIGURG";
+    case MD_EXCEPTION_CODE_LIN_SIGXCPU:
+      return "SIGXCPU";
+    case MD_EXCEPTION_CODE_LIN_SIGXFSZ:
+      return "SIGXFSZ";
+    case MD_EXCEPTION_CODE_LIN_SIGVTALRM:
+      return "SIGVTALRM";
+    case MD_EXCEPTION_CODE_LIN_SIGPROF:
+      return "SIGPROF";
+    case MD_EXCEPTION_CODE_LIN_SIGWINCH:
+      return "SIGWINCH";
+    case MD_EXCEPTION_CODE_LIN_SIGIO:
+      return "SIGIO";
+    case MD_EXCEPTION_CODE_LIN_SIGPWR:
+      return "SIGPWR";
+    case MD_EXCEPTION_CODE_LIN_SIGSYS:
+      return "SIGSYS";
+    case MD_EXCEPTION_CODE_LIN_DUMP_REQUESTED:
+      return "DUMP_REQUESTED";
+    default:
+      return "UNKNOWN";
+  }
+}
+
+bool LinuxDumper::GetMappingAbsolutePath(const MappingInfo& mapping,
+                                         char path[PATH_MAX]) const {
+  return my_strlcpy(path, root_prefix_, PATH_MAX) < PATH_MAX &&
+         my_strlcat(path, mapping.name, PATH_MAX) < PATH_MAX;
+}
+
+namespace {
+// Find the shared object name (SONAME) by examining the ELF information
+// for |mapping|. If the SONAME is found copy it into the passed buffer
+// |soname| and return true. The size of the buffer is |soname_size|.
+// The SONAME will be truncated if it is too long to fit in the buffer.
+bool ElfFileSoName(const LinuxDumper& dumper,
+    const MappingInfo& mapping, char* soname, size_t soname_size) {
+  if (IsMappedFileOpenUnsafe(mapping)) {
+    // Not safe
+    return false;
+  }
+
+  char filename[PATH_MAX];
+  if (!dumper.GetMappingAbsolutePath(mapping, filename))
+    return false;
+
+  MemoryMappedFile mapped_file(filename, mapping.offset);
+  if (!mapped_file.data() || mapped_file.size() < SELFMAG) {
+    // mmap failed
+    return false;
+  }
+
+  return ElfFileSoNameFromMappedFile(mapped_file.data(), soname, soname_size);
+}
+
+}  // namespace
+
+
+void LinuxDumper::GetMappingEffectiveNameAndPath(const MappingInfo& mapping,
+                                                 char* file_path,
+                                                 size_t file_path_size,
+                                                 char* file_name,
+                                                 size_t file_name_size) {
+  my_strlcpy(file_path, mapping.name, file_path_size);
+
+  // Tools such as minidump_stackwalk use the name of the module to look up
+  // symbols produced by dump_syms. dump_syms will prefer to use a module's
+  // DT_SONAME as the module name, if one exists, and will fall back to the
+  // filesystem name of the module.
+
+  // Just use the filesystem name if no SONAME is present.
+  if (!ElfFileSoName(*this, mapping, file_name, file_name_size)) {
+    //   file_path := /path/to/libname.so
+    //   file_name := libname.so
+    const char* basename = my_strrchr(file_path, '/');
+    basename = basename == NULL ? file_path : (basename + 1);
+    my_strlcpy(file_name, basename, file_name_size);
+    return;
+  }
+
+  if (mapping.exec && mapping.offset != 0) {
+    // If an executable is mapped from a non-zero offset, this is likely because
+    // the executable was loaded directly from inside an archive file (e.g., an
+    // apk on Android).
+    // In this case, we append the file_name to the mapped archive path:
+    //   file_name := libname.so
+    //   file_path := /path/to/ARCHIVE.APK/libname.so
+    if (my_strlen(file_path) + 1 + my_strlen(file_name) < file_path_size) {
+      my_strlcat(file_path, "/", file_path_size);
+      my_strlcat(file_path, file_name, file_path_size);
+    }
+  } else {
+    // Otherwise, replace the basename with the SONAME.
+    char* basename = const_cast<char*>(my_strrchr(file_path, '/'));
+    if (basename) {
+      my_strlcpy(basename + 1, file_name,
+                 file_path_size - my_strlen(file_path) +
+                     my_strlen(basename + 1));
+    } else {
+      my_strlcpy(file_path, file_name, file_path_size);
+    }
+  }
+}
+
 bool LinuxDumper::ReadAuxv() {
   char auxv_path[NAME_MAX];
   if (!BuildProcPath(auxv_path, pid_, "auxv")) {
@@ -175,11 +551,11 @@ bool LinuxDumper::EnumerateMappings() {
   // See http://www.trilithium.com/johan/2005/08/linux-gate/ for more
   // information.
   const void* linux_gate_loc =
-      reinterpret_cast<void *>(auxv_[AT_SYSINFO_EHDR]);
+      reinterpret_cast<void*>(auxv_[AT_SYSINFO_EHDR]);
   // Although the initial executable is usually the first mapping, it's not
   // guaranteed (see http://crosbug.com/25355); therefore, try to use the
   // actual entry point to find the mapping.
-  const void* entry_point_loc = reinterpret_cast<void *>(auxv_[AT_ENTRY]);
+  const void* entry_point_loc = reinterpret_cast<void*>(auxv_[AT_ENTRY]);
 
   const int fd = sys_open(maps_path, O_RDONLY, 0);
   if (fd < 0)
@@ -195,6 +571,7 @@ bool LinuxDumper::EnumerateMappings() {
     if (*i1 == '-') {
       const char* i2 = my_read_hex_ptr(&end_addr, i1 + 1);
       if (*i2 == ' ') {
+        bool exec = (*(i2 + 3) == 'x');
         const char* i3 = my_read_hex_ptr(&offset, i2 + 6 /* skip ' rwxp ' */);
         if (*i3 == ' ') {
           const char* name = NULL;
@@ -206,58 +583,176 @@ bool LinuxDumper::EnumerateMappings() {
             name = kLinuxGateLibraryName;
             offset = 0;
           }
-          // Merge adjacent mappings with the same name into one module,
-          // assuming they're a single library mapped by the dynamic linker
+          // Merge adjacent mappings into one module, assuming they're a single
+          // library mapped by the dynamic linker. Do this only if their name
+          // matches and either they have the same +x protection flag, or if the
+          // previous mapping is not executable and the new one is, to handle
+          // lld's output (see crbug.com/716484).
           if (name && !mappings_.empty()) {
             MappingInfo* module = mappings_.back();
             if ((start_addr == module->start_addr + module->size) &&
                 (my_strlen(name) == my_strlen(module->name)) &&
-                (my_strncmp(name, module->name, my_strlen(name)) == 0)) {
+                (my_strncmp(name, module->name, my_strlen(name)) == 0) &&
+                ((exec == module->exec) || (!module->exec && exec))) {
+              module->system_mapping_info.end_addr = end_addr;
               module->size = end_addr - module->start_addr;
+              module->exec |= exec;
               line_reader->PopLine(line_len);
               continue;
             }
           }
           MappingInfo* const module = new(allocator_) MappingInfo;
+          mappings_.push_back(module);
           my_memset(module, 0, sizeof(MappingInfo));
+          module->system_mapping_info.start_addr = start_addr;
+          module->system_mapping_info.end_addr = end_addr;
           module->start_addr = start_addr;
           module->size = end_addr - start_addr;
           module->offset = offset;
+          module->exec = exec;
           if (name != NULL) {
             const unsigned l = my_strlen(name);
             if (l < sizeof(module->name))
               my_memcpy(module->name, name, l);
           }
-          // If this is the entry-point mapping, and it's not already the
-          // first one, then we need to make it be first.  This is because
-          // the minidump format assumes the first module is the one that
-          // corresponds to the main executable (as codified in
-          // processor/minidump.cc:MinidumpModuleList::GetMainModule()).
-          if (entry_point_loc &&
-              (entry_point_loc >=
-                  reinterpret_cast<void*>(module->start_addr)) &&
-              (entry_point_loc <
-                  reinterpret_cast<void*>(module->start_addr+module->size)) &&
-              !mappings_.empty()) {
-            // push the module onto the front of the list.
-            mappings_.resize(mappings_.size() + 1);
-            for (size_t idx = mappings_.size() - 1; idx > 0; idx--)
-              mappings_[idx] = mappings_[idx - 1];
-            mappings_[0] = module;
-          } else {
-            mappings_.push_back(module);
-          }
         }
       }
     }
     line_reader->PopLine(line_len);
   }
 
+  if (entry_point_loc) {
+    for (size_t i = 0; i < mappings_.size(); ++i) {
+      MappingInfo* module = mappings_[i];
+
+      // If this module contains the entry-point, and it's not already the first
+      // one, then we need to make it be first.  This is because the minidump
+      // format assumes the first module is the one that corresponds to the main
+      // executable (as codified in
+      // processor/minidump.cc:MinidumpModuleList::GetMainModule()).
+      if ((entry_point_loc >= reinterpret_cast<void*>(module->start_addr)) &&
+          (entry_point_loc <
+           reinterpret_cast<void*>(module->start_addr + module->size))) {
+        for (size_t j = i; j > 0; j--)
+          mappings_[j] = mappings_[j - 1];
+        mappings_[0] = module;
+        break;
+      }
+    }
+  }
+
   sys_close(fd);
 
   return !mappings_.empty();
 }
 
+#if defined(__ANDROID__)
+
+bool LinuxDumper::GetLoadedElfHeader(uintptr_t start_addr, ElfW(Ehdr)* ehdr) {
+  CopyFromProcess(ehdr, pid_,
+                  reinterpret_cast<const void*>(start_addr),
+                  sizeof(*ehdr));
+  return my_memcmp(&ehdr->e_ident, ELFMAG, SELFMAG) == 0;
+}
+
+void LinuxDumper::ParseLoadedElfProgramHeaders(ElfW(Ehdr)* ehdr,
+                                               uintptr_t start_addr,
+                                               uintptr_t* min_vaddr_ptr,
+                                               uintptr_t* dyn_vaddr_ptr,
+                                               size_t* dyn_count_ptr) {
+  uintptr_t phdr_addr = start_addr + ehdr->e_phoff;
+
+  const uintptr_t max_addr = UINTPTR_MAX;
+  uintptr_t min_vaddr = max_addr;
+  uintptr_t dyn_vaddr = 0;
+  size_t dyn_count = 0;
+
+  for (size_t i = 0; i < ehdr->e_phnum; ++i) {
+    ElfW(Phdr) phdr;
+    CopyFromProcess(&phdr, pid_,
+                    reinterpret_cast<const void*>(phdr_addr),
+                    sizeof(phdr));
+    if (phdr.p_type == PT_LOAD && phdr.p_vaddr < min_vaddr) {
+      min_vaddr = phdr.p_vaddr;
+    }
+    if (phdr.p_type == PT_DYNAMIC) {
+      dyn_vaddr = phdr.p_vaddr;
+      dyn_count = phdr.p_memsz / sizeof(ElfW(Dyn));
+    }
+    phdr_addr += sizeof(phdr);
+  }
+
+  *min_vaddr_ptr = min_vaddr;
+  *dyn_vaddr_ptr = dyn_vaddr;
+  *dyn_count_ptr = dyn_count;
+}
+
+bool LinuxDumper::HasAndroidPackedRelocations(uintptr_t load_bias,
+                                              uintptr_t dyn_vaddr,
+                                              size_t dyn_count) {
+  uintptr_t dyn_addr = load_bias + dyn_vaddr;
+  for (size_t i = 0; i < dyn_count; ++i) {
+    ElfW(Dyn) dyn;
+    CopyFromProcess(&dyn, pid_,
+                    reinterpret_cast<const void*>(dyn_addr),
+                    sizeof(dyn));
+    if (dyn.d_tag == DT_ANDROID_REL || dyn.d_tag == DT_ANDROID_RELA) {
+      return true;
+    }
+    dyn_addr += sizeof(dyn);
+  }
+  return false;
+}
+
+uintptr_t LinuxDumper::GetEffectiveLoadBias(ElfW(Ehdr)* ehdr,
+                                            uintptr_t start_addr) {
+  uintptr_t min_vaddr = 0;
+  uintptr_t dyn_vaddr = 0;
+  size_t dyn_count = 0;
+  ParseLoadedElfProgramHeaders(ehdr, start_addr,
+                               &min_vaddr, &dyn_vaddr, &dyn_count);
+  // If |min_vaddr| is non-zero and we find Android packed relocation tags,
+  // return the effective load bias.
+  if (min_vaddr != 0) {
+    const uintptr_t load_bias = start_addr - min_vaddr;
+    if (HasAndroidPackedRelocations(load_bias, dyn_vaddr, dyn_count)) {
+      return load_bias;
+    }
+  }
+  // Either |min_vaddr| is zero, or it is non-zero but we did not find the
+  // expected Android packed relocations tags.
+  return start_addr;
+}
+
+void LinuxDumper::LatePostprocessMappings() {
+  for (size_t i = 0; i < mappings_.size(); ++i) {
+    // Only consider exec mappings that indicate a file path was mapped, and
+    // where the ELF header indicates a mapped shared library.
+    MappingInfo* mapping = mappings_[i];
+    if (!(mapping->exec && mapping->name[0] == '/')) {
+      continue;
+    }
+    ElfW(Ehdr) ehdr;
+    if (!GetLoadedElfHeader(mapping->start_addr, &ehdr)) {
+      continue;
+    }
+    if (ehdr.e_type == ET_DYN) {
+      // Compute the effective load bias for this mapped library, and update
+      // the mapping to hold that rather than |start_addr|, at the same time
+      // adjusting |size| to account for the change in |start_addr|. Where
+      // the library does not contain Android packed relocations,
+      // GetEffectiveLoadBias() returns |start_addr| and the mapping entry
+      // is not changed.
+      const uintptr_t load_bias = GetEffectiveLoadBias(&ehdr,
+                                                       mapping->start_addr);
+      mapping->size += mapping->start_addr - load_bias;
+      mapping->start_addr = load_bias;
+    }
+  }
+}
+
+#endif  // __ANDROID__
+
 // Get information about the stack, given the stack pointer. We don't try to
 // walk the stack since we might not have all the information needed to do
 // unwind. So we just grab, up to, 32k of stack.
@@ -285,6 +780,126 @@ bool LinuxDumper::GetStackInfo(const void** stack, size_t* stack_len,
   return true;
 }
 
+void LinuxDumper::SanitizeStackCopy(uint8_t* stack_copy, size_t stack_len,
+                                    uintptr_t stack_pointer,
+                                    uintptr_t sp_offset) {
+  // We optimize the search for containing mappings in three ways:
+  // 1) We expect that pointers into the stack mapping will be common, so
+  //    we cache that address range.
+  // 2) The last referenced mapping is a reasonable predictor for the next
+  //    referenced mapping, so we test that first.
+  // 3) We precompute a bitfield based upon bits 32:32-n of the start and
+  //    stop addresses, and use that to short circuit any values that can
+  //    not be pointers. (n=11)
+  const uintptr_t defaced =
+#if defined(__LP64__)
+      0x0defaced0defaced;
+#else
+      0x0defaced;
+#endif
+  // the bitfield length is 2^test_bits long.
+  const unsigned int test_bits = 11;
+  // byte length of the corresponding array.
+  const unsigned int array_size = 1 << (test_bits - 3);
+  const unsigned int array_mask = array_size - 1;
+  // The amount to right shift pointers by. This captures the top bits
+  // on 32 bit architectures. On 64 bit architectures this would be
+  // uninformative so we take the same range of bits.
+  const unsigned int shift = 32 - 11;
+  const MappingInfo* last_hit_mapping = nullptr;
+  const MappingInfo* hit_mapping = nullptr;
+  const MappingInfo* stack_mapping = FindMappingNoBias(stack_pointer);
+  // The magnitude below which integers are considered to be to be
+  // 'small', and not constitute a PII risk. These are included to
+  // avoid eliding useful register values.
+  const ssize_t small_int_magnitude = 4096;
+
+  char could_hit_mapping[array_size];
+  my_memset(could_hit_mapping, 0, array_size);
+
+  // Initialize the bitfield such that if the (pointer >> shift)'th
+  // bit, modulo the bitfield size, is not set then there does not
+  // exist a mapping in mappings_ that would contain that pointer.
+  for (size_t i = 0; i < mappings_.size(); ++i) {
+    if (!mappings_[i]->exec) continue;
+    // For each mapping, work out the (unmodulo'ed) range of bits to
+    // set.
+    uintptr_t start = mappings_[i]->start_addr;
+    uintptr_t end = start + mappings_[i]->size;
+    start >>= shift;
+    end >>= shift;
+    for (size_t bit = start; bit <= end; ++bit) {
+      // Set each bit in the range, applying the modulus.
+      could_hit_mapping[(bit >> 3) & array_mask] |= 1 << (bit & 7);
+    }
+  }
+
+  // Zero memory that is below the current stack pointer.
+  const uintptr_t offset =
+      (sp_offset + sizeof(uintptr_t) - 1) & ~(sizeof(uintptr_t) - 1);
+  if (offset) {
+    my_memset(stack_copy, 0, offset);
+  }
+
+  // Apply sanitization to each complete pointer-aligned word in the
+  // stack.
+  uint8_t* sp;
+  for (sp = stack_copy + offset;
+       sp <= stack_copy + stack_len - sizeof(uintptr_t);
+       sp += sizeof(uintptr_t)) {
+    uintptr_t addr;
+    my_memcpy(&addr, sp, sizeof(uintptr_t));
+    if (static_cast<intptr_t>(addr) <= small_int_magnitude &&
+        static_cast<intptr_t>(addr) >= -small_int_magnitude) {
+      continue;
+    }
+    if (stack_mapping && MappingContainsAddress(*stack_mapping, addr)) {
+      continue;
+    }
+    if (last_hit_mapping && MappingContainsAddress(*last_hit_mapping, addr)) {
+      continue;
+    }
+    uintptr_t test = addr >> shift;
+    if (could_hit_mapping[(test >> 3) & array_mask] & (1 << (test & 7)) &&
+        (hit_mapping = FindMappingNoBias(addr)) != nullptr &&
+        hit_mapping->exec) {
+      last_hit_mapping = hit_mapping;
+      continue;
+    }
+    my_memcpy(sp, &defaced, sizeof(uintptr_t));
+  }
+  // Zero any partial word at the top of the stack, if alignment is
+  // such that that is required.
+  if (sp < stack_copy + stack_len) {
+    my_memset(sp, 0, stack_copy + stack_len - sp);
+  }
+}
+
+bool LinuxDumper::StackHasPointerToMapping(const uint8_t* stack_copy,
+                                           size_t stack_len,
+                                           uintptr_t sp_offset,
+                                           const MappingInfo& mapping) {
+  // Loop over all stack words that would have been on the stack in
+  // the target process (i.e. are word aligned, and at addresses >=
+  // the stack pointer).  Regardless of the alignment of |stack_copy|,
+  // the memory starting at |stack_copy| + |offset| represents an
+  // aligned word in the target process.
+  const uintptr_t low_addr = mapping.system_mapping_info.start_addr;
+  const uintptr_t high_addr = mapping.system_mapping_info.end_addr;
+  const uintptr_t offset =
+      (sp_offset + sizeof(uintptr_t) - 1) & ~(sizeof(uintptr_t) - 1);
+
+  for (const uint8_t* sp = stack_copy + offset;
+       sp <= stack_copy + stack_len - sizeof(uintptr_t);
+       sp += sizeof(uintptr_t)) {
+    uintptr_t addr;
+    my_memcpy(&addr, sp, sizeof(uintptr_t));
+    if (low_addr <= addr && addr <= high_addr)
+      return true;
+  }
+  return false;
+}
+
 // Find the mapping which the given memory address falls in.
 const MappingInfo* LinuxDumper::FindMapping(const void* address) const {
   const uintptr_t addr = (uintptr_t) address;
@@ -298,6 +913,19 @@ const MappingInfo* LinuxDumper::FindMapping(const void* address) const {
   return NULL;
 }
 
+// Find the mapping which the given memory address falls in. Uses the
+// unadjusted mapping address range from the kernel, rather than the
+// biased range.
+const MappingInfo* LinuxDumper::FindMappingNoBias(uintptr_t address) const {
+  for (size_t i = 0; i < mappings_.size(); ++i) {
+    if (address >= mappings_[i]->system_mapping_info.start_addr &&
+        address < mappings_[i]->system_mapping_info.end_addr) {
+      return mappings_[i];
+    }
+  }
+  return NULL;
+}
+
 bool LinuxDumper::HandleDeletedFileInMapping(char* path) const {
   static const size_t kDeletedSuffixLen = sizeof(kDeletedSuffix) - 1;
 
@@ -313,10 +941,13 @@ bool LinuxDumper::HandleDeletedFileInMapping(char* path) const {
 
   // Check |path| against the /proc/pid/exe 'symlink'.
   char exe_link[NAME_MAX];
-  char new_path[NAME_MAX];
   if (!BuildProcPath(exe_link, pid_, "exe"))
     return false;
-  if (!SafeReadLink(exe_link, new_path))
+  MappingInfo new_mapping = {0};
+  if (!SafeReadLink(exe_link, new_mapping.name))
+    return false;
+  char new_path[PATH_MAX];
+  if (!GetMappingAbsolutePath(new_mapping, new_path))
     return false;
   if (my_strcmp(path, new_path) != 0)
     return false;
diff --git a/src/MEGASync/google_breakpad/client/linux/minidump_writer/linux_dumper.h b/src/MEGASync/google_breakpad/client/linux/minidump_writer/linux_dumper.h
index 37f78e6b..7bee160f 100644
--- a/src/MEGASync/google_breakpad/client/linux/minidump_writer/linux_dumper.h
+++ b/src/MEGASync/google_breakpad/client/linux/minidump_writer/linux_dumper.h
@@ -38,91 +38,59 @@
 #ifndef CLIENT_LINUX_MINIDUMP_WRITER_LINUX_DUMPER_H_
 #define CLIENT_LINUX_MINIDUMP_WRITER_LINUX_DUMPER_H_
 
+#include <assert.h>
 #include <elf.h>
+#if defined(__ANDROID__)
+#include <link.h>
+#endif
 #include <linux/limits.h>
 #include <stdint.h>
 #include <sys/types.h>
 #include <sys/user.h>
 
-#include "common/memory.h"
-#include "google_breakpad/common/minidump_format.h"
-
-#if __cplusplus >= 201103L
-#include <type_traits>
-#define TYPEOF(x) std::remove_reference<decltype(x)>::type
-#else
-#define TYPEOF(x) typeof(x)
-#endif
+#include <vector>
 
+#include "client/linux/dump_writer_common/mapping_info.h"
+#include "client/linux/dump_writer_common/thread_info.h"
+#include "common/linux/file_id.h"
+#include "common/memory_allocator.h"
+#include "google_breakpad/common/minidump_format.h"
 
 namespace google_breakpad {
 
-#if defined(__i386) || defined(__x86_64)
-typedef TYPEOF(((struct user*) 0)->u_debugreg[0]) debugreg_t;
-#endif
-
 // Typedef for our parsing of the auxv variables in /proc/pid/auxv.
-#if defined(__i386) || defined(__ARM_EABI__) || defined(__mips__)
+#if defined(__i386) || defined(__ARM_EABI__) || \
+ (defined(__mips__) && _MIPS_SIM == _ABIO32)
 typedef Elf32_auxv_t elf_aux_entry;
-#elif defined(__x86_64)
+#elif defined(__x86_64) || defined(__aarch64__) || \
+     (defined(__mips__) && _MIPS_SIM != _ABIO32)
 typedef Elf64_auxv_t elf_aux_entry;
 #endif
 
-typedef TYPEOF(((elf_aux_entry*) 0)->a_un.a_val) elf_aux_val_t;
+typedef __typeof__(((elf_aux_entry*) 0)->a_un.a_val) elf_aux_val_t;
 
 // When we find the VDSO mapping in the process's address space, this
 // is the name we use for it when writing it to the minidump.
 // This should always be less than NAME_MAX!
 const char kLinuxGateLibraryName[] = "linux-gate.so";
 
-// We produce one of these structures for each thread in the crashed process.
-struct ThreadInfo {
-  pid_t tgid;   // thread group id
-  pid_t ppid;   // parent process
-
-  uintptr_t stack_pointer;  // thread stack pointer
-
-
-#if defined(__i386) || defined(__x86_64)
-  user_regs_struct regs;
-  user_fpregs_struct fpregs;
-  static const unsigned kNumDebugRegisters = 8;
-  debugreg_t dregs[8];
-#if defined(__i386)
-  user_fpxregs_struct fpxregs;
-#endif  // defined(__i386)
-
-#elif defined(__ARM_EABI__)
-  // Mimicking how strace does this(see syscall.c, search for GETREGS)
-  struct user_regs regs;
-  struct user_fpregs fpregs;
-#elif defined(__mips__)
-  user_regs_struct regs;
-  user_fpregs_struct fpregs;
-  uint32_t hi[3];
-  uint32_t lo[3];
-  uint32_t dsp_control;
-#endif
-};
-
-// One of these is produced for each mapping in the process (i.e. line in
-// /proc/$x/maps).
-struct MappingInfo {
-  uintptr_t start_addr;
-  size_t size;
-  size_t offset;  // offset into the backed file.
-  char name[NAME_MAX];
-};
-
 class LinuxDumper {
  public:
-  explicit LinuxDumper(pid_t pid);
+  // The |root_prefix| is prepended to mapping paths before opening them, which
+  // is useful if the crash originates from a chroot.
+  explicit LinuxDumper(pid_t pid, const char* root_prefix = "");
 
   virtual ~LinuxDumper();
 
   // Parse the data for |threads| and |mappings|.
   virtual bool Init();
 
+  // Take any actions that could not be taken in Init(). LateInit() is
+  // called after all other caller's initialization is complete, and in
+  // particular after it has called ThreadsSuspend(), so that ptrace is
+  // available.
+  virtual bool LateInit();
+
   // Return true if the dumper performs a post-mortem dump.
   virtual bool IsPostMortem() const = 0;
 
@@ -134,10 +102,22 @@ class LinuxDumper {
   // Returns true on success. One must have called |ThreadsSuspend| first.
   virtual bool GetThreadInfoByIndex(size_t index, ThreadInfo* info) = 0;
 
+  size_t GetMainThreadIndex() const {
+    for (size_t i = 0; i < threads_.size(); ++i) {
+      if (threads_[i] == pid_) return i;
+    }
+    return -1u;
+  }
+
   // These are only valid after a call to |Init|.
-  const wasteful_vector<pid_t> &threads() { return threads_; }
-  const wasteful_vector<MappingInfo*> &mappings() { return mappings_; }
+  const wasteful_vector<pid_t>& threads() { return threads_; }
+  const wasteful_vector<MappingInfo*>& mappings() { return mappings_; }
   const MappingInfo* FindMapping(const void* address) const;
+  // Find the mapping which the given memory address falls in. Unlike
+  // FindMapping, this method uses the unadjusted mapping address
+  // ranges from the kernel, rather than the ranges that have had the
+  // load bias applied.
+  const MappingInfo* FindMappingNoBias(uintptr_t address) const;
   const wasteful_vector<elf_aux_val_t>& auxv() { return auxv_; }
 
   // Find a block of memory to take as the stack given the top of stack pointer.
@@ -146,11 +126,37 @@ class LinuxDumper {
   //   stack_top: the current top of the stack
   bool GetStackInfo(const void** stack, size_t* stack_len, uintptr_t stack_top);
 
+  // Sanitize a copy of the stack by overwriting words that are not
+  // pointers with a sentinel (0x0defaced).
+  //   stack_copy: a copy of the stack to sanitize. |stack_copy| might
+  //               not be word aligned, but it represents word aligned
+  //               data copied from another location.
+  //   stack_len: the length of the allocation pointed to by |stack_copy|.
+  //   stack_pointer: the address of the stack pointer (used to locate
+  //                  the stack mapping, as an optimization).
+  //   sp_offset: the offset relative to stack_copy that reflects the
+  //              current value of the stack pointer.
+  void SanitizeStackCopy(uint8_t* stack_copy, size_t stack_len,
+                         uintptr_t stack_pointer, uintptr_t sp_offset);
+
+  // Test whether |stack_copy| contains a pointer-aligned word that
+  // could be an address within a given mapping.
+  //   stack_copy: a copy of the stack to check. |stack_copy| might
+  //               not be word aligned, but it represents word aligned
+  //               data copied from another location.
+  //   stack_len: the length of the allocation pointed to by |stack_copy|.
+  //   sp_offset: the offset relative to stack_copy that reflects the
+  //              current value of the stack pointer.
+  //   mapping: the mapping against which to test stack words.
+  bool StackHasPointerToMapping(const uint8_t* stack_copy, size_t stack_len,
+                                uintptr_t sp_offset,
+                                const MappingInfo& mapping);
+
   PageAllocator* allocator() { return &allocator_; }
 
   // Copy content of |length| bytes from a given process |child|,
-  // starting from |src|, into |dest|.
-  virtual void CopyFromProcess(void* dest, pid_t child, const void* src,
+  // starting from |src|, into |dest|. Returns true on success.
+  virtual bool CopyFromProcess(void* dest, pid_t child, const void* src,
                                size_t length) = 0;
 
   // Builds a proc path for a certain pid for a node (/proc/<pid>/<node>).
@@ -160,11 +166,14 @@ class LinuxDumper {
   virtual bool BuildProcPath(char* path, pid_t pid, const char* node) const = 0;
 
   // Generate a File ID from the .text section of a mapped entry.
-  // If not a member, mapping_id is ignored.
+  // If not a member, mapping_id is ignored. This method can also manipulate the
+  // |mapping|.name to truncate "(deleted)" from the file name if necessary.
   bool ElfFileIdentifierForMapping(const MappingInfo& mapping,
                                    bool member,
                                    unsigned int mapping_id,
-                                   uint8_t identifier[sizeof(MDGUID)]);
+                                   wasteful_vector<uint8_t>& identifier);
+
+  void SetCrashInfoFromSigInfo(const siginfo_t& siginfo);
 
   uintptr_t crash_address() const { return crash_address_; }
   void set_crash_address(uintptr_t crash_address) {
@@ -173,10 +182,38 @@ class LinuxDumper {
 
   int crash_signal() const { return crash_signal_; }
   void set_crash_signal(int crash_signal) { crash_signal_ = crash_signal; }
+  const char* GetCrashSignalString() const;
+
+  void set_crash_signal_code(int code) { crash_signal_code_ = code; }
+  int crash_signal_code() const { return crash_signal_code_; }
+
+  void set_crash_exception_info(const std::vector<uint64_t>& exception_info) {
+    assert(exception_info.size() <= MD_EXCEPTION_MAXIMUM_PARAMETERS);
+    crash_exception_info_ = exception_info;
+  }
+  const std::vector<uint64_t>& crash_exception_info() const {
+    return crash_exception_info_;
+  }
 
   pid_t crash_thread() const { return crash_thread_; }
   void set_crash_thread(pid_t crash_thread) { crash_thread_ = crash_thread; }
 
+  // Concatenates the |root_prefix_| and |mapping| path. Writes into |path| and
+  // returns true unless the string is too long.
+  bool GetMappingAbsolutePath(const MappingInfo& mapping,
+                              char path[PATH_MAX]) const;
+
+  // Extracts the effective path and file name of from |mapping|. In most cases
+  // the effective name/path are just the mapping's path and basename. In some
+  // other cases, however, a library can be mapped from an archive (e.g., when
+  // loading .so libs from an apk on Android) and this method is able to
+  // reconstruct the original file name.
+  void GetMappingEffectiveNameAndPath(const MappingInfo& mapping,
+                                      char* file_path,
+                                      size_t file_path_size,
+                                      char* file_name,
+                                      size_t file_name_size);
+
  protected:
   bool ReadAuxv();
 
@@ -198,12 +235,21 @@ class LinuxDumper {
    // ID of the crashed process.
   const pid_t pid_;
 
+  // Path of the root directory to which mapping paths are relative.
+  const char* const root_prefix_;
+
   // Virtual address at which the process crashed.
   uintptr_t crash_address_;
 
   // Signal that terminated the crashed process.
   int crash_signal_;
 
+  // The code associated with |crash_signal_|.
+  int crash_signal_code_;
+
+  // The additional fields associated with |crash_signal_|.
+  std::vector<uint64_t> crash_exception_info_;
+
   // ID of the crashed thread.
   pid_t crash_thread_;
 
@@ -217,6 +263,62 @@ class LinuxDumper {
 
   // Info from /proc/<pid>/auxv
   wasteful_vector<elf_aux_val_t> auxv_;
+
+#if defined(__ANDROID__)
+ private:
+  // Android M and later support packed ELF relocations in shared libraries.
+  // Packing relocations changes the vaddr of the LOAD segments, such that
+  // the effective load bias is no longer the same as the start address of
+  // the memory mapping containing the executable parts of the library. The
+  // packing is applied to the stripped library run on the target, but not to
+  // any other library, and in particular not to the library used to generate
+  // breakpad symbols. As a result, we need to adjust the |start_addr| for
+  // any mapping that results from a shared library that contains Android
+  // packed relocations, so that it properly represents the effective library
+  // load bias. The following functions support this adjustment.
+
+  // Check that a given mapping at |start_addr| is for an ELF shared library.
+  // If it is, place the ELF header in |ehdr| and return true.
+  // The first LOAD segment in an ELF shared library has offset zero, so the
+  // ELF file header is at the start of this map entry, and in already mapped
+  // memory.
+  bool GetLoadedElfHeader(uintptr_t start_addr, ElfW(Ehdr)* ehdr);
+
+  // For the ELF file mapped at |start_addr|, iterate ELF program headers to
+  // find the min vaddr of all program header LOAD segments, the vaddr for
+  // the DYNAMIC segment, and a count of DYNAMIC entries. Return values in
+  // |min_vaddr_ptr|, |dyn_vaddr_ptr|, and |dyn_count_ptr|.
+  // The program header table is also in already mapped memory.
+  void ParseLoadedElfProgramHeaders(ElfW(Ehdr)* ehdr,
+                                    uintptr_t start_addr,
+                                    uintptr_t* min_vaddr_ptr,
+                                    uintptr_t* dyn_vaddr_ptr,
+                                    size_t* dyn_count_ptr);
+
+  // Search the DYNAMIC tags for the ELF file with the given |load_bias|, and
+  // return true if the tags indicate that the file contains Android packed
+  // relocations. Dynamic tags are found at |dyn_vaddr| past the |load_bias|.
+  bool HasAndroidPackedRelocations(uintptr_t load_bias,
+                                   uintptr_t dyn_vaddr,
+                                   size_t dyn_count);
+
+  // If the ELF file mapped at |start_addr| contained Android packed
+  // relocations, return the load bias that the system linker (or Chromium
+  // crazy linker) will have used. If the file did not contain Android
+  // packed relocations, returns |start_addr|, indicating that no adjustment
+  // is necessary.
+  // The effective load bias is |start_addr| adjusted downwards by the
+  // min vaddr in the library LOAD segments.
+  uintptr_t GetEffectiveLoadBias(ElfW(Ehdr)* ehdr, uintptr_t start_addr);
+
+  // Called from LateInit(). Iterates |mappings_| and rewrites the |start_addr|
+  // field of any that represent ELF shared libraries with Android packed
+  // relocations, so that |start_addr| is the load bias that the system linker
+  // (or Chromium crazy linker) used. This value matches the addresses produced
+  // when the non-relocation-packed library is used for breakpad symbol
+  // generation.
+  void LatePostprocessMappings();
+#endif  // __ANDROID__
 };
 
 }  // namespace google_breakpad
diff --git a/src/MEGASync/google_breakpad/client/linux/minidump_writer/linux_dumper_unittest_helper.cc b/src/MEGASync/google_breakpad/client/linux/minidump_writer/linux_dumper_unittest_helper.cc
index 461a6cfe..331f4bb3 100644
--- a/src/MEGASync/google_breakpad/client/linux/minidump_writer/linux_dumper_unittest_helper.cc
+++ b/src/MEGASync/google_breakpad/client/linux/minidump_writer/linux_dumper_unittest_helper.cc
@@ -43,6 +43,8 @@
 
 #if defined(__ARM_EABI__)
 #define TID_PTR_REGISTER "r3"
+#elif defined(__aarch64__)
+#define TID_PTR_REGISTER "x3"
 #elif defined(__i386)
 #define TID_PTR_REGISTER "ecx"
 #elif defined(__x86_64)
@@ -53,22 +55,23 @@
 #error This test has not been ported to this platform.
 #endif
 
-void *thread_function(void *data) {
-  int pipefd = *static_cast<int *>(data);
-  volatile pid_t thread_id = syscall(__NR_gettid);
+void* thread_function(void* data) {
+  int pipefd = *static_cast<int*>(data);
+  volatile pid_t* thread_id = new pid_t;
+  *thread_id = syscall(__NR_gettid);
   // Signal parent that a thread has started.
   uint8_t byte = 1;
   if (write(pipefd, &byte, sizeof(byte)) != sizeof(byte)) {
     perror("ERROR: parent notification failed");
     return NULL;
   }
-  register volatile pid_t *thread_id_ptr asm(TID_PTR_REGISTER) = &thread_id;
+  register volatile pid_t* thread_id_ptr asm(TID_PTR_REGISTER) = thread_id;
   while (true)
     asm volatile ("" : : "r" (thread_id_ptr));
   return NULL;
 }
 
-int main(int argc, char *argv[]) {
+int main(int argc, char* argv[]) {
   if (argc < 3) {
     fprintf(stderr,
             "usage: linux_dumper_unittest_helper <pipe fd> <# of threads>\n");
diff --git a/src/MEGASync/google_breakpad/client/linux/minidump_writer/linux_ptrace_dumper.cc b/src/MEGASync/google_breakpad/client/linux/minidump_writer/linux_ptrace_dumper.cc
index 8b96037e..e3ddb81a 100644
--- a/src/MEGASync/google_breakpad/client/linux/minidump_writer/linux_ptrace_dumper.cc
+++ b/src/MEGASync/google_breakpad/client/linux/minidump_writer/linux_ptrace_dumper.cc
@@ -47,6 +47,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <sys/ptrace.h>
+#include <sys/uio.h>
 #include <sys/wait.h>
 
 #if defined(__i386)
@@ -129,7 +130,7 @@ bool LinuxPtraceDumper::BuildProcPath(char* path, pid_t pid,
   return true;
 }
 
-void LinuxPtraceDumper::CopyFromProcess(void* dest, pid_t child,
+bool LinuxPtraceDumper::CopyFromProcess(void* dest, pid_t child,
                                         const void* src, size_t length) {
   unsigned long tmp = 55;
   size_t done = 0;
@@ -145,6 +146,51 @@ void LinuxPtraceDumper::CopyFromProcess(void* dest, pid_t child,
     my_memcpy(local + done, &tmp, l);
     done += l;
   }
+  return true;
+}
+
+bool LinuxPtraceDumper::ReadRegisterSet(ThreadInfo* info, pid_t tid)
+{
+#ifdef PTRACE_GETREGSET
+  struct iovec io;
+  info->GetGeneralPurposeRegisters(&io.iov_base, &io.iov_len);
+  if (sys_ptrace(PTRACE_GETREGSET, tid, (void*)NT_PRSTATUS, (void*)&io) == -1) {
+    return false;
+  }
+
+  info->GetFloatingPointRegisters(&io.iov_base, &io.iov_len);
+  if (sys_ptrace(PTRACE_GETREGSET, tid, (void*)NT_FPREGSET, (void*)&io) == -1) {
+    return false;
+  }
+  return true;
+#else
+  return false;
+#endif
+}
+
+bool LinuxPtraceDumper::ReadRegisters(ThreadInfo* info, pid_t tid) {
+#ifdef PTRACE_GETREGS
+  void* gp_addr;
+  info->GetGeneralPurposeRegisters(&gp_addr, NULL);
+  if (sys_ptrace(PTRACE_GETREGS, tid, NULL, gp_addr) == -1) {
+    return false;
+  }
+
+#if !(defined(__ANDROID__) && defined(__ARM_EABI__))
+  // When running an arm build on an arm64 device, attempting to get the
+  // floating point registers fails. On Android, the floating point registers
+  // aren't written to the cpu context anyway, so just don't get them here.
+  // See http://crbug.com/508324
+  void* fp_addr;
+  info->GetFloatingPointRegisters(&fp_addr, NULL);
+  if (sys_ptrace(PTRACE_GETFPREGS, tid, NULL, fp_addr) == -1) {
+    return false;
+  }
+#endif  // !(defined(__ANDROID__) && defined(__ARM_EABI__))
+  return true;
+#else  // PTRACE_GETREGS
+  return false;
+#endif
 }
 
 // Read thread info from /proc/$pid/status.
@@ -186,12 +232,10 @@ bool LinuxPtraceDumper::GetThreadInfoByIndex(size_t index, ThreadInfo* info) {
   if (info->ppid == -1 || info->tgid == -1)
     return false;
 
-  if (sys_ptrace(PTRACE_GETREGS, tid, NULL, &info->regs) == -1) {
-    return false;
-  }
-
-  if (sys_ptrace(PTRACE_GETFPREGS, tid, NULL, &info->fpregs) == -1) {
-    return false;
+  if (!ReadRegisterSet(info, tid)) {
+    if (!ReadRegisters(info, tid)) {
+      return false;
+    }
   }
 
 #if defined(__i386)
@@ -224,14 +268,22 @@ bool LinuxPtraceDumper::GetThreadInfoByIndex(size_t index, ThreadInfo* info) {
 #endif
 
 #if defined(__mips__)
-  for (int i = 0; i < 3; ++i) {
-    sys_ptrace(PTRACE_PEEKUSER, tid,
-               reinterpret_cast<void*>(DSP_BASE + (i * 2)), &info->hi[i]);
-    sys_ptrace(PTRACE_PEEKUSER, tid,
-               reinterpret_cast<void*>(DSP_BASE + (i * 2) + 1), &info->lo[i]);
-  }
   sys_ptrace(PTRACE_PEEKUSER, tid,
-             reinterpret_cast<void*>(DSP_CONTROL), &info->dsp_control);
+             reinterpret_cast<void*>(PC), &info->mcontext.pc);
+  sys_ptrace(PTRACE_PEEKUSER, tid,
+             reinterpret_cast<void*>(DSP_BASE), &info->mcontext.hi1);
+  sys_ptrace(PTRACE_PEEKUSER, tid,
+             reinterpret_cast<void*>(DSP_BASE + 1), &info->mcontext.lo1);
+  sys_ptrace(PTRACE_PEEKUSER, tid,
+             reinterpret_cast<void*>(DSP_BASE + 2), &info->mcontext.hi2);
+  sys_ptrace(PTRACE_PEEKUSER, tid,
+             reinterpret_cast<void*>(DSP_BASE + 3), &info->mcontext.lo2);
+  sys_ptrace(PTRACE_PEEKUSER, tid,
+             reinterpret_cast<void*>(DSP_BASE + 4), &info->mcontext.hi3);
+  sys_ptrace(PTRACE_PEEKUSER, tid,
+             reinterpret_cast<void*>(DSP_BASE + 5), &info->mcontext.lo3);
+  sys_ptrace(PTRACE_PEEKUSER, tid,
+             reinterpret_cast<void*>(DSP_CONTROL), &info->mcontext.dsp);
 #endif
 
   const uint8_t* stack_pointer;
@@ -241,9 +293,11 @@ bool LinuxPtraceDumper::GetThreadInfoByIndex(size_t index, ThreadInfo* info) {
   my_memcpy(&stack_pointer, &info->regs.rsp, sizeof(info->regs.rsp));
 #elif defined(__ARM_EABI__)
   my_memcpy(&stack_pointer, &info->regs.ARM_sp, sizeof(info->regs.ARM_sp));
+#elif defined(__aarch64__)
+  my_memcpy(&stack_pointer, &info->regs.sp, sizeof(info->regs.sp));
 #elif defined(__mips__)
   stack_pointer =
-      reinterpret_cast<uint8_t*>(info->regs.regs[MD_CONTEXT_MIPS_REG_SP]);
+      reinterpret_cast<uint8_t*>(info->mcontext.gregs[MD_CONTEXT_MIPS_REG_SP]);
 #else
 #error "This code hasn't been ported to your platform yet."
 #endif
@@ -264,8 +318,10 @@ bool LinuxPtraceDumper::ThreadsSuspend() {
       // If the thread either disappeared before we could attach to it, or if
       // it was part of the seccomp sandbox's trusted code, it is OK to
       // silently drop it from the minidump.
-      my_memmove(&threads_[i], &threads_[i+1],
-                 (threads_.size() - i - 1) * sizeof(threads_[i]));
+      if (i < threads_.size() - 1) {
+        my_memmove(&threads_[i], &threads_[i + 1],
+                   (threads_.size() - i - 1) * sizeof(threads_[i]));
+      }
       threads_.resize(threads_.size() - 1);
       --i;
     }
diff --git a/src/MEGASync/google_breakpad/client/linux/minidump_writer/linux_ptrace_dumper.h b/src/MEGASync/google_breakpad/client/linux/minidump_writer/linux_ptrace_dumper.h
index 1e9bcfdf..cee58178 100644
--- a/src/MEGASync/google_breakpad/client/linux/minidump_writer/linux_ptrace_dumper.h
+++ b/src/MEGASync/google_breakpad/client/linux/minidump_writer/linux_ptrace_dumper.h
@@ -55,8 +55,8 @@ class LinuxPtraceDumper : public LinuxDumper {
   // Implements LinuxDumper::CopyFromProcess().
   // Copies content of |length| bytes from a given process |child|,
   // starting from |src|, into |dest|. This method uses ptrace to extract
-  // the content from the target process.
-  virtual void CopyFromProcess(void* dest, pid_t child, const void* src,
+  // the content from the target process. Always returns true.
+  virtual bool CopyFromProcess(void* dest, pid_t child, const void* src,
                                size_t length);
 
   // Implements LinuxDumper::GetThreadInfoByIndex().
@@ -85,6 +85,15 @@ class LinuxPtraceDumper : public LinuxDumper {
  private:
   // Set to true if all threads of the crashed process are suspended.
   bool threads_suspended_;
+
+  // Read the tracee's registers on kernel with PTRACE_GETREGSET support.
+  // Returns false if PTRACE_GETREGSET is not defined.
+  // Returns true on success.
+  bool ReadRegisterSet(ThreadInfo* info, pid_t tid);
+
+  // Read the tracee's registers on kernel with PTRACE_GETREGS support.
+  // Returns true on success.
+  bool ReadRegisters(ThreadInfo* info, pid_t tid);
 };
 
 }  // namespace google_breakpad
diff --git a/src/MEGASync/google_breakpad/client/linux/minidump_writer/linux_ptrace_dumper_unittest.cc b/src/MEGASync/google_breakpad/client/linux/minidump_writer/linux_ptrace_dumper_unittest.cc
index 15a66ce2..da71e15d 100644
--- a/src/MEGASync/google_breakpad/client/linux/minidump_writer/linux_ptrace_dumper_unittest.cc
+++ b/src/MEGASync/google_breakpad/client/linux/minidump_writer/linux_ptrace_dumper_unittest.cc
@@ -36,13 +36,13 @@
 #include <errno.h>
 #include <fcntl.h>
 #include <limits.h>
+#include <poll.h>
 #include <unistd.h>
 #include <signal.h>
 #include <stdint.h>
 #include <string.h>
 #include <sys/mman.h>
 #include <sys/prctl.h>
-#include <sys/poll.h>
 #include <sys/stat.h>
 #include <sys/types.h>
 
@@ -55,7 +55,7 @@
 #include "common/linux/file_id.h"
 #include "common/linux/ignore_ret.h"
 #include "common/linux/safe_readlink.h"
-#include "common/memory.h"
+#include "common/memory_allocator.h"
 #include "common/using_std_string.h"
 
 #ifndef PR_SET_PTRACER
@@ -66,6 +66,64 @@ using namespace google_breakpad;
 
 namespace {
 
+pid_t SetupChildProcess(int number_of_threads) {
+  char kNumberOfThreadsArgument[2];
+  sprintf(kNumberOfThreadsArgument, "%d", number_of_threads);
+
+  int fds[2];
+  EXPECT_NE(-1, pipe(fds));
+
+  pid_t child_pid = fork();
+  if (child_pid == 0) {
+    // In child process.
+    close(fds[0]);
+
+    string helper_path(GetHelperBinary());
+    if (helper_path.empty()) {
+      fprintf(stderr, "Couldn't find helper binary\n");
+      _exit(1);
+    }
+
+    // Pass the pipe fd and the number of threads as arguments.
+    char pipe_fd_string[8];
+    sprintf(pipe_fd_string, "%d", fds[1]);
+    execl(helper_path.c_str(),
+          "linux_dumper_unittest_helper",
+          pipe_fd_string,
+          kNumberOfThreadsArgument,
+          NULL);
+    // Kill if we get here.
+    printf("Errno from exec: %d", errno);
+    std::string err_str = "Exec of  " + helper_path + " failed";
+    perror(err_str.c_str());
+    _exit(1);
+  }
+  close(fds[1]);
+
+  // Wait for all child threads to indicate that they have started
+  for (int threads = 0; threads < number_of_threads; threads++) {
+    struct pollfd pfd;
+    memset(&pfd, 0, sizeof(pfd));
+    pfd.fd = fds[0];
+    pfd.events = POLLIN | POLLERR;
+
+    const int r = HANDLE_EINTR(poll(&pfd, 1, 1000));
+    EXPECT_EQ(1, r);
+    EXPECT_TRUE(pfd.revents & POLLIN);
+    uint8_t junk;
+    EXPECT_EQ(read(fds[0], &junk, sizeof(junk)),
+              static_cast<ssize_t>(sizeof(junk)));
+  }
+  close(fds[0]);
+
+  // There is a race here because we may stop a child thread before
+  // it is actually running the busy loop. Empirically this sleep
+  // is sufficient to avoid the race.
+  usleep(100000);
+  return child_pid;
+}
+
+typedef wasteful_vector<uint8_t> id_vector;
 typedef testing::Test LinuxPtraceDumperTest;
 
 /* Fixture for running tests in a child process. */
@@ -86,8 +144,8 @@ class LinuxPtraceDumperChildTest : public testing::Test {
     if (child_pid_ == 0) {
       // child process
       RealTestBody();
-      exit(HasFatalFailure() ? kFatalFailure :
-           (HasNonfatalFailure() ? kNonFatalFailure : 0));
+      _exit(HasFatalFailure() ? kFatalFailure :
+            (HasNonfatalFailure() ? kNonFatalFailure : 0));
     }
 
     ASSERT_TRUE(child_pid_ > 0);
@@ -105,11 +163,17 @@ class LinuxPtraceDumperChildTest : public testing::Test {
    * This is achieved by defining a TestBody macro further below.
    */
   virtual void RealTestBody() = 0;
+
+  id_vector make_vector() {
+    return id_vector(&allocator, kDefaultBuildIdSize);
+  }
+
  private:
   static const int kFatalFailure = 1;
   static const int kNonFatalFailure = 2;
 
   pid_t child_pid_;
+  PageAllocator allocator;
 };
 
 }  // namespace
@@ -186,7 +250,7 @@ void LinuxPtraceDumperMappingsTest::SetUp() {
   helper_path_ = GetHelperBinary();
   if (helper_path_.empty()) {
     FAIL() << "Couldn't find helper binary";
-    exit(1);
+    _exit(1);
   }
 
   // mmap two segments out of the helper binary, one
@@ -273,7 +337,7 @@ TEST_F(LinuxPtraceDumperChildTest, MappingsIncludeLinuxGate) {
   ASSERT_TRUE(dumper.Init());
 
   void* linux_gate_loc =
-    reinterpret_cast<void *>(dumper.auxv()[AT_SYSINFO_EHDR]);
+    reinterpret_cast<void*>(dumper.auxv()[AT_SYSINFO_EHDR]);
   ASSERT_TRUE(linux_gate_loc);
   bool found_linux_gate = false;
 
@@ -310,14 +374,15 @@ TEST_F(LinuxPtraceDumperChildTest, LinuxGateMappingID) {
 
   // Need to suspend the child so ptrace actually works.
   ASSERT_TRUE(dumper.ThreadsSuspend());
-  uint8_t identifier[sizeof(MDGUID)];
+  id_vector identifier(make_vector());
   ASSERT_TRUE(dumper.ElfFileIdentifierForMapping(*mappings[index],
                                                  true,
                                                  index,
                                                  identifier));
-  uint8_t empty_identifier[sizeof(MDGUID)];
-  memset(empty_identifier, 0, sizeof(empty_identifier));
-  EXPECT_NE(0, memcmp(empty_identifier, identifier, sizeof(identifier)));
+
+  id_vector empty_identifier(make_vector());
+  empty_identifier.resize(kDefaultBuildIdSize, 0);
+  EXPECT_NE(empty_identifier, identifier);
   EXPECT_TRUE(dumper.ThreadsResume());
 }
 #endif
@@ -343,86 +408,41 @@ TEST_F(LinuxPtraceDumperChildTest, FileIDsMatch) {
   }
   ASSERT_TRUE(found_exe);
 
-  uint8_t identifier1[sizeof(MDGUID)];
-  uint8_t identifier2[sizeof(MDGUID)];
+  id_vector identifier1(make_vector());
+  id_vector identifier2(make_vector());
   EXPECT_TRUE(dumper.ElfFileIdentifierForMapping(*mappings[i], true, i,
                                                  identifier1));
   FileID fileid(exe_name);
   EXPECT_TRUE(fileid.ElfFileIdentifier(identifier2));
-  char identifier_string1[37];
-  char identifier_string2[37];
-  FileID::ConvertIdentifierToString(identifier1, identifier_string1,
-                                    37);
-  FileID::ConvertIdentifierToString(identifier2, identifier_string2,
-                                    37);
-  EXPECT_STREQ(identifier_string1, identifier_string2);
+
+  string identifier_string1 =
+      FileID::ConvertIdentifierToUUIDString(identifier1);
+  string identifier_string2 =
+      FileID::ConvertIdentifierToUUIDString(identifier2);
+  EXPECT_EQ(identifier_string1, identifier_string2);
 }
 
 /* Get back to normal behavior of TEST*() macros wrt TestBody. */
 #undef TestBody
 
 TEST(LinuxPtraceDumperTest, VerifyStackReadWithMultipleThreads) {
-  static const int kNumberOfThreadsInHelperProgram = 5;
-  char kNumberOfThreadsArgument[2];
-  sprintf(kNumberOfThreadsArgument, "%d", kNumberOfThreadsInHelperProgram);
+  static const size_t kNumberOfThreadsInHelperProgram = 5;
 
-  int fds[2];
-  ASSERT_NE(-1, pipe(fds));
-
-  pid_t child_pid = fork();
-  if (child_pid == 0) {
-    // In child process.
-    close(fds[0]);
-
-    string helper_path(GetHelperBinary());
-    if (helper_path.empty()) {
-      FAIL() << "Couldn't find helper binary";
-      exit(1);
-    }
-
-    // Pass the pipe fd and the number of threads as arguments.
-    char pipe_fd_string[8];
-    sprintf(pipe_fd_string, "%d", fds[1]);
-    execl(helper_path.c_str(),
-          "linux_dumper_unittest_helper",
-          pipe_fd_string,
-          kNumberOfThreadsArgument,
-          NULL);
-    // Kill if we get here.
-    printf("Errno from exec: %d", errno);
-    FAIL() << "Exec of " << helper_path << " failed: " << strerror(errno);
-    exit(0);
-  }
-  close(fds[1]);
-
-  // Wait for all child threads to indicate that they have started
-  for (int threads = 0; threads < kNumberOfThreadsInHelperProgram; threads++) {
-    struct pollfd pfd;
-    memset(&pfd, 0, sizeof(pfd));
-    pfd.fd = fds[0];
-    pfd.events = POLLIN | POLLERR;
-
-    const int r = HANDLE_EINTR(poll(&pfd, 1, 1000));
-    ASSERT_EQ(1, r);
-    ASSERT_TRUE(pfd.revents & POLLIN);
-    uint8_t junk;
-    ASSERT_EQ(read(fds[0], &junk, sizeof(junk)),
-              static_cast<ssize_t>(sizeof(junk)));
-  }
-  close(fds[0]);
-
-  // There is a race here because we may stop a child thread before
-  // it is actually running the busy loop. Empirically this sleep
-  // is sufficient to avoid the race.
-  usleep(100000);
+  pid_t child_pid = SetupChildProcess(kNumberOfThreadsInHelperProgram);
+  ASSERT_NE(child_pid, -1);
 
   // Children are ready now.
   LinuxPtraceDumper dumper(child_pid);
   ASSERT_TRUE(dumper.Init());
-  EXPECT_EQ((size_t)kNumberOfThreadsInHelperProgram, dumper.threads().size());
+#if defined(THREAD_SANITIZER)
+  EXPECT_GE(dumper.threads().size(), (size_t)kNumberOfThreadsInHelperProgram);
+#else
+  EXPECT_EQ(dumper.threads().size(), (size_t)kNumberOfThreadsInHelperProgram);
+#endif
   EXPECT_TRUE(dumper.ThreadsSuspend());
 
   ThreadInfo one_thread;
+  size_t matching_threads = 0;
   for (size_t i = 0; i < dumper.threads().size(); ++i) {
     EXPECT_TRUE(dumper.GetThreadInfoByIndex(i, &one_thread));
     const void* stack;
@@ -433,13 +453,15 @@ TEST(LinuxPtraceDumperTest, VerifyStackReadWithMultipleThreads) {
     // specific register. Check that we can recover its value.
 #if defined(__ARM_EABI__)
     pid_t* process_tid_location = (pid_t*)(one_thread.regs.uregs[3]);
+#elif defined(__aarch64__)
+    pid_t* process_tid_location = (pid_t*)(one_thread.regs.regs[3]);
 #elif defined(__i386)
     pid_t* process_tid_location = (pid_t*)(one_thread.regs.ecx);
 #elif defined(__x86_64)
     pid_t* process_tid_location = (pid_t*)(one_thread.regs.rcx);
 #elif defined(__mips__)
     pid_t* process_tid_location =
-        reinterpret_cast<pid_t*>(one_thread.regs.regs[1]);
+        reinterpret_cast<pid_t*>(one_thread.mcontext.gregs[1]);
 #else
 #error This test has not been ported to this platform.
 #endif
@@ -448,8 +470,9 @@ TEST(LinuxPtraceDumperTest, VerifyStackReadWithMultipleThreads) {
                            dumper.threads()[i],
                            process_tid_location,
                            4);
-    EXPECT_EQ(dumper.threads()[i], one_thread_id);
+    matching_threads += (dumper.threads()[i] == one_thread_id) ? 1 : 0;
   }
+  EXPECT_EQ(matching_threads, kNumberOfThreadsInHelperProgram);
   EXPECT_TRUE(dumper.ThreadsResume());
   kill(child_pid, SIGKILL);
 
@@ -459,3 +482,99 @@ TEST(LinuxPtraceDumperTest, VerifyStackReadWithMultipleThreads) {
   ASSERT_TRUE(WIFSIGNALED(status));
   ASSERT_EQ(SIGKILL, WTERMSIG(status));
 }
+
+TEST_F(LinuxPtraceDumperTest, SanitizeStackCopy) {
+  static const size_t kNumberOfThreadsInHelperProgram = 1;
+
+  pid_t child_pid = SetupChildProcess(kNumberOfThreadsInHelperProgram);
+  ASSERT_NE(child_pid, -1);
+
+  LinuxPtraceDumper dumper(child_pid);
+  ASSERT_TRUE(dumper.Init());
+  EXPECT_TRUE(dumper.ThreadsSuspend());
+
+  ThreadInfo thread_info;
+  EXPECT_TRUE(dumper.GetThreadInfoByIndex(0, &thread_info));
+
+  const uintptr_t defaced =
+#if defined(__LP64__)
+      0x0defaced0defaced;
+#else
+      0x0defaced;
+#endif
+
+  uintptr_t simulated_stack[2];
+
+  // Pointers into the stack shouldn't be sanitized.
+  memset(simulated_stack, 0xff, sizeof(simulated_stack));
+  simulated_stack[1] = thread_info.stack_pointer;
+  dumper.SanitizeStackCopy(reinterpret_cast<uint8_t*>(&simulated_stack),
+                           sizeof(simulated_stack), thread_info.stack_pointer,
+                           sizeof(uintptr_t));
+  ASSERT_NE(simulated_stack[1], defaced);
+
+  // Memory prior to the stack pointer should be cleared.
+  ASSERT_EQ(simulated_stack[0], 0u);
+
+  // Small integers should not be sanitized.
+  for (int i = -4096; i <= 4096; ++i) {
+    memset(simulated_stack, 0, sizeof(simulated_stack));
+    simulated_stack[0] = static_cast<uintptr_t>(i);
+    dumper.SanitizeStackCopy(reinterpret_cast<uint8_t*>(&simulated_stack),
+                             sizeof(simulated_stack), thread_info.stack_pointer,
+                             0u);
+    ASSERT_NE(simulated_stack[0], defaced);
+  }
+
+  // The instruction pointer definitely should point into an executable mapping.
+  const MappingInfo* mapping_info = dumper.FindMappingNoBias(
+      reinterpret_cast<uintptr_t>(thread_info.GetInstructionPointer()));
+  ASSERT_NE(mapping_info, nullptr);
+  ASSERT_TRUE(mapping_info->exec);
+
+  // Pointers to code shouldn't be sanitized.
+  memset(simulated_stack, 0, sizeof(simulated_stack));
+  simulated_stack[1] = thread_info.GetInstructionPointer();
+  dumper.SanitizeStackCopy(reinterpret_cast<uint8_t*>(&simulated_stack),
+                           sizeof(simulated_stack), thread_info.stack_pointer,
+                           0u);
+  ASSERT_NE(simulated_stack[0], defaced);
+
+  // String fragments should be sanitized.
+  memcpy(simulated_stack, "abcdefghijklmnop", sizeof(simulated_stack));
+  dumper.SanitizeStackCopy(reinterpret_cast<uint8_t*>(&simulated_stack),
+                           sizeof(simulated_stack), thread_info.stack_pointer,
+                           0u);
+  ASSERT_EQ(simulated_stack[0], defaced);
+  ASSERT_EQ(simulated_stack[1], defaced);
+
+  // Heap pointers should be sanititzed.
+#if defined(__ARM_EABI__)
+  uintptr_t heap_addr = thread_info.regs.uregs[3];
+#elif defined(__aarch64__)
+  uintptr_t heap_addr = thread_info.regs.regs[3];
+#elif defined(__i386)
+  uintptr_t heap_addr = thread_info.regs.ecx;
+#elif defined(__x86_64)
+  uintptr_t heap_addr = thread_info.regs.rcx;
+#elif defined(__mips__)
+  uintptr_t heap_addr = thread_info.mcontext.gregs[1];
+#else
+#error This test has not been ported to this platform.
+#endif
+  memset(simulated_stack, 0, sizeof(simulated_stack));
+  simulated_stack[0] = heap_addr;
+  dumper.SanitizeStackCopy(reinterpret_cast<uint8_t*>(&simulated_stack),
+                           sizeof(simulated_stack), thread_info.stack_pointer,
+                           0u);
+  ASSERT_EQ(simulated_stack[0], defaced);
+
+  EXPECT_TRUE(dumper.ThreadsResume());
+  kill(child_pid, SIGKILL);
+
+  // Reap child.
+  int status;
+  ASSERT_NE(-1, HANDLE_EINTR(waitpid(child_pid, &status, 0)));
+  ASSERT_TRUE(WIFSIGNALED(status));
+  ASSERT_EQ(SIGKILL, WTERMSIG(status));
+}
diff --git a/src/MEGASync/google_breakpad/client/linux/minidump_writer/minidump_writer.cc b/src/MEGASync/google_breakpad/client/linux/minidump_writer/minidump_writer.cc
index 1276db54..32634ef0 100644
--- a/src/MEGASync/google_breakpad/client/linux/minidump_writer/minidump_writer.cc
+++ b/src/MEGASync/google_breakpad/client/linux/minidump_writer/minidump_writer.cc
@@ -59,10 +59,13 @@
 #include <sys/ucontext.h>
 #include <sys/user.h>
 #include <sys/utsname.h>
+#include <time.h>
 #include <unistd.h>
 
 #include <algorithm>
 
+#include "client/linux/dump_writer_common/thread_info.h"
+#include "client/linux/dump_writer_common/ucontext_reader.h"
 #include "client/linux/handler/exception_handler.h"
 #include "client/linux/minidump_writer/cpu_set.h"
 #include "client/linux/minidump_writer/line_reader.h"
@@ -70,378 +73,38 @@
 #include "client/linux/minidump_writer/linux_ptrace_dumper.h"
 #include "client/linux/minidump_writer/proc_cpuinfo_reader.h"
 #include "client/minidump_file_writer.h"
+#include "common/linux/file_id.h"
 #include "common/linux/linux_libc_support.h"
+#include "common/minidump_type_helper.h"
 #include "google_breakpad/common/minidump_format.h"
 #include "third_party/lss/linux_syscall_support.h"
 
 namespace {
 
 using google_breakpad::AppMemoryList;
+using google_breakpad::auto_wasteful_vector;
 using google_breakpad::ExceptionHandler;
 using google_breakpad::CpuSet;
+using google_breakpad::kDefaultBuildIdSize;
 using google_breakpad::LineReader;
 using google_breakpad::LinuxDumper;
 using google_breakpad::LinuxPtraceDumper;
+using google_breakpad::MDTypeHelper;
 using google_breakpad::MappingEntry;
 using google_breakpad::MappingInfo;
 using google_breakpad::MappingList;
 using google_breakpad::MinidumpFileWriter;
 using google_breakpad::PageAllocator;
 using google_breakpad::ProcCpuInfoReader;
+using google_breakpad::RawContextCPU;
 using google_breakpad::ThreadInfo;
 using google_breakpad::TypedMDRVA;
+using google_breakpad::UContextReader;
 using google_breakpad::UntypedMDRVA;
 using google_breakpad::wasteful_vector;
 
-// Minidump defines register structures which are different from the raw
-// structures which we get from the kernel. These are platform specific
-// functions to juggle the ucontext and user structures into minidump format.
-#if defined(__i386__)
-typedef MDRawContextX86 RawContextCPU;
-
-// Write a uint16_t to memory
-//   out: memory location to write to
-//   v: value to write.
-void U16(void* out, uint16_t v) {
-  my_memcpy(out, &v, sizeof(v));
-}
-
-// Write a uint32_t to memory
-//   out: memory location to write to
-//   v: value to write.
-void U32(void* out, uint32_t v) {
-  my_memcpy(out, &v, sizeof(v));
-}
-
-// Juggle an x86 user_(fp|fpx|)regs_struct into minidump format
-//   out: the minidump structure
-//   info: the collection of register structures.
-void CPUFillFromThreadInfo(MDRawContextX86 *out,
-                           const google_breakpad::ThreadInfo &info) {
-  out->context_flags = MD_CONTEXT_X86_ALL;
-
-  out->dr0 = info.dregs[0];
-  out->dr1 = info.dregs[1];
-  out->dr2 = info.dregs[2];
-  out->dr3 = info.dregs[3];
-  // 4 and 5 deliberatly omitted because they aren't included in the minidump
-  // format.
-  out->dr6 = info.dregs[6];
-  out->dr7 = info.dregs[7];
-
-  out->gs = info.regs.xgs;
-  out->fs = info.regs.xfs;
-  out->es = info.regs.xes;
-  out->ds = info.regs.xds;
-
-  out->edi = info.regs.edi;
-  out->esi = info.regs.esi;
-  out->ebx = info.regs.ebx;
-  out->edx = info.regs.edx;
-  out->ecx = info.regs.ecx;
-  out->eax = info.regs.eax;
-
-  out->ebp = info.regs.ebp;
-  out->eip = info.regs.eip;
-  out->cs = info.regs.xcs;
-  out->eflags = info.regs.eflags;
-  out->esp = info.regs.esp;
-  out->ss = info.regs.xss;
-
-  out->float_save.control_word = info.fpregs.cwd;
-  out->float_save.status_word = info.fpregs.swd;
-  out->float_save.tag_word = info.fpregs.twd;
-  out->float_save.error_offset = info.fpregs.fip;
-  out->float_save.error_selector = info.fpregs.fcs;
-  out->float_save.data_offset = info.fpregs.foo;
-  out->float_save.data_selector = info.fpregs.fos;
-
-  // 8 registers * 10 bytes per register.
-  my_memcpy(out->float_save.register_area, info.fpregs.st_space, 10 * 8);
-
-  // This matches the Intel fpsave format.
-  U16(out->extended_registers + 0, info.fpregs.cwd);
-  U16(out->extended_registers + 2, info.fpregs.swd);
-  U16(out->extended_registers + 4, info.fpregs.twd);
-  U16(out->extended_registers + 6, info.fpxregs.fop);
-  U32(out->extended_registers + 8, info.fpxregs.fip);
-  U16(out->extended_registers + 12, info.fpxregs.fcs);
-  U32(out->extended_registers + 16, info.fpregs.foo);
-  U16(out->extended_registers + 20, info.fpregs.fos);
-  U32(out->extended_registers + 24, info.fpxregs.mxcsr);
-
-  my_memcpy(out->extended_registers + 32, &info.fpxregs.st_space, 128);
-  my_memcpy(out->extended_registers + 160, &info.fpxregs.xmm_space, 128);
-}
-
-// Juggle an x86 ucontext into minidump format
-//   out: the minidump structure
-//   info: the collection of register structures.
-void CPUFillFromUContext(MDRawContextX86 *out, const ucontext_t *uc,
-                         const struct _libc_fpstate* fp) {
-  const greg_t* regs = uc->uc_mcontext.gregs;
-
-  out->context_flags = MD_CONTEXT_X86_FULL |
-                       MD_CONTEXT_X86_FLOATING_POINT;
-
-  out->gs = regs[REG_GS];
-  out->fs = regs[REG_FS];
-  out->es = regs[REG_ES];
-  out->ds = regs[REG_DS];
-
-  out->edi = regs[REG_EDI];
-  out->esi = regs[REG_ESI];
-  out->ebx = regs[REG_EBX];
-  out->edx = regs[REG_EDX];
-  out->ecx = regs[REG_ECX];
-  out->eax = regs[REG_EAX];
-
-  out->ebp = regs[REG_EBP];
-  out->eip = regs[REG_EIP];
-  out->cs = regs[REG_CS];
-  out->eflags = regs[REG_EFL];
-  out->esp = regs[REG_UESP];
-  out->ss = regs[REG_SS];
-
-  out->float_save.control_word = fp->cw;
-  out->float_save.status_word = fp->sw;
-  out->float_save.tag_word = fp->tag;
-  out->float_save.error_offset = fp->ipoff;
-  out->float_save.error_selector = fp->cssel;
-  out->float_save.data_offset = fp->dataoff;
-  out->float_save.data_selector = fp->datasel;
-
-  // 8 registers * 10 bytes per register.
-  my_memcpy(out->float_save.register_area, fp->_st, 10 * 8);
-}
-
-#elif defined(__x86_64)
-typedef MDRawContextAMD64 RawContextCPU;
-
-void CPUFillFromThreadInfo(MDRawContextAMD64 *out,
-                           const google_breakpad::ThreadInfo &info) {
-  out->context_flags = MD_CONTEXT_AMD64_FULL |
-                       MD_CONTEXT_AMD64_SEGMENTS;
-
-  out->cs = info.regs.cs;
-
-  out->ds = info.regs.ds;
-  out->es = info.regs.es;
-  out->fs = info.regs.fs;
-  out->gs = info.regs.gs;
-
-  out->ss = info.regs.ss;
-  out->eflags = info.regs.eflags;
-
-  out->dr0 = info.dregs[0];
-  out->dr1 = info.dregs[1];
-  out->dr2 = info.dregs[2];
-  out->dr3 = info.dregs[3];
-  // 4 and 5 deliberatly omitted because they aren't included in the minidump
-  // format.
-  out->dr6 = info.dregs[6];
-  out->dr7 = info.dregs[7];
-
-  out->rax = info.regs.rax;
-  out->rcx = info.regs.rcx;
-  out->rdx = info.regs.rdx;
-  out->rbx = info.regs.rbx;
-
-  out->rsp = info.regs.rsp;
-
-  out->rbp = info.regs.rbp;
-  out->rsi = info.regs.rsi;
-  out->rdi = info.regs.rdi;
-  out->r8 = info.regs.r8;
-  out->r9 = info.regs.r9;
-  out->r10 = info.regs.r10;
-  out->r11 = info.regs.r11;
-  out->r12 = info.regs.r12;
-  out->r13 = info.regs.r13;
-  out->r14 = info.regs.r14;
-  out->r15 = info.regs.r15;
-
-  out->rip = info.regs.rip;
-
-  out->flt_save.control_word = info.fpregs.cwd;
-  out->flt_save.status_word = info.fpregs.swd;
-  out->flt_save.tag_word = info.fpregs.ftw;
-  out->flt_save.error_opcode = info.fpregs.fop;
-  out->flt_save.error_offset = info.fpregs.rip;
-  out->flt_save.error_selector = 0;  // We don't have this.
-  out->flt_save.data_offset = info.fpregs.rdp;
-  out->flt_save.data_selector = 0;   // We don't have this.
-  out->flt_save.mx_csr = info.fpregs.mxcsr;
-  out->flt_save.mx_csr_mask = info.fpregs.mxcr_mask;
-  my_memcpy(&out->flt_save.float_registers, &info.fpregs.st_space, 8 * 16);
-  my_memcpy(&out->flt_save.xmm_registers, &info.fpregs.xmm_space, 16 * 16);
-}
-
-void CPUFillFromUContext(MDRawContextAMD64 *out, const ucontext_t *uc,
-                         const struct _libc_fpstate* fpregs) {
-  const greg_t* regs = uc->uc_mcontext.gregs;
-
-  out->context_flags = MD_CONTEXT_AMD64_FULL;
-
-  out->cs = regs[REG_CSGSFS] & 0xffff;
-
-  out->fs = (regs[REG_CSGSFS] >> 32) & 0xffff;
-  out->gs = (regs[REG_CSGSFS] >> 16) & 0xffff;
-
-  out->eflags = regs[REG_EFL];
-
-  out->rax = regs[REG_RAX];
-  out->rcx = regs[REG_RCX];
-  out->rdx = regs[REG_RDX];
-  out->rbx = regs[REG_RBX];
-
-  out->rsp = regs[REG_RSP];
-  out->rbp = regs[REG_RBP];
-  out->rsi = regs[REG_RSI];
-  out->rdi = regs[REG_RDI];
-  out->r8 = regs[REG_R8];
-  out->r9 = regs[REG_R9];
-  out->r10 = regs[REG_R10];
-  out->r11 = regs[REG_R11];
-  out->r12 = regs[REG_R12];
-  out->r13 = regs[REG_R13];
-  out->r14 = regs[REG_R14];
-  out->r15 = regs[REG_R15];
-
-  out->rip = regs[REG_RIP];
-
-  out->flt_save.control_word = fpregs->cwd;
-  out->flt_save.status_word = fpregs->swd;
-  out->flt_save.tag_word = fpregs->ftw;
-  out->flt_save.error_opcode = fpregs->fop;
-  out->flt_save.error_offset = fpregs->rip;
-  out->flt_save.data_offset = fpregs->rdp;
-  out->flt_save.error_selector = 0;  // We don't have this.
-  out->flt_save.data_selector = 0;  // We don't have this.
-  out->flt_save.mx_csr = fpregs->mxcsr;
-  out->flt_save.mx_csr_mask = fpregs->mxcr_mask;
-  my_memcpy(&out->flt_save.float_registers, &fpregs->_st, 8 * 16);
-  my_memcpy(&out->flt_save.xmm_registers, &fpregs->_xmm, 16 * 16);
-}
-
-#elif defined(__ARMEL__)
-typedef MDRawContextARM RawContextCPU;
-
-void CPUFillFromThreadInfo(MDRawContextARM* out,
-                           const google_breakpad::ThreadInfo& info) {
-  out->context_flags = MD_CONTEXT_ARM_FULL;
-
-  for (int i = 0; i < MD_CONTEXT_ARM_GPR_COUNT; ++i)
-    out->iregs[i] = info.regs.uregs[i];
-  // No CPSR register in ThreadInfo(it's not accessible via ptrace)
-  out->cpsr = 0;
-#if !defined(__ANDROID__)
-  out->float_save.fpscr = info.fpregs.fpsr |
-    (static_cast<uint64_t>(info.fpregs.fpcr) << 32);
-  // TODO: sort this out, actually collect floating point registers
-  my_memset(&out->float_save.regs, 0, sizeof(out->float_save.regs));
-  my_memset(&out->float_save.extra, 0, sizeof(out->float_save.extra));
-#endif
-}
-
-void CPUFillFromUContext(MDRawContextARM* out, const ucontext_t* uc,
-                         const struct _libc_fpstate* fpregs) {
-  out->context_flags = MD_CONTEXT_ARM_FULL;
-
-  out->iregs[0] = uc->uc_mcontext.arm_r0;
-  out->iregs[1] = uc->uc_mcontext.arm_r1;
-  out->iregs[2] = uc->uc_mcontext.arm_r2;
-  out->iregs[3] = uc->uc_mcontext.arm_r3;
-  out->iregs[4] = uc->uc_mcontext.arm_r4;
-  out->iregs[5] = uc->uc_mcontext.arm_r5;
-  out->iregs[6] = uc->uc_mcontext.arm_r6;
-  out->iregs[7] = uc->uc_mcontext.arm_r7;
-  out->iregs[8] = uc->uc_mcontext.arm_r8;
-  out->iregs[9] = uc->uc_mcontext.arm_r9;
-  out->iregs[10] = uc->uc_mcontext.arm_r10;
-
-  out->iregs[11] = uc->uc_mcontext.arm_fp;
-  out->iregs[12] = uc->uc_mcontext.arm_ip;
-  out->iregs[13] = uc->uc_mcontext.arm_sp;
-  out->iregs[14] = uc->uc_mcontext.arm_lr;
-  out->iregs[15] = uc->uc_mcontext.arm_pc;
-
-  out->cpsr = uc->uc_mcontext.arm_cpsr;
-
-  // TODO: fix this after fixing ExceptionHandler
-  out->float_save.fpscr = 0;
-  my_memset(&out->float_save.regs, 0, sizeof(out->float_save.regs));
-  my_memset(&out->float_save.extra, 0, sizeof(out->float_save.extra));
-}
-
-#elif defined(__mips__)
-typedef MDRawContextMIPS RawContextCPU;
-
-static void CPUFillFromThreadInfo(MDRawContextMIPS* out,
-                                  const google_breakpad::ThreadInfo& info) {
-  out->context_flags = MD_CONTEXT_MIPS_FULL;
-
-  for (int i = 0; i < MD_CONTEXT_MIPS_GPR_COUNT; ++i)
-    out->iregs[i] = info.regs.regs[i];
-
-  out->mdhi = info.regs.hi;
-  out->mdlo = info.regs.lo;
-
-  for (int i = 0; i < MD_CONTEXT_MIPS_DSP_COUNT; ++i) {
-    out->hi[i] = info.hi[i];
-    out->lo[i] = info.lo[i];
-  }
-  out->dsp_control = info.dsp_control;
-
-  out->epc = info.regs.epc;
-  out->badvaddr = info.regs.badvaddr;
-  out->status = info.regs.status;
-  out->cause = info.regs.cause;
-
-  for (int i = 0; i < MD_FLOATINGSAVEAREA_MIPS_FPR_COUNT; ++i)
-    out->float_save.regs[i] = info.fpregs.regs[i];
-
-  out->float_save.fpcsr = info.fpregs.fpcsr;
-  out->float_save.fir = info.fpregs.fir;
-}
-
-static void CPUFillFromUContext(MDRawContextMIPS* out, const ucontext_t* uc,
-                                const struct _libc_fpstate* fpregs) {
-  out->context_flags = MD_CONTEXT_MIPS_FULL;
-
-  for (int i = 0; i < MD_CONTEXT_MIPS_GPR_COUNT; ++i)
-    out->iregs[i] = uc->uc_mcontext.gregs[i];
-
-  out->mdhi = uc->uc_mcontext.mdhi;
-  out->mdlo = uc->uc_mcontext.mdlo;
-
-  out->hi[0] = uc->uc_mcontext.hi1;
-  out->hi[1] = uc->uc_mcontext.hi2;
-  out->hi[2] = uc->uc_mcontext.hi3;
-  out->lo[0] = uc->uc_mcontext.lo1;
-  out->lo[1] = uc->uc_mcontext.lo2;
-  out->lo[2] = uc->uc_mcontext.lo3;
-  out->dsp_control = uc->uc_mcontext.dsp;
-
-  out->epc = uc->uc_mcontext.pc;
-  out->badvaddr = 0;  // Not reported in signal context.
-  out->status = 0;  // Not reported in signal context.
-  out->cause = 0;  // Not reported in signal context.
-
-  for (int i = 0; i < MD_FLOATINGSAVEAREA_MIPS_FPR_COUNT; ++i)
-#if defined (__ANDROID__)
-    out->float_save.regs[i] = uc->uc_mcontext.fpregs[i];
-#else
-    out->float_save.regs[i] = uc->uc_mcontext.fpregs.fp_r.fp_dregs[i];
-#endif
-
-  out->float_save.fpcsr = uc->uc_mcontext.fpc_csr;
-  out->float_save.fir = uc->uc_mcontext.fpc_eir;  // Unused.
-}
-
-#else
-#error "This code has not been ported to your platform yet."
-#endif
+typedef MDTypeHelper<sizeof(void*)>::MDRawDebug MDRawDebug;
+typedef MDTypeHelper<sizeof(void*)>::MDRawLinkMap MDRawLinkMap;
 
 class MinidumpWriter {
  public:
@@ -466,21 +129,26 @@ class MinidumpWriter {
                  const ExceptionHandler::CrashContext* context,
                  const MappingList& mappings,
                  const AppMemoryList& appmem,
+                 bool skip_stacks_if_mapping_unreferenced,
+                 uintptr_t principal_mapping_address,
+                 bool sanitize_stacks,
                  LinuxDumper* dumper)
       : fd_(minidump_fd),
         path_(minidump_path),
         ucontext_(context ? &context->context : NULL),
 #if !defined(__ARM_EABI__) && !defined(__mips__)
         float_state_(context ? &context->float_state : NULL),
-#else
-        // TODO: fix this after fixing ExceptionHandler
-        float_state_(NULL),
 #endif
         dumper_(dumper),
         minidump_size_limit_(-1),
         memory_blocks_(dumper_->allocator()),
         mapping_list_(mappings),
-        app_memory_list_(appmem) {
+        app_memory_list_(appmem),
+        skip_stacks_if_mapping_unreferenced_(
+            skip_stacks_if_mapping_unreferenced),
+        principal_mapping_address_(principal_mapping_address),
+        principal_mapping_(nullptr),
+    sanitize_stacks_(sanitize_stacks) {
     // Assert there should be either a valid fd or a valid path, not both.
     assert(fd_ != -1 || minidump_path);
     assert(fd_ == -1 || !minidump_path);
@@ -490,12 +158,22 @@ class MinidumpWriter {
     if (!dumper_->Init())
       return false;
 
+    if (!dumper_->ThreadsSuspend() || !dumper_->LateInit())
+      return false;
+
+    if (skip_stacks_if_mapping_unreferenced_) {
+      principal_mapping_ =
+          dumper_->FindMappingNoBias(principal_mapping_address_);
+      if (!CrashingThreadReferencesPrincipalMapping())
+        return false;
+    }
+
     if (fd_ != -1)
       minidump_writer_.SetFile(fd_);
     else if (!minidump_writer_.Open(path_))
       return false;
 
-    return dumper_->ThreadsSuspend();
+    return true;
   }
 
   ~MinidumpWriter() {
@@ -506,24 +184,63 @@ class MinidumpWriter {
     dumper_->ThreadsResume();
   }
 
+  bool CrashingThreadReferencesPrincipalMapping() {
+    if (!ucontext_ || !principal_mapping_)
+      return false;
+
+    const uintptr_t low_addr =
+        principal_mapping_->system_mapping_info.start_addr;
+    const uintptr_t high_addr =
+        principal_mapping_->system_mapping_info.end_addr;
+
+    const uintptr_t stack_pointer = UContextReader::GetStackPointer(ucontext_);
+    const uintptr_t pc = UContextReader::GetInstructionPointer(ucontext_);
+
+    if (pc >= low_addr && pc < high_addr)
+      return true;
+
+    uint8_t* stack_copy;
+    const void* stack;
+    size_t stack_len;
+
+    if (!dumper_->GetStackInfo(&stack, &stack_len, stack_pointer))
+      return false;
+
+    stack_copy = reinterpret_cast<uint8_t*>(Alloc(stack_len));
+    dumper_->CopyFromProcess(stack_copy, GetCrashThread(), stack, stack_len);
+
+    uintptr_t stack_pointer_offset =
+        stack_pointer - reinterpret_cast<uintptr_t>(stack);
+
+    return dumper_->StackHasPointerToMapping(
+        stack_copy, stack_len, stack_pointer_offset, *principal_mapping_);
+  }
+
   bool Dump() {
     // A minidump file contains a number of tagged streams. This is the number
     // of stream which we write.
     unsigned kNumWriters = 13;
 
-    TypedMDRVA<MDRawHeader> header(&minidump_writer_);
     TypedMDRVA<MDRawDirectory> dir(&minidump_writer_);
-    if (!header.Allocate())
-      return false;
-    if (!dir.AllocateArray(kNumWriters))
-      return false;
-    my_memset(header.get(), 0, sizeof(MDRawHeader));
+    {
+      // Ensure the header gets flushed, as that happens in the destructor.
+      // If a crash occurs somewhere below, at least the header will be
+      // intact.
+      TypedMDRVA<MDRawHeader> header(&minidump_writer_);
+      if (!header.Allocate())
+        return false;
 
-    header.get()->signature = MD_HEADER_SIGNATURE;
-    header.get()->version = MD_HEADER_VERSION;
-    header.get()->time_date_stamp = time(NULL);
-    header.get()->stream_count = kNumWriters;
-    header.get()->stream_directory_rva = dir.position();
+      if (!dir.AllocateArray(kNumWriters))
+        return false;
+
+      my_memset(header.get(), 0, sizeof(MDRawHeader));
+
+      header.get()->signature = MD_HEADER_SIGNATURE;
+      header.get()->version = MD_HEADER_VERSION;
+      header.get()->time_date_stamp = time(NULL);
+      header.get()->stream_count = kNumWriters;
+      header.get()->stream_directory_rva = dir.position();
+    }
 
     unsigned dir_index = 0;
     MDRawDirectory dirent;
@@ -598,148 +315,61 @@ class MinidumpWriter {
     return true;
   }
 
-  // Check if the top of the stack is part of a system call that has been
-  // redirected by the seccomp sandbox. If so, try to pop the stack frames
-  // all the way back to the point where the interception happened.
-  void PopSeccompStackFrame(RawContextCPU* cpu, const MDRawThread& thread,
-                            uint8_t* stack_copy) {
-#if defined(__x86_64)
-    uint64_t bp = cpu->rbp;
-    uint64_t top = thread.stack.start_of_memory_range;
-    for (int i = 4; i--; ) {
-      if (bp < top ||
-          bp + sizeof(bp) > thread.stack.start_of_memory_range +
-          thread.stack.memory.data_size ||
-          bp & 1) {
-        break;
-      }
-      uint64_t old_top = top;
-      top = bp;
-      uint8_t* bp_addr = stack_copy + bp - thread.stack.start_of_memory_range;
-      my_memcpy(&bp, bp_addr, sizeof(bp));
-      if (bp == 0xDEADBEEFDEADBEEFull) {
-        struct {
-          uint64_t r15;
-          uint64_t r14;
-          uint64_t r13;
-          uint64_t r12;
-          uint64_t r11;
-          uint64_t r10;
-          uint64_t r9;
-          uint64_t r8;
-          uint64_t rdi;
-          uint64_t rsi;
-          uint64_t rdx;
-          uint64_t rcx;
-          uint64_t rbx;
-          uint64_t deadbeef;
-          uint64_t rbp;
-          uint64_t fakeret;
-          uint64_t ret;
-          /* char redzone[128]; */
-        } seccomp_stackframe;
-        if (top - offsetof(TYPEOF(seccomp_stackframe), deadbeef) < old_top ||
-            top - offsetof(TYPEOF(seccomp_stackframe), deadbeef) +
-            sizeof(seccomp_stackframe) >
-            thread.stack.start_of_memory_range+thread.stack.memory.data_size) {
-          break;
-        }
-        my_memcpy(&seccomp_stackframe,
-                  bp_addr - offsetof(TYPEOF(seccomp_stackframe), deadbeef),
-                  sizeof(seccomp_stackframe));
-        cpu->rbx = seccomp_stackframe.rbx;
-        cpu->rcx = seccomp_stackframe.rcx;
-        cpu->rdx = seccomp_stackframe.rdx;
-        cpu->rsi = seccomp_stackframe.rsi;
-        cpu->rdi = seccomp_stackframe.rdi;
-        cpu->rbp = seccomp_stackframe.rbp;
-        cpu->rsp = top + 4*sizeof(uint64_t) + 128;
-        cpu->r8  = seccomp_stackframe.r8;
-        cpu->r9  = seccomp_stackframe.r9;
-        cpu->r10 = seccomp_stackframe.r10;
-        cpu->r11 = seccomp_stackframe.r11;
-        cpu->r12 = seccomp_stackframe.r12;
-        cpu->r13 = seccomp_stackframe.r13;
-        cpu->r14 = seccomp_stackframe.r14;
-        cpu->r15 = seccomp_stackframe.r15;
-        cpu->rip = seccomp_stackframe.fakeret;
-        return;
-      }
-    }
-#elif defined(__i386__)
-    uint32_t bp = cpu->ebp;
-    uint32_t top = thread.stack.start_of_memory_range;
-    for (int i = 4; i--; ) {
-      if (bp < top ||
-          bp + sizeof(bp) > thread.stack.start_of_memory_range +
-          thread.stack.memory.data_size ||
-          bp & 1) {
-        break;
-      }
-      uint32_t old_top = top;
-      top = bp;
-      uint8_t* bp_addr = stack_copy + bp - thread.stack.start_of_memory_range;
-      my_memcpy(&bp, bp_addr, sizeof(bp));
-      if (bp == 0xDEADBEEFu) {
-        struct {
-          uint32_t edi;
-          uint32_t esi;
-          uint32_t edx;
-          uint32_t ecx;
-          uint32_t ebx;
-          uint32_t deadbeef;
-          uint32_t ebp;
-          uint32_t fakeret;
-          uint32_t ret;
-        } seccomp_stackframe;
-        if (top - offsetof(TYPEOF(seccomp_stackframe), deadbeef) < old_top ||
-            top - offsetof(TYPEOF(seccomp_stackframe), deadbeef) +
-            sizeof(seccomp_stackframe) >
-            thread.stack.start_of_memory_range+thread.stack.memory.data_size) {
-          break;
-        }
-        my_memcpy(&seccomp_stackframe,
-                  bp_addr - offsetof(TYPEOF(seccomp_stackframe), deadbeef),
-                  sizeof(seccomp_stackframe));
-        cpu->ebx = seccomp_stackframe.ebx;
-        cpu->ecx = seccomp_stackframe.ecx;
-        cpu->edx = seccomp_stackframe.edx;
-        cpu->esi = seccomp_stackframe.esi;
-        cpu->edi = seccomp_stackframe.edi;
-        cpu->ebp = seccomp_stackframe.ebp;
-        cpu->esp = top + 4*sizeof(void*);
-        cpu->eip = seccomp_stackframe.fakeret;
-        return;
-      }
-    }
-#endif
-  }
-
   bool FillThreadStack(MDRawThread* thread, uintptr_t stack_pointer,
-                       int max_stack_len, uint8_t** stack_copy) {
+                       uintptr_t pc, int max_stack_len, uint8_t** stack_copy) {
     *stack_copy = NULL;
     const void* stack;
     size_t stack_len;
+
+    thread->stack.start_of_memory_range = stack_pointer;
+    thread->stack.memory.data_size = 0;
+    thread->stack.memory.rva = minidump_writer_.position();
+
     if (dumper_->GetStackInfo(&stack, &stack_len, stack_pointer)) {
-      UntypedMDRVA memory(&minidump_writer_);
       if (max_stack_len >= 0 &&
           stack_len > static_cast<unsigned int>(max_stack_len)) {
         stack_len = max_stack_len;
+        // Skip empty chunks of length max_stack_len.
+        uintptr_t int_stack = reinterpret_cast<uintptr_t>(stack);
+        if (max_stack_len > 0) {
+          while (int_stack + max_stack_len < stack_pointer) {
+            int_stack += max_stack_len;
+          }
+        }
+        stack = reinterpret_cast<const void*>(int_stack);
       }
-      if (!memory.Allocate(stack_len))
-        return false;
       *stack_copy = reinterpret_cast<uint8_t*>(Alloc(stack_len));
       dumper_->CopyFromProcess(*stack_copy, thread->thread_id, stack,
                                stack_len);
+
+      uintptr_t stack_pointer_offset =
+          stack_pointer - reinterpret_cast<uintptr_t>(stack);
+      if (skip_stacks_if_mapping_unreferenced_) {
+        if (!principal_mapping_) {
+          return true;
+        }
+        uintptr_t low_addr = principal_mapping_->system_mapping_info.start_addr;
+        uintptr_t high_addr = principal_mapping_->system_mapping_info.end_addr;
+        if ((pc < low_addr || pc > high_addr) &&
+            !dumper_->StackHasPointerToMapping(*stack_copy, stack_len,
+                                               stack_pointer_offset,
+                                               *principal_mapping_)) {
+          return true;
+        }
+      }
+
+      if (sanitize_stacks_) {
+        dumper_->SanitizeStackCopy(*stack_copy, stack_len, stack_pointer,
+                                   stack_pointer_offset);
+      }
+
+      UntypedMDRVA memory(&minidump_writer_);
+      if (!memory.Allocate(stack_len))
+        return false;
       memory.Copy(*stack_copy, stack_len);
-      thread->stack.start_of_memory_range =
-          reinterpret_cast<uintptr_t>(stack);
+      thread->stack.start_of_memory_range = reinterpret_cast<uintptr_t>(stack);
       thread->stack.memory = memory.location();
       memory_blocks_.push_back(thread->stack);
-    } else {
-      thread->stack.start_of_memory_range = stack_pointer;
-      thread->stack.memory.data_size = 0;
-      thread->stack.memory.rva = minidump_writer_.position();
     }
     return true;
   }
@@ -785,12 +415,15 @@ class MinidumpWriter {
           ucontext_ &&
           !dumper_->IsPostMortem()) {
         uint8_t* stack_copy;
-        if (!FillThreadStack(&thread, GetStackPointer(), -1, &stack_copy))
+        const uintptr_t stack_ptr = UContextReader::GetStackPointer(ucontext_);
+        if (!FillThreadStack(&thread, stack_ptr,
+                             UContextReader::GetInstructionPointer(ucontext_),
+                             -1, &stack_copy))
           return false;
 
         // Copy 256 bytes around crashing instruction pointer to minidump.
         const size_t kIPMemorySize = 256;
-        uint64_t ip = GetInstructionPointer();
+        uint64_t ip = UContextReader::GetInstructionPointer(ucontext_);
         // Bound it to the upper and lower bounds of the memory map
         // it's contained within. If it's not in mapped memory,
         // don't bother trying to write it.
@@ -835,9 +468,11 @@ class MinidumpWriter {
         if (!cpu.Allocate())
           return false;
         my_memset(cpu.get(), 0, sizeof(RawContextCPU));
-        CPUFillFromUContext(cpu.get(), ucontext_, float_state_);
-        if (stack_copy)
-          PopSeccompStackFrame(cpu.get(), thread, stack_copy);
+#if !defined(__ARM_EABI__) && !defined(__mips__)
+        UContextReader::FillCPUContext(cpu.get(), ucontext_, float_state_);
+#else
+        UContextReader::FillCPUContext(cpu.get(), ucontext_);
+#endif
         thread.thread_context = cpu.location();
         crashing_thread_context_ = cpu.location();
       } else {
@@ -849,17 +484,16 @@ class MinidumpWriter {
         int max_stack_len = -1;  // default to no maximum for this thread
         if (minidump_size_limit_ >= 0 && i >= kLimitBaseThreadCount)
           max_stack_len = extra_thread_stack_len;
-        if (!FillThreadStack(&thread, info.stack_pointer, max_stack_len,
-            &stack_copy))
+        if (!FillThreadStack(&thread, info.stack_pointer,
+                             info.GetInstructionPointer(), max_stack_len,
+                             &stack_copy))
           return false;
 
         TypedMDRVA<RawContextCPU> cpu(&minidump_writer_);
         if (!cpu.Allocate())
           return false;
         my_memset(cpu.get(), 0, sizeof(RawContextCPU));
-        CPUFillFromThreadInfo(cpu.get(), info);
-        if (stack_copy)
-          PopSeccompStackFrame(cpu.get(), thread, stack_copy);
+        info.FillCPUContext(cpu.get());
         thread.thread_context = cpu.location();
         if (dumper_->threads()[i] == GetCrashThread()) {
           crashing_thread_context_ = cpu.location();
@@ -867,7 +501,7 @@ class MinidumpWriter {
             // This is the crashing thread of a live process, but
             // no context was provided, so set the crash address
             // while the instruction pointer is already here.
-            dumper_->set_crash_address(GetInstructionPointer(info));
+            dumper_->set_crash_address(info.GetInstructionPointer());
           }
         }
       }
@@ -904,7 +538,9 @@ class MinidumpWriter {
 
   static bool ShouldIncludeMapping(const MappingInfo& mapping) {
     if (mapping.name[0] == 0 ||  // only want modules with filenames.
-        mapping.offset ||  // only want to include one mapping per shared lib.
+        // Only want to include one mapping per shared lib.
+        // Avoid filtering executable mappings.
+        (mapping.offset != 0 && !mapping.exec) ||
         mapping.size < 4096) {  // too small to get a signature for.
       return false;
     }
@@ -966,7 +602,7 @@ class MinidumpWriter {
         continue;
 
       MDRawModule mod;
-      if (!FillRawModule(mapping, true, i, mod, NULL))
+      if (!FillRawModule(mapping, true, i, &mod, NULL))
         return false;
       list.CopyIndexAfterObject(j++, &mod, MD_MODULE_SIZE);
     }
@@ -975,7 +611,7 @@ class MinidumpWriter {
          iter != mapping_list_.end();
          ++iter) {
       MDRawModule mod;
-      if (!FillRawModule(iter->first, false, 0, mod, iter->second))
+      if (!FillRawModule(iter->first, false, 0, &mod, iter->second))
         return false;
       list.CopyIndexAfterObject(j++, &mod, MD_MODULE_SIZE);
     }
@@ -989,56 +625,51 @@ class MinidumpWriter {
   bool FillRawModule(const MappingInfo& mapping,
                      bool member,
                      unsigned int mapping_id,
-                     MDRawModule& mod,
+                     MDRawModule* mod,
                      const uint8_t* identifier) {
-    my_memset(&mod, 0, MD_MODULE_SIZE);
+    my_memset(mod, 0, MD_MODULE_SIZE);
 
-    mod.base_of_image = mapping.start_addr;
-    mod.size_of_image = mapping.size;
-    const size_t filepath_len = my_strlen(mapping.name);
+    mod->base_of_image = mapping.start_addr;
+    mod->size_of_image = mapping.size;
 
-    // Figure out file name from path
-    const char* filename_ptr = mapping.name + filepath_len - 1;
-    while (filename_ptr >= mapping.name) {
-      if (*filename_ptr == '/')
-        break;
-      filename_ptr--;
-    }
-    filename_ptr++;
-
-    const size_t filename_len = mapping.name + filepath_len - filename_ptr;
-
-    uint8_t cv_buf[MDCVInfoPDB70_minsize + NAME_MAX];
-    uint8_t* cv_ptr = cv_buf;
-    UntypedMDRVA cv(&minidump_writer_);
-    if (!cv.Allocate(MDCVInfoPDB70_minsize + filename_len + 1))
-      return false;
+    auto_wasteful_vector<uint8_t, kDefaultBuildIdSize> identifier_bytes(
+        dumper_->allocator());
 
-    const uint32_t cv_signature = MD_CVINFOPDB70_SIGNATURE;
-    my_memcpy(cv_ptr, &cv_signature, sizeof(cv_signature));
-    cv_ptr += sizeof(cv_signature);
-    uint8_t* signature = cv_ptr;
-    cv_ptr += sizeof(MDGUID);
     if (identifier) {
       // GUID was provided by caller.
-      my_memcpy(signature, identifier, sizeof(MDGUID));
+      identifier_bytes.insert(identifier_bytes.end(),
+                              identifier,
+                              identifier + sizeof(MDGUID));
     } else {
-      dumper_->ElfFileIdentifierForMapping(mapping, member,
-                                           mapping_id, signature);
+      // Note: ElfFileIdentifierForMapping() can manipulate the |mapping.name|.
+      dumper_->ElfFileIdentifierForMapping(mapping,
+                                           member,
+                                           mapping_id,
+                                           identifier_bytes);
     }
-    my_memset(cv_ptr, 0, sizeof(uint32_t));  // Set age to 0 on Linux.
-    cv_ptr += sizeof(uint32_t);
 
-    // Write pdb_file_name
-    my_memcpy(cv_ptr, filename_ptr, filename_len + 1);
-    cv.Copy(cv_buf, MDCVInfoPDB70_minsize + filename_len + 1);
+    if (!identifier_bytes.empty()) {
+      UntypedMDRVA cv(&minidump_writer_);
+      if (!cv.Allocate(MDCVInfoELF_minsize + identifier_bytes.size()))
+        return false;
+
+      const uint32_t cv_signature = MD_CVINFOELF_SIGNATURE;
+      cv.Copy(&cv_signature, sizeof(cv_signature));
+      cv.Copy(cv.position() + sizeof(cv_signature), &identifier_bytes[0],
+              identifier_bytes.size());
+
+      mod->cv_record = cv.location();
+    }
 
-    mod.cv_record = cv.location();
+    char file_name[NAME_MAX];
+    char file_path[NAME_MAX];
+    dumper_->GetMappingEffectiveNameAndPath(
+        mapping, file_path, sizeof(file_path), file_name, sizeof(file_name));
 
     MDLocationDescriptor ld;
-    if (!minidump_writer_.WriteString(mapping.name, filepath_len, &ld))
+    if (!minidump_writer_.WriteString(file_path, my_strlen(file_path), &ld))
       return false;
-    mod.module_name_rva = ld.rva;
+    mod->module_name_rva = ld.rva;
     return true;
   }
 
@@ -1071,15 +702,24 @@ class MinidumpWriter {
     TypedMDRVA<MDRawExceptionStream> exc(&minidump_writer_);
     if (!exc.Allocate())
       return false;
-    my_memset(exc.get(), 0, sizeof(MDRawExceptionStream));
+
+    MDRawExceptionStream* stream = exc.get();
+    my_memset(stream, 0, sizeof(MDRawExceptionStream));
 
     dirent->stream_type = MD_EXCEPTION_STREAM;
     dirent->location = exc.location();
 
-    exc.get()->thread_id = GetCrashThread();
-    exc.get()->exception_record.exception_code = dumper_->crash_signal();
-    exc.get()->exception_record.exception_address = dumper_->crash_address();
-    exc.get()->thread_context = crashing_thread_context_;
+    stream->thread_id = GetCrashThread();
+    stream->exception_record.exception_code = dumper_->crash_signal();
+    stream->exception_record.exception_flags = dumper_->crash_signal_code();
+    stream->exception_record.exception_address = dumper_->crash_address();
+    const std::vector<uint64_t> crash_exception_info =
+        dumper_->crash_exception_info();
+    stream->exception_record.number_parameters = crash_exception_info.size();
+    memcpy(stream->exception_record.exception_information,
+           crash_exception_info.data(),
+           sizeof(uint64_t) * crash_exception_info.size());
+    stream->thread_context = crashing_thread_context_;
 
     return true;
   }
@@ -1100,20 +740,22 @@ class MinidumpWriter {
   }
 
   bool WriteDSODebugStream(MDRawDirectory* dirent) {
-    ElfW(Phdr)* phdr = reinterpret_cast<ElfW(Phdr) *>(dumper_->auxv()[AT_PHDR]);
+    ElfW(Phdr)* phdr = reinterpret_cast<ElfW(Phdr)*>(dumper_->auxv()[AT_PHDR]);
     char* base;
     int phnum = dumper_->auxv()[AT_PHNUM];
     if (!phnum || !phdr)
       return false;
 
     // Assume the program base is at the beginning of the same page as the PHDR
-    base = reinterpret_cast<char *>(reinterpret_cast<uintptr_t>(phdr) & ~0xfff);
+    base = reinterpret_cast<char*>(reinterpret_cast<uintptr_t>(phdr) & ~0xfff);
 
     // Search for the program PT_DYNAMIC segment
     ElfW(Addr) dyn_addr = 0;
     for (; phnum >= 0; phnum--, phdr++) {
       ElfW(Phdr) ph;
-      dumper_->CopyFromProcess(&ph, GetCrashThread(), phdr, sizeof(ph));
+      if (!dumper_->CopyFromProcess(&ph, GetCrashThread(), phdr, sizeof(ph)))
+        return false;
+
       // Adjust base address with the virtual address of the PT_LOAD segment
       // corresponding to offset 0
       if (ph.p_type == PT_LOAD && ph.p_offset == 0) {
@@ -1126,7 +768,7 @@ class MinidumpWriter {
     if (!dyn_addr)
       return false;
 
-    ElfW(Dyn) *dynamic = reinterpret_cast<ElfW(Dyn) *>(dyn_addr + base);
+    ElfW(Dyn)* dynamic = reinterpret_cast<ElfW(Dyn)*>(dyn_addr + base);
 
     // The dynamic linker makes information available that helps gdb find all
     // DSOs loaded into the program. If this information is indeed available,
@@ -1134,12 +776,20 @@ class MinidumpWriter {
     struct r_debug* r_debug = NULL;
     uint32_t dynamic_length = 0;
 
-    for (int i = 0;;) {
+    for (int i = 0; ; ++i) {
       ElfW(Dyn) dyn;
       dynamic_length += sizeof(dyn);
-      dumper_->CopyFromProcess(&dyn, GetCrashThread(), dynamic+i++,
-                               sizeof(dyn));
-      if (dyn.d_tag == DT_DEBUG) {
+      if (!dumper_->CopyFromProcess(&dyn, GetCrashThread(), dynamic + i,
+                                    sizeof(dyn))) {
+        return false;
+      }
+
+#ifdef __mips__
+      const int32_t debug_tag = DT_MIPS_RLD_MAP;
+#else
+      const int32_t debug_tag = DT_DEBUG;
+#endif
+      if (dyn.d_tag == debug_tag) {
         r_debug = reinterpret_cast<struct r_debug*>(dyn.d_un.d_ptr);
         continue;
       } else if (dyn.d_tag == DT_NULL) {
@@ -1158,11 +808,15 @@ class MinidumpWriter {
     // Count the number of loaded DSOs
     int dso_count = 0;
     struct r_debug debug_entry;
-    dumper_->CopyFromProcess(&debug_entry, GetCrashThread(), r_debug,
-                             sizeof(debug_entry));
+    if (!dumper_->CopyFromProcess(&debug_entry, GetCrashThread(), r_debug,
+                                  sizeof(debug_entry))) {
+      return false;
+    }
     for (struct link_map* ptr = debug_entry.r_map; ptr; ) {
       struct link_map map;
-      dumper_->CopyFromProcess(&map, GetCrashThread(), ptr, sizeof(map));
+      if (!dumper_->CopyFromProcess(&map, GetCrashThread(), ptr, sizeof(map)))
+        return false;
+
       ptr = map.l_next;
       dso_count++;
     }
@@ -1180,7 +834,9 @@ class MinidumpWriter {
       // Iterate over DSOs and write their information to mini dump
       for (struct link_map* ptr = debug_entry.r_map; ptr; ) {
         struct link_map map;
-        dumper_->CopyFromProcess(&map, GetCrashThread(), ptr, sizeof(map));
+        if (!dumper_->CopyFromProcess(&map, GetCrashThread(), ptr, sizeof(map)))
+          return  false;
+
         ptr = map.l_next;
         char filename[257] = { 0 };
         if (map.l_name) {
@@ -1192,8 +848,8 @@ class MinidumpWriter {
           return false;
         MDRawLinkMap entry;
         entry.name = location.rva;
-        entry.addr = reinterpret_cast<void*>(map.l_addr);
-        entry.ld = reinterpret_cast<void*>(map.l_ld);
+        entry.addr = map.l_addr;
+        entry.ld = reinterpret_cast<uintptr_t>(map.l_ld);
         linkmap.CopyIndex(idx++, &entry);
       }
     }
@@ -1209,9 +865,9 @@ class MinidumpWriter {
     debug.get()->version = debug_entry.r_version;
     debug.get()->map = linkmap_rva;
     debug.get()->dso_count = dso_count;
-    debug.get()->brk = reinterpret_cast<void*>(debug_entry.r_brk);
-    debug.get()->ldbase = reinterpret_cast<void*>(debug_entry.r_ldbase);
-    debug.get()->dynamic = dynamic;
+    debug.get()->brk = debug_entry.r_brk;
+    debug.get()->ldbase = debug_entry.r_ldbase;
+    debug.get()->dynamic = reinterpret_cast<uintptr_t>(dynamic);
 
     wasteful_vector<char> dso_debug_data(dumper_->allocator(), dynamic_length);
     // The passed-in size to the constructor (above) is only a hint.
@@ -1235,58 +891,6 @@ class MinidumpWriter {
     return dumper_->crash_thread();
   }
 
-#if defined(__i386__)
-  uintptr_t GetStackPointer() {
-    return ucontext_->uc_mcontext.gregs[REG_ESP];
-  }
-
-  uintptr_t GetInstructionPointer() {
-    return ucontext_->uc_mcontext.gregs[REG_EIP];
-  }
-
-  uintptr_t GetInstructionPointer(const ThreadInfo& info) {
-    return info.regs.eip;
-  }
-#elif defined(__x86_64)
-  uintptr_t GetStackPointer() {
-    return ucontext_->uc_mcontext.gregs[REG_RSP];
-  }
-
-  uintptr_t GetInstructionPointer() {
-    return ucontext_->uc_mcontext.gregs[REG_RIP];
-  }
-
-  uintptr_t GetInstructionPointer(const ThreadInfo& info) {
-    return info.regs.rip;
-  }
-#elif defined(__ARM_EABI__)
-  uintptr_t GetStackPointer() {
-    return ucontext_->uc_mcontext.arm_sp;
-  }
-
-  uintptr_t GetInstructionPointer() {
-    return ucontext_->uc_mcontext.arm_pc;
-  }
-
-  uintptr_t GetInstructionPointer(const ThreadInfo& info) {
-    return info.regs.uregs[15];
-  }
-#elif defined(__mips__)
-  uintptr_t GetStackPointer() {
-    return ucontext_->uc_mcontext.gregs[MD_CONTEXT_MIPS_REG_SP];
-  }
-
-  uintptr_t GetInstructionPointer() {
-    return ucontext_->uc_mcontext.pc;
-  }
-
-  uintptr_t GetInstructionPointer(const ThreadInfo& info) {
-    return info.regs.epc;
-  }
-#else
-#error "This code has not been ported to your platform yet."
-#endif
-
   void NullifyDirectoryEntry(MDRawDirectory* dirent) {
     dirent->stream_type = 0;
     dirent->location.data_size = 0;
@@ -1304,7 +908,7 @@ class MinidumpWriter {
       bool found;
     } cpu_info_table[] = {
       { "processor", -1, false },
-#if !defined(__mips__)
+#if defined(__i386__) || defined(__x86_64__)
       { "model", 0, false },
       { "stepping",  0, false },
       { "cpu family", 0, false },
@@ -1314,7 +918,13 @@ class MinidumpWriter {
     // processor_architecture should always be set, do this first
     sys_info->processor_architecture =
 #if defined(__mips__)
+# if _MIPS_SIM == _ABIO32
         MD_CPU_ARCHITECTURE_MIPS;
+# elif _MIPS_SIM == _ABI64
+        MD_CPU_ARCHITECTURE_MIPS64;
+# else
+#  error "This mips ABI is currently not supported (n32)"
+#endif
 #elif defined(__i386__)
         MD_CPU_ARCHITECTURE_X86;
 #else
@@ -1330,15 +940,14 @@ class MinidumpWriter {
       ProcCpuInfoReader* const reader = new(allocator) ProcCpuInfoReader(fd);
       const char* field;
       while (reader->GetNextField(&field)) {
-        for (size_t i = 0;
-             i < sizeof(cpu_info_table) / sizeof(cpu_info_table[0]);
-             i++) {
-          CpuInfoEntry* entry = &cpu_info_table[i];
-          if (i > 0 && entry->found) {
+        bool is_first_entry = true;
+        for (CpuInfoEntry& entry : cpu_info_table) {
+          if (!is_first_entry && entry.found) {
             // except for the 'processor' field, ignore repeated values.
             continue;
           }
-          if (!my_strcmp(field, entry->info_name)) {
+          is_first_entry = false;
+          if (!my_strcmp(field, entry.info_name)) {
             size_t value_len;
             const char* value = reader->GetValueAndLen(&value_len);
             if (value_len == 0)
@@ -1348,8 +957,8 @@ class MinidumpWriter {
             if (my_read_decimal_ptr(&val, value) == value)
               continue;
 
-            entry->value = static_cast<int>(val);
-            entry->found = true;
+            entry.value = static_cast<int>(val);
+            entry.found = true;
           }
         }
 
@@ -1365,10 +974,8 @@ class MinidumpWriter {
     }
 
     // make sure we got everything we wanted
-    for (size_t i = 0;
-         i < sizeof(cpu_info_table) / sizeof(cpu_info_table[0]);
-         i++) {
-      if (!cpu_info_table[i].found) {
+    for (const CpuInfoEntry& entry : cpu_info_table) {
+      if (!entry.found) {
         return false;
       }
     }
@@ -1378,7 +985,7 @@ class MinidumpWriter {
     cpu_info_table[0].value++;
 
     sys_info->number_of_processors = cpu_info_table[0].value;
-#if !defined(__mips__)
+#if defined(__i386__) || defined(__x86_64__)
     sys_info->processor_level      = cpu_info_table[3].value;
     sys_info->processor_revision   = cpu_info_table[1].value << 8 |
                                      cpu_info_table[2].value;
@@ -1390,7 +997,7 @@ class MinidumpWriter {
     }
     return true;
   }
-#elif defined(__arm__)
+#elif defined(__arm__) || defined(__aarch64__)
   bool WriteCPUInformation(MDRawSystemInfo* sys_info) {
     // The CPUID value is broken up in several entries in /proc/cpuinfo.
     // This table is used to rebuild it from the entries.
@@ -1412,6 +1019,7 @@ class MinidumpWriter {
       const char* tag;
       uint32_t hwcaps;
     } cpu_features_entries[] = {
+#if defined(__arm__)
       { "swp",  MD_CPU_ARM_ELF_HWCAP_SWP },
       { "half", MD_CPU_ARM_ELF_HWCAP_HALF },
       { "thumb", MD_CPU_ARM_ELF_HWCAP_THUMB },
@@ -1432,10 +1040,18 @@ class MinidumpWriter {
       { "idiva", MD_CPU_ARM_ELF_HWCAP_IDIVA },
       { "idivt", MD_CPU_ARM_ELF_HWCAP_IDIVT },
       { "idiv", MD_CPU_ARM_ELF_HWCAP_IDIVA | MD_CPU_ARM_ELF_HWCAP_IDIVT },
+#elif defined(__aarch64__)
+      // No hwcaps on aarch64.
+#endif
     };
 
     // processor_architecture should always be set, do this first
-    sys_info->processor_architecture = MD_CPU_ARCHITECTURE_ARM;
+    sys_info->processor_architecture =
+#if defined(__aarch64__)
+        MD_CPU_ARCHITECTURE_ARM64_OLD;
+#else
+        MD_CPU_ARCHITECTURE_ARM;
+#endif
 
     // /proc/cpuinfo is not readable under various sandboxed environments
     // (e.g. Android services with the android:isolatedProcess attribute)
@@ -1495,18 +1111,15 @@ class MinidumpWriter {
           new(allocator) ProcCpuInfoReader(fd);
       const char* field;
       while (reader->GetNextField(&field)) {
-        for (size_t i = 0;
-             i < sizeof(cpu_id_entries)/sizeof(cpu_id_entries[0]);
-             ++i) {
-          const CpuIdEntry* entry = &cpu_id_entries[i];
-          if (my_strcmp(entry->field, field) != 0)
+        for (const CpuIdEntry& entry : cpu_id_entries) {
+          if (my_strcmp(entry.field, field) != 0)
             continue;
           uintptr_t result = 0;
           const char* value = reader->GetValue();
           const char* p = value;
           if (value[0] == '0' && value[1] == 'x') {
             p = my_read_hex_ptr(&result, value+2);
-          } else if (entry->format == 'x') {
+          } else if (entry.format == 'x') {
             p = my_read_hex_ptr(&result, value);
           } else {
             p = my_read_decimal_ptr(&result, value);
@@ -1514,18 +1127,19 @@ class MinidumpWriter {
           if (p == value)
             continue;
 
-          result &= (1U << entry->bit_length)-1;
-          result <<= entry->bit_lshift;
+          result &= (1U << entry.bit_length)-1;
+          result <<= entry.bit_lshift;
           sys_info->cpu.arm_cpu_info.cpuid |=
               static_cast<uint32_t>(result);
         }
+#if defined(__arm__)
         // Get the architecture version from the "Processor" field.
         // Note that it is also available in the "CPU architecture" field,
         // however, some existing kernels are misconfigured and will report
         // invalid values here (e.g. 6, while the CPU is ARMv7-A based).
         // The "Processor" field doesn't have this issue.
         if (!my_strcmp(field, "Processor")) {
-          unsigned value_len;
+          size_t value_len;
           const char* value = reader->GetValueAndLen(&value_len);
           // Expected format: <text> (v<level><endian>)
           // Where <text> is some text like "ARMv7 Processor rev 2"
@@ -1544,9 +1158,23 @@ class MinidumpWriter {
             sys_info->processor_level = static_cast<uint16_t>(arch_level);
           }
         }
+#elif defined(__aarch64__)
+        // The aarch64 architecture does not provide the architecture level
+        // in the Processor field, so we instead check the "CPU architecture"
+        // field.
+        if (!my_strcmp(field, "CPU architecture")) {
+          uintptr_t arch_level = 0;
+          const char* value = reader->GetValue();
+          const char* p = value;
+          p = my_read_decimal_ptr(&arch_level, value);
+          if (p == value)
+            continue;
+          sys_info->processor_level = static_cast<uint16_t>(arch_level);
+        }
+#endif
         // Rebuild the ELF hwcaps from the 'Features' field.
         if (!my_strcmp(field, "Features")) {
-          unsigned value_len;
+          size_t value_len;
           const char* value = reader->GetValueAndLen(&value_len);
 
           // Parse each space-separated tag.
@@ -1554,7 +1182,7 @@ class MinidumpWriter {
             const char* tag = value;
             size_t tag_len = value_len;
             const char* p = my_strchr(tag, ' ');
-            if (p != NULL) {
+            if (p) {
               tag_len = static_cast<size_t>(p - tag);
               value += tag_len + 1;
               value_len -= tag_len + 1;
@@ -1562,14 +1190,10 @@ class MinidumpWriter {
               tag_len = strlen(tag);
               value_len = 0;
             }
-            for (size_t i = 0;
-                i < sizeof(cpu_features_entries)/
-                    sizeof(cpu_features_entries[0]);
-                ++i) {
-              const CpuFeaturesEntry* entry = &cpu_features_entries[i];
-              if (tag_len == strlen(entry->tag) &&
-                  !memcmp(tag, entry->tag, tag_len)) {
-                sys_info->cpu.arm_cpu_info.elf_hwcaps |= entry->hwcaps;
+            for (const CpuFeaturesEntry& entry : cpu_features_entries) {
+              if (tag_len == strlen(entry.tag) &&
+                  !memcmp(tag, entry.tag, tag_len)) {
+                sys_info->cpu.arm_cpu_info.elf_hwcaps |= entry.hwcaps;
                 break;
               }
             }
@@ -1598,7 +1222,7 @@ class MinidumpWriter {
       Buffers* next;
       size_t len;
       uint8_t data[kBufSize];
-    } *buffers = reinterpret_cast<Buffers*>(Alloc(sizeof(Buffers)));
+    }* buffers = reinterpret_cast<Buffers*>(Alloc(sizeof(Buffers)));
     buffers->next = NULL;
     buffers->len = 0;
 
@@ -1688,23 +1312,6 @@ class MinidumpWriter {
       space_left -= info_len;
     }
 
-#ifdef __ANDROID__
-    // On Android, try to get the build fingerprint and append it.
-    // Fail gracefully because there is no guarantee that the system
-    // property will always be available or accessible.
-    char fingerprint[PROP_VALUE_MAX];
-    int fingerprint_len = __system_property_get("ro.build.fingerprint",
-                                                fingerprint);
-    // System property values shall always be zero-terminated.
-    // Be paranoid and don't trust the system.
-    if (fingerprint_len > 0 && fingerprint_len < PROP_VALUE_MAX) {
-      const char* separator = " ";
-      if (!first_item)
-        my_strlcat(buf, separator, sizeof(buf));
-      my_strlcat(buf, fingerprint, sizeof(buf));
-    }
-#endif
-
     MDLocationDescriptor location;
     if (!minidump_writer_.WriteString(buf, 0, &location))
       return false;
@@ -1726,7 +1333,9 @@ class MinidumpWriter {
   const char* path_;  // Path to the file where the minidum should be written.
 
   const ucontext_t* const ucontext_;  // also from the signal handler
-  const struct _libc_fpstate* const float_state_;  // ditto
+#if !defined(__ARM_EABI__) && !defined(__mips__)
+  const google_breakpad::fpstate_t* const float_state_;  // ditto
+#endif
   LinuxDumper* dumper_;
   MinidumpFileWriter minidump_writer_;
   off_t minidump_size_limit_;
@@ -1740,6 +1349,13 @@ class MinidumpWriter {
   // Additional memory regions to be included in the dump,
   // provided by the caller.
   const AppMemoryList& app_memory_list_;
+  // If set, skip recording any threads that do not reference the
+  // mapping containing principal_mapping_address_.
+  bool skip_stacks_if_mapping_unreferenced_;
+  uintptr_t principal_mapping_address_;
+  const MappingInfo* principal_mapping_;
+  // If true, apply stack sanitization to stored stack data.
+  bool sanitize_stacks_;
 };
 
 
@@ -1749,20 +1365,22 @@ bool WriteMinidumpImpl(const char* minidump_path,
                        pid_t crashing_process,
                        const void* blob, size_t blob_size,
                        const MappingList& mappings,
-                       const AppMemoryList& appmem) {
+                       const AppMemoryList& appmem,
+                       bool skip_stacks_if_mapping_unreferenced,
+                       uintptr_t principal_mapping_address,
+                       bool sanitize_stacks) {
   LinuxPtraceDumper dumper(crashing_process);
   const ExceptionHandler::CrashContext* context = NULL;
   if (blob) {
     if (blob_size != sizeof(ExceptionHandler::CrashContext))
       return false;
     context = reinterpret_cast<const ExceptionHandler::CrashContext*>(blob);
-    dumper.set_crash_address(
-        reinterpret_cast<uintptr_t>(context->siginfo.si_addr));
-    dumper.set_crash_signal(context->siginfo.si_signo);
+    dumper.SetCrashInfoFromSigInfo(context->siginfo);
     dumper.set_crash_thread(context->tid);
   }
   MinidumpWriter writer(minidump_path, minidump_fd, context, mappings,
-                        appmem, &dumper);
+                        appmem, skip_stacks_if_mapping_unreferenced,
+                        principal_mapping_address, sanitize_stacks, &dumper);
   // Set desired limit for file size of minidump (-1 means no limit).
   writer.set_minidump_size_limit(minidump_size_limit);
   if (!writer.Init())
@@ -1775,17 +1393,29 @@ bool WriteMinidumpImpl(const char* minidump_path,
 namespace google_breakpad {
 
 bool WriteMinidump(const char* minidump_path, pid_t crashing_process,
-                   const void* blob, size_t blob_size) {
+                   const void* blob, size_t blob_size,
+                   bool skip_stacks_if_mapping_unreferenced,
+                   uintptr_t principal_mapping_address,
+                   bool sanitize_stacks) {
   return WriteMinidumpImpl(minidump_path, -1, -1,
                            crashing_process, blob, blob_size,
-                           MappingList(), AppMemoryList());
+                           MappingList(), AppMemoryList(),
+                           skip_stacks_if_mapping_unreferenced,
+                           principal_mapping_address,
+                           sanitize_stacks);
 }
 
 bool WriteMinidump(int minidump_fd, pid_t crashing_process,
-                   const void* blob, size_t blob_size) {
+                   const void* blob, size_t blob_size,
+                   bool skip_stacks_if_mapping_unreferenced,
+                   uintptr_t principal_mapping_address,
+                   bool sanitize_stacks) {
   return WriteMinidumpImpl(NULL, minidump_fd, -1,
                            crashing_process, blob, blob_size,
-                           MappingList(), AppMemoryList());
+                           MappingList(), AppMemoryList(),
+                           skip_stacks_if_mapping_unreferenced,
+                           principal_mapping_address,
+                           sanitize_stacks);
 }
 
 bool WriteMinidump(const char* minidump_path, pid_t process,
@@ -1794,8 +1424,10 @@ bool WriteMinidump(const char* minidump_path, pid_t process,
   // MinidumpWriter will set crash address
   dumper.set_crash_signal(MD_EXCEPTION_CODE_LIN_DUMP_REQUESTED);
   dumper.set_crash_thread(process_blamed_thread);
-  MinidumpWriter writer(minidump_path, -1, NULL, MappingList(),
-                        AppMemoryList(), &dumper);
+  MappingList mapping_list;
+  AppMemoryList app_memory_list;
+  MinidumpWriter writer(minidump_path, -1, NULL, mapping_list,
+                        app_memory_list, false, 0, false, &dumper);
   if (!writer.Init())
     return false;
   return writer.Dump();
@@ -1804,46 +1436,71 @@ bool WriteMinidump(const char* minidump_path, pid_t process,
 bool WriteMinidump(const char* minidump_path, pid_t crashing_process,
                    const void* blob, size_t blob_size,
                    const MappingList& mappings,
-                   const AppMemoryList& appmem) {
+                   const AppMemoryList& appmem,
+                   bool skip_stacks_if_mapping_unreferenced,
+                   uintptr_t principal_mapping_address,
+                   bool sanitize_stacks) {
   return WriteMinidumpImpl(minidump_path, -1, -1, crashing_process,
                            blob, blob_size,
-                           mappings, appmem);
+                           mappings, appmem,
+                           skip_stacks_if_mapping_unreferenced,
+                           principal_mapping_address,
+                           sanitize_stacks);
 }
 
 bool WriteMinidump(int minidump_fd, pid_t crashing_process,
                    const void* blob, size_t blob_size,
                    const MappingList& mappings,
-                   const AppMemoryList& appmem) {
+                   const AppMemoryList& appmem,
+                   bool skip_stacks_if_mapping_unreferenced,
+                   uintptr_t principal_mapping_address,
+                   bool sanitize_stacks) {
   return WriteMinidumpImpl(NULL, minidump_fd, -1, crashing_process,
                            blob, blob_size,
-                           mappings, appmem);
+                           mappings, appmem,
+                           skip_stacks_if_mapping_unreferenced,
+                           principal_mapping_address,
+                           sanitize_stacks);
 }
 
 bool WriteMinidump(const char* minidump_path, off_t minidump_size_limit,
                    pid_t crashing_process,
                    const void* blob, size_t blob_size,
                    const MappingList& mappings,
-                   const AppMemoryList& appmem) {
+                   const AppMemoryList& appmem,
+                   bool skip_stacks_if_mapping_unreferenced,
+                   uintptr_t principal_mapping_address,
+                   bool sanitize_stacks) {
   return WriteMinidumpImpl(minidump_path, -1, minidump_size_limit,
                            crashing_process, blob, blob_size,
-                           mappings, appmem);
+                           mappings, appmem,
+                           skip_stacks_if_mapping_unreferenced,
+                           principal_mapping_address,
+                           sanitize_stacks);
 }
 
 bool WriteMinidump(int minidump_fd, off_t minidump_size_limit,
                    pid_t crashing_process,
                    const void* blob, size_t blob_size,
                    const MappingList& mappings,
-                   const AppMemoryList& appmem) {
+                   const AppMemoryList& appmem,
+                   bool skip_stacks_if_mapping_unreferenced,
+                   uintptr_t principal_mapping_address,
+                   bool sanitize_stacks) {
   return WriteMinidumpImpl(NULL, minidump_fd, minidump_size_limit,
                            crashing_process, blob, blob_size,
-                           mappings, appmem);
+                           mappings, appmem,
+                           skip_stacks_if_mapping_unreferenced,
+                           principal_mapping_address,
+                           sanitize_stacks);
 }
 
 bool WriteMinidump(const char* filename,
                    const MappingList& mappings,
                    const AppMemoryList& appmem,
                    LinuxDumper* dumper) {
-  MinidumpWriter writer(filename, -1, NULL, mappings, appmem, dumper);
+  MinidumpWriter writer(filename, -1, NULL, mappings, appmem,
+                        false, 0, false, dumper);
   if (!writer.Init())
     return false;
   return writer.Dump();
diff --git a/src/MEGASync/google_breakpad/client/linux/minidump_writer/minidump_writer.h b/src/MEGASync/google_breakpad/client/linux/minidump_writer/minidump_writer.h
index c9e150ae..e3b0b16d 100644
--- a/src/MEGASync/google_breakpad/client/linux/minidump_writer/minidump_writer.h
+++ b/src/MEGASync/google_breakpad/client/linux/minidump_writer/minidump_writer.h
@@ -32,9 +32,11 @@
 
 #include <stdint.h>
 #include <sys/types.h>
+#include <sys/ucontext.h>
 #include <unistd.h>
 
 #include <list>
+#include <type_traits>
 #include <utility>
 
 #include "client/linux/minidump_writer/linux_dumper.h"
@@ -44,13 +46,11 @@ namespace google_breakpad {
 
 class ExceptionHandler;
 
-struct MappingEntry {
-  MappingInfo first;
-  uint8_t second[sizeof(MDGUID)];
-};
-
-// A list of <MappingInfo, GUID>
-typedef std::list<MappingEntry> MappingList;
+#if defined(__aarch64__)
+typedef struct fpsimd_context fpstate_t;
+#elif !defined(__ARM_EABI__) && !defined(__mips__)
+typedef std::remove_pointer<fpregset_t>::type fpstate_t;
+#endif
 
 // These entries store a list of memory regions that the client wants included
 // in the minidump.
@@ -79,10 +79,16 @@ typedef std::list<AppMemory> AppMemoryList;
 //
 // Returns true iff successful.
 bool WriteMinidump(const char* minidump_path, pid_t crashing_process,
-                   const void* blob, size_t blob_size);
+                   const void* blob, size_t blob_size,
+                   bool skip_stacks_if_mapping_unreferenced = false,
+                   uintptr_t principal_mapping_address = 0,
+                   bool sanitize_stacks = false);
 // Same as above but takes an open file descriptor instead of a path.
 bool WriteMinidump(int minidump_fd, pid_t crashing_process,
-                   const void* blob, size_t blob_size);
+                   const void* blob, size_t blob_size,
+                   bool skip_stacks_if_mapping_unreferenced = false,
+                   uintptr_t principal_mapping_address = 0,
+                   bool sanitize_stacks = false);
 
 // Alternate form of WriteMinidump() that works with processes that
 // are not expected to have crashed.  If |process_blamed_thread| is
@@ -97,23 +103,35 @@ bool WriteMinidump(const char* minidump_path, pid_t process,
 bool WriteMinidump(const char* minidump_path, pid_t crashing_process,
                    const void* blob, size_t blob_size,
                    const MappingList& mappings,
-                   const AppMemoryList& appdata);
+                   const AppMemoryList& appdata,
+                   bool skip_stacks_if_mapping_unreferenced = false,
+                   uintptr_t principal_mapping_address = 0,
+                   bool sanitize_stacks = false);
 bool WriteMinidump(int minidump_fd, pid_t crashing_process,
                    const void* blob, size_t blob_size,
                    const MappingList& mappings,
-                   const AppMemoryList& appdata);
+                   const AppMemoryList& appdata,
+                   bool skip_stacks_if_mapping_unreferenced = false,
+                   uintptr_t principal_mapping_address = 0,
+                   bool sanitize_stacks = false);
 
 // These overloads also allow passing a file size limit for the minidump.
 bool WriteMinidump(const char* minidump_path, off_t minidump_size_limit,
                    pid_t crashing_process,
                    const void* blob, size_t blob_size,
                    const MappingList& mappings,
-                   const AppMemoryList& appdata);
+                   const AppMemoryList& appdata,
+                   bool skip_stacks_if_mapping_unreferenced = false,
+                   uintptr_t principal_mapping_address = 0,
+                   bool sanitize_stacks = false);
 bool WriteMinidump(int minidump_fd, off_t minidump_size_limit,
                    pid_t crashing_process,
                    const void* blob, size_t blob_size,
                    const MappingList& mappings,
-                   const AppMemoryList& appdata);
+                   const AppMemoryList& appdata,
+                   bool skip_stacks_if_mapping_unreferenced = false,
+                   uintptr_t principal_mapping_address = 0,
+                   bool sanitize_stacks = false);
 
 bool WriteMinidump(const char* filename,
                    const MappingList& mappings,
diff --git a/src/MEGASync/google_breakpad/client/linux/minidump_writer/minidump_writer_unittest.cc b/src/MEGASync/google_breakpad/client/linux/minidump_writer/minidump_writer_unittest.cc
index 1ef064b1..d192e5cb 100644
--- a/src/MEGASync/google_breakpad/client/linux/minidump_writer/minidump_writer_unittest.cc
+++ b/src/MEGASync/google_breakpad/client/linux/minidump_writer/minidump_writer_unittest.cc
@@ -28,7 +28,7 @@
 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #include <fcntl.h>
-#include <sys/poll.h>
+#include <poll.h>
 #include <sys/stat.h>
 #include <sys/syscall.h>
 #include <sys/types.h>
@@ -42,6 +42,7 @@
 #include "client/linux/minidump_writer/linux_dumper.h"
 #include "client/linux/minidump_writer/minidump_writer.h"
 #include "client/linux/minidump_writer/minidump_writer_unittest_utils.h"
+#include "common/linux/breakpad_getcontext.h"
 #include "common/linux/eintr_wrapper.h"
 #include "common/linux/file_id.h"
 #include "common/linux/ignore_ret.h"
@@ -54,10 +55,6 @@
 
 using namespace google_breakpad;
 
-// Length of a formatted GUID string =
-// sizeof(MDGUID) * 2 + 4 (for dashes) + 1 (null terminator)
-const int kGUIDStringSize = 37;
-
 namespace {
 
 typedef testing::Test MinidumpWriterTest;
@@ -74,7 +71,7 @@ TEST(MinidumpWriterTest, SetupWithPath) {
     char b;
     IGNORE_RET(HANDLE_EINTR(read(fds[0], &b, sizeof(b))));
     close(fds[0]);
-    syscall(__NR_exit);
+    syscall(__NR_exit_group);
   }
   close(fds[0]);
 
@@ -91,6 +88,7 @@ TEST(MinidumpWriterTest, SetupWithPath) {
   ASSERT_GT(st.st_size, 0);
 
   close(fds[1]);
+  IGNORE_EINTR(waitpid(child, nullptr, 0));
 }
 
 TEST(MinidumpWriterTest, SetupWithFD) {
@@ -103,7 +101,7 @@ TEST(MinidumpWriterTest, SetupWithFD) {
     char b;
     HANDLE_EINTR(read(fds[0], &b, sizeof(b)));
     close(fds[0]);
-    syscall(__NR_exit);
+    syscall(__NR_exit_group);
   }
   close(fds[0]);
 
@@ -121,6 +119,7 @@ TEST(MinidumpWriterTest, SetupWithFD) {
   ASSERT_GT(st.st_size, 0);
 
   close(fds[1]);
+  IGNORE_EINTR(waitpid(child, nullptr, 0));
 }
 
 // Test that mapping info can be specified when writing a minidump,
@@ -137,19 +136,7 @@ TEST(MinidumpWriterTest, MappingInfo) {
     0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
     0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF
   };
-  char module_identifier_buffer[kGUIDStringSize];
-  FileID::ConvertIdentifierToString(kModuleGUID,
-                                    module_identifier_buffer,
-                                    sizeof(module_identifier_buffer));
-  string module_identifier(module_identifier_buffer);
-  // Strip out dashes
-  size_t pos;
-  while ((pos = module_identifier.find('-')) != string::npos) {
-    module_identifier.erase(pos, 1);
-  }
-  // And append a zero, because module IDs include an "age" field
-  // which is always zero on Linux.
-  module_identifier += "0";
+  const string module_identifier = "33221100554477668899AABBCCDDEEFF0";
 
   // Get some memory.
   char* memory =
@@ -168,7 +155,7 @@ TEST(MinidumpWriterTest, MappingInfo) {
     char b;
     IGNORE_RET(HANDLE_EINTR(read(fds[0], &b, sizeof(b))));
     close(fds[0]);
-    syscall(__NR_exit);
+    syscall(__NR_exit_group);
   }
   close(fds[0]);
 
@@ -185,6 +172,7 @@ TEST(MinidumpWriterTest, MappingInfo) {
   info.start_addr = kMemoryAddress;
   info.size = memory_size;
   info.offset = 0;
+  info.exec = false;
   strcpy(info.name, kMemoryName);
 
   MappingList mappings;
@@ -194,7 +182,7 @@ TEST(MinidumpWriterTest, MappingInfo) {
   memcpy(mapping.second, kModuleGUID, sizeof(MDGUID));
   mappings.push_back(mapping);
   ASSERT_TRUE(WriteMinidump(templ.c_str(), child, &context, sizeof(context),
-                            mappings, memory_list));
+                            mappings, memory_list, false, 0, false));
 
   // Read the minidump. Load the module list, and ensure that
   // the mmap'ed |memory| is listed with the given module name
@@ -228,6 +216,203 @@ TEST(MinidumpWriterTest, MappingInfo) {
   EXPECT_TRUE(minidump.SeekToStreamType(MD_LINUX_DSO_DEBUG, &len));
 
   close(fds[1]);
+  IGNORE_EINTR(waitpid(child, nullptr, 0));
+}
+
+// Test that minidumping is skipped while writing minidumps if principal mapping
+// is not referenced.
+TEST(MinidumpWriterTest, MinidumpSkippedIfRequested) {
+  int fds[2];
+  ASSERT_NE(-1, pipe(fds));
+
+  const pid_t child = fork();
+  if (child == 0) {
+    close(fds[1]);
+    char b;
+    IGNORE_RET(HANDLE_EINTR(read(fds[0], &b, sizeof(b))));
+    close(fds[0]);
+    syscall(__NR_exit_group);
+  }
+  close(fds[0]);
+
+  ExceptionHandler::CrashContext context;
+  memset(&context, 0, sizeof(context));
+  ASSERT_EQ(0, getcontext(&context.context));
+  context.tid = child;
+
+  AutoTempDir temp_dir;
+  string templ = temp_dir.path() + kMDWriterUnitTestFileName;
+
+  // pass an invalid principal mapping address, which will force
+  // WriteMinidump to not write a minidump.
+  ASSERT_FALSE(WriteMinidump(templ.c_str(), child, &context, sizeof(context),
+                            true, static_cast<uintptr_t>(0x0102030405060708ull),
+                            false));
+  close(fds[1]);
+  IGNORE_EINTR(waitpid(child, nullptr, 0));
+}
+
+// Test that minidumping is skipped while writing minidumps if principal mapping
+// is not referenced.
+TEST(MinidumpWriterTest, MinidumpStacksSkippedIfRequested) {
+  int fds[2];
+  ASSERT_NE(-1, pipe(fds));
+
+  const pid_t child = fork();
+  if (child == 0) {
+    close(fds[1]);
+
+    // Create a thread that does not return, and only references libc (not the
+    // current executable). This thread should not be captured in the minidump.
+    pthread_t thread;
+    pthread_attr_t thread_attributes;
+    pthread_attr_init(&thread_attributes);
+    pthread_attr_setdetachstate(&thread_attributes, PTHREAD_CREATE_DETACHED);
+    sigset_t sigset;
+    sigemptyset(&sigset);
+    pthread_create(&thread, &thread_attributes,
+                   reinterpret_cast<void* (*)(void*)>(&sigsuspend), &sigset);
+
+    char b;
+    IGNORE_RET(HANDLE_EINTR(read(fds[0], &b, sizeof(b))));
+    close(fds[0]);
+    syscall(__NR_exit_group);
+  }
+  close(fds[0]);
+
+  ExceptionHandler::CrashContext context;
+  memset(&context, 0, sizeof(context));
+  ASSERT_EQ(0, getcontext(&context.context));
+  context.tid = child;
+
+  AutoTempDir temp_dir;
+  string templ = temp_dir.path() + kMDWriterUnitTestFileName;
+
+  // Pass an invalid principal mapping address, which will force
+  // WriteMinidump to not dump any thread stacks.
+  ASSERT_TRUE(WriteMinidump(
+      templ.c_str(), child, &context, sizeof(context), true,
+      reinterpret_cast<uintptr_t>(google_breakpad::WriteFile), false));
+
+  // Read the minidump. And ensure that thread memory was dumped only for the
+  // main thread.
+  Minidump minidump(templ);
+  ASSERT_TRUE(minidump.Read());
+
+  MinidumpThreadList* threads = minidump.GetThreadList();
+  int threads_with_stacks = 0;
+  for (unsigned int i = 0; i < threads->thread_count(); ++i) {
+    MinidumpThread* thread = threads->GetThreadAtIndex(i);
+    if (thread->GetMemory()) {
+      ++threads_with_stacks;
+    }
+  }
+#if defined(THREAD_SANITIZER) || defined(ADDRESS_SANITIZER)
+  ASSERT_GE(threads_with_stacks, 1);
+#else
+  ASSERT_EQ(threads_with_stacks, 1);
+#endif
+  close(fds[1]);
+  IGNORE_EINTR(waitpid(child, nullptr, 0));
+}
+
+// Test that stacks can be sanitized while writing minidumps.
+TEST(MinidumpWriterTest, StacksAreSanitizedIfRequested) {
+  int fds[2];
+  ASSERT_NE(-1, pipe(fds));
+
+  const pid_t child = fork();
+  if (child == 0) {
+    close(fds[1]);
+    char b;
+    IGNORE_RET(HANDLE_EINTR(read(fds[0], &b, sizeof(b))));
+    close(fds[0]);
+    syscall(__NR_exit_group);
+  }
+  close(fds[0]);
+
+  ExceptionHandler::CrashContext context;
+  memset(&context, 0, sizeof(context));
+  ASSERT_EQ(0, getcontext(&context.context));
+  context.tid = child;
+
+  AutoTempDir temp_dir;
+  string templ = temp_dir.path() + kMDWriterUnitTestFileName;
+  // pass an invalid principal mapping address, which will force
+  // WriteMinidump to not dump any thread stacks.
+  ASSERT_TRUE(WriteMinidump(templ.c_str(), child, &context, sizeof(context),
+                            false, 0, true));
+
+  // Read the minidump. And ensure that thread memory contains a defaced value.
+  Minidump minidump(templ);
+  ASSERT_TRUE(minidump.Read());
+
+  const uintptr_t defaced =
+#if defined(__LP64__)
+      0x0defaced0defaced;
+#else
+      0x0defaced;
+#endif
+  MinidumpThreadList* threads = minidump.GetThreadList();
+  for (unsigned int i = 0; i < threads->thread_count(); ++i) {
+    MinidumpThread* thread = threads->GetThreadAtIndex(i);
+    MinidumpMemoryRegion* mem = thread->GetMemory();
+    ASSERT_TRUE(mem != nullptr);
+    uint32_t sz = mem->GetSize();
+    const uint8_t* data = mem->GetMemory();
+    ASSERT_TRUE(memmem(data, sz, &defaced, sizeof(defaced)) != nullptr);
+  }
+  close(fds[1]);
+  IGNORE_EINTR(waitpid(child, nullptr, 0));
+}
+
+// Test that a binary with a longer-than-usual build id note
+// makes its way all the way through to the minidump unscathed.
+// The linux_client_unittest is linked with an explicit --build-id
+// in Makefile.am.
+TEST(MinidumpWriterTest, BuildIDLong) {
+  int fds[2];
+  ASSERT_NE(-1, pipe(fds));
+
+  const pid_t child = fork();
+  if (child == 0) {
+    close(fds[1]);
+    char b;
+    IGNORE_RET(HANDLE_EINTR(read(fds[0], &b, sizeof(b))));
+    close(fds[0]);
+    syscall(__NR_exit_group);
+  }
+  close(fds[0]);
+
+  ExceptionHandler::CrashContext context;
+  memset(&context, 0, sizeof(context));
+  ASSERT_EQ(0, getcontext(&context.context));
+  context.tid = child;
+
+  AutoTempDir temp_dir;
+  const string dump_path = temp_dir.path() + kMDWriterUnitTestFileName;
+
+  EXPECT_TRUE(WriteMinidump(dump_path.c_str(),
+                            child, &context, sizeof(context)));
+  close(fds[1]);
+
+  // Read the minidump. Load the module list, and ensure that
+  // the main module has the correct debug id and code id.
+  Minidump minidump(dump_path);
+  ASSERT_TRUE(minidump.Read());
+
+  MinidumpModuleList* module_list = minidump.GetModuleList();
+  ASSERT_TRUE(module_list);
+  const MinidumpModule* module = module_list->GetMainModule();
+  ASSERT_TRUE(module);
+  const string module_identifier = "030201000504070608090A0B0C0D0E0F0";
+  // This is passed explicitly to the linker in Makefile.am
+  const string build_id =
+      "000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f";
+  EXPECT_EQ(module_identifier, module->debug_identifier());
+  EXPECT_EQ(build_id, module->code_identifier());
+
+  IGNORE_EINTR(waitpid(child, nullptr, 0));
 }
 
 // Test that mapping info can be specified, and that it overrides
@@ -245,19 +430,7 @@ TEST(MinidumpWriterTest, MappingInfoContained) {
     0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
     0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF
   };
-  char module_identifier_buffer[kGUIDStringSize];
-  FileID::ConvertIdentifierToString(kModuleGUID,
-                                    module_identifier_buffer,
-                                    sizeof(module_identifier_buffer));
-  string module_identifier(module_identifier_buffer);
-  // Strip out dashes
-  size_t pos;
-  while ((pos = module_identifier.find('-')) != string::npos) {
-    module_identifier.erase(pos, 1);
-  }
-  // And append a zero, because module IDs include an "age" field
-  // which is always zero on Linux.
-  module_identifier += "0";
+  const string module_identifier = "33221100554477668899AABBCCDDEEFF0";
 
   // mmap a file
   AutoTempDir temp_dir;
@@ -288,7 +461,7 @@ TEST(MinidumpWriterTest, MappingInfoContained) {
     char b;
     IGNORE_RET(HANDLE_EINTR(read(fds[0], &b, sizeof(b))));
     close(fds[0]);
-    syscall(__NR_exit);
+    syscall(__NR_exit_group);
   }
   close(fds[0]);
 
@@ -304,6 +477,7 @@ TEST(MinidumpWriterTest, MappingInfoContained) {
   info.start_addr = kMemoryAddress - memory_size;
   info.size = memory_size * 3;
   info.offset = 0;
+  info.exec = false;
   strcpy(info.name, kMemoryName);
 
   MappingList mappings;
@@ -333,6 +507,7 @@ TEST(MinidumpWriterTest, MappingInfoContained) {
   EXPECT_EQ(module_identifier, module->debug_identifier());
 
   close(fds[1]);
+  IGNORE_EINTR(waitpid(child, nullptr, 0));
 }
 
 TEST(MinidumpWriterTest, DeletedBinary) {
@@ -346,7 +521,7 @@ TEST(MinidumpWriterTest, DeletedBinary) {
   // Copy binary to a temp file.
   AutoTempDir temp_dir;
   string binpath = temp_dir.path() + "/linux-dumper-unittest-helper";
-  ASSERT_TRUE(CopyFile(helper_path.c_str(), binpath.c_str()))
+  ASSERT_TRUE(CopyFile(helper_path, binpath))
       << "Failed to copy " << helper_path << " to " << binpath;
   ASSERT_EQ(0, chmod(binpath.c_str(), 0755));
 
@@ -410,12 +585,10 @@ TEST(MinidumpWriterTest, DeletedBinary) {
   EXPECT_STREQ(binpath.c_str(), module->code_file().c_str());
   // Check that the file ID is correct.
   FileID fileid(helper_path.c_str());
-  uint8_t identifier[sizeof(MDGUID)];
+  PageAllocator allocator;
+  wasteful_vector<uint8_t> identifier(&allocator, kDefaultBuildIdSize);
   EXPECT_TRUE(fileid.ElfFileIdentifier(identifier));
-  char identifier_string[kGUIDStringSize];
-  FileID::ConvertIdentifierToString(identifier,
-                                    identifier_string,
-                                    kGUIDStringSize);
+  string identifier_string = FileID::ConvertIdentifierToUUIDString(identifier);
   string module_identifier(identifier_string);
   // Strip out dashes
   size_t pos;
@@ -426,6 +599,8 @@ TEST(MinidumpWriterTest, DeletedBinary) {
   // which is always zero on Linux.
   module_identifier += "0";
   EXPECT_EQ(module_identifier, module->debug_identifier());
+
+  IGNORE_EINTR(waitpid(child_pid, nullptr, 0));
 }
 
 // Test that an additional memory region can be added to the minidump.
@@ -453,7 +628,7 @@ TEST(MinidumpWriterTest, AdditionalMemory) {
     char b;
     HANDLE_EINTR(read(fds[0], &b, sizeof(b)));
     close(fds[0]);
-    syscall(__NR_exit);
+    syscall(__NR_exit_group);
   }
   close(fds[0]);
 
@@ -498,6 +673,7 @@ TEST(MinidumpWriterTest, AdditionalMemory) {
 
   delete[] memory;
   close(fds[1]);
+  IGNORE_EINTR(waitpid(child, nullptr, 0));
 }
 
 // Test that an invalid thread stack pointer still results in a minidump.
@@ -511,7 +687,7 @@ TEST(MinidumpWriterTest, InvalidStackPointer) {
     char b;
     HANDLE_EINTR(read(fds[0], &b, sizeof(b)));
     close(fds[0]);
-    syscall(__NR_exit);
+    syscall(__NR_exit_group);
   }
   close(fds[0]);
 
@@ -525,26 +701,19 @@ TEST(MinidumpWriterTest, InvalidStackPointer) {
 
   // Fake the child's stack pointer for its crashing thread.  NOTE: This must
   // be an invalid memory address for the child process (stack or otherwise).
-#if defined(__i386)
   // Try 1MB below the current stack.
   uintptr_t invalid_stack_pointer =
       reinterpret_cast<uintptr_t>(&context) - 1024*1024;
+#if defined(__i386)
   context.context.uc_mcontext.gregs[REG_ESP] = invalid_stack_pointer;
 #elif defined(__x86_64)
-  // Try 1MB below the current stack.
-  uintptr_t invalid_stack_pointer =
-      reinterpret_cast<uintptr_t>(&context) - 1024*1024;
   context.context.uc_mcontext.gregs[REG_RSP] = invalid_stack_pointer;
 #elif defined(__ARM_EABI__)
-  // Try 1MB below the current stack.
-  uintptr_t invalid_stack_pointer =
-      reinterpret_cast<uintptr_t>(&context) - 1024*1024;
   context.context.uc_mcontext.arm_sp = invalid_stack_pointer;
+#elif defined(__aarch64__)
+  context.context.uc_mcontext.sp = invalid_stack_pointer;
 #elif defined(__mips__)
-  // Try 1MB below the current stack.
-  uintptr_t invalid_stack_pointer =
-      reinterpret_cast<uintptr_t>(&context) - 1024 * 1024;
-  context.context.uc_mcontext.gregs[MD_CONTEXT_MIPS_REG_SP] = 
+  context.context.uc_mcontext.gregs[MD_CONTEXT_MIPS_REG_SP] =
       invalid_stack_pointer;
 #else
 # error "This code has not been ported to your platform yet."
@@ -584,6 +753,7 @@ TEST(MinidumpWriterTest, InvalidStackPointer) {
 #endif
 
   close(fds[1]);
+  IGNORE_EINTR(waitpid(child, nullptr, 0));
 }
 
 // Test that limiting the size of the minidump works.
@@ -629,7 +799,7 @@ TEST(MinidumpWriterTest, MinidumpSizeLimit) {
     ASSERT_EQ(1, r);
     ASSERT_TRUE(pfd.revents & POLLIN);
     uint8_t junk;
-    ASSERT_EQ(read(fds[0], &junk, sizeof(junk)), 
+    ASSERT_EQ(read(fds[0], &junk, sizeof(junk)),
               static_cast<ssize_t>(sizeof(junk)));
   }
   close(fds[0]);
@@ -758,6 +928,7 @@ TEST(MinidumpWriterTest, MinidumpSizeLimit) {
 
   // Kill the helper program.
   kill(child_pid, SIGKILL);
+  IGNORE_EINTR(waitpid(child_pid, nullptr, 0));
 }
 
 }  // namespace
diff --git a/src/MEGASync/google_breakpad/client/linux/minidump_writer/minidump_writer_unittest_utils.cc b/src/MEGASync/google_breakpad/client/linux/minidump_writer/minidump_writer_unittest_utils.cc
index 9f46fa65..8e2319e7 100644
--- a/src/MEGASync/google_breakpad/client/linux/minidump_writer/minidump_writer_unittest_utils.cc
+++ b/src/MEGASync/google_breakpad/client/linux/minidump_writer/minidump_writer_unittest_utils.cc
@@ -41,7 +41,7 @@ namespace google_breakpad {
 
 string GetHelperBinary() {
   string helper_path;
-  char *bindir = getenv("bindir");
+  char* bindir = getenv("bindir");
   if (bindir) {
     helper_path = string(bindir) + "/";
   } else {
diff --git a/src/MEGASync/google_breakpad/client/linux/minidump_writer/proc_cpuinfo_reader_unittest.cc b/src/MEGASync/google_breakpad/client/linux/minidump_writer/proc_cpuinfo_reader_unittest.cc
index 6037c7e6..d9b1203e 100644
--- a/src/MEGASync/google_breakpad/client/linux/minidump_writer/proc_cpuinfo_reader_unittest.cc
+++ b/src/MEGASync/google_breakpad/client/linux/minidump_writer/proc_cpuinfo_reader_unittest.cc
@@ -65,7 +65,7 @@ TEST(ProcCpuInfoReaderTest, EmptyFile) {
   ASSERT_TRUE(file.IsOk());
   ProcCpuInfoReader reader(file.GetFd());
 
-  const char *field;
+  const char* field;
   ASSERT_FALSE(reader.GetNextField(&field));
 }
 
@@ -74,7 +74,7 @@ TEST(ProcCpuInfoReaderTest, OneLineTerminated) {
   ASSERT_TRUE(file.IsOk());
   ProcCpuInfoReader reader(file.GetFd());
 
-  const char *field;
+  const char* field;
   ASSERT_TRUE(reader.GetNextField(&field));
   ASSERT_STREQ("foo", field);
   ASSERT_STREQ("bar", reader.GetValue());
@@ -87,7 +87,7 @@ TEST(ProcCpuInfoReaderTest, OneLine) {
   ASSERT_TRUE(file.IsOk());
   ProcCpuInfoReader reader(file.GetFd());
 
-  const char *field;
+  const char* field;
   size_t value_len;
   ASSERT_TRUE(reader.GetNextField(&field));
   ASSERT_STREQ("foo", field);
diff --git a/src/MEGASync/google_breakpad/client/linux/sender/google_crash_report_sender.cc b/src/MEGASync/google_breakpad/client/linux/sender/google_crash_report_sender.cc
index 0d48cbe6..6bf337a8 100644
--- a/src/MEGASync/google_breakpad/client/linux/sender/google_crash_report_sender.cc
+++ b/src/MEGASync/google_breakpad/client/linux/sender/google_crash_report_sender.cc
@@ -28,9 +28,10 @@
 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #include "common/linux/google_crashdump_uploader.h"
-#include "third_party/linux/include/gflags/gflags.h"
 #include <string>
 #include <iostream>
+#include <gflags/gflags.h>
+#include <glog/logging.h>
 
 #include "common/using_std_string.h"
 
@@ -83,7 +84,7 @@ bool CheckForRequiredFlagsOrDie() {
   return true;
 }
 
-int main(int argc, char *argv[]) {
+int main(int argc, char* argv[]) {
   google::InitGoogleLogging(argv[0]);
   google::ParseCommandLineFlags(&argc, &argv, true);
   if (!CheckForRequiredFlagsOrDie()) {
@@ -100,5 +101,5 @@ int main(int argc, char *argv[]) {
                                              FLAGS_crash_server,
                                              FLAGS_proxy_host,
                                              FLAGS_proxy_userpasswd);
-  g.Upload();
+  g.Upload(NULL, NULL, NULL);
 }
diff --git a/src/MEGASync/google_breakpad/client/mac/Breakpad.xcodeproj/project.pbxproj b/src/MEGASync/google_breakpad/client/mac/Breakpad.xcodeproj/project.pbxproj
index 2507710b..10876535 100644
--- a/src/MEGASync/google_breakpad/client/mac/Breakpad.xcodeproj/project.pbxproj
+++ b/src/MEGASync/google_breakpad/client/mac/Breakpad.xcodeproj/project.pbxproj
@@ -52,6 +52,10 @@
 		3329D4ED0FA16D820007BBC5 /* Breakpad.xib in Resources */ = {isa = PBXBuildFile; fileRef = 3329D4EC0FA16D820007BBC5 /* Breakpad.xib */; };
 		33880C800F9E097100817F82 /* InfoPlist.strings in Resources */ = {isa = PBXBuildFile; fileRef = 33880C7E0F9E097100817F82 /* InfoPlist.strings */; };
 		4084699D0F5D9CF900FDCA37 /* crash_report_sender.icns in Resources */ = {isa = PBXBuildFile; fileRef = 4084699C0F5D9CF900FDCA37 /* crash_report_sender.icns */; };
+		421BC5BC21110C0300B8042E /* convert_old_arm64_context.cc in Sources */ = {isa = PBXBuildFile; fileRef = 421BC5AD21110C0300B8042E /* convert_old_arm64_context.cc */; };
+		421BC5BD21110C0300B8042E /* convert_old_arm64_context.h in Headers */ = {isa = PBXBuildFile; fileRef = 421BC5BB21110C0300B8042E /* convert_old_arm64_context.h */; };
+		421BC5BE21110C1000B8042E /* convert_old_arm64_context.cc in Sources */ = {isa = PBXBuildFile; fileRef = 421BC5AD21110C0300B8042E /* convert_old_arm64_context.cc */; };
+		4247E6412110D7A300482558 /* memory_allocator_unittest.cc in Sources */ = {isa = PBXBuildFile; fileRef = D244540A12439BA0009BBCE0 /* memory_allocator_unittest.cc */; };
 		4D61A25F14F43CFC002D5862 /* bootstrap_compat.cc in Sources */ = {isa = PBXBuildFile; fileRef = 4D61A25D14F43CFC002D5862 /* bootstrap_compat.cc */; };
 		4D61A26B14F43D3C002D5862 /* bootstrap_compat.cc in Sources */ = {isa = PBXBuildFile; fileRef = 4D61A25D14F43CFC002D5862 /* bootstrap_compat.cc */; };
 		4D61A26C14F43D42002D5862 /* bootstrap_compat.cc in Sources */ = {isa = PBXBuildFile; fileRef = 4D61A25D14F43CFC002D5862 /* bootstrap_compat.cc */; };
@@ -85,7 +89,6 @@
 		D244536B12426F00009BBCE0 /* minidump.cc in Sources */ = {isa = PBXBuildFile; fileRef = D244535212426EBB009BBCE0 /* minidump.cc */; };
 		D244536C12426F00009BBCE0 /* pathname_stripper.cc in Sources */ = {isa = PBXBuildFile; fileRef = D244535312426EBB009BBCE0 /* pathname_stripper.cc */; };
 		D244536D12426F00009BBCE0 /* basic_code_modules.cc in Sources */ = {isa = PBXBuildFile; fileRef = D244534F12426E98009BBCE0 /* basic_code_modules.cc */; };
-		D244540B12439BA0009BBCE0 /* memory_unittest.cc in Sources */ = {isa = PBXBuildFile; fileRef = D244540A12439BA0009BBCE0 /* memory_unittest.cc */; };
 		D246417012BAA40E005170D0 /* exception_handler.cc in Sources */ = {isa = PBXBuildFile; fileRef = F92C536D0ECCE3FD009BE4BA /* exception_handler.cc */; };
 		D246417112BAA41C005170D0 /* crash_generation_client.cc in Sources */ = {isa = PBXBuildFile; fileRef = D2F9A4C6121336C7002747C1 /* crash_generation_client.cc */; };
 		D246417512BAA438005170D0 /* minidump_generator.cc in Sources */ = {isa = PBXBuildFile; fileRef = F92C536F0ECCE3FD009BE4BA /* minidump_generator.cc */; };
@@ -95,7 +98,7 @@
 		D246418812BAA4E3005170D0 /* string_utilities.cc in Sources */ = {isa = PBXBuildFile; fileRef = F92C53820ECCE635009BE4BA /* string_utilities.cc */; };
 		D246418C12BAA508005170D0 /* minidump_file_writer.cc in Sources */ = {isa = PBXBuildFile; fileRef = F92C538F0ECCE70A009BE4BA /* minidump_file_writer.cc */; };
 		D246419012BAA52A005170D0 /* string_conversion.cc in Sources */ = {isa = PBXBuildFile; fileRef = F92C53850ECCE6AD009BE4BA /* string_conversion.cc */; };
-		D246419112BAA52F005170D0 /* convert_UTF.c in Sources */ = {isa = PBXBuildFile; fileRef = F92C53870ECCE6C0009BE4BA /* convert_UTF.c */; };
+		D246419112BAA52F005170D0 /* convert_UTF.cc in Sources */ = {isa = PBXBuildFile; fileRef = F92C53870ECCE6C0009BE4BA /* convert_UTF.cc */; };
 		D246419512BAA54C005170D0 /* file_id.cc in Sources */ = {isa = PBXBuildFile; fileRef = F92C53740ECCE635009BE4BA /* file_id.cc */; };
 		D246419612BAA55A005170D0 /* macho_id.cc in Sources */ = {isa = PBXBuildFile; fileRef = F92C537A0ECCE635009BE4BA /* macho_id.cc */; };
 		D24641A012BAA67F005170D0 /* macho_walker.cc in Sources */ = {isa = PBXBuildFile; fileRef = F92C537E0ECCE635009BE4BA /* macho_walker.cc */; };
@@ -136,7 +139,7 @@
 		D2F9A533121383A1002747C1 /* exception_handler.cc in Sources */ = {isa = PBXBuildFile; fileRef = F92C536D0ECCE3FD009BE4BA /* exception_handler.cc */; };
 		D2F9A534121383A1002747C1 /* minidump_generator.cc in Sources */ = {isa = PBXBuildFile; fileRef = F92C536F0ECCE3FD009BE4BA /* minidump_generator.cc */; };
 		D2F9A535121383A1002747C1 /* minidump_file_writer.cc in Sources */ = {isa = PBXBuildFile; fileRef = F92C538F0ECCE70A009BE4BA /* minidump_file_writer.cc */; };
-		D2F9A536121383A1002747C1 /* convert_UTF.c in Sources */ = {isa = PBXBuildFile; fileRef = F92C53870ECCE6C0009BE4BA /* convert_UTF.c */; };
+		D2F9A536121383A1002747C1 /* convert_UTF.cc in Sources */ = {isa = PBXBuildFile; fileRef = F92C53870ECCE6C0009BE4BA /* convert_UTF.cc */; };
 		D2F9A537121383A1002747C1 /* string_conversion.cc in Sources */ = {isa = PBXBuildFile; fileRef = F92C53850ECCE6AD009BE4BA /* string_conversion.cc */; };
 		D2F9A538121383A1002747C1 /* file_id.cc in Sources */ = {isa = PBXBuildFile; fileRef = F92C53740ECCE635009BE4BA /* file_id.cc */; };
 		D2F9A539121383A1002747C1 /* macho_id.cc in Sources */ = {isa = PBXBuildFile; fileRef = F92C537A0ECCE635009BE4BA /* macho_id.cc */; };
@@ -146,6 +149,9 @@
 		D2F9A53F121383A1002747C1 /* Foundation.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 0867D69BFE84028FC02AAC07 /* Foundation.framework */; };
 		D2F9A541121383A1002747C1 /* libgtest.a in Frameworks */ = {isa = PBXBuildFile; fileRef = D2F9A41512131EF0002747C1 /* libgtest.a */; };
 		D2F9A553121383DC002747C1 /* crash_generation_server_test.cc in Sources */ = {isa = PBXBuildFile; fileRef = D2F9A4CE121336F7002747C1 /* crash_generation_server_test.cc */; };
+		F4DAB1DD19F1027100A5A838 /* launch_reporter.cc in Sources */ = {isa = PBXBuildFile; fileRef = F4DAB1DB19F1027100A5A838 /* launch_reporter.cc */; };
+		F4DAB1DE19F1027100A5A838 /* launch_reporter.h in Headers */ = {isa = PBXBuildFile; fileRef = F4DAB1DC19F1027100A5A838 /* launch_reporter.h */; };
+		F4F916B619F10FFC00B83BE4 /* launch_reporter.cc in Sources */ = {isa = PBXBuildFile; fileRef = F4DAB1DB19F1027100A5A838 /* launch_reporter.cc */; };
 		F91AF6210FD60784009D8BE2 /* Breakpad.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 8DC2EF5B0486A6940098B216 /* Breakpad.framework */; };
 		F9286B3A0F7EB25800A4DCC8 /* InspectorMain.mm in Sources */ = {isa = PBXBuildFile; fileRef = F9286B390F7EB25800A4DCC8 /* InspectorMain.mm */; };
 		F92C53B80ECCE7B3009BE4BA /* Inspector.mm in Sources */ = {isa = PBXBuildFile; fileRef = F92C53B70ECCE7B3009BE4BA /* Inspector.mm */; };
@@ -154,7 +160,7 @@
 		F92C55D10ECD0064009BE4BA /* Breakpad.mm in Sources */ = {isa = PBXBuildFile; fileRef = F92C55CF0ECD0064009BE4BA /* Breakpad.mm */; };
 		F92C56330ECD0DF1009BE4BA /* OnDemandServer.h in Headers */ = {isa = PBXBuildFile; fileRef = F92C56310ECD0DF1009BE4BA /* OnDemandServer.h */; };
 		F92C56340ECD0DF1009BE4BA /* OnDemandServer.mm in Sources */ = {isa = PBXBuildFile; fileRef = F92C56320ECD0DF1009BE4BA /* OnDemandServer.mm */; };
-		F92C563F0ECD10CA009BE4BA /* convert_UTF.c in Sources */ = {isa = PBXBuildFile; fileRef = F92C53870ECCE6C0009BE4BA /* convert_UTF.c */; };
+		F92C563F0ECD10CA009BE4BA /* convert_UTF.cc in Sources */ = {isa = PBXBuildFile; fileRef = F92C53870ECCE6C0009BE4BA /* convert_UTF.cc */; };
 		F92C56400ECD10CA009BE4BA /* dynamic_images.cc in Sources */ = {isa = PBXBuildFile; fileRef = F92C536B0ECCE3FD009BE4BA /* dynamic_images.cc */; };
 		F92C56410ECD10CA009BE4BA /* file_id.cc in Sources */ = {isa = PBXBuildFile; fileRef = F92C53740ECCE635009BE4BA /* file_id.cc */; };
 		F92C56420ECD10CA009BE4BA /* macho_id.cc in Sources */ = {isa = PBXBuildFile; fileRef = F92C537A0ECCE635009BE4BA /* macho_id.cc */; };
@@ -177,7 +183,7 @@
 		F93803CE0F8083B7004D428B /* exception_handler.cc in Sources */ = {isa = PBXBuildFile; fileRef = F92C536D0ECCE3FD009BE4BA /* exception_handler.cc */; };
 		F93803CF0F8083B7004D428B /* minidump_generator.cc in Sources */ = {isa = PBXBuildFile; fileRef = F92C536F0ECCE3FD009BE4BA /* minidump_generator.cc */; };
 		F93803D00F8083B7004D428B /* minidump_file_writer.cc in Sources */ = {isa = PBXBuildFile; fileRef = F92C538F0ECCE70A009BE4BA /* minidump_file_writer.cc */; };
-		F93803D10F8083B7004D428B /* convert_UTF.c in Sources */ = {isa = PBXBuildFile; fileRef = F92C53870ECCE6C0009BE4BA /* convert_UTF.c */; };
+		F93803D10F8083B7004D428B /* convert_UTF.cc in Sources */ = {isa = PBXBuildFile; fileRef = F92C53870ECCE6C0009BE4BA /* convert_UTF.cc */; };
 		F93803D20F8083B7004D428B /* string_conversion.cc in Sources */ = {isa = PBXBuildFile; fileRef = F92C53850ECCE6AD009BE4BA /* string_conversion.cc */; };
 		F93803D30F8083B7004D428B /* file_id.cc in Sources */ = {isa = PBXBuildFile; fileRef = F92C53740ECCE635009BE4BA /* file_id.cc */; };
 		F93803D40F8083B7004D428B /* macho_id.cc in Sources */ = {isa = PBXBuildFile; fileRef = F92C537A0ECCE635009BE4BA /* macho_id.cc */; };
@@ -186,13 +192,13 @@
 		F93803D70F8083B7004D428B /* string_utilities.cc in Sources */ = {isa = PBXBuildFile; fileRef = F92C53820ECCE635009BE4BA /* string_utilities.cc */; };
 		F93DE2D80F82A70E00608B94 /* minidump_file_writer_unittest.cc in Sources */ = {isa = PBXBuildFile; fileRef = F93DE2D70F82A70E00608B94 /* minidump_file_writer_unittest.cc */; };
 		F93DE2D90F82A73500608B94 /* minidump_file_writer.cc in Sources */ = {isa = PBXBuildFile; fileRef = F92C538F0ECCE70A009BE4BA /* minidump_file_writer.cc */; };
-		F93DE2DA0F82A73500608B94 /* convert_UTF.c in Sources */ = {isa = PBXBuildFile; fileRef = F92C53870ECCE6C0009BE4BA /* convert_UTF.c */; };
+		F93DE2DA0F82A73500608B94 /* convert_UTF.cc in Sources */ = {isa = PBXBuildFile; fileRef = F92C53870ECCE6C0009BE4BA /* convert_UTF.cc */; };
 		F93DE2DB0F82A73500608B94 /* string_conversion.cc in Sources */ = {isa = PBXBuildFile; fileRef = F92C53850ECCE6AD009BE4BA /* string_conversion.cc */; };
 		F93DE3350F82C66B00608B94 /* dynamic_images.cc in Sources */ = {isa = PBXBuildFile; fileRef = F92C536B0ECCE3FD009BE4BA /* dynamic_images.cc */; };
 		F93DE3360F82C66B00608B94 /* exception_handler.cc in Sources */ = {isa = PBXBuildFile; fileRef = F92C536D0ECCE3FD009BE4BA /* exception_handler.cc */; };
 		F93DE3370F82C66B00608B94 /* minidump_generator.cc in Sources */ = {isa = PBXBuildFile; fileRef = F92C536F0ECCE3FD009BE4BA /* minidump_generator.cc */; };
 		F93DE3380F82C66B00608B94 /* minidump_file_writer.cc in Sources */ = {isa = PBXBuildFile; fileRef = F92C538F0ECCE70A009BE4BA /* minidump_file_writer.cc */; };
-		F93DE3390F82C66B00608B94 /* convert_UTF.c in Sources */ = {isa = PBXBuildFile; fileRef = F92C53870ECCE6C0009BE4BA /* convert_UTF.c */; };
+		F93DE3390F82C66B00608B94 /* convert_UTF.cc in Sources */ = {isa = PBXBuildFile; fileRef = F92C53870ECCE6C0009BE4BA /* convert_UTF.cc */; };
 		F93DE33A0F82C66B00608B94 /* string_conversion.cc in Sources */ = {isa = PBXBuildFile; fileRef = F92C53850ECCE6AD009BE4BA /* string_conversion.cc */; };
 		F93DE33B0F82C66B00608B94 /* file_id.cc in Sources */ = {isa = PBXBuildFile; fileRef = F92C53740ECCE635009BE4BA /* file_id.cc */; };
 		F93DE33C0F82C66B00608B94 /* macho_id.cc in Sources */ = {isa = PBXBuildFile; fileRef = F92C537A0ECCE635009BE4BA /* macho_id.cc */; };
@@ -574,13 +580,14 @@
 		3329D4EC0FA16D820007BBC5 /* Breakpad.xib */ = {isa = PBXFileReference; lastKnownFileType = file.xib; name = Breakpad.xib; path = sender/Breakpad.xib; sourceTree = "<group>"; };
 		33880C7F0F9E097100817F82 /* English */ = {isa = PBXFileReference; fileEncoding = 10; lastKnownFileType = text.plist.strings; name = English; path = sender/English.lproj/InfoPlist.strings; sourceTree = "<group>"; };
 		4084699C0F5D9CF900FDCA37 /* crash_report_sender.icns */ = {isa = PBXFileReference; lastKnownFileType = image.icns; name = crash_report_sender.icns; path = sender/crash_report_sender.icns; sourceTree = "<group>"; };
+		421BC5AD21110C0300B8042E /* convert_old_arm64_context.cc */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = convert_old_arm64_context.cc; path = ../../processor/convert_old_arm64_context.cc; sourceTree = "<group>"; };
+		421BC5BB21110C0300B8042E /* convert_old_arm64_context.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = convert_old_arm64_context.h; path = ../../processor/convert_old_arm64_context.h; sourceTree = "<group>"; };
 		4D61A25D14F43CFC002D5862 /* bootstrap_compat.cc */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = bootstrap_compat.cc; path = ../../common/mac/bootstrap_compat.cc; sourceTree = SOURCE_ROOT; };
 		4D61A25E14F43CFC002D5862 /* bootstrap_compat.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = bootstrap_compat.h; path = ../../common/mac/bootstrap_compat.h; sourceTree = SOURCE_ROOT; };
 		4D72CA0D13DFAD5C006CABE3 /* md5.cc */ = {isa = PBXFileReference; explicitFileType = sourcecode.cpp.cpp; fileEncoding = 4; name = md5.cc; path = ../../common/md5.cc; sourceTree = SOURCE_ROOT; };
 		4DBE4769134A4F080072546A /* CoreServices.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = CoreServices.framework; path = System/Library/Frameworks/CoreServices.framework; sourceTree = SDKROOT; };
 		8B31007011F0CD3C00FCF3E4 /* GTMDefines.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GTMDefines.h; path = ../../common/mac/GTMDefines.h; sourceTree = SOURCE_ROOT; };
 		8B3101E911F0CDE300FCF3E4 /* SenTestingKit.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = SenTestingKit.framework; path = Library/Frameworks/SenTestingKit.framework; sourceTree = DEVELOPER_DIR; };
-		8B31022211F0CE1000FCF3E4 /* GTMGarbageCollection.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GTMGarbageCollection.h; path = ../../common/mac/GTMGarbageCollection.h; sourceTree = SOURCE_ROOT; };
 		8B31027711F0D3AF00FCF3E4 /* BreakpadDebug.xcconfig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xcconfig; name = BreakpadDebug.xcconfig; path = ../../common/mac/BreakpadDebug.xcconfig; sourceTree = SOURCE_ROOT; };
 		8B31027811F0D3AF00FCF3E4 /* BreakpadRelease.xcconfig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xcconfig; name = BreakpadRelease.xcconfig; path = ../../common/mac/BreakpadRelease.xcconfig; sourceTree = SOURCE_ROOT; };
 		8B31FFF611F0C90500FCF3E4 /* Breakpad.xcconfig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xcconfig; name = Breakpad.xcconfig; path = ../../common/mac/Breakpad.xcconfig; sourceTree = SOURCE_ROOT; };
@@ -592,12 +599,12 @@
 		D244535112426EBB009BBCE0 /* logging.cc */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = logging.cc; path = ../../processor/logging.cc; sourceTree = SOURCE_ROOT; };
 		D244535212426EBB009BBCE0 /* minidump.cc */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = minidump.cc; path = ../../processor/minidump.cc; sourceTree = SOURCE_ROOT; };
 		D244535312426EBB009BBCE0 /* pathname_stripper.cc */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = pathname_stripper.cc; path = ../../processor/pathname_stripper.cc; sourceTree = SOURCE_ROOT; };
-		D244540A12439BA0009BBCE0 /* memory_unittest.cc */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = memory_unittest.cc; path = ../../common/memory_unittest.cc; sourceTree = SOURCE_ROOT; };
+		D244540A12439BA0009BBCE0 /* memory_allocator_unittest.cc */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = memory_allocator_unittest.cc; path = ../../common/memory_allocator_unittest.cc; sourceTree = SOURCE_ROOT; };
 		D2F9A3D41212F87C002747C1 /* exception_handler_test.cc */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = exception_handler_test.cc; path = tests/exception_handler_test.cc; sourceTree = "<group>"; };
 		D2F9A41512131EF0002747C1 /* libgtest.a */ = {isa = PBXFileReference; explicitFileType = archive.ar; includeInIndex = 0; path = libgtest.a; sourceTree = BUILT_PRODUCTS_DIR; };
-		D2F9A43C12131F55002747C1 /* gmock-all.cc */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = "gmock-all.cc"; path = "../../testing/src/gmock-all.cc"; sourceTree = SOURCE_ROOT; };
-		D2F9A43E12131F65002747C1 /* gtest_main.cc */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = gtest_main.cc; path = ../../testing/gtest/src/gtest_main.cc; sourceTree = "<group>"; };
-		D2F9A43F12131F65002747C1 /* gtest-all.cc */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = "gtest-all.cc"; path = "../../testing/gtest/src/gtest-all.cc"; sourceTree = "<group>"; };
+		D2F9A43C12131F55002747C1 /* gmock-all.cc */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = "gmock-all.cc"; path = "../../testing/googlemock/src/gmock-all.cc"; sourceTree = SOURCE_ROOT; };
+		D2F9A43E12131F65002747C1 /* gtest_main.cc */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = gtest_main.cc; path = ../../testing/googletest/src/gtest_main.cc; sourceTree = "<group>"; };
+		D2F9A43F12131F65002747C1 /* gtest-all.cc */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = "gtest-all.cc"; path = "../../testing/googletest/src/gtest-all.cc"; sourceTree = "<group>"; };
 		D2F9A4C4121336C7002747C1 /* client_info.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = client_info.h; path = crash_generation/client_info.h; sourceTree = "<group>"; };
 		D2F9A4C5121336C7002747C1 /* crash_generation_client.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = crash_generation_client.h; path = crash_generation/crash_generation_client.h; sourceTree = "<group>"; };
 		D2F9A4C6121336C7002747C1 /* crash_generation_client.cc */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = crash_generation_client.cc; path = crash_generation/crash_generation_client.cc; sourceTree = "<group>"; };
@@ -627,6 +634,8 @@
 		DE43468E11C72971004F095F /* sl */ = {isa = PBXFileReference; fileEncoding = 10; lastKnownFileType = text.plist.strings; name = sl; path = sender/sl.lproj/InfoPlist.strings; sourceTree = "<group>"; };
 		DE43468F11C72973004F095F /* sv */ = {isa = PBXFileReference; fileEncoding = 10; lastKnownFileType = text.plist.strings; name = sv; path = sender/sv.lproj/InfoPlist.strings; sourceTree = "<group>"; };
 		DE43469011C72976004F095F /* tr */ = {isa = PBXFileReference; fileEncoding = 10; lastKnownFileType = text.plist.strings; name = tr; path = sender/tr.lproj/InfoPlist.strings; sourceTree = "<group>"; };
+		F4DAB1DB19F1027100A5A838 /* launch_reporter.cc */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = launch_reporter.cc; path = ../../common/mac/launch_reporter.cc; sourceTree = SOURCE_ROOT; };
+		F4DAB1DC19F1027100A5A838 /* launch_reporter.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = launch_reporter.h; path = ../../common/mac/launch_reporter.h; sourceTree = SOURCE_ROOT; };
 		F91AF5CF0FD60393009D8BE2 /* BreakpadFramework_Test.mm */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.objcpp; name = BreakpadFramework_Test.mm; path = tests/BreakpadFramework_Test.mm; sourceTree = "<group>"; };
 		F9286B380F7EB25800A4DCC8 /* Inspector.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Inspector.h; path = crash_generation/Inspector.h; sourceTree = "<group>"; };
 		F9286B390F7EB25800A4DCC8 /* InspectorMain.mm */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.objcpp; name = InspectorMain.mm; path = crash_generation/InspectorMain.mm; sourceTree = "<group>"; };
@@ -659,7 +668,7 @@
 		F92C53830ECCE635009BE4BA /* string_utilities.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = string_utilities.h; path = ../../common/mac/string_utilities.h; sourceTree = SOURCE_ROOT; };
 		F92C53850ECCE6AD009BE4BA /* string_conversion.cc */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = string_conversion.cc; path = ../../common/string_conversion.cc; sourceTree = SOURCE_ROOT; };
 		F92C53860ECCE6AD009BE4BA /* string_conversion.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = string_conversion.h; path = ../../common/string_conversion.h; sourceTree = SOURCE_ROOT; };
-		F92C53870ECCE6C0009BE4BA /* convert_UTF.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; name = convert_UTF.c; path = ../../common/convert_UTF.c; sourceTree = SOURCE_ROOT; };
+		F92C53870ECCE6C0009BE4BA /* convert_UTF.cc */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = convert_UTF.cc; path = ../../common/convert_UTF.cc; sourceTree = SOURCE_ROOT; };
 		F92C53880ECCE6C0009BE4BA /* convert_UTF.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = convert_UTF.h; path = ../../common/convert_UTF.h; sourceTree = SOURCE_ROOT; };
 		F92C538E0ECCE70A009BE4BA /* minidump_file_writer-inl.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = "minidump_file_writer-inl.h"; path = "../minidump_file_writer-inl.h"; sourceTree = SOURCE_ROOT; };
 		F92C538F0ECCE70A009BE4BA /* minidump_file_writer.cc */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = minidump_file_writer.cc; path = ../minidump_file_writer.cc; sourceTree = SOURCE_ROOT; };
@@ -892,6 +901,8 @@
 		D244536912426EE7009BBCE0 /* processor */ = {
 			isa = PBXGroup;
 			children = (
+				421BC5AD21110C0300B8042E /* convert_old_arm64_context.cc */,
+				421BC5BB21110C0300B8042E /* convert_old_arm64_context.h */,
 				D244535112426EBB009BBCE0 /* logging.cc */,
 				D244535212426EBB009BBCE0 /* minidump.cc */,
 				D244535312426EBB009BBCE0 /* pathname_stripper.cc */,
@@ -932,8 +943,8 @@
 		F92C53600ECCE3D6009BE4BA /* common */ = {
 			isa = PBXGroup;
 			children = (
-				D244540A12439BA0009BBCE0 /* memory_unittest.cc */,
-				F92C53870ECCE6C0009BE4BA /* convert_UTF.c */,
+				D244540A12439BA0009BBCE0 /* memory_allocator_unittest.cc */,
+				F92C53870ECCE6C0009BE4BA /* convert_UTF.cc */,
 				F92C53880ECCE6C0009BE4BA /* convert_UTF.h */,
 				4D72CA0D13DFAD5C006CABE3 /* md5.cc */,
 				1EEEB6211720829E00F7E689 /* simple_string_dictionary.cc */,
@@ -950,7 +961,6 @@
 			children = (
 				162F64F0161C577500CD68D5 /* arch_utilities.cc */,
 				162F64F1161C577500CD68D5 /* arch_utilities.h */,
-				8B31022211F0CE1000FCF3E4 /* GTMGarbageCollection.h */,
 				8B31007011F0CD3C00FCF3E4 /* GTMDefines.h */,
 				F9C77E0F0F7DDF650045F7DB /* testing */,
 				F9C44EE70EF0A3C1003AEBAA /* GTMLogger.h */,
@@ -959,6 +969,8 @@
 				F92C53750ECCE635009BE4BA /* file_id.h */,
 				F92C53760ECCE635009BE4BA /* HTTPMultipartUpload.h */,
 				F92C53770ECCE635009BE4BA /* HTTPMultipartUpload.m */,
+				F4DAB1DB19F1027100A5A838 /* launch_reporter.cc */,
+				F4DAB1DC19F1027100A5A838 /* launch_reporter.h */,
 				F92C53780ECCE635009BE4BA /* MachIPC.h */,
 				F92C53790ECCE635009BE4BA /* MachIPC.mm */,
 				4D61A25D14F43CFC002D5862 /* bootstrap_compat.cc */,
@@ -1149,7 +1161,9 @@
 				D2F9A4CC121336C7002747C1 /* crash_generation_server.h in Headers */,
 				163201D61443019E00C4DBF5 /* ConfigFile.h in Headers */,
 				16C7C918147D45AE00776EAD /* BreakpadDefines.h in Headers */,
+				421BC5BD21110C0300B8042E /* convert_old_arm64_context.h in Headers */,
 				162F64F3161C577500CD68D5 /* arch_utilities.h in Headers */,
+				F4DAB1DE19F1027100A5A838 /* launch_reporter.h in Headers */,
 				1EEEB6241720829E00F7E689 /* simple_string_dictionary.h in Headers */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
@@ -1393,6 +1407,8 @@
 /* Begin PBXProject section */
 		0867D690FE84028FC02AAC07 /* Project object */ = {
 			isa = PBXProject;
+			attributes = {
+			};
 			buildConfigurationList = 1DEB91B108733DA50010E9CD /* Build configuration list for PBXProject "Breakpad" */;
 			compatibilityVersion = "Xcode 3.1";
 			developmentRegion = English;
@@ -1671,12 +1687,14 @@
 				F92C565F0ECD116B009BE4BA /* protected_memory_allocator.cc in Sources */,
 				F92C56630ECD1179009BE4BA /* exception_handler.cc in Sources */,
 				F92C55D10ECD0064009BE4BA /* Breakpad.mm in Sources */,
+				F4DAB1DD19F1027100A5A838 /* launch_reporter.cc in Sources */,
 				F92C56340ECD0DF1009BE4BA /* OnDemandServer.mm in Sources */,
 				D2F9A4CB121336C7002747C1 /* crash_generation_client.cc in Sources */,
 				D2F9A4CD121336C7002747C1 /* crash_generation_server.cc in Sources */,
 				163201D71443019E00C4DBF5 /* ConfigFile.mm in Sources */,
 				162F64F2161C577500CD68D5 /* arch_utilities.cc in Sources */,
 				1EEEB6231720829E00F7E689 /* simple_string_dictionary.cc in Sources */,
+				421BC5BC21110C0300B8042E /* convert_old_arm64_context.cc in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -1694,7 +1712,7 @@
 				D246418812BAA4E3005170D0 /* string_utilities.cc in Sources */,
 				D246418C12BAA508005170D0 /* minidump_file_writer.cc in Sources */,
 				D246419012BAA52A005170D0 /* string_conversion.cc in Sources */,
-				D246419112BAA52F005170D0 /* convert_UTF.c in Sources */,
+				D246419112BAA52F005170D0 /* convert_UTF.cc in Sources */,
 				D246419512BAA54C005170D0 /* file_id.cc in Sources */,
 				D246419612BAA55A005170D0 /* macho_id.cc in Sources */,
 				D24641A012BAA67F005170D0 /* macho_walker.cc in Sources */,
@@ -1727,7 +1745,7 @@
 				D2F9A533121383A1002747C1 /* exception_handler.cc in Sources */,
 				D2F9A534121383A1002747C1 /* minidump_generator.cc in Sources */,
 				D2F9A535121383A1002747C1 /* minidump_file_writer.cc in Sources */,
-				D2F9A536121383A1002747C1 /* convert_UTF.c in Sources */,
+				D2F9A536121383A1002747C1 /* convert_UTF.cc in Sources */,
 				D2F9A537121383A1002747C1 /* string_conversion.cc in Sources */,
 				D2F9A538121383A1002747C1 /* file_id.cc in Sources */,
 				D2F9A539121383A1002747C1 /* macho_id.cc in Sources */,
@@ -1758,10 +1776,11 @@
 			isa = PBXSourcesBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
+				F4F916B619F10FFC00B83BE4 /* launch_reporter.cc in Sources */,
 				162F64F4161C579B00CD68D5 /* arch_utilities.cc in Sources */,
 				162F64F5161C579B00CD68D5 /* arch_utilities.h in Sources */,
 				D2A5DD301188633800081F03 /* breakpad_nlist_64.cc in Sources */,
-				F92C563F0ECD10CA009BE4BA /* convert_UTF.c in Sources */,
+				F92C563F0ECD10CA009BE4BA /* convert_UTF.cc in Sources */,
 				F92C56400ECD10CA009BE4BA /* dynamic_images.cc in Sources */,
 				F92C56410ECD10CA009BE4BA /* file_id.cc in Sources */,
 				F92C56420ECD10CA009BE4BA /* macho_id.cc in Sources */,
@@ -1804,7 +1823,7 @@
 				F93803CE0F8083B7004D428B /* exception_handler.cc in Sources */,
 				F93803CF0F8083B7004D428B /* minidump_generator.cc in Sources */,
 				F93803D00F8083B7004D428B /* minidump_file_writer.cc in Sources */,
-				F93803D10F8083B7004D428B /* convert_UTF.c in Sources */,
+				F93803D10F8083B7004D428B /* convert_UTF.cc in Sources */,
 				F93803D20F8083B7004D428B /* string_conversion.cc in Sources */,
 				F93803D30F8083B7004D428B /* file_id.cc in Sources */,
 				F93803D40F8083B7004D428B /* macho_id.cc in Sources */,
@@ -1824,7 +1843,7 @@
 			buildActionMask = 2147483647;
 			files = (
 				F93DE2D90F82A73500608B94 /* minidump_file_writer.cc in Sources */,
-				F93DE2DA0F82A73500608B94 /* convert_UTF.c in Sources */,
+				F93DE2DA0F82A73500608B94 /* convert_UTF.cc in Sources */,
 				F93DE2DB0F82A73500608B94 /* string_conversion.cc in Sources */,
 				F93DE2D80F82A70E00608B94 /* minidump_file_writer_unittest.cc in Sources */,
 			);
@@ -1834,6 +1853,8 @@
 			isa = PBXSourcesBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
+				421BC5BE21110C1000B8042E /* convert_old_arm64_context.cc in Sources */,
+				4247E6412110D7A300482558 /* memory_allocator_unittest.cc in Sources */,
 				D244536A12426F00009BBCE0 /* logging.cc in Sources */,
 				D244536B12426F00009BBCE0 /* minidump.cc in Sources */,
 				D244536C12426F00009BBCE0 /* pathname_stripper.cc in Sources */,
@@ -1846,7 +1867,7 @@
 				F93DE3360F82C66B00608B94 /* exception_handler.cc in Sources */,
 				F93DE3370F82C66B00608B94 /* minidump_generator.cc in Sources */,
 				F93DE3380F82C66B00608B94 /* minidump_file_writer.cc in Sources */,
-				F93DE3390F82C66B00608B94 /* convert_UTF.c in Sources */,
+				F93DE3390F82C66B00608B94 /* convert_UTF.cc in Sources */,
 				F93DE33A0F82C66B00608B94 /* string_conversion.cc in Sources */,
 				F93DE33B0F82C66B00608B94 /* file_id.cc in Sources */,
 				F93DE33C0F82C66B00608B94 /* macho_id.cc in Sources */,
@@ -1854,7 +1875,6 @@
 				F93DE33E0F82C66B00608B94 /* macho_walker.cc in Sources */,
 				F93DE33F0F82C66B00608B94 /* string_utilities.cc in Sources */,
 				D2F9A3D51212F87C002747C1 /* exception_handler_test.cc in Sources */,
-				D244540B12439BA0009BBCE0 /* memory_unittest.cc in Sources */,
 				4D72CA3813DFAE91006CABE3 /* md5.cc in Sources */,
 				4D61A26E14F43D45002D5862 /* bootstrap_compat.cc in Sources */,
 				1EEEB6271720831E00F7E689 /* BreakpadFramework_Test.mm in Sources */,
@@ -2118,8 +2138,9 @@
 			isa = XCBuildConfiguration;
 			baseConfigurationReference = 8B31027711F0D3AF00FCF3E4 /* BreakpadDebug.xcconfig */;
 			buildSettings = {
+				CLANG_CXX_LANGUAGE_STANDARD = "c++17";
 				GCC_TREAT_WARNINGS_AS_ERRORS = NO;
-				SDKROOT = macosx10.5;
+				SDKROOT = macosx;
 			};
 			name = Debug;
 		};
@@ -2127,6 +2148,7 @@
 			isa = XCBuildConfiguration;
 			baseConfigurationReference = 8B31027811F0D3AF00FCF3E4 /* BreakpadRelease.xcconfig */;
 			buildSettings = {
+				CLANG_CXX_LANGUAGE_STANDARD = "c++17";
 				GCC_TREAT_WARNINGS_AS_ERRORS = NO;
 			};
 			name = Release;
@@ -2185,10 +2207,10 @@
 				GCC_OPTIMIZATION_LEVEL = 0;
 				HEADER_SEARCH_PATHS = (
 					"$(inherited)",
-					../../testing,
-					../../testing/include,
-					../../testing/gtest,
-					../../testing/gtest/include,
+					../../testing/googlemock,
+					../../testing/googlemock/include,
+					../../testing/googletest,
+					../../testing/googletest/include,
 				);
 				PREBINDING = NO;
 				PRODUCT_NAME = gtest;
@@ -2201,10 +2223,10 @@
 				ALWAYS_SEARCH_USER_PATHS = NO;
 				HEADER_SEARCH_PATHS = (
 					"$(inherited)",
-					../../testing,
-					../../testing/include,
-					../../testing/gtest,
-					../../testing/gtest/include,
+					../../testing/googlemock,
+					../../testing/googlemock/include,
+					../../testing/googletest,
+					../../testing/googletest/include,
 				);
 				PREBINDING = NO;
 				PRODUCT_NAME = gtest;
@@ -2220,10 +2242,10 @@
 				GCC_ENABLE_FIX_AND_CONTINUE = NO;
 				HEADER_SEARCH_PATHS = (
 					"$(inherited)",
-					../../testing,
-					../../testing/include,
-					../../testing/gtest,
-					../../testing/gtest/include,
+					../../testing/googlemock,
+					../../testing/googlemock/include,
+					../../testing/googletest,
+					../../testing/googletest/include,
 				);
 				PREBINDING = NO;
 				PRODUCT_NAME = gtest;
@@ -2240,10 +2262,10 @@
 				GCC_SYMBOLS_PRIVATE_EXTERN = NO;
 				HEADER_SEARCH_PATHS = (
 					../..,
-					../../testing,
-					../../testing/include,
-					../../testing/gtest,
-					../../testing/gtest/include,
+					../../testing/googlemock,
+					../../testing/googlemock/include,
+					../../testing/googletest,
+					../../testing/googletest/include,
 				);
 				LIBRARY_SEARCH_PATHS = (
 					"$(inherited)",
@@ -2258,10 +2280,10 @@
 			buildSettings = {
 				HEADER_SEARCH_PATHS = (
 					../..,
-					../../testing,
-					../../testing/include,
-					../../testing/gtest,
-					../../testing/gtest/include,
+					../../testing/googlemock,
+					../../testing/googlemock/include,
+					../../testing/googletest,
+					../../testing/googletest/include,
 				);
 				LIBRARY_SEARCH_PATHS = (
 					"$(inherited)",
@@ -2276,10 +2298,10 @@
 			buildSettings = {
 				HEADER_SEARCH_PATHS = (
 					../..,
-					../../testing,
-					../../testing/include,
-					../../testing/gtest,
-					../../testing/gtest/include,
+					../../testing/googlemock,
+					../../testing/googlemock/include,
+					../../testing/googletest,
+					../../testing/googletest/include,
 				);
 				LIBRARY_SEARCH_PATHS = (
 					"$(inherited)",
@@ -2360,10 +2382,8 @@
 				HEADER_SEARCH_PATHS = (
 					../..,
 					../../..,
-					../../testing,
-					../../testing/include,
-					../../testing/gtest,
-					../../testing/gtest/include,
+					../../testing/googlemock/include,
+					../../testing/googletest/include,
 				);
 				PRODUCT_NAME = generator_test;
 			};
@@ -2375,10 +2395,8 @@
 				HEADER_SEARCH_PATHS = (
 					../..,
 					../../..,
-					../../testing,
-					../../testing/include,
-					../../testing/gtest,
-					../../testing/gtest/include,
+					../../testing/googlemock/include,
+					../../testing/googletest/include,
 				);
 				PRODUCT_NAME = generator_test;
 			};
@@ -2410,10 +2428,10 @@
 				HEADER_SEARCH_PATHS = (
 					../../..,
 					../..,
-					../../testing,
-					../../testing/include,
-					../../testing/gtest,
-					../../testing/gtest/include,
+					../../testing/googletest,
+					../../testing/googletest/include,
+					../../testing/googlemock,
+					../../testing/googlemock/include,
 				);
 				LIBRARY_SEARCH_PATHS = (
 					"$(inherited)",
@@ -2429,10 +2447,10 @@
 				HEADER_SEARCH_PATHS = (
 					../../..,
 					../..,
-					../../testing,
-					../../testing/include,
-					../../testing/gtest,
-					../../testing/gtest/include,
+					../../testing/googletest,
+					../../testing/googletest/include,
+					../../testing/googlemock,
+					../../testing/googlemock/include,
 				);
 				LIBRARY_SEARCH_PATHS = (
 					"$(inherited)",
@@ -2446,6 +2464,7 @@
 			isa = XCBuildConfiguration;
 			baseConfigurationReference = 8B31027711F0D3AF00FCF3E4 /* BreakpadDebug.xcconfig */;
 			buildSettings = {
+				CLANG_CXX_LANGUAGE_STANDARD = "c++17";
 				GCC_TREAT_WARNINGS_AS_ERRORS = NO;
 			};
 			name = "Debug With Code Coverage";
@@ -2535,10 +2554,8 @@
 				HEADER_SEARCH_PATHS = (
 					../..,
 					../../..,
-					../../testing,
-					../../testing/include,
-					../../testing/gtest,
-					../../testing/gtest/include,
+					../../testing/googlemock/include,
+					../../testing/googletest/include,
 				);
 				PRODUCT_NAME = generator_test;
 			};
@@ -2558,10 +2575,10 @@
 				HEADER_SEARCH_PATHS = (
 					../../..,
 					../..,
-					../../testing,
-					../../testing/include,
-					../../testing/gtest,
-					../../testing/gtest/include,
+					../../testing/googletest,
+					../../testing/googletest/include,
+					../../testing/googlemock,
+					../../testing/googlemock/include,
 				);
 				LIBRARY_SEARCH_PATHS = (
 					"$(inherited)",
diff --git a/src/MEGASync/google_breakpad/client/mac/Framework/Breakpad.h b/src/MEGASync/google_breakpad/client/mac/Framework/Breakpad.h
index dbc620eb..9e191ce2 100644
--- a/src/MEGASync/google_breakpad/client/mac/Framework/Breakpad.h
+++ b/src/MEGASync/google_breakpad/client/mac/Framework/Breakpad.h
@@ -45,7 +45,7 @@
 // OnDemandServer and restored in Inspector.
 #define BREAKPAD_BOOTSTRAP_PARENT_PORT    "com.Breakpad.BootstrapParent"
 
-typedef void *BreakpadRef;
+typedef void* BreakpadRef;
 
 #ifdef __cplusplus
 extern "C" {
@@ -65,7 +65,7 @@ extern "C" {
 typedef bool (*BreakpadFilterCallback)(int exception_type,
                                        int exception_code,
                                        mach_port_t crashing_thread,
-                                       void *context);
+                                       void* context);
 
 // Create a new BreakpadRef object and install it as an exception
 // handler.  The |parameters| will typically be the contents of your
@@ -158,6 +158,11 @@ typedef bool (*BreakpadFilterCallback)(int exception_type,
 //                                but pass as URL parameters when
 //                                uploading theminidump to the crash
 //                                server.
+//
+// BREAKPAD_IN_PROCESS            A boolean NSNumber value. If YES, Breakpad
+//                                will write the dump file in-process and then
+//                                launch the reporter executable as a child
+//                                process.
 //=============================================================================
 // The BREAKPAD_PRODUCT, BREAKPAD_VERSION and BREAKPAD_URL are
 // required to have non-NULL values.  By default, the BREAKPAD_PRODUCT
@@ -221,7 +226,7 @@ typedef bool (*BreakpadFilterCallback)(int exception_type,
 //                                   Only used in crash_report_sender.
 
 // Returns a new BreakpadRef object on success, NULL otherwise.
-BreakpadRef BreakpadCreate(NSDictionary *parameters);
+BreakpadRef BreakpadCreate(NSDictionary* parameters);
 
 // Uninstall and release the data associated with |ref|.
 void BreakpadRelease(BreakpadRef ref);
@@ -233,7 +238,7 @@ void BreakpadRelease(BreakpadRef ref);
 // Context is a pointer to arbitrary data to make the callback with.
 void BreakpadSetFilterCallback(BreakpadRef ref,
                                BreakpadFilterCallback callback,
-                               void *context);
+                               void* context);
 
 // User defined key and value string storage.  Generally this is used
 // to configure Breakpad's internal operation, such as whether the
@@ -254,23 +259,23 @@ void BreakpadSetFilterCallback(BreakpadRef ref,
 // TODO (nealsid): separate server parameter dictionary from the
 // dictionary used to configure Breakpad, and document limits for each
 // independently.
-void BreakpadSetKeyValue(BreakpadRef ref, NSString *key, NSString *value);
-NSString *BreakpadKeyValue(BreakpadRef ref, NSString *key);
-void BreakpadRemoveKeyValue(BreakpadRef ref, NSString *key);
+void BreakpadSetKeyValue(BreakpadRef ref, NSString* key, NSString* value);
+NSString* BreakpadKeyValue(BreakpadRef ref, NSString* key);
+void BreakpadRemoveKeyValue(BreakpadRef ref, NSString* key);
 
 // You can use this method to specify parameters that will be uploaded
 // to the crash server.  They will be automatically encoded as
 // necessary.  Note that as mentioned above there are limits on both
 // the number of keys and their length.
-void BreakpadAddUploadParameter(BreakpadRef ref, NSString *key,
-                                NSString *value);
+void BreakpadAddUploadParameter(BreakpadRef ref, NSString* key,
+                                NSString* value);
 
 // This method will remove a previously-added parameter from the
 // upload parameter set.
-void BreakpadRemoveUploadParameter(BreakpadRef ref, NSString *key);
+void BreakpadRemoveUploadParameter(BreakpadRef ref, NSString* key);
 
 // Add a log file for Breakpad to read and send upon crash dump
-void BreakpadAddLogFile(BreakpadRef ref, NSString *logPathname);
+void BreakpadAddLogFile(BreakpadRef ref, NSString* logPathname);
 
 // Generate a minidump and send
 void BreakpadGenerateAndSendReport(BreakpadRef ref);
diff --git a/src/MEGASync/google_breakpad/client/mac/Framework/Breakpad.mm b/src/MEGASync/google_breakpad/client/mac/Framework/Breakpad.mm
index a1336475..1a46b597 100644
--- a/src/MEGASync/google_breakpad/client/mac/Framework/Breakpad.mm
+++ b/src/MEGASync/google_breakpad/client/mac/Framework/Breakpad.mm
@@ -33,6 +33,7 @@
 
 #import "client/mac/Framework/Breakpad.h"
 
+#include <assert.h>
 #import <Foundation/Foundation.h>
 #include <pthread.h>
 #include <sys/stat.h>
@@ -43,10 +44,11 @@
 #import "client/mac/Framework/Breakpad.h"
 #import "client/mac/Framework/OnDemandServer.h"
 #import "client/mac/handler/protected_memory_allocator.h"
+#include "common/mac/launch_reporter.h"
 #import "common/mac/MachIPC.h"
 #import "common/simple_string_dictionary.h"
 
-#ifndef __EXCEPTIONS
+#if !defined(__EXCEPTIONS) || (__clang__ && !__has_feature(cxx_exceptions))
 // This file uses C++ try/catch (but shouldn't). Duplicate the macros from
 // <c++/4.2.1/exception_defines.h> allowing this file to work properly with
 // exceptions disabled even when other C++ libraries are used. #undef the try
@@ -79,9 +81,9 @@ using google_breakpad::SimpleStringDictionary;
 // allocation of C++ objects.  Note that we don't use operator delete()
 // but instead call the objects destructor directly:  object->~ClassName();
 //
-ProtectedMemoryAllocator *gMasterAllocator = NULL;
-ProtectedMemoryAllocator *gKeyValueAllocator = NULL;
-ProtectedMemoryAllocator *gBreakpadAllocator = NULL;
+ProtectedMemoryAllocator* gMasterAllocator = NULL;
+ProtectedMemoryAllocator* gKeyValueAllocator = NULL;
+ProtectedMemoryAllocator* gBreakpadAllocator = NULL;
 
 // Mutex for thread-safe access to the key/value dictionary used by breakpad.
 // It's a global instead of an instance variable of Breakpad
@@ -95,48 +97,44 @@ pthread_mutex_t gDictionaryMutex;
 // ProtectedMemoryLocker will unprotect this block after taking the lock.
 // Its destructor will first re-protect the memory then release the lock.
 class ProtectedMemoryLocker {
-public:
-  // allocator may be NULL, in which case no Protect() or Unprotect() calls
-  // will be made, but a lock will still be taken
-  ProtectedMemoryLocker(pthread_mutex_t *mutex,
-                        ProtectedMemoryAllocator *allocator)
-  : mutex_(mutex), allocator_(allocator) {
+ public:
+  ProtectedMemoryLocker(pthread_mutex_t* mutex,
+                        ProtectedMemoryAllocator* allocator)
+      : mutex_(mutex),
+        allocator_(allocator) {
     // Lock the mutex
-    assert(pthread_mutex_lock(mutex_) == 0);
+    __attribute__((unused)) int rv = pthread_mutex_lock(mutex_);
+    assert(rv == 0);
 
     // Unprotect the memory
-    if (allocator_ ) {
-      allocator_->Unprotect();
-    }
+    allocator_->Unprotect();
   }
 
   ~ProtectedMemoryLocker() {
     // First protect the memory
-    if (allocator_) {
-      allocator_->Protect();
-    }
+    allocator_->Protect();
 
     // Then unlock the mutex
-    assert(pthread_mutex_unlock(mutex_) == 0);
-  };
+    __attribute__((unused)) int rv = pthread_mutex_unlock(mutex_);
+    assert(rv == 0);
+  }
 
-private:
-  //  Keep anybody from ever creating one of these things not on the stack.
-  ProtectedMemoryLocker() { }
+ private:
+  ProtectedMemoryLocker();
   ProtectedMemoryLocker(const ProtectedMemoryLocker&);
-  ProtectedMemoryLocker & operator=(ProtectedMemoryLocker&);
+  ProtectedMemoryLocker& operator=(const ProtectedMemoryLocker&);
 
-  pthread_mutex_t           *mutex_;
-  ProtectedMemoryAllocator  *allocator_;
+  pthread_mutex_t* mutex_;
+  ProtectedMemoryAllocator* allocator_;
 };
 
 //=============================================================================
 class Breakpad {
  public:
   // factory method
-  static Breakpad *Create(NSDictionary *parameters) {
+  static Breakpad* Create(NSDictionary* parameters) {
     // Allocate from our special allocation pool
-    Breakpad *breakpad =
+    Breakpad* breakpad =
       new (gBreakpadAllocator->Allocate(sizeof(Breakpad)))
         Breakpad();
 
@@ -154,13 +152,13 @@ class Breakpad {
 
   ~Breakpad();
 
-  void SetKeyValue(NSString *key, NSString *value);
-  NSString *KeyValue(NSString *key);
-  void RemoveKeyValue(NSString *key);
+  void SetKeyValue(NSString* key, NSString* value);
+  NSString* KeyValue(NSString* key);
+  void RemoveKeyValue(NSString* key);
 
   void GenerateAndSendReport();
 
-  void SetFilterCallback(BreakpadFilterCallback callback, void *context) {
+  void SetFilterCallback(BreakpadFilterCallback callback, void* context) {
     filter_callback_ = callback;
     filter_callback_context_ = context;
   }
@@ -175,12 +173,14 @@ class Breakpad {
     inspector_path_[0] = 0;
   }
 
-  bool Initialize(NSDictionary *parameters);
+  bool Initialize(NSDictionary* parameters);
+  bool InitializeInProcess(NSDictionary* parameters);
+  bool InitializeOutOfProcess(NSDictionary* parameters);
 
-  bool ExtractParameters(NSDictionary *parameters);
+  bool ExtractParameters(NSDictionary* parameters);
 
   // Dispatches to HandleException()
-  static bool ExceptionHandlerDirectCallback(void *context,
+  static bool ExceptionHandlerDirectCallback(void* context,
                                              int exception_type,
                                              int exception_code,
                                              int exception_subcode,
@@ -191,20 +191,31 @@ class Breakpad {
                        int exception_subcode,
                        mach_port_t crashing_thread);
 
+  // Dispatches to HandleMinidump().
+  // This gets called instead of ExceptionHandlerDirectCallback when running
+  // with the BREAKPAD_IN_PROCESS option.
+  static bool HandleMinidumpCallback(const char* dump_dir,
+                                     const char* minidump_id,
+                                     void* context,
+                                     bool succeeded);
+
+  // This is only used when BREAKPAD_IN_PROCESS is YES.
+  bool HandleMinidump(const char* dump_dir, const char* minidump_id);
+
   // Since ExceptionHandler (w/o namespace) is defined as typedef in OSX's
   // MachineExceptions.h, we have to explicitly name the handler.
-  google_breakpad::ExceptionHandler *handler_; // The actual handler (STRONG)
+  google_breakpad::ExceptionHandler* handler_; // The actual handler (STRONG)
 
   char                    inspector_path_[PATH_MAX];  // Path to inspector tool
 
-  SimpleStringDictionary  *config_params_; // Create parameters (STRONG)
+  SimpleStringDictionary* config_params_; // Create parameters (STRONG)
 
   OnDemandServer          inspector_;
 
   bool                    send_and_exit_;  // Exit after sending, if true
 
   BreakpadFilterCallback  filter_callback_;
-  void                    *filter_callback_context_;
+  void*                   filter_callback_context_;
 };
 
 #pragma mark -
@@ -216,14 +227,14 @@ class Breakpad {
 //=============================================================================
 static BOOL IsDebuggerActive() {
   BOOL result = NO;
-  NSUserDefaults *stdDefaults = [NSUserDefaults standardUserDefaults];
+  NSUserDefaults* stdDefaults = [NSUserDefaults standardUserDefaults];
 
   // We check both defaults and the environment variable here
 
   BOOL ignoreDebugger = [stdDefaults boolForKey:@IGNORE_DEBUGGER];
 
   if (!ignoreDebugger) {
-    char *ignoreDebuggerStr = getenv(IGNORE_DEBUGGER);
+    char* ignoreDebuggerStr = getenv(IGNORE_DEBUGGER);
     ignoreDebugger = (ignoreDebuggerStr ? strtol(ignoreDebuggerStr, NULL, 10) : 0) != 0;
   }
 
@@ -234,7 +245,7 @@ static BOOL IsDebuggerActive() {
     size_t actualSize;
 
     if (sysctl(mib, mibSize, NULL, &actualSize, NULL, 0) == 0) {
-      struct kinfo_proc *info = (struct kinfo_proc *)malloc(actualSize);
+      struct kinfo_proc* info = (struct kinfo_proc*)malloc(actualSize);
 
       if (info) {
         // This comes from looking at the Darwin xnu Kernel
@@ -250,12 +261,12 @@ static BOOL IsDebuggerActive() {
 }
 
 //=============================================================================
-bool Breakpad::ExceptionHandlerDirectCallback(void *context,
-                                                    int exception_type,
-                                                    int exception_code,
-                                                    int exception_subcode,
-                                                    mach_port_t crashing_thread) {
-  Breakpad *breakpad = (Breakpad *)context;
+bool Breakpad::ExceptionHandlerDirectCallback(void* context,
+                                              int exception_type,
+                                              int exception_code,
+                                              int exception_subcode,
+                                              mach_port_t crashing_thread) {
+  Breakpad* breakpad = (Breakpad*)context;
 
   // If our context is damaged or something, just return false to indicate that
   // the handler should continue without us.
@@ -268,6 +279,21 @@ bool Breakpad::ExceptionHandlerDirectCallback(void *context,
                                     crashing_thread);
 }
 
+//=============================================================================
+bool Breakpad::HandleMinidumpCallback(const char* dump_dir,
+                                      const char* minidump_id,
+                                      void* context,
+                                      bool succeeded) {
+  Breakpad* breakpad = (Breakpad*)context;
+
+  // If our context is damaged or something, just return false to indicate that
+  // the handler should continue without us.
+  if (!breakpad || !succeeded)
+    return false;
+
+  return breakpad->HandleMinidump(dump_dir, minidump_id);
+}
+
 //=============================================================================
 #pragma mark -
 
@@ -281,9 +307,9 @@ bool Breakpad::ExceptionHandlerDirectCallback(void *context,
 // simple non-static C name
 //
 extern "C" {
-NSString * GetResourcePath();
-NSString * GetResourcePath() {
-  NSString *resourcePath = nil;
+NSString* GetResourcePath();
+NSString* GetResourcePath() {
+  NSString* resourcePath = nil;
 
   // If there are multiple breakpads installed then calling bundleWithIdentifier
   // will not work properly, so only use that as a backup plan.
@@ -294,17 +320,17 @@ NSString * GetResourcePath() {
   // Get the pathname to the code which contains this function
   Dl_info info;
   if (dladdr((const void*)GetResourcePath, &info) != 0) {
-    NSFileManager *filemgr = [NSFileManager defaultManager];
-    NSString *filePath =
+    NSFileManager* filemgr = [NSFileManager defaultManager];
+    NSString* filePath =
         [filemgr stringWithFileSystemRepresentation:info.dli_fname
                                              length:strlen(info.dli_fname)];
-    NSString *bundlePath = [filePath stringByDeletingLastPathComponent];
+    NSString* bundlePath = [filePath stringByDeletingLastPathComponent];
     // The "Resources" directory should be in the same directory as the
     // executable code, since that's how the Breakpad framework is built.
     resourcePath = [bundlePath stringByAppendingPathComponent:@"Resources/"];
   } else {
     // fallback plan
-    NSBundle *bundle =
+    NSBundle* bundle =
         [NSBundle bundleWithIdentifier:@"com.Google.BreakpadFramework"];
     resourcePath = [bundle resourcePath];
   }
@@ -314,7 +340,7 @@ NSString * GetResourcePath() {
 }  // extern "C"
 
 //=============================================================================
-bool Breakpad::Initialize(NSDictionary *parameters) {
+bool Breakpad::Initialize(NSDictionary* parameters) {
   // Initialize
   config_params_ = NULL;
   handler_ = NULL;
@@ -329,8 +355,27 @@ bool Breakpad::Initialize(NSDictionary *parameters) {
     return false;
   }
 
+  if ([[parameters objectForKey:@BREAKPAD_IN_PROCESS] boolValue])
+    return InitializeInProcess(parameters);
+  else
+    return InitializeOutOfProcess(parameters);
+}
+
+//=============================================================================
+bool Breakpad::InitializeInProcess(NSDictionary* parameters) {
+  handler_ =
+      new (gBreakpadAllocator->Allocate(
+          sizeof(google_breakpad::ExceptionHandler)))
+          google_breakpad::ExceptionHandler(
+              config_params_->GetValueForKey(BREAKPAD_DUMP_DIRECTORY),
+              0, &HandleMinidumpCallback, this, true, 0);
+  return true;    
+}
+
+//=============================================================================
+bool Breakpad::InitializeOutOfProcess(NSDictionary* parameters) {
   // Get path to Inspector executable.
-  NSString *inspectorPathString = KeyValue(@BREAKPAD_INSPECTOR_LOCATION);
+  NSString* inspectorPathString = KeyValue(@BREAKPAD_INSPECTOR_LOCATION);
 
   // Standardize path (resolve symlinkes, etc.)  and escape spaces
   inspectorPathString = [inspectorPathString stringByStandardizingPath];
@@ -389,34 +434,34 @@ Breakpad::~Breakpad() {
 }
 
 //=============================================================================
-bool Breakpad::ExtractParameters(NSDictionary *parameters) {
-  NSUserDefaults *stdDefaults = [NSUserDefaults standardUserDefaults];
-  NSString *skipConfirm = [stdDefaults stringForKey:@BREAKPAD_SKIP_CONFIRM];
-  NSString *sendAndExit = [stdDefaults stringForKey:@BREAKPAD_SEND_AND_EXIT];
-
-  NSString *serverType = [parameters objectForKey:@BREAKPAD_SERVER_TYPE];
-  NSString *display = [parameters objectForKey:@BREAKPAD_PRODUCT_DISPLAY];
-  NSString *product = [parameters objectForKey:@BREAKPAD_PRODUCT];
-  NSString *version = [parameters objectForKey:@BREAKPAD_VERSION];
-  NSString *urlStr = [parameters objectForKey:@BREAKPAD_URL];
-  NSString *interval = [parameters objectForKey:@BREAKPAD_REPORT_INTERVAL];
-  NSString *inspectorPathString =
+bool Breakpad::ExtractParameters(NSDictionary* parameters) {
+  NSUserDefaults* stdDefaults = [NSUserDefaults standardUserDefaults];
+  NSString* skipConfirm = [stdDefaults stringForKey:@BREAKPAD_SKIP_CONFIRM];
+  NSString* sendAndExit = [stdDefaults stringForKey:@BREAKPAD_SEND_AND_EXIT];
+
+  NSString* serverType = [parameters objectForKey:@BREAKPAD_SERVER_TYPE];
+  NSString* display = [parameters objectForKey:@BREAKPAD_PRODUCT_DISPLAY];
+  NSString* product = [parameters objectForKey:@BREAKPAD_PRODUCT];
+  NSString* version = [parameters objectForKey:@BREAKPAD_VERSION];
+  NSString* urlStr = [parameters objectForKey:@BREAKPAD_URL];
+  NSString* interval = [parameters objectForKey:@BREAKPAD_REPORT_INTERVAL];
+  NSString* inspectorPathString =
       [parameters objectForKey:@BREAKPAD_INSPECTOR_LOCATION];
-  NSString *reporterPathString =
+  NSString* reporterPathString =
       [parameters objectForKey:@BREAKPAD_REPORTER_EXE_LOCATION];
-  NSString *timeout = [parameters objectForKey:@BREAKPAD_CONFIRM_TIMEOUT];
-  NSArray  *logFilePaths = [parameters objectForKey:@BREAKPAD_LOGFILES];
-  NSString *logFileTailSize =
+  NSString* timeout = [parameters objectForKey:@BREAKPAD_CONFIRM_TIMEOUT];
+  NSArray*  logFilePaths = [parameters objectForKey:@BREAKPAD_LOGFILES];
+  NSString* logFileTailSize =
       [parameters objectForKey:@BREAKPAD_LOGFILE_UPLOAD_SIZE];
-  NSString *requestUserText =
+  NSString* requestUserText =
       [parameters objectForKey:@BREAKPAD_REQUEST_COMMENTS];
-  NSString *requestEmail = [parameters objectForKey:@BREAKPAD_REQUEST_EMAIL];
-  NSString *vendor =
+  NSString* requestEmail = [parameters objectForKey:@BREAKPAD_REQUEST_EMAIL];
+  NSString* vendor =
       [parameters objectForKey:@BREAKPAD_VENDOR];
-  NSString *dumpSubdirectory =
+  NSString* dumpSubdirectory =
       [parameters objectForKey:@BREAKPAD_DUMP_DIRECTORY];
 
-  NSDictionary *serverParameters =
+  NSDictionary* serverParameters =
       [parameters objectForKey:@BREAKPAD_SERVER_PARAMETER_DICT];
 
   // These may have been set above as user prefs, which take priority.
@@ -491,7 +536,7 @@ bool Breakpad::ExtractParameters(NSDictionary *parameters) {
   }
 
   // Find the helper applications if not specified in user config.
-  NSString *resourcePath = nil;
+  NSString* resourcePath = nil;
   if (!inspectorPathString || !reporterPathString) {
     resourcePath = GetResourcePath();
     if (!resourcePath) {
@@ -546,7 +591,7 @@ bool Breakpad::ExtractParameters(NSDictionary *parameters) {
       new (gKeyValueAllocator->Allocate(sizeof(SimpleStringDictionary)) )
         SimpleStringDictionary();
 
-  SimpleStringDictionary &dictionary = *config_params_;
+  SimpleStringDictionary& dictionary = *config_params_;
 
   dictionary.SetKeyValue(BREAKPAD_SERVER_TYPE,     [serverType UTF8String]);
   dictionary.SetKeyValue(BREAKPAD_PRODUCT_DISPLAY, [display UTF8String]);
@@ -588,8 +633,8 @@ bool Breakpad::ExtractParameters(NSDictionary *parameters) {
 
   if (serverParameters) {
     // For each key-value pair, call BreakpadAddUploadParameter()
-    NSEnumerator *keyEnumerator = [serverParameters keyEnumerator];
-    NSString *aParameter;
+    NSEnumerator* keyEnumerator = [serverParameters keyEnumerator];
+    NSString* aParameter;
     while ((aParameter = [keyEnumerator nextObject])) {
       BreakpadAddUploadParameter(this, aParameter,
 				 [serverParameters objectForKey:aParameter]);
@@ -599,7 +644,7 @@ bool Breakpad::ExtractParameters(NSDictionary *parameters) {
 }
 
 //=============================================================================
-void Breakpad::SetKeyValue(NSString *key, NSString *value) {
+void Breakpad::SetKeyValue(NSString* key, NSString* value) {
   // We allow nil values. This is the same as removing the keyvalue.
   if (!config_params_ || !key)
     return;
@@ -608,16 +653,16 @@ void Breakpad::SetKeyValue(NSString *key, NSString *value) {
 }
 
 //=============================================================================
-NSString *Breakpad::KeyValue(NSString *key) {
+NSString* Breakpad::KeyValue(NSString* key) {
   if (!config_params_ || !key)
     return nil;
 
-  const char *value = config_params_->GetValueForKey([key UTF8String]);
+  const char* value = config_params_->GetValueForKey([key UTF8String]);
   return value ? [NSString stringWithUTF8String:value] : nil;
 }
 
 //=============================================================================
-void Breakpad::RemoveKeyValue(NSString *key) {
+void Breakpad::RemoveKeyValue(NSString* key) {
   if (!config_params_ || !key) return;
 
   config_params_->RemoveKey([key UTF8String]);
@@ -677,7 +722,7 @@ bool Breakpad::HandleException(int exception_type,
 
   if (result == KERN_SUCCESS) {
     // Now, send a series of key-value pairs to the Inspector.
-    const SimpleStringDictionary::Entry *entry = NULL;
+    const SimpleStringDictionary::Entry* entry = NULL;
     SimpleStringDictionary::Iterator iter(*config_params_);
 
     while ( (entry = iter.Next()) ) {
@@ -713,6 +758,16 @@ bool Breakpad::HandleException(int exception_type,
   return false;
 }
 
+//=============================================================================
+bool Breakpad::HandleMinidump(const char* dump_dir, const char* minidump_id) {
+  google_breakpad::ConfigFile config_file;
+  config_file.WriteFile(dump_dir, config_params_, dump_dir, minidump_id);
+  google_breakpad::LaunchReporter(
+      config_params_->GetValueForKey(BREAKPAD_REPORTER_EXE_LOCATION),
+      config_file.GetFilePath());
+  return true;
+}
+
 //=============================================================================
 //=============================================================================
 
@@ -720,7 +775,7 @@ bool Breakpad::HandleException(int exception_type,
 #pragma mark Public API
 
 //=============================================================================
-BreakpadRef BreakpadCreate(NSDictionary *parameters) {
+BreakpadRef BreakpadCreate(NSDictionary* parameters) {
   try {
     // This is confusing.  Our two main allocators for breakpad memory are:
     //    - gKeyValueAllocator for the key/value memory
@@ -760,8 +815,8 @@ BreakpadRef BreakpadCreate(NSDictionary *parameters) {
               ProtectedMemoryAllocator(breakpad_pool_size);
 
       // Stack-based autorelease pool for Breakpad::Create() obj-c code.
-      NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
-      Breakpad *breakpad = Breakpad::Create(parameters);
+      NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];
+      Breakpad* breakpad = Breakpad::Create(parameters);
 
       if (breakpad) {
         // Make read-only to protect against memory smashers
@@ -801,7 +856,7 @@ BreakpadRef BreakpadCreate(NSDictionary *parameters) {
 //=============================================================================
 void BreakpadRelease(BreakpadRef ref) {
   try {
-    Breakpad *breakpad = (Breakpad *)ref;
+    Breakpad* breakpad = (Breakpad*)ref;
 
     if (gMasterAllocator) {
       gMasterAllocator->Unprotect();
@@ -834,10 +889,10 @@ void BreakpadRelease(BreakpadRef ref) {
 }
 
 //=============================================================================
-void BreakpadSetKeyValue(BreakpadRef ref, NSString *key, NSString *value) {
+void BreakpadSetKeyValue(BreakpadRef ref, NSString* key, NSString* value) {
   try {
     // Not called at exception time
-    Breakpad *breakpad = (Breakpad *)ref;
+    Breakpad* breakpad = (Breakpad*)ref;
 
     if (breakpad && key && gKeyValueAllocator) {
       ProtectedMemoryLocker locker(&gDictionaryMutex, gKeyValueAllocator);
@@ -850,20 +905,20 @@ void BreakpadSetKeyValue(BreakpadRef ref, NSString *key, NSString *value) {
 }
 
 void BreakpadAddUploadParameter(BreakpadRef ref,
-                                NSString *key,
-                                NSString *value) {
+                                NSString* key,
+                                NSString* value) {
   // The only difference, internally, between an upload parameter and
   // a key value one that is set with BreakpadSetKeyValue is that we
   // prepend the keyname with a special prefix.  This informs the
   // crash sender that the parameter should be sent along with the
   // POST of the crash dump upload.
   try {
-    Breakpad *breakpad = (Breakpad *)ref;
+    Breakpad* breakpad = (Breakpad*)ref;
 
     if (breakpad && key && gKeyValueAllocator) {
       ProtectedMemoryLocker locker(&gDictionaryMutex, gKeyValueAllocator);
 
-      NSString *prefixedKey = [@BREAKPAD_SERVER_PARAMETER_PREFIX
+      NSString* prefixedKey = [@BREAKPAD_SERVER_PARAMETER_PREFIX
 				stringByAppendingString:key];
       breakpad->SetKeyValue(prefixedKey, value);
     }
@@ -873,15 +928,15 @@ void BreakpadAddUploadParameter(BreakpadRef ref,
 }
 
 void BreakpadRemoveUploadParameter(BreakpadRef ref,
-                                   NSString *key) {
+                                   NSString* key) {
   try {
     // Not called at exception time
-    Breakpad *breakpad = (Breakpad *)ref;
+    Breakpad* breakpad = (Breakpad*)ref;
 
     if (breakpad && key && gKeyValueAllocator) {
       ProtectedMemoryLocker locker(&gDictionaryMutex, gKeyValueAllocator);
 
-      NSString *prefixedKey = [NSString stringWithFormat:@"%@%@",
+      NSString* prefixedKey = [NSString stringWithFormat:@"%@%@",
                                         @BREAKPAD_SERVER_PARAMETER_PREFIX, key];
       breakpad->RemoveKeyValue(prefixedKey);
     }
@@ -890,12 +945,12 @@ void BreakpadRemoveUploadParameter(BreakpadRef ref,
   }
 }
 //=============================================================================
-NSString *BreakpadKeyValue(BreakpadRef ref, NSString *key) {
-  NSString *value = nil;
+NSString* BreakpadKeyValue(BreakpadRef ref, NSString* key) {
+  NSString* value = nil;
 
   try {
     // Not called at exception time
-    Breakpad *breakpad = (Breakpad *)ref;
+    Breakpad* breakpad = (Breakpad*)ref;
 
     if (!breakpad || !key || !gKeyValueAllocator)
       return nil;
@@ -911,10 +966,10 @@ NSString *BreakpadKeyValue(BreakpadRef ref, NSString *key) {
 }
 
 //=============================================================================
-void BreakpadRemoveKeyValue(BreakpadRef ref, NSString *key) {
+void BreakpadRemoveKeyValue(BreakpadRef ref, NSString* key) {
   try {
     // Not called at exception time
-    Breakpad *breakpad = (Breakpad *)ref;
+    Breakpad* breakpad = (Breakpad*)ref;
 
     if (breakpad && key && gKeyValueAllocator) {
       ProtectedMemoryLocker locker(&gDictionaryMutex, gKeyValueAllocator);
@@ -929,7 +984,7 @@ void BreakpadRemoveKeyValue(BreakpadRef ref, NSString *key) {
 //=============================================================================
 void BreakpadGenerateAndSendReport(BreakpadRef ref) {
   try {
-    Breakpad *breakpad = (Breakpad *)ref;
+    Breakpad* breakpad = (Breakpad*)ref;
 
     if (breakpad && gKeyValueAllocator) {
       ProtectedMemoryLocker locker(&gDictionaryMutex, gKeyValueAllocator);
@@ -946,10 +1001,10 @@ void BreakpadGenerateAndSendReport(BreakpadRef ref) {
 //=============================================================================
 void BreakpadSetFilterCallback(BreakpadRef ref,
                                BreakpadFilterCallback callback,
-                               void *context) {
+                               void* context) {
 
   try {
-    Breakpad *breakpad = (Breakpad *)ref;
+    Breakpad* breakpad = (Breakpad*)ref;
 
     if (breakpad && gBreakpadAllocator) {
       // share the dictionary mutex here (we really don't need a mutex)
@@ -963,14 +1018,14 @@ void BreakpadSetFilterCallback(BreakpadRef ref,
 }
 
 //============================================================================
-void BreakpadAddLogFile(BreakpadRef ref, NSString *logPathname) {
+void BreakpadAddLogFile(BreakpadRef ref, NSString* logPathname) {
   int logFileCounter = 0;
 
-  NSString *logFileKey = [NSString stringWithFormat:@"%@%d",
+  NSString* logFileKey = [NSString stringWithFormat:@"%@%d",
                                    @BREAKPAD_LOGFILE_KEY_PREFIX,
                                    logFileCounter];
 
-  NSString *existingLogFilename = nil;
+  NSString* existingLogFilename = nil;
   existingLogFilename = BreakpadKeyValue(ref, logFileKey);
   // Find the first log file key that we can use by testing for existence
   while (existingLogFilename) {
diff --git a/src/MEGASync/google_breakpad/client/mac/Framework/OnDemandServer.h b/src/MEGASync/google_breakpad/client/mac/Framework/OnDemandServer.h
index b8aabbe4..be0d2b79 100644
--- a/src/MEGASync/google_breakpad/client/mac/Framework/OnDemandServer.h
+++ b/src/MEGASync/google_breakpad/client/mac/Framework/OnDemandServer.h
@@ -41,7 +41,7 @@
 // Example Usage :
 //
 //  kern_return_t result;
-//  OnDemandServer *server = OnDemandServer::Create("/tmp/myserver",
+//  OnDemandServer* server = OnDemandServer::Create("/tmp/myserver",
 //                                                  "com.MyCompany.MyServiceName",
 //                                                  true,
 //                                                  &result);
@@ -88,8 +88,8 @@ class OnDemandServer {
   }
 
   // Creates the bootstrap server and service
-  kern_return_t Initialize(const char *server_command,
-                           const char *service_name,
+  kern_return_t Initialize(const char* server_command,
+                           const char* service_name,
                            bool unregister_on_cleanup);
 
   // Returns an OnDemandServer object if successful, or NULL if there's
@@ -110,10 +110,10 @@ class OnDemandServer {
   //    out_result : if non-NULL, returns the result
   //      this value will be KERN_SUCCESS if Create() returns non-NULL
   //
-  static OnDemandServer *Create(const char *server_command,
-                                const char *service_name,
+  static OnDemandServer* Create(const char *server_command,
+                                const char* service_name,
                                 bool unregister_on_cleanup,
-                                kern_return_t *out_result);
+                                kern_return_t* out_result);
 
   // Cleans up and if LaunchOnDemand() has not yet been called then
   // the bootstrap service will be unregistered.
@@ -127,7 +127,7 @@ class OnDemandServer {
   // This is the port we need to send a mach message to after calling
   // LaunchOnDemand().  Sending a message causing an immediate launch
   // of the server
-  mach_port_t GetServicePort() { return service_port_; };
+  mach_port_t GetServicePort() { return service_port_; }
 
  private:
   // Disallow copy constructor
diff --git a/src/MEGASync/google_breakpad/client/mac/Framework/OnDemandServer.mm b/src/MEGASync/google_breakpad/client/mac/Framework/OnDemandServer.mm
index dbe601bb..b6b59ca5 100644
--- a/src/MEGASync/google_breakpad/client/mac/Framework/OnDemandServer.mm
+++ b/src/MEGASync/google_breakpad/client/mac/Framework/OnDemandServer.mm
@@ -49,11 +49,11 @@
 #endif
 
 //==============================================================================
-OnDemandServer *OnDemandServer::Create(const char *server_command,
-                                       const char *service_name,
+OnDemandServer* OnDemandServer::Create(const char* server_command,
+                                       const char* service_name,
                                        bool unregister_on_cleanup,
-                                       kern_return_t *out_result) {
-  OnDemandServer *server = new OnDemandServer();
+                                       kern_return_t* out_result) {
+  OnDemandServer* server = new OnDemandServer();
 
   if (!server) return NULL;
 
@@ -71,11 +71,11 @@ OnDemandServer *OnDemandServer::Create(const char *server_command,
 
   delete server;
   return NULL;
-};
+}
 
 //==============================================================================
-kern_return_t OnDemandServer::Initialize(const char *server_command,
-                                         const char *service_name,
+kern_return_t OnDemandServer::Initialize(const char* server_command,
+                                         const char* service_name,
                                          bool unregister_on_cleanup) {
   unregister_on_cleanup_ = unregister_on_cleanup;
 
diff --git a/src/MEGASync/google_breakpad/client/mac/crash_generation/ConfigFile.h b/src/MEGASync/google_breakpad/client/mac/crash_generation/ConfigFile.h
index 5662e8b0..11bc2e43 100644
--- a/src/MEGASync/google_breakpad/client/mac/crash_generation/ConfigFile.h
+++ b/src/MEGASync/google_breakpad/client/mac/crash_generation/ConfigFile.h
@@ -35,7 +35,7 @@
 
 namespace google_breakpad {
 
-BOOL EnsureDirectoryPathExists(NSString *dirPath);
+BOOL EnsureDirectoryPathExists(NSString* dirPath);
 
 //=============================================================================
 class ConfigFile {
@@ -44,17 +44,17 @@ class ConfigFile {
     config_file_ = -1;
     config_file_path_[0] = 0;
     has_created_file_ = false;
-  };
+  }
 
   ~ConfigFile() {
-  };
+  }
 
   void WriteFile(const char* directory,
-                 const SimpleStringDictionary *configurationParameters,
-                 const char *dump_dir,
-                 const char *minidump_id);
+                 const SimpleStringDictionary* configurationParameters,
+                 const char* dump_dir,
+                 const char* minidump_id);
 
-  const char *GetFilePath() { return config_file_path_; }
+  const char* GetFilePath() { return config_file_path_; }
 
   void Unlink() {
     if (config_file_ != -1)
@@ -64,16 +64,16 @@ class ConfigFile {
   }
 
  private:
-  BOOL WriteData(const void *data, size_t length);
+  BOOL WriteData(const void* data, size_t length);
 
-  BOOL AppendConfigData(const char *key,
-                        const void *data,
+  BOOL AppendConfigData(const char* key,
+                        const void* data,
                         size_t length);
 
-  BOOL AppendConfigString(const char *key,
-                          const char *value);
+  BOOL AppendConfigString(const char* key,
+                          const char* value);
 
-  BOOL AppendCrashTimeParameters(const char *processStartTimeString);
+  BOOL AppendCrashTimeParameters(const char* processStartTimeString);
 
   int   config_file_;                    // descriptor for config file
   char  config_file_path_[PATH_MAX];     // Path to configuration file
diff --git a/src/MEGASync/google_breakpad/client/mac/crash_generation/ConfigFile.mm b/src/MEGASync/google_breakpad/client/mac/crash_generation/ConfigFile.mm
index dbb0f24d..57d07590 100644
--- a/src/MEGASync/google_breakpad/client/mac/crash_generation/ConfigFile.mm
+++ b/src/MEGASync/google_breakpad/client/mac/crash_generation/ConfigFile.mm
@@ -36,16 +36,16 @@
 #include <sys/time.h>
 
 #import "client/apple/Framework/BreakpadDefines.h"
-#import "GTMDefines.h"
+#import "common/mac/GTMDefines.h"
 
 
 namespace google_breakpad {
 
 //=============================================================================
-BOOL EnsureDirectoryPathExists(NSString *dirPath) {
-  NSFileManager *mgr = [NSFileManager defaultManager];
+BOOL EnsureDirectoryPathExists(NSString* dirPath) {
+  NSFileManager* mgr = [NSFileManager defaultManager];
 
-  NSDictionary *attrs =
+  NSDictionary* attrs =
     [NSDictionary dictionaryWithObject:[NSNumber numberWithUnsignedLong:0750]
                                 forKey:NSFilePosixPermissions];
 
@@ -56,15 +56,15 @@ BOOL EnsureDirectoryPathExists(NSString *dirPath) {
 }
 
 //=============================================================================
-BOOL ConfigFile::WriteData(const void *data, size_t length) {
+BOOL ConfigFile::WriteData(const void* data, size_t length) {
   size_t result = write(config_file_, data, length);
 
   return result == length;
 }
 
 //=============================================================================
-BOOL ConfigFile::AppendConfigData(const char *key,
-                                  const void *data, size_t length) {
+BOOL ConfigFile::AppendConfigData(const char* key,
+                                  const void* data, size_t length) {
   assert(config_file_ != -1);
 
   if (!key) {
@@ -88,13 +88,13 @@ BOOL ConfigFile::AppendConfigData(const char *key,
 }
 
 //=============================================================================
-BOOL ConfigFile::AppendConfigString(const char *key,
-                                    const char *value) {
+BOOL ConfigFile::AppendConfigString(const char* key,
+                                    const char* value) {
   return AppendConfigData(key, value, strlen(value));
 }
 
 //=============================================================================
-BOOL ConfigFile::AppendCrashTimeParameters(const char *processStartTimeString) {
+BOOL ConfigFile::AppendCrashTimeParameters(const char* processStartTimeString) {
   // Set process uptime parameter
   struct timeval tv;
   gettimeofday(&tv, NULL);
@@ -118,9 +118,9 @@ BOOL ConfigFile::AppendCrashTimeParameters(const char *processStartTimeString) {
 
 //=============================================================================
 void ConfigFile::WriteFile(const char* directory,
-                           const SimpleStringDictionary *configurationParameters,
-                           const char *dump_dir,
-                           const char *minidump_id) {
+                           const SimpleStringDictionary* configurationParameters,
+                           const char* dump_dir,
+                           const char* minidump_id) {
 
   assert(config_file_ == -1);
 
@@ -146,9 +146,9 @@ void ConfigFile::WriteFile(const char* directory,
 
   // Write out the configuration parameters
   BOOL result = YES;
-  const SimpleStringDictionary &dictionary = *configurationParameters;
+  const SimpleStringDictionary& dictionary = *configurationParameters;
 
-  const SimpleStringDictionary::Entry *entry = NULL;
+  const SimpleStringDictionary::Entry* entry = NULL;
   SimpleStringDictionary::Iterator iter(dictionary);
 
   while ((entry = iter.Next())) {
diff --git a/src/MEGASync/google_breakpad/client/mac/crash_generation/Inspector.h b/src/MEGASync/google_breakpad/client/mac/crash_generation/Inspector.h
index 7e2eec80..c9671136 100644
--- a/src/MEGASync/google_breakpad/client/mac/crash_generation/Inspector.h
+++ b/src/MEGASync/google_breakpad/client/mac/crash_generation/Inspector.h
@@ -63,7 +63,7 @@ struct KeyValueMessageData {
  public:
   KeyValueMessageData() {}
   explicit KeyValueMessageData(
-      const google_breakpad::SimpleStringDictionary::Entry &inEntry) {
+      const google_breakpad::SimpleStringDictionary::Entry& inEntry) {
     strlcpy(key, inEntry.key, sizeof(key) );
     strlcpy(value, inEntry.value, sizeof(value) );
   }
@@ -80,7 +80,7 @@ namespace google_breakpad {
 //=============================================================================
 class MinidumpLocation {
  public:
-  MinidumpLocation(NSString *minidumpDir) {
+  MinidumpLocation(NSString* minidumpDir) {
     // Ensure that the path exists.  Fallback to /tmp if unable to locate path.
     assert(minidumpDir);
     if (!EnsureDirectoryPathExists(minidumpDir)) {
@@ -98,10 +98,10 @@ class MinidumpLocation {
       (MinidumpGenerator::UniqueNameInDirectory(dump_path, &next_minidump_id));
 
     strlcpy(minidump_id_, next_minidump_id.c_str(), sizeof(minidump_id_));
-  };
+  }
 
-  const char *GetPath() { return minidump_dir_path_; }
-  const char *GetID() { return minidump_id_; }
+  const char* GetPath() { return minidump_dir_path_; }
+  const char* GetID() { return minidump_id_; }
 
  private:
   char minidump_dir_path_[PATH_MAX];             // Path to minidump directory
@@ -111,12 +111,12 @@ class MinidumpLocation {
 //=============================================================================
 class Inspector {
  public:
-  Inspector() {};
+  Inspector() {}
 
   // given a bootstrap service name, receives mach messages
   // from a crashed process, then inspects it, creates a minidump file
   // and asks the user if he wants to upload it to a server.
-  void            Inspect(const char *receive_port_name);
+  void            Inspect(const char* receive_port_name);
 
  private:
   // The Inspector is invoked with its bootstrap port set to the bootstrap
@@ -131,14 +131,13 @@ class Inspector {
   // ServiceCheckOut.
   kern_return_t   ResetBootstrapPort();
 
-  kern_return_t   ServiceCheckIn(const char *receive_port_name);
-  kern_return_t   ServiceCheckOut(const char *receive_port_name);
+  kern_return_t   ServiceCheckIn(const char* receive_port_name);
+  kern_return_t   ServiceCheckOut(const char* receive_port_name);
 
   kern_return_t   ReadMessages();
 
   bool            InspectTask();
   kern_return_t   SendAcknowledgement();
-  void            LaunchReporter(const char *inConfigFilePath);
 
   // The bootstrap port in which the inspector is registered and into which it
   // must check in.
diff --git a/src/MEGASync/google_breakpad/client/mac/crash_generation/Inspector.mm b/src/MEGASync/google_breakpad/client/mac/crash_generation/Inspector.mm
index d226ca38..d5fc29e0 100644
--- a/src/MEGASync/google_breakpad/client/mac/crash_generation/Inspector.mm
+++ b/src/MEGASync/google_breakpad/client/mac/crash_generation/Inspector.mm
@@ -43,6 +43,7 @@
 
 #import "common/mac/MachIPC.h"
 #include "common/mac/bootstrap_compat.h"
+#include "common/mac/launch_reporter.h"
 
 #import "GTMDefines.h"
 
@@ -51,7 +52,7 @@
 namespace google_breakpad {
 
 //=============================================================================
-void Inspector::Inspect(const char *receive_port_name) {
+void Inspector::Inspect(const char* receive_port_name) {
   kern_return_t result = ResetBootstrapPort();
   if (result != KERN_SUCCESS) {
     return;
@@ -76,7 +77,9 @@ void Inspector::Inspect(const char *receive_port_name) {
       if (wrote_minidump) {
         // Ask the user if he wants to upload the crash report to a server,
         // and do so if he agrees.
-        LaunchReporter(config_file_.GetFilePath());
+        LaunchReporter(
+            config_params_.GetValueForKey(BREAKPAD_REPORTER_EXE_LOCATION),
+            config_file_.GetFilePath());
       } else {
         fprintf(stderr, "Inspection of crashed process failed\n");
       }
@@ -140,7 +143,7 @@ kern_return_t Inspector::ResetBootstrapPort() {
 }
 
 //=============================================================================
-kern_return_t Inspector::ServiceCheckIn(const char *receive_port_name) {
+kern_return_t Inspector::ServiceCheckIn(const char* receive_port_name) {
   // We need to get the mach port representing this service, so we can
   // get information from the crashed process.
   kern_return_t kr = bootstrap_check_in(bootstrap_subset_port_,
@@ -157,7 +160,7 @@ kern_return_t Inspector::ServiceCheckIn(const char *receive_port_name) {
 }
 
 //=============================================================================
-kern_return_t Inspector::ServiceCheckOut(const char *receive_port_name) {
+kern_return_t Inspector::ServiceCheckOut(const char* receive_port_name) {
   // We're done receiving mach messages from the crashed process,
   // so clean up a bit.
   kern_return_t kr;
@@ -195,7 +198,7 @@ kern_return_t Inspector::ReadMessages() {
   kern_return_t result = receive_port.WaitForMessage(&message, 1000);
 
   if (result == KERN_SUCCESS) {
-    InspectorInfo &info = (InspectorInfo &)*message.GetData();
+    InspectorInfo& info = (InspectorInfo&)*message.GetData();
     exception_type_ = info.exception_type;
     exception_code_ = info.exception_code;
     exception_subcode_ = info.exception_subcode;
@@ -234,7 +237,7 @@ kern_return_t Inspector::ReadMessages() {
       result = receive_port.WaitForMessage(&parameter_message, 1000);
 
       if(result == KERN_SUCCESS) {
-        KeyValueMessageData &key_value_data =
+        KeyValueMessageData& key_value_data =
           (KeyValueMessageData&)*parameter_message.GetData();
         // If we get a blank key, make sure we don't increment the
         // parameter count; in some cases (notably on-demand generation
@@ -264,27 +267,27 @@ bool Inspector::InspectTask() {
   // keep the task quiet while we're looking at it
   task_suspend(remote_task_);
 
-  NSString *minidumpDir;
+  NSString* minidumpDir;
 
-  const char *minidumpDirectory =
+  const char* minidumpDirectory =
     config_params_.GetValueForKey(BREAKPAD_DUMP_DIRECTORY);
 
   // If the client app has not specified a minidump directory,
   // use a default of Library/<kDefaultLibrarySubdirectory>/<Product Name>
   if (!minidumpDirectory || 0 == strlen(minidumpDirectory)) {
-    NSArray *libraryDirectories =
+    NSArray* libraryDirectories =
       NSSearchPathForDirectoriesInDomains(NSLibraryDirectory,
                                           NSUserDomainMask,
                                           YES);
 
-    NSString *applicationSupportDirectory =
+    NSString* applicationSupportDirectory =
         [libraryDirectories objectAtIndex:0];
-    NSString *library_subdirectory = [NSString
+    NSString* library_subdirectory = [NSString
         stringWithUTF8String:kDefaultLibrarySubdirectory];
-    NSString *breakpad_product = [NSString
+    NSString* breakpad_product = [NSString
         stringWithUTF8String:config_params_.GetValueForKey(BREAKPAD_PRODUCT)];
 
-    NSArray *path_components = [NSArray
+    NSArray* path_components = [NSArray
         arrayWithObjects:applicationSupportDirectory,
                          library_subdirectory,
                          breakpad_product,
@@ -303,11 +306,11 @@ bool Inspector::InspectTask() {
   // assumes system encoding and in RTL locales will prepend an LTR override
   // character for paths beginning with '/' which fileSystemRepresentation does
   // not remove. Filed as rdar://6889706 .
-  NSString *path_ns = [NSString
+  NSString* path_ns = [NSString
       stringWithUTF8String:minidumpLocation.GetPath()];
-  NSString *pathid_ns = [NSString
+  NSString* pathid_ns = [NSString
       stringWithUTF8String:minidumpLocation.GetID()];
-  NSString *minidumpPath = [path_ns stringByAppendingPathComponent:pathid_ns];
+  NSString* minidumpPath = [path_ns stringByAppendingPathComponent:pathid_ns];
   minidumpPath = [minidumpPath
       stringByAppendingPathExtension:@"dmp"];
 
@@ -355,51 +358,5 @@ kern_return_t Inspector::SendAcknowledgement() {
   return KERN_INVALID_NAME;
 }
 
-//=============================================================================
-void Inspector::LaunchReporter(const char *inConfigFilePath) {
-  // Extract the path to the reporter executable.
-  const char *reporterExecutablePath =
-          config_params_.GetValueForKey(BREAKPAD_REPORTER_EXE_LOCATION);
-
-  // Setup and launch the crash dump sender.
-  const char *argv[3];
-  argv[0] = reporterExecutablePath;
-  argv[1] = inConfigFilePath;
-  argv[2] = NULL;
-
-  // Launch the reporter
-  pid_t pid = fork();
-
-  // If we're in the child, load in our new executable and run.
-  // The parent will not wait for the child to complete.
-  if (pid == 0) {
-    execv(argv[0], (char * const *)argv);
-    config_file_.Unlink();  // launch failed - get rid of config file
-    _exit(1);
-  }
-
-  // Wait until the Reporter child process exits.
-  //
-
-  // We'll use a timeout of one minute.
-  int timeoutCount = 60;   // 60 seconds
-
-  while (timeoutCount-- > 0) {
-    int status;
-    pid_t result = waitpid(pid, &status, WNOHANG);
-
-    if (result == 0) {
-      // The child has not yet finished.
-      sleep(1);
-    } else if (result == -1) {
-      // error occurred.
-      break;
-    } else {
-      // child has finished
-      break;
-    }
-  }
-}
-
 } // namespace google_breakpad
 
diff --git a/src/MEGASync/google_breakpad/client/mac/crash_generation/crash_generation_client.cc b/src/MEGASync/google_breakpad/client/mac/crash_generation/crash_generation_client.cc
index 05aa967a..ceeb3b32 100644
--- a/src/MEGASync/google_breakpad/client/mac/crash_generation/crash_generation_client.cc
+++ b/src/MEGASync/google_breakpad/client/mac/crash_generation/crash_generation_client.cc
@@ -65,7 +65,7 @@ bool CrashGenerationClient::RequestDumpForException(
   const mach_msg_timeout_t kReceiveTimeoutMs = 5 * 1000;
   MachReceiveMessage acknowledge_message;
   result = acknowledge_port.WaitForMessage(&acknowledge_message,
-                                           kReceiveTimeoutMs);
+					   kReceiveTimeoutMs);
   return result == KERN_SUCCESS;
 }
 
diff --git a/src/MEGASync/google_breakpad/client/mac/crash_generation/crash_generation_server.cc b/src/MEGASync/google_breakpad/client/mac/crash_generation/crash_generation_server.cc
index 50942a26..ae44e8bf 100644
--- a/src/MEGASync/google_breakpad/client/mac/crash_generation/crash_generation_server.cc
+++ b/src/MEGASync/google_breakpad/client/mac/crash_generation/crash_generation_server.cc
@@ -29,27 +29,27 @@
 
 #include "client/mac/crash_generation/crash_generation_server.h"
 
+#include <pthread.h>
+
 #include "client/mac/crash_generation/client_info.h"
 #include "client/mac/handler/minidump_generator.h"
 #include "common/mac/scoped_task_suspend-inl.h"
 
-#include <pthread.h>
-
 namespace google_breakpad {
 
 CrashGenerationServer::CrashGenerationServer(
-    const char *mach_port_name,
+    const char* mach_port_name,
     FilterCallback filter,
-    void *filter_context,
+    void* filter_context,
     OnClientDumpRequestCallback dump_callback,
-    void *dump_context,
+    void* dump_context,
     OnClientExitingCallback exit_callback,
-    void *exit_context,
+    void* exit_context,
     bool generate_dumps,
-    const std::string &dump_path)
-    : dump_callback_(dump_callback),
-      filter_(filter),
+    const std::string& dump_path)
+    : filter_(filter),
       filter_context_(filter_context),
+      dump_callback_(dump_callback),
       dump_context_(dump_context),
       exit_callback_(exit_callback),
       exit_context_(exit_context),
@@ -90,8 +90,8 @@ bool CrashGenerationServer::Stop() {
 }
 
 // static
-void *CrashGenerationServer::WaitForMessages(void *server) {
-  CrashGenerationServer *self =
+void* CrashGenerationServer::WaitForMessages(void* server) {
+  CrashGenerationServer* self =
       reinterpret_cast<CrashGenerationServer*>(server);
   while (self->WaitForOneMessage()) {}
   return NULL;
@@ -104,7 +104,7 @@ bool CrashGenerationServer::WaitForOneMessage() {
   if (result == KERN_SUCCESS) {
     switch (message.GetMessageID()) {
       case kDumpRequestMessage: {
-        ExceptionInfo &info = (ExceptionInfo &)*message.GetData();
+        ExceptionInfo& info = (ExceptionInfo&)*message.GetData();
       
         mach_port_t remote_task = message.GetTranslatedPort(0);
         mach_port_t crashing_thread = message.GetTranslatedPort(1);
diff --git a/src/MEGASync/google_breakpad/client/mac/crash_generation/crash_generation_server.h b/src/MEGASync/google_breakpad/client/mac/crash_generation/crash_generation_server.h
index 85bd5b5e..82fef146 100644
--- a/src/MEGASync/google_breakpad/client/mac/crash_generation/crash_generation_server.h
+++ b/src/MEGASync/google_breakpad/client/mac/crash_generation/crash_generation_server.h
@@ -59,14 +59,14 @@ class CrashGenerationServer {
   // WARNING: callbacks may be invoked on a different thread
   // than that which creates the CrashGenerationServer.  They must
   // be thread safe.
-  typedef void (*OnClientDumpRequestCallback)(void *context,
-                                              const ClientInfo &client_info,
-                                              const std::string &file_path);
+  typedef void (*OnClientDumpRequestCallback)(void* context,
+                                              const ClientInfo& client_info,
+                                              const std::string& file_path);
 
-  typedef void (*OnClientExitingCallback)(void *context,
-                                          const ClientInfo &client_info);
+  typedef void (*OnClientExitingCallback)(void* context,
+                                          const ClientInfo& client_info);
   // If a FilterCallback returns false, the dump will not be written.
-  typedef bool (*FilterCallback)(void *context);
+  typedef bool (*FilterCallback)(void* context);
 
   // Create an instance with the given parameters.
   //
@@ -83,15 +83,15 @@ class CrashGenerationServer {
   //     passed for this parameter.
   // dump_path: Path for generating dumps; required only if true is
   //     passed for generateDumps parameter; NULL can be passed otherwise.
-  CrashGenerationServer(const char *mach_port_name,
+  CrashGenerationServer(const char* mach_port_name,
                         FilterCallback filter,
-                        void *filter_context,
+                        void* filter_context,
                         OnClientDumpRequestCallback dump_callback,
-                        void *dump_context,
+                        void* dump_context,
                         OnClientExitingCallback exit_callback,
-                        void *exit_context,
+                        void* exit_context,
                         bool generate_dumps,
-                        const std::string &dump_path);
+                        const std::string& dump_path);
 
   ~CrashGenerationServer();
 
@@ -105,24 +105,24 @@ class CrashGenerationServer {
 
  private:
   // Return a unique filename at which a minidump can be written.
-  bool MakeMinidumpFilename(std::string &outFilename);
+  bool MakeMinidumpFilename(std::string& outFilename);
 
   // Loop reading client messages and responding to them until
   // a quit message is received.
-  static void *WaitForMessages(void *server);
+  static void* WaitForMessages(void* server);
 
   // Wait for a single client message and respond to it. Returns false
   // if a quit message was received or if an error occurred.
   bool WaitForOneMessage();
 
   FilterCallback filter_;
-  void *filter_context_;
+  void* filter_context_;
 
   OnClientDumpRequestCallback dump_callback_;
-  void *dump_context_;
+  void* dump_context_;
 
   OnClientExitingCallback exit_callback_;
-  void *exit_context_;
+  void* exit_context_;
 
   bool generate_dumps_;
 
diff --git a/src/MEGASync/google_breakpad/client/mac/handler/breakpad_nlist_64.cc b/src/MEGASync/google_breakpad/client/mac/handler/breakpad_nlist_64.cc
index fcb667e3..b4f04c91 100644
--- a/src/MEGASync/google_breakpad/client/mac/handler/breakpad_nlist_64.cc
+++ b/src/MEGASync/google_breakpad/client/mac/handler/breakpad_nlist_64.cc
@@ -131,7 +131,7 @@ struct MachBits<nlist64> {
 
 template<typename nlist_type>
 int
-__breakpad_fdnlist(int fd, nlist_type *list, const char **symbolNames,
+__breakpad_fdnlist(int fd, nlist_type* list, const char** symbolNames,
                    cpu_type_t cpu_type);
 
 /*
@@ -139,9 +139,9 @@ __breakpad_fdnlist(int fd, nlist_type *list, const char **symbolNames,
  */
 
 template <typename nlist_type>
-int breakpad_nlist_common(const char *name,
-                          nlist_type *list,
-                          const char **symbolNames,
+int breakpad_nlist_common(const char* name,
+                          nlist_type* list,
+                          const char** symbolNames,
                           cpu_type_t cpu_type) {
   int fd = open(name, O_RDONLY, 0);
   if (fd < 0)
@@ -151,16 +151,16 @@ int breakpad_nlist_common(const char *name,
   return n;
 }
 
-int breakpad_nlist(const char *name,
-                   struct nlist *list,
-                   const char **symbolNames,
+int breakpad_nlist(const char* name,
+                   struct nlist* list,
+                   const char** symbolNames,
                    cpu_type_t cpu_type) {
   return breakpad_nlist_common(name, list, symbolNames, cpu_type);
 }
 
-int breakpad_nlist(const char *name,
-                   struct nlist_64 *list,
-                   const char **symbolNames,
+int breakpad_nlist(const char* name,
+                   struct nlist_64* list,
+                   const char** symbolNames,
                    cpu_type_t cpu_type) {
   return breakpad_nlist_common(name, list, symbolNames, cpu_type);
 }
@@ -168,7 +168,7 @@ int breakpad_nlist(const char *name,
 /* Note: __fdnlist() is called from kvm_nlist in libkvm's kvm.c */
 
 template<typename nlist_type>
-int __breakpad_fdnlist(int fd, nlist_type *list, const char **symbolNames,
+int __breakpad_fdnlist(int fd, nlist_type* list, const char** symbolNames,
                        cpu_type_t cpu_type) {
   typedef typename MachBits<nlist_type>::mach_header_type mach_header_type;
   typedef typename MachBits<nlist_type>::word_type word_type;
@@ -189,9 +189,9 @@ int __breakpad_fdnlist(int fd, nlist_type *list, const char **symbolNames,
   }
 
   struct exec buf;
-  if (read(fd, (char *)&buf, sizeof(buf)) != sizeof(buf) ||
-      (N_BADMAG(buf) && *((uint32_t *)&buf) != magic &&
-        CFSwapInt32BigToHost(*((uint32_t *)&buf)) != FAT_MAGIC &&
+  if (read(fd, (char*)&buf, sizeof(buf)) != sizeof(buf) ||
+      (N_BADMAG(buf) && *((uint32_t*)&buf) != magic &&
+        CFSwapInt32BigToHost(*((uint32_t*)&buf)) != FAT_MAGIC &&
        /* The following is the big-endian ppc64 check */
        (*((uint32_t*)&buf)) != FAT_MAGIC)) {
     return -1;
@@ -199,26 +199,15 @@ int __breakpad_fdnlist(int fd, nlist_type *list, const char **symbolNames,
 
   /* Deal with fat file if necessary */
   unsigned arch_offset = 0;
-  if (CFSwapInt32BigToHost(*((uint32_t *)&buf)) == FAT_MAGIC ||
+  if (CFSwapInt32BigToHost(*((uint32_t*)&buf)) == FAT_MAGIC ||
       /* The following is the big-endian ppc64 check */
-      *((unsigned int *)&buf) == FAT_MAGIC) {
-    /* Get host info */
-    host_t host = mach_host_self();
-    unsigned hic = HOST_BASIC_INFO_COUNT;
-    struct host_basic_info hbi;
-    kern_return_t kr;
-    if ((kr = host_info(host, HOST_BASIC_INFO,
-                        (host_info_t)(&hbi), &hic)) != KERN_SUCCESS) {
-      return -1;
-    }
-    mach_port_deallocate(mach_task_self(), host);
-
+      *((unsigned int*)&buf) == FAT_MAGIC) {
     /* Read in the fat header */
     struct fat_header fh;
     if (lseek(fd, 0, SEEK_SET) == -1) {
       return -1;
     }
-    if (read(fd, (char *)&fh, sizeof(fh)) != sizeof(fh)) {
+    if (read(fd, (char*)&fh, sizeof(fh)) != sizeof(fh)) {
       return -1;
     }
 
@@ -226,12 +215,12 @@ int __breakpad_fdnlist(int fd, nlist_type *list, const char **symbolNames,
     fh.nfat_arch = CFSwapInt32BigToHost(fh.nfat_arch);
 
     /* Read in the fat archs */
-    struct fat_arch *fat_archs =
-        (struct fat_arch *)malloc(fh.nfat_arch * sizeof(struct fat_arch));
+    struct fat_arch* fat_archs =
+        (struct fat_arch*)malloc(fh.nfat_arch * sizeof(struct fat_arch));
     if (fat_archs == NULL) {
       return -1;
     }
-    if (read(fd, (char *)fat_archs,
+    if (read(fd, (char*)fat_archs,
              sizeof(struct fat_arch) * fh.nfat_arch) !=
         (ssize_t)(sizeof(struct fat_arch) * fh.nfat_arch)) {
       free(fat_archs);
@@ -255,7 +244,7 @@ int __breakpad_fdnlist(int fd, nlist_type *list, const char **symbolNames,
         CFSwapInt32BigToHost(fat_archs[i].align);
     }
 
-    struct fat_arch *fap = NULL;
+    struct fat_arch* fap = NULL;
     for (unsigned i = 0; i < fh.nfat_arch; i++) {
       if (fat_archs[i].cputype == cpu_type) {
         fap = &fat_archs[i];
@@ -274,56 +263,53 @@ int __breakpad_fdnlist(int fd, nlist_type *list, const char **symbolNames,
     if (lseek(fd, arch_offset, SEEK_SET) == -1) {
       return -1;
     }
-    if (read(fd, (char *)&buf, sizeof(buf)) != sizeof(buf)) {
+    if (read(fd, (char*)&buf, sizeof(buf)) != sizeof(buf)) {
       return -1;
     }
   }
 
   off_t sa;  /* symbol address */
   off_t ss;  /* start of strings */
-  register register_t n;
-  if (*((unsigned int *)&buf) == magic) {
+  register_t n;
+  if (*((unsigned int*)&buf) == magic) {
     if (lseek(fd, arch_offset, SEEK_SET) == -1) {
       return -1;
     }
     mach_header_type mh;
-    if (read(fd, (char *)&mh, sizeof(mh)) != sizeof(mh)) {
+    if (read(fd, (char*)&mh, sizeof(mh)) != sizeof(mh)) {
       return -1;
     }
 
-    struct load_command *load_commands =
-        (struct load_command *)malloc(mh.sizeofcmds);
+    struct load_command* load_commands =
+        (struct load_command*)malloc(mh.sizeofcmds);
     if (load_commands == NULL) {
       return -1;
     }
-    if (read(fd, (char *)load_commands, mh.sizeofcmds) !=
+    if (read(fd, (char*)load_commands, mh.sizeofcmds) !=
         (ssize_t)mh.sizeofcmds) {
       free(load_commands);
       return -1;
     }
-    struct symtab_command *stp = NULL;
-    struct load_command *lcp = load_commands;
+    struct symtab_command* stp = NULL;
+    struct load_command* lcp = load_commands;
     // iterate through all load commands, looking for
     // LC_SYMTAB load command
     for (uint32_t i = 0; i < mh.ncmds; i++) {
       if (lcp->cmdsize % sizeof(word_type) != 0 ||
           lcp->cmdsize <= 0 ||
-          (char *)lcp + lcp->cmdsize >
-          (char *)load_commands + mh.sizeofcmds) {
+          (char*)lcp + lcp->cmdsize > (char*)load_commands + mh.sizeofcmds) {
         free(load_commands);
         return -1;
       }
       if (lcp->cmd == LC_SYMTAB) {
-        if (lcp->cmdsize !=
-            sizeof(struct symtab_command)) {
+        if (lcp->cmdsize != sizeof(struct symtab_command)) {
           free(load_commands);
           return -1;
         }
-        stp = (struct symtab_command *)lcp;
+        stp = (struct symtab_command*)lcp;
         break;
       }
-      lcp = (struct load_command *)
-        ((char *)lcp + lcp->cmdsize);
+      lcp = (struct load_command*)((char*)lcp + lcp->cmdsize);
     }
     if (stp == NULL) {
       free(load_commands);
@@ -354,11 +340,11 @@ int __breakpad_fdnlist(int fd, nlist_type *list, const char **symbolNames,
   // and look for a match
   while (n) {
     nlist_type space[BUFSIZ/sizeof (nlist_type)];
-    register register_t m = sizeof (space);
+    register_t m = sizeof (space);
 
     if (n < m)
       m = n;
-    if (read(fd, (char *)space, m) != m)
+    if (read(fd, (char*)space, m) != m)
       break;
     n -= m;
     off_t savpos = lseek(fd, 0, SEEK_CUR);
@@ -379,13 +365,13 @@ int __breakpad_fdnlist(int fd, nlist_type *list, const char **symbolNames,
       if (read(fd, nambuf, maxlen+1) == -1) {
         return -1;
       }
-      const char *s2 = nambuf;
-      for (nlist_type *p = list; 
+      const char* s2 = nambuf;
+      for (nlist_type* p = list; 
            symbolNames[p-list] && symbolNames[p-list][0];
            p++) {
         // get the symbol name the user has passed in that 
         // corresponds to the nlist entry that we're looking at
-        const char *s1 = symbolNames[p - list];
+        const char* s1 = symbolNames[p - list];
         while (*s1) {
           if (*s1++ != *s2++)
             goto cont;
diff --git a/src/MEGASync/google_breakpad/client/mac/handler/breakpad_nlist_64.h b/src/MEGASync/google_breakpad/client/mac/handler/breakpad_nlist_64.h
index 1d2c6391..a1a3e83c 100644
--- a/src/MEGASync/google_breakpad/client/mac/handler/breakpad_nlist_64.h
+++ b/src/MEGASync/google_breakpad/client/mac/handler/breakpad_nlist_64.h
@@ -32,16 +32,17 @@
 // nlist function implemented to work on 64-bit.
 
 #ifndef CLIENT_MAC_HANDLER_BREAKPAD_NLIST_H__
+#define CLIENT_MAC_HANDLER_BREAKPAD_NLIST_H__
 
 #include <mach/machine.h>
 
-int breakpad_nlist(const char *name,
-                   struct nlist *list,
-                   const char **symbolNames,
+int breakpad_nlist(const char* name,
+                   struct nlist* list,
+                   const char** symbolNames,
                    cpu_type_t cpu_type);
-int breakpad_nlist(const char *name,
-                   struct nlist_64 *list,
-                   const char **symbolNames,
+int breakpad_nlist(const char* name,
+                   struct nlist_64* list,
+                   const char** symbolNames,
                    cpu_type_t cpu_type);
 
 #endif  /* CLIENT_MAC_HANDLER_BREAKPAD_NLIST_H__ */
diff --git a/src/MEGASync/google_breakpad/client/mac/handler/dynamic_images.cc b/src/MEGASync/google_breakpad/client/mac/handler/dynamic_images.cc
index fbd6dcf0..b78c2087 100644
--- a/src/MEGASync/google_breakpad/client/mac/handler/dynamic_images.cc
+++ b/src/MEGASync/google_breakpad/client/mac/handler/dynamic_images.cc
@@ -66,7 +66,7 @@ struct task_dyld_info {
   mach_vm_size_t all_image_info_size;
 };
 typedef struct task_dyld_info task_dyld_info_data_t;
-typedef struct task_dyld_info *task_dyld_info_t;
+typedef struct task_dyld_info* task_dyld_info_t;
 #define TASK_DYLD_INFO_COUNT (sizeof(task_dyld_info_data_t) / sizeof(natural_t))
 
 #endif
@@ -88,7 +88,7 @@ using std::vector;
 //
 static mach_vm_size_t GetMemoryRegionSize(task_port_t target_task,
                                           const uint64_t address,
-                                          mach_vm_size_t *size_to_end) {
+                                          mach_vm_size_t* size_to_end) {
   mach_vm_address_t region_base = (mach_vm_address_t)address;
   mach_vm_size_t region_size;
   natural_t nesting_level = 0;
@@ -182,7 +182,7 @@ static string ReadTaskString(task_port_t target_task,
 kern_return_t ReadTaskMemory(task_port_t target_task,
                              const uint64_t address,
                              size_t length,
-                             vector<uint8_t> &bytes) {
+                             vector<uint8_t>& bytes) {
   int systemPageSize = getpagesize();
 
   // use the negative of the page size for the mask to find the page address
@@ -250,16 +250,16 @@ bool FindTextSection(DynamicImage& image) {
     return false;
   }
 
-  const struct load_command *cmd =
-      reinterpret_cast<const struct load_command *>(header + 1);
+  const struct load_command* cmd =
+      reinterpret_cast<const struct load_command*>(header + 1);
 
   bool found_text_section = false;
   bool found_dylib_id_command = false;
   for (unsigned int i = 0; cmd && (i < header->ncmds); ++i) {
     if (!found_text_section) {
       if (cmd->cmd == MachBits::segment_load_command) {
-        const mach_segment_command_type *seg =
-            reinterpret_cast<const mach_segment_command_type *>(cmd);
+        const mach_segment_command_type* seg =
+            reinterpret_cast<const mach_segment_command_type*>(cmd);
 
         if (!strcmp(seg->segname, "__TEXT")) {
           image.vmaddr_ = static_cast<mach_vm_address_t>(seg->vmaddr);
@@ -277,8 +277,8 @@ bool FindTextSection(DynamicImage& image) {
 
     if (!found_dylib_id_command) {
       if (cmd->cmd == LC_ID_DYLIB) {
-        const struct dylib_command *dc =
-            reinterpret_cast<const struct dylib_command *>(cmd);
+        const struct dylib_command* dc =
+            reinterpret_cast<const struct dylib_command*>(cmd);
 
         image.version_ = dc->dylib.current_version;
         found_dylib_id_command = true;
@@ -289,8 +289,8 @@ bool FindTextSection(DynamicImage& image) {
       return true;
     }
 
-    cmd = reinterpret_cast<const struct load_command *>
-        (reinterpret_cast<const char *>(cmd) + cmd->cmdsize);
+    cmd = reinterpret_cast<const struct load_command*>
+        (reinterpret_cast<const char*>(cmd) + cmd->cmdsize);
   }
 
   return false;
@@ -349,8 +349,8 @@ static uint64_t LookupSymbol(const char* symbol_name,
   typedef typename MachBits::nlist_type nlist_type;
 
   nlist_type symbol_info[8] = {};
-  const char *symbolNames[2] = { symbol_name, "\0" };
-  nlist_type &list = symbol_info[0];
+  const char* symbolNames[2] = { symbol_name, "\0" };
+  nlist_type& list = symbol_info[0];
   int invalidEntriesCount = breakpad_nlist(filename,
                                            &list,
                                            symbolNames,
@@ -364,7 +364,7 @@ static uint64_t LookupSymbol(const char* symbol_name,
   return list.n_value;
 }
 
-#if TARGET_OS_IPHONE
+#if TARGET_OS_IPHONE || MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_6
 static bool HasTaskDyldInfo() {
   return true;
 }
@@ -381,13 +381,9 @@ static SInt32 GetOSVersion() {
 }
 
 static bool HasTaskDyldInfo() {
-#if MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_6
-  return true;
-#else
   return GetOSVersion() >= 0x1060;
-#endif
 }
-#endif  // TARGET_OS_IPHONE
+#endif  // TARGET_OS_IPHONE || MAC_OS_X_VERSION_MIN_REQUIRED >= 10_6
 
 uint64_t DynamicImages::GetDyldAllImageInfosPointer() {
   if (HasTaskDyldInfo()) {
@@ -400,8 +396,8 @@ uint64_t DynamicImages::GetDyldAllImageInfosPointer() {
 
     return (uint64_t)task_dyld_info.all_image_info_addr;
   } else {
-    const char *imageSymbolName = "_dyld_all_image_infos";
-    const char *dyldPath = "/usr/lib/dyld";
+    const char* imageSymbolName = "_dyld_all_image_infos";
+    const char* dyldPath = "/usr/lib/dyld";
 
     if (Is64Bit())
       return LookupSymbol<MachO64>(imageSymbolName, dyldPath, cpu_type_);
@@ -432,7 +428,7 @@ void ReadImageInfo(DynamicImages& images,
                      dyld_all_info_bytes) != KERN_SUCCESS)
     return;
 
-  dyld_all_image_infos *dyldInfo =
+  dyld_all_image_infos* dyldInfo =
     reinterpret_cast<dyld_all_image_infos*>(&dyld_all_info_bytes[0]);
 
   // number of loaded images
@@ -447,12 +443,12 @@ void ReadImageInfo(DynamicImages& images,
                        dyld_info_array_bytes) != KERN_SUCCESS)
       return;
 
-    dyld_image_info *infoArray =
+    dyld_image_info* infoArray =
         reinterpret_cast<dyld_image_info*>(&dyld_info_array_bytes[0]);
     images.image_list_.reserve(count);
 
     for (int i = 0; i < count; ++i) {
-      dyld_image_info &info = infoArray[i];
+      dyld_image_info& info = infoArray[i];
 
       // First read just the mach_header from the image in the task.
       vector<uint8_t> mach_header_bytes;
@@ -462,7 +458,7 @@ void ReadImageInfo(DynamicImages& images,
                          mach_header_bytes) != KERN_SUCCESS)
         continue;  // bail on this dynamic image
 
-      mach_header_type *header =
+      mach_header_type* header =
           reinterpret_cast<mach_header_type*>(&mach_header_bytes[0]);
 
       // Now determine the total amount necessary to read the header
@@ -486,7 +482,7 @@ void ReadImageInfo(DynamicImages& images,
       }
 
       // Create an object representing this image and add it to our list.
-      DynamicImage *new_image;
+      DynamicImage* new_image;
       new_image = new DynamicImage(&mach_header_bytes[0],
                                    header_size,
                                    info.load_address_,
@@ -526,7 +522,7 @@ void DynamicImages::ReadImageInfoForTask() {
 }
 
 //==============================================================================
-DynamicImage  *DynamicImages::GetExecutableImage() {
+DynamicImage* DynamicImages::GetExecutableImage() {
   int executable_index = GetExecutableImageIndex();
 
   if (executable_index >= 0) {
@@ -542,7 +538,7 @@ int DynamicImages::GetExecutableImageIndex() {
   int image_count = GetImageCount();
 
   for (int i = 0; i < image_count; ++i) {
-    DynamicImage  *image = GetImage(i);
+    DynamicImage* image = GetImage(i);
     if (image->GetFileType() == MH_EXECUTE) {
       return i;
     }
@@ -567,7 +563,7 @@ cpu_type_t DynamicImages::DetermineTaskCPUType(task_t task) {
 
     cpu_type_t cpu_type;
     size_t cpuTypeSize = sizeof(cpu_type);
-    sysctl(mib, mibLen, &cpu_type, &cpuTypeSize, 0, 0);
+    sysctl(mib, static_cast<u_int>(mibLen), &cpu_type, &cpuTypeSize, 0, 0);
     return cpu_type;
   }
 
diff --git a/src/MEGASync/google_breakpad/client/mac/handler/dynamic_images.h b/src/MEGASync/google_breakpad/client/mac/handler/dynamic_images.h
index 6f4c3377..e81ea7f3 100644
--- a/src/MEGASync/google_breakpad/client/mac/handler/dynamic_images.h
+++ b/src/MEGASync/google_breakpad/client/mac/handler/dynamic_images.h
@@ -108,7 +108,7 @@ uint32_t GetFileTypeFromHeader(DynamicImage& image);
 // Represents a single dynamically loaded mach-o image
 class DynamicImage {
  public:
-  DynamicImage(uint8_t *header,     // data is copied
+  DynamicImage(uint8_t* header,     // data is copied
                size_t header_size,  // includes load commands
                uint64_t load_address,
                string file_path,
@@ -163,7 +163,7 @@ class DynamicImage {
 
   uint32_t GetVersion() {return version_;}
   // For sorting
-  bool operator<(const DynamicImage &inInfo) {
+  bool operator<(const DynamicImage& inInfo) {
     return GetLoadAddress() < inInfo.GetLoadAddress();
   }
 
@@ -171,8 +171,8 @@ class DynamicImage {
   bool IsValid() {return GetVMSize() != 0;}
 
  private:
-  DynamicImage(const DynamicImage &);
-  DynamicImage &operator=(const DynamicImage &);
+  DynamicImage(const DynamicImage&);
+  DynamicImage& operator=(const DynamicImage&);
 
   friend class DynamicImages;
   template<typename MachBits>
@@ -205,26 +205,26 @@ class DynamicImage {
 //
 class DynamicImageRef {
  public:
-  explicit DynamicImageRef(DynamicImage *inP) : p(inP) {}
+  explicit DynamicImageRef(DynamicImage* inP) : p(inP) {}
   // The copy constructor is required by STL
-  DynamicImageRef(const DynamicImageRef &inRef) : p(inRef.p) {}
+  DynamicImageRef(const DynamicImageRef& inRef) : p(inRef.p) {}
 
-  bool operator<(const DynamicImageRef &inRef) const {
+  bool operator<(const DynamicImageRef& inRef) const {
     return (*const_cast<DynamicImageRef*>(this)->p)
       < (*const_cast<DynamicImageRef&>(inRef).p);
   }
 
-  bool operator==(const DynamicImageRef &inInfo) const {
+  bool operator==(const DynamicImageRef& inInfo) const {
     return (*const_cast<DynamicImageRef*>(this)->p).GetLoadAddress() ==
         (*const_cast<DynamicImageRef&>(inInfo)).GetLoadAddress();
   }
 
   // Be just like DynamicImage*
-  DynamicImage  *operator->() {return p;}
+  DynamicImage* operator->() {return p;}
   operator DynamicImage*() {return p;}
 
  private:
-  DynamicImage  *p;
+  DynamicImage* p;
 };
 
 // Helper function to deal with 32-bit/64-bit Mach-O differences.
@@ -250,7 +250,7 @@ class DynamicImages {
   int GetImageCount() const {return static_cast<int>(image_list_.size());}
 
   // Returns an individual image.
-  DynamicImage *GetImage(int i) {
+  DynamicImage* GetImage(int i) {
     if (i < (int)image_list_.size()) {
       return image_list_[i];
     }
@@ -258,7 +258,7 @@ class DynamicImages {
   }
 
   // Returns the image corresponding to the main executable.
-  DynamicImage *GetExecutableImage();
+  DynamicImage* GetExecutableImage();
   int GetExecutableImageIndex();
 
   // Returns the task which we're looking at.
@@ -285,7 +285,7 @@ class DynamicImages {
     return CPU_TYPE_POWERPC64;
 #elif defined(__arm__)
     return CPU_TYPE_ARM;
-#elif defined(__arm64__)
+#elif defined(__aarch64__)
     return CPU_TYPE_ARM64;
 #else
 #error "GetNativeCPUType not implemented for this architecture"
@@ -312,7 +312,7 @@ class DynamicImages {
 kern_return_t ReadTaskMemory(task_port_t target_task,
                              const uint64_t address,
                              size_t length,
-                             vector<uint8_t> &bytes);
+                             vector<uint8_t>& bytes);
 
 }   // namespace google_breakpad
 
diff --git a/src/MEGASync/google_breakpad/client/mac/handler/exception_handler.cc b/src/MEGASync/google_breakpad/client/mac/handler/exception_handler.cc
index 58ecc415..287fe1be 100644
--- a/src/MEGASync/google_breakpad/client/mac/handler/exception_handler.cc
+++ b/src/MEGASync/google_breakpad/client/mac/handler/exception_handler.cc
@@ -74,8 +74,12 @@ namespace google_breakpad {
 
 static union {
 #if USE_PROTECTED_ALLOCATIONS
+#if defined PAGE_MAX_SIZE
+  char protected_buffer[PAGE_MAX_SIZE] __attribute__((aligned(PAGE_MAX_SIZE)));
+#else
   char protected_buffer[PAGE_SIZE] __attribute__((aligned(PAGE_SIZE)));
-#endif
+#endif  // defined PAGE_MAX_SIZE
+#endif  // USE_PROTECTED_ALLOCATIONS
   google_breakpad::ExceptionHandler *handler;
 } gProtectedData;
 
@@ -122,7 +126,7 @@ extern "C" {
                        mach_msg_header_t* reply);
 
   // This symbol must be visible to dlsym() - see
-  // http://code.google.com/p/google-breakpad/issues/detail?id=345 for details.
+  // https://bugs.chromium.org/p/google-breakpad/issues/detail?id=345 for details.
   kern_return_t catch_exception_raise(mach_port_t target_port,
                                       mach_port_t failed_thread,
                                       mach_port_t task,
@@ -216,7 +220,7 @@ kern_return_t catch_exception_raise(mach_port_t port, mach_port_t failed_thread,
 }
 #endif
 
-ExceptionHandler::ExceptionHandler(const string &dump_path,
+ExceptionHandler::ExceptionHandler(const string& dump_path,
                                    FilterCallback filter,
                                    MinidumpCallback callback,
                                    void* callback_context,
@@ -300,7 +304,7 @@ bool ExceptionHandler::WriteMinidump(bool write_exception_stream) {
 }
 
 // static
-bool ExceptionHandler::WriteMinidump(const string &dump_path,
+bool ExceptionHandler::WriteMinidump(const string& dump_path,
                                      bool write_exception_stream,
                                      MinidumpCallback callback,
                                      void* callback_context) {
@@ -312,7 +316,7 @@ bool ExceptionHandler::WriteMinidump(const string &dump_path,
 // static
 bool ExceptionHandler::WriteMinidumpForChild(mach_port_t child,
                                              mach_port_t child_blamed_thread,
-                                             const string &dump_path,
+                                             const string& dump_path,
                                              MinidumpCallback callback,
                                              void* callback_context) {
   ScopedTaskSuspend suspend(child);
@@ -326,7 +330,7 @@ bool ExceptionHandler::WriteMinidumpForChild(mach_port_t child,
                                     EXC_I386_BPT,
 #elif defined(__ppc__) || defined(__ppc64__)
                                     EXC_PPC_BREAKPOINT,
-#elif defined(__arm__) || defined(__arm64__)
+#elif defined(__arm__) || defined(__aarch64__)
                                     EXC_ARM_BREAKPOINT,
 #else
 #error architecture not supported
@@ -352,6 +356,11 @@ bool ExceptionHandler::WriteMinidumpWithException(
     bool report_current_thread) {
   bool result = false;
 
+#if TARGET_OS_IPHONE
+  // _exit() should never be called on iOS.
+  exit_after_write = false;
+#endif
+
   if (directCallback_) {
     if (directCallback_(callback_context_,
                         exception_type,
@@ -455,7 +464,7 @@ kern_return_t ForwardException(mach_port_t task, mach_port_t failed_thread,
 
   kern_return_t result;
   // TODO: Handle the case where |target_behavior| has MACH_EXCEPTION_CODES
-  // set. https://code.google.com/p/google-breakpad/issues/detail?id=551
+  // set. https://bugs.chromium.org/p/google-breakpad/issues/detail?id=551
   switch (target_behavior) {
     case EXCEPTION_DEFAULT:
       result = exception_raise(target_port, failed_thread, task, exception,
@@ -522,7 +531,7 @@ void* ExceptionHandler::WaitForMessage(void* exception_handler_class) {
           exception_code = EXC_I386_BPT;
 #elif defined(__ppc__) || defined(__ppc64__)
           exception_code = EXC_PPC_BREAKPOINT;
-#elif defined(__arm__) || defined(__arm64__)
+#elif defined(__arm__) || defined(__aarch64__)
           exception_code = EXC_ARM_BREAKPOINT;
 #else
 #error architecture not supported
diff --git a/src/MEGASync/google_breakpad/client/mac/handler/exception_handler.h b/src/MEGASync/google_breakpad/client/mac/handler/exception_handler.h
index f1d9ae92..fe7491fd 100644
--- a/src/MEGASync/google_breakpad/client/mac/handler/exception_handler.h
+++ b/src/MEGASync/google_breakpad/client/mac/handler/exception_handler.h
@@ -75,7 +75,7 @@ class ExceptionHandler {
   // attempting to write a minidump.  If a FilterCallback returns false, Breakpad
   // will immediately report the exception as unhandled without writing a
   // minidump, allowing another handler the opportunity to handle it.
-  typedef bool (*FilterCallback)(void *context);
+  typedef bool (*FilterCallback)(void* context);
 
   // A callback function to run after the minidump has been written.
   // |minidump_id| is a unique id for the dump, so the minidump
@@ -85,18 +85,18 @@ class ExceptionHandler {
   // Return true if the exception was fully handled and breakpad should exit.
   // Return false to allow any other exception handlers to process the
   // exception.
-  typedef bool (*MinidumpCallback)(const char *dump_dir,
-                                   const char *minidump_id,
-                                   void *context, bool succeeded);
+  typedef bool (*MinidumpCallback)(const char* dump_dir,
+                                   const char* minidump_id,
+                                   void* context, bool succeeded);
 
   // A callback function which will be called directly if an exception occurs.
   // This bypasses the minidump file writing and simply gives the client
   // the exception information.
-  typedef bool (*DirectCallback)( void *context,
-                                  int exception_type,
-                                  int exception_code,
-                                  int exception_subcode,
-                                  mach_port_t thread_name);
+  typedef bool (*DirectCallback)(void* context,
+                                 int exception_type,
+                                 int exception_code,
+                                 int exception_subcode,
+                                 mach_port_t thread_name);
 
   // Creates a new ExceptionHandler instance to handle writing minidumps.
   // Minidump files will be written to dump_path, and the optional callback
@@ -106,22 +106,22 @@ class ExceptionHandler {
   // be written when WriteMinidump is called.
   // If port_name is non-NULL, attempt to perform out-of-process dump generation
   // If port_name is NULL, in-process dump generation will be used.
-  ExceptionHandler(const string &dump_path,
+  ExceptionHandler(const string& dump_path,
                    FilterCallback filter, MinidumpCallback callback,
-                   void *callback_context, bool install_handler,
-		   const char *port_name);
+                   void* callback_context, bool install_handler,
+                   const char* port_name);
 
   // A special constructor if we want to bypass minidump writing and
   // simply get a callback with the exception information.
   ExceptionHandler(DirectCallback callback,
-                   void *callback_context,
+                   void* callback_context,
                    bool install_handler);
 
   ~ExceptionHandler();
 
   // Get and set the minidump path.
   string dump_path() const { return dump_path_; }
-  void set_dump_path(const string &dump_path) {
+  void set_dump_path(const string& dump_path) {
     dump_path_ = dump_path;
     dump_path_c_ = dump_path_.c_str();
     UpdateNextID();  // Necessary to put dump_path_ in next_minidump_path_.
@@ -137,23 +137,23 @@ class ExceptionHandler {
 
   // Convenience form of WriteMinidump which does not require an
   // ExceptionHandler instance.
-  static bool WriteMinidump(const string &dump_path, MinidumpCallback callback,
-                            void *callback_context) {
+  static bool WriteMinidump(const string& dump_path, MinidumpCallback callback,
+                            void* callback_context) {
     return WriteMinidump(dump_path, false, callback, callback_context);
   }
 
-  static bool WriteMinidump(const string &dump_path,
+  static bool WriteMinidump(const string& dump_path,
                             bool write_exception_stream,
                             MinidumpCallback callback,
-                            void *callback_context);
+                            void* callback_context);
 
   // Write a minidump of child immediately. This can be used to capture
   // the execution state of a child process independently of a crash.
   static bool WriteMinidumpForChild(mach_port_t child,
-				    mach_port_t child_blamed_thread,
-				    const std::string &dump_path,
-				    MinidumpCallback callback,
-				    void *callback_context);
+                                    mach_port_t child_blamed_thread,
+                                    const std::string& dump_path,
+                                    MinidumpCallback callback,
+                                    void* callback_context);
 
   // Returns whether out-of-process dump generation is used or not.
   bool IsOutOfProcess() const {
@@ -189,21 +189,21 @@ class ExceptionHandler {
   bool WriteMinidumpWithException(int exception_type,
                                   int exception_code,
                                   int exception_subcode,
-                                  breakpad_ucontext_t *task_context,
+                                  breakpad_ucontext_t* task_context,
                                   mach_port_t thread_name,
                                   bool exit_after_write,
                                   bool report_current_thread);
 
   // When installed, this static function will be call from a newly created
   // pthread with |this| as the argument
-  static void *WaitForMessage(void *exception_handler_class);
+  static void* WaitForMessage(void* exception_handler_class);
 
   // Signal handler for SIGABRT.
   static void SignalHandler(int sig, siginfo_t* info, void* uc);
 
   // disallow copy ctor and operator=
-  explicit ExceptionHandler(const ExceptionHandler &);
-  void operator=(const ExceptionHandler &);
+  explicit ExceptionHandler(const ExceptionHandler&);
+  void operator=(const ExceptionHandler&);
 
   // Generates a new ID and stores it in next_minidump_id_, and stores the
   // path of the next minidump to be written in next_minidump_path_.
@@ -224,15 +224,15 @@ class ExceptionHandler {
   string next_minidump_path_;
 
   // Pointers to the UTF-8 versions of above
-  const char *dump_path_c_;
-  const char *next_minidump_id_c_;
-  const char *next_minidump_path_c_;
+  const char* dump_path_c_;
+  const char* next_minidump_id_c_;
+  const char* next_minidump_path_c_;
 
   // The callback function and pointer to be passed back after the minidump
   // has been written
   FilterCallback filter_;
   MinidumpCallback callback_;
-  void *callback_context_;
+  void* callback_context_;
 
   // The callback function to be passed back when we don't want a minidump
   // file to be written
@@ -247,7 +247,7 @@ class ExceptionHandler {
 
   // These variables save the previous exception handler's data so that it
   // can be re-installed when this handler is uninstalled
-  ExceptionParameters *previous_;
+  ExceptionParameters* previous_;
 
   // True, if we've installed the exception handler
   bool installed_exception_handler_;
diff --git a/src/MEGASync/google_breakpad/client/mac/handler/mach_vm_compat.h b/src/MEGASync/google_breakpad/client/mac/handler/mach_vm_compat.h
index cb5cf2bd..9e9028b9 100644
--- a/src/MEGASync/google_breakpad/client/mac/handler/mach_vm_compat.h
+++ b/src/MEGASync/google_breakpad/client/mac/handler/mach_vm_compat.h
@@ -39,11 +39,7 @@
 #define mach_vm_address_t vm_address_t
 #define mach_vm_deallocate vm_deallocate
 #define mach_vm_read vm_read
-#if defined(__LP64__)
 #define mach_vm_region_recurse vm_region_recurse_64
-#else
-#define mach_vm_region_recurse vm_region_recurse
-#endif
 #define mach_vm_size_t vm_size_t
 #else
 #include <mach/mach_vm.h>
diff --git a/src/MEGASync/google_breakpad/client/mac/handler/minidump_generator.cc b/src/MEGASync/google_breakpad/client/mac/handler/minidump_generator.cc
index a85c6704..e0351c4b 100644
--- a/src/MEGASync/google_breakpad/client/mac/handler/minidump_generator.cc
+++ b/src/MEGASync/google_breakpad/client/mac/handler/minidump_generator.cc
@@ -62,7 +62,7 @@ using MacStringUtils::IntegerValueAtIndex;
 
 namespace google_breakpad {
 
-#if __LP64__
+#if defined(__LP64__) && __LP64__
 #define LC_SEGMENT_ARCH LC_SEGMENT_64
 #else
 #define LC_SEGMENT_ARCH LC_SEGMENT
@@ -133,25 +133,47 @@ void MinidumpGenerator::GatherSystemInformation() {
                                   vers_path,
                                   kCFURLPOSIXPathStyle,
                                   false);
-  CFDataRef data;
-  SInt32 error;
-  CFURLCreateDataAndPropertiesFromResource(NULL, sys_vers, &data, NULL, NULL,
-                                           &error);
-
+  CFReadStreamRef read_stream = CFReadStreamCreateWithFile(NULL, sys_vers);
+  CFRelease(sys_vers);
+  if (!read_stream) {
+    return;
+  }
+  if (!CFReadStreamOpen(read_stream)) {
+    CFRelease(read_stream);
+    return;
+  }
+  CFMutableDataRef data = NULL;
+  while (true) {
+    // Actual data file tests: Mac at 480 bytes and iOS at 413 bytes.
+    const CFIndex kMaxBufferLength = 1024;
+    UInt8 data_bytes[kMaxBufferLength];
+    CFIndex num_bytes_read =
+      CFReadStreamRead(read_stream, data_bytes, kMaxBufferLength);
+    if (num_bytes_read < 0) {
+      if (data) {
+        CFRelease(data);
+        data = NULL;
+      }
+      break;
+    } else if (num_bytes_read == 0) {
+      break;
+    } else if (!data) {
+      data = CFDataCreateMutable(NULL, 0);
+    }
+    CFDataAppendBytes(data, data_bytes, num_bytes_read);
+  }
+  CFReadStreamClose(read_stream);
+  CFRelease(read_stream);
   if (!data) {
-    CFRelease(sys_vers);
     return;
   }
-
-  CFDictionaryRef list = static_cast<CFDictionaryRef>
-    (CFPropertyListCreateFromXMLData(NULL, data, kCFPropertyListImmutable,
-                                     NULL));
+  CFDictionaryRef list =
+      static_cast<CFDictionaryRef>(CFPropertyListCreateWithData(
+          NULL, data, kCFPropertyListImmutable, NULL, NULL));
+  CFRelease(data);
   if (!list) {
-    CFRelease(sys_vers);
-    CFRelease(data);
     return;
   }
-
   CFStringRef build_version = static_cast<CFStringRef>
     (CFDictionaryGetValue(list, CFSTR("ProductBuildVersion")));
   CFStringRef product_version = static_cast<CFStringRef>
@@ -160,8 +182,6 @@ void MinidumpGenerator::GatherSystemInformation() {
   string product_str = ConvertToString(product_version);
 
   CFRelease(list);
-  CFRelease(sys_vers);
-  CFRelease(data);
 
   strlcpy(build_string_, build_str.c_str(), sizeof(build_string_));
 
@@ -171,12 +191,12 @@ void MinidumpGenerator::GatherSystemInformation() {
   os_build_number_ = IntegerValueAtIndex(product_str, 2);
 }
 
-void MinidumpGenerator::SetTaskContext(breakpad_ucontext_t *task_context) {
+void MinidumpGenerator::SetTaskContext(breakpad_ucontext_t* task_context) {
   task_context_ = task_context;
 }
 
-string MinidumpGenerator::UniqueNameInDirectory(const string &dir,
-                                                string *unique_name) {
+string MinidumpGenerator::UniqueNameInDirectory(const string& dir,
+                                                string* unique_name) {
   CFUUIDRef uuid = CFUUIDCreate(NULL);
   CFStringRef uuid_cfstr = CFUUIDCreateString(NULL, uuid);
   CFRelease(uuid);
@@ -200,7 +220,7 @@ string MinidumpGenerator::UniqueNameInDirectory(const string &dir,
   return path;
 }
 
-bool MinidumpGenerator::Write(const char *path) {
+bool MinidumpGenerator::Write(const char* path) {
   WriteStreamFN writers[] = {
     &MinidumpGenerator::WriteThreadListStream,
     &MinidumpGenerator::WriteMemoryListStream,
@@ -236,10 +256,10 @@ bool MinidumpGenerator::Write(const char *path) {
     if (!dir.AllocateArray(writer_count))
       return false;
 
-    MDRawHeader *header_ptr = header.get();
+    MDRawHeader* header_ptr = header.get();
     header_ptr->signature = MD_HEADER_SIGNATURE;
     header_ptr->version = MD_HEADER_VERSION;
-    time(reinterpret_cast<time_t *>(&(header_ptr->time_date_stamp)));
+    time(reinterpret_cast<time_t*>(&(header_ptr->time_date_stamp)));
     header_ptr->stream_count = writer_count;
     header_ptr->stream_directory_rva = dir.position();
 
@@ -315,7 +335,7 @@ size_t MinidumpGenerator::CalculateStackSize(mach_vm_address_t start_addr) {
 
 bool MinidumpGenerator::WriteStackFromStartAddress(
     mach_vm_address_t start_addr,
-    MDMemoryDescriptor *stack_location) {
+    MDMemoryDescriptor* stack_location) {
   UntypedMDRVA memory(&writer_);
 
   bool result = false;
@@ -352,7 +372,7 @@ bool MinidumpGenerator::WriteStackFromStartAddress(
 
       result = memory.Copy(&stack_memory[0], size);
     } else {
-      result = memory.Copy(reinterpret_cast<const void *>(start_addr), size);
+      result = memory.Copy(reinterpret_cast<const void*>(start_addr), size);
     }
   }
 
@@ -363,7 +383,7 @@ bool MinidumpGenerator::WriteStackFromStartAddress(
 }
 
 bool MinidumpGenerator::WriteStack(breakpad_thread_state_data_t state,
-                                   MDMemoryDescriptor *stack_location) {
+                                   MDMemoryDescriptor* stack_location) {
   switch (cpu_type_) {
 #ifdef HAS_ARM_SUPPORT
     case CPU_TYPE_ARM:
@@ -391,7 +411,7 @@ bool MinidumpGenerator::WriteStack(breakpad_thread_state_data_t state,
 }
 
 bool MinidumpGenerator::WriteContext(breakpad_thread_state_data_t state,
-                                     MDLocationDescriptor *register_location) {
+                                     MDLocationDescriptor* register_location) {
   switch (cpu_type_) {
 #ifdef HAS_ARM_SUPPORT
     case CPU_TYPE_ARM:
@@ -449,33 +469,33 @@ uint64_t MinidumpGenerator::CurrentPCForStack(
 
 #ifdef HAS_ARM_SUPPORT
 bool MinidumpGenerator::WriteStackARM(breakpad_thread_state_data_t state,
-                                      MDMemoryDescriptor *stack_location) {
-  arm_thread_state_t *machine_state =
-      reinterpret_cast<arm_thread_state_t *>(state);
+                                      MDMemoryDescriptor* stack_location) {
+  arm_thread_state_t* machine_state =
+      reinterpret_cast<arm_thread_state_t*>(state);
   mach_vm_address_t start_addr = REGISTER_FROM_THREADSTATE(machine_state, sp);
   return WriteStackFromStartAddress(start_addr, stack_location);
 }
 
 uint64_t
 MinidumpGenerator::CurrentPCForStackARM(breakpad_thread_state_data_t state) {
-  arm_thread_state_t *machine_state =
-      reinterpret_cast<arm_thread_state_t *>(state);
+  arm_thread_state_t* machine_state =
+      reinterpret_cast<arm_thread_state_t*>(state);
 
   return REGISTER_FROM_THREADSTATE(machine_state, pc);
 }
 
 bool MinidumpGenerator::WriteContextARM(breakpad_thread_state_data_t state,
-                                        MDLocationDescriptor *register_location)
+                                        MDLocationDescriptor* register_location)
 {
   TypedMDRVA<MDRawContextARM> context(&writer_);
-  arm_thread_state_t *machine_state =
-      reinterpret_cast<arm_thread_state_t *>(state);
+  arm_thread_state_t* machine_state =
+      reinterpret_cast<arm_thread_state_t*>(state);
 
   if (!context.Allocate())
     return false;
 
   *register_location = context.location();
-  MDRawContextARM *context_ptr = context.get();
+  MDRawContextARM* context_ptr = context.get();
   context_ptr->context_flags = MD_CONTEXT_ARM_FULL;
 
 #define AddGPR(a) context_ptr->iregs[a] = REGISTER_FROM_THREADSTATE(machine_state, r[a])
@@ -506,38 +526,38 @@ bool MinidumpGenerator::WriteContextARM(breakpad_thread_state_data_t state,
 
 #ifdef HAS_ARM64_SUPPORT
 bool MinidumpGenerator::WriteStackARM64(breakpad_thread_state_data_t state,
-                                        MDMemoryDescriptor *stack_location) {
-  arm_thread_state64_t *machine_state =
-      reinterpret_cast<arm_thread_state64_t *>(state);
+                                        MDMemoryDescriptor* stack_location) {
+  arm_thread_state64_t* machine_state =
+      reinterpret_cast<arm_thread_state64_t*>(state);
   mach_vm_address_t start_addr = REGISTER_FROM_THREADSTATE(machine_state, sp);
   return WriteStackFromStartAddress(start_addr, stack_location);
 }
 
 uint64_t
 MinidumpGenerator::CurrentPCForStackARM64(breakpad_thread_state_data_t state) {
-  arm_thread_state64_t *machine_state =
-      reinterpret_cast<arm_thread_state64_t *>(state);
+  arm_thread_state64_t* machine_state =
+      reinterpret_cast<arm_thread_state64_t*>(state);
 
   return REGISTER_FROM_THREADSTATE(machine_state, pc);
 }
 
 bool
 MinidumpGenerator::WriteContextARM64(breakpad_thread_state_data_t state,
-                                     MDLocationDescriptor *register_location)
+                                     MDLocationDescriptor* register_location)
 {
-  TypedMDRVA<MDRawContextARM64> context(&writer_);
-  arm_thread_state64_t *machine_state =
-      reinterpret_cast<arm_thread_state64_t *>(state);
+  TypedMDRVA<MDRawContextARM64_Old> context(&writer_);
+  arm_thread_state64_t* machine_state =
+      reinterpret_cast<arm_thread_state64_t*>(state);
 
   if (!context.Allocate())
     return false;
 
   *register_location = context.location();
-  MDRawContextARM64 *context_ptr = context.get();
-  context_ptr->context_flags = MD_CONTEXT_ARM64_FULL;
+  MDRawContextARM64_Old* context_ptr = context.get();
+  context_ptr->context_flags = MD_CONTEXT_ARM64_FULL_OLD;
 
-#define AddGPR(a) context_ptr->iregs[a] = \
-    REGISTER_FROM_THREADSTATE(machine_state, x[a])
+#define AddGPR(a)                                                              \
+  context_ptr->iregs[a] = ARRAY_REGISTER_FROM_THREADSTATE(machine_state, x, a)
 
   context_ptr->iregs[29] = REGISTER_FROM_THREADSTATE(machine_state, fp);
   context_ptr->iregs[30] = REGISTER_FROM_THREADSTATE(machine_state, lr);
@@ -582,53 +602,56 @@ MinidumpGenerator::WriteContextARM64(breakpad_thread_state_data_t state,
 
 #ifdef HAS_PCC_SUPPORT
 bool MinidumpGenerator::WriteStackPPC(breakpad_thread_state_data_t state,
-                                      MDMemoryDescriptor *stack_location) {
-  ppc_thread_state_t *machine_state =
-      reinterpret_cast<ppc_thread_state_t *>(state);
+                                      MDMemoryDescriptor* stack_location) {
+  ppc_thread_state_t* machine_state =
+      reinterpret_cast<ppc_thread_state_t*>(state);
   mach_vm_address_t start_addr = REGISTER_FROM_THREADSTATE(machine_state, r1);
   return WriteStackFromStartAddress(start_addr, stack_location);
 }
 
 bool MinidumpGenerator::WriteStackPPC64(breakpad_thread_state_data_t state,
-                                        MDMemoryDescriptor *stack_location) {
-  ppc_thread_state64_t *machine_state =
-      reinterpret_cast<ppc_thread_state64_t *>(state);
+                                        MDMemoryDescriptor* stack_location) {
+  ppc_thread_state64_t* machine_state =
+      reinterpret_cast<ppc_thread_state64_t*>(state);
   mach_vm_address_t start_addr = REGISTER_FROM_THREADSTATE(machine_state, r1);
   return WriteStackFromStartAddress(start_addr, stack_location);
 }
 
 uint64_t
 MinidumpGenerator::CurrentPCForStackPPC(breakpad_thread_state_data_t state) {
-  ppc_thread_state_t *machine_state =
-      reinterpret_cast<ppc_thread_state_t *>(state);
+  ppc_thread_state_t* machine_state =
+      reinterpret_cast<ppc_thread_state_t*>(state);
 
   return REGISTER_FROM_THREADSTATE(machine_state, srr0);
 }
 
 uint64_t
 MinidumpGenerator::CurrentPCForStackPPC64(breakpad_thread_state_data_t state) {
-  ppc_thread_state64_t *machine_state =
-      reinterpret_cast<ppc_thread_state64_t *>(state);
+  ppc_thread_state64_t* machine_state =
+      reinterpret_cast<ppc_thread_state64_t*>(state);
 
   return REGISTER_FROM_THREADSTATE(machine_state, srr0);
 }
 
 bool MinidumpGenerator::WriteContextPPC(breakpad_thread_state_data_t state,
-                                        MDLocationDescriptor *register_location)
+                                        MDLocationDescriptor* register_location)
 {
   TypedMDRVA<MDRawContextPPC> context(&writer_);
-  ppc_thread_state_t *machine_state =
-      reinterpret_cast<ppc_thread_state_t *>(state);
+  ppc_thread_state_t* machine_state =
+      reinterpret_cast<ppc_thread_state_t*>(state);
 
   if (!context.Allocate())
     return false;
 
   *register_location = context.location();
-  MDRawContextPPC *context_ptr = context.get();
+  MDRawContextPPC* context_ptr = context.get();
   context_ptr->context_flags = MD_CONTEXT_PPC_BASE;
 
-#define AddReg(a) context_ptr->a = REGISTER_FROM_THREADSTATE(machine_state, a)
-#define AddGPR(a) context_ptr->gpr[a] = REGISTER_FROM_THREADSTATE(machine_state, r ## a)
+#define AddReg(a) context_ptr->a = static_cast<__typeof__(context_ptr->a)>( \
+    REGISTER_FROM_THREADSTATE(machine_state, a))
+#define AddGPR(a) context_ptr->gpr[a] = \
+    static_cast<__typeof__(context_ptr->a)>( \
+    REGISTER_FROM_THREADSTATE(machine_state, r ## a)
 
   AddReg(srr0);
   AddReg(cr);
@@ -678,20 +701,23 @@ bool MinidumpGenerator::WriteContextPPC(breakpad_thread_state_data_t state,
 
 bool MinidumpGenerator::WriteContextPPC64(
     breakpad_thread_state_data_t state,
-    MDLocationDescriptor *register_location) {
+    MDLocationDescriptor* register_location) {
   TypedMDRVA<MDRawContextPPC64> context(&writer_);
-  ppc_thread_state64_t *machine_state =
-      reinterpret_cast<ppc_thread_state64_t *>(state);
+  ppc_thread_state64_t* machine_state =
+      reinterpret_cast<ppc_thread_state64_t*>(state);
 
   if (!context.Allocate())
     return false;
 
   *register_location = context.location();
-  MDRawContextPPC64 *context_ptr = context.get();
+  MDRawContextPPC64* context_ptr = context.get();
   context_ptr->context_flags = MD_CONTEXT_PPC_BASE;
 
-#define AddReg(a) context_ptr->a = REGISTER_FROM_THREADSTATE(machine_state, a)
-#define AddGPR(a) context_ptr->gpr[a] = REGISTER_FROM_THREADSTATE(machine_state, r ## a)
+#define AddReg(a) context_ptr->a = static_cast<__typeof__(context_ptr->a)>( \
+    REGISTER_FROM_THREADSTATE(machine_state, a))
+#define AddGPR(a) context_ptr->gpr[a] = \
+    static_cast<__typeof__(context_ptr->a)>( \
+    REGISTER_FROM_THREADSTATE(machine_state, r ## a)
 
   AddReg(srr0);
   AddReg(cr);
@@ -742,53 +768,55 @@ bool MinidumpGenerator::WriteContextPPC64(
 
 #ifdef HAS_X86_SUPPORT
 bool MinidumpGenerator::WriteStackX86(breakpad_thread_state_data_t state,
-                                   MDMemoryDescriptor *stack_location) {
-  i386_thread_state_t *machine_state =
-      reinterpret_cast<i386_thread_state_t *>(state);
+                                   MDMemoryDescriptor* stack_location) {
+  i386_thread_state_t* machine_state =
+      reinterpret_cast<i386_thread_state_t*>(state);
 
   mach_vm_address_t start_addr = REGISTER_FROM_THREADSTATE(machine_state, esp);
   return WriteStackFromStartAddress(start_addr, stack_location);
 }
 
 bool MinidumpGenerator::WriteStackX86_64(breakpad_thread_state_data_t state,
-                                         MDMemoryDescriptor *stack_location) {
-  x86_thread_state64_t *machine_state =
-      reinterpret_cast<x86_thread_state64_t *>(state);
+                                         MDMemoryDescriptor* stack_location) {
+  x86_thread_state64_t* machine_state =
+      reinterpret_cast<x86_thread_state64_t*>(state);
 
-  mach_vm_address_t start_addr = REGISTER_FROM_THREADSTATE(machine_state, rsp);
+  mach_vm_address_t start_addr = static_cast<mach_vm_address_t>(
+      REGISTER_FROM_THREADSTATE(machine_state, rsp));
   return WriteStackFromStartAddress(start_addr, stack_location);
 }
 
 uint64_t
 MinidumpGenerator::CurrentPCForStackX86(breakpad_thread_state_data_t state) {
-  i386_thread_state_t *machine_state =
-      reinterpret_cast<i386_thread_state_t *>(state);
+  i386_thread_state_t* machine_state =
+      reinterpret_cast<i386_thread_state_t*>(state);
 
   return REGISTER_FROM_THREADSTATE(machine_state, eip);
 }
 
 uint64_t
 MinidumpGenerator::CurrentPCForStackX86_64(breakpad_thread_state_data_t state) {
-  x86_thread_state64_t *machine_state =
-      reinterpret_cast<x86_thread_state64_t *>(state);
+  x86_thread_state64_t* machine_state =
+      reinterpret_cast<x86_thread_state64_t*>(state);
 
   return REGISTER_FROM_THREADSTATE(machine_state, rip);
 }
 
 bool MinidumpGenerator::WriteContextX86(breakpad_thread_state_data_t state,
-                                        MDLocationDescriptor *register_location)
+                                        MDLocationDescriptor* register_location)
 {
   TypedMDRVA<MDRawContextX86> context(&writer_);
-  i386_thread_state_t *machine_state =
-      reinterpret_cast<i386_thread_state_t *>(state);
+  i386_thread_state_t* machine_state =
+      reinterpret_cast<i386_thread_state_t*>(state);
 
   if (!context.Allocate())
     return false;
 
   *register_location = context.location();
-  MDRawContextX86 *context_ptr = context.get();
+  MDRawContextX86* context_ptr = context.get();
 
-#define AddReg(a) context_ptr->a = REGISTER_FROM_THREADSTATE(machine_state, a)
+#define AddReg(a) context_ptr->a = static_cast<__typeof__(context_ptr->a)>( \
+    REGISTER_FROM_THREADSTATE(machine_state, a))
 
   context_ptr->context_flags = MD_CONTEXT_X86;
   AddReg(eax);
@@ -816,18 +844,19 @@ bool MinidumpGenerator::WriteContextX86(breakpad_thread_state_data_t state,
 
 bool MinidumpGenerator::WriteContextX86_64(
     breakpad_thread_state_data_t state,
-    MDLocationDescriptor *register_location) {
+    MDLocationDescriptor* register_location) {
   TypedMDRVA<MDRawContextAMD64> context(&writer_);
-  x86_thread_state64_t *machine_state =
-      reinterpret_cast<x86_thread_state64_t *>(state);
+  x86_thread_state64_t* machine_state =
+      reinterpret_cast<x86_thread_state64_t*>(state);
 
   if (!context.Allocate())
     return false;
 
   *register_location = context.location();
-  MDRawContextAMD64 *context_ptr = context.get();
+  MDRawContextAMD64* context_ptr = context.get();
 
-#define AddReg(a) context_ptr->a = REGISTER_FROM_THREADSTATE(machine_state, a)
+#define AddReg(a) context_ptr->a = static_cast<__typeof__(context_ptr->a)>( \
+    REGISTER_FROM_THREADSTATE(machine_state, a))
 
   context_ptr->context_flags = MD_CONTEXT_AMD64;
   AddReg(rax);
@@ -863,7 +892,7 @@ bool MinidumpGenerator::WriteContextX86_64(
 
 bool MinidumpGenerator::GetThreadState(thread_act_t target_thread,
                                        thread_state_t state,
-                                       mach_msg_type_number_t *count) {
+                                       mach_msg_type_number_t* count) {
   if (task_context_ && target_thread == mach_thread_self()) {
     switch (cpu_type_) {
 #ifdef HAS_ARM_SUPPORT
@@ -871,7 +900,7 @@ bool MinidumpGenerator::GetThreadState(thread_act_t target_thread,
         size_t final_size =
             std::min(static_cast<size_t>(*count), sizeof(arm_thread_state_t));
         memcpy(state, &task_context_->breakpad_uc_mcontext->__ss, final_size);
-        *count = final_size;
+        *count = static_cast<mach_msg_type_number_t>(final_size);
         return true;
 #endif
 #ifdef HAS_ARM64_SUPPORT
@@ -879,7 +908,7 @@ bool MinidumpGenerator::GetThreadState(thread_act_t target_thread,
         size_t final_size =
             std::min(static_cast<size_t>(*count), sizeof(arm_thread_state64_t));
         memcpy(state, &task_context_->breakpad_uc_mcontext->__ss, final_size);
-        *count = final_size;
+        *count = static_cast<mach_msg_type_number_t>(final_size);
         return true;
       }
 #endif
@@ -891,7 +920,7 @@ bool MinidumpGenerator::GetThreadState(thread_act_t target_thread,
         size_t final_size =
             std::min(static_cast<size_t>(*count), state_size);
         memcpy(state, &task_context_->breakpad_uc_mcontext->__ss, final_size);
-        *count = final_size;
+        *count = static_cast<mach_msg_type_number_t>(final_size);
         return true;
       }
 #endif
@@ -934,7 +963,7 @@ bool MinidumpGenerator::GetThreadState(thread_act_t target_thread,
 }
 
 bool MinidumpGenerator::WriteThreadStream(mach_port_t thread_id,
-                                          MDRawThread *thread) {
+                                          MDRawThread* thread) {
   breakpad_thread_state_data_t state;
   mach_msg_type_number_t state_count
       = static_cast<mach_msg_type_number_t>(sizeof(state));
@@ -957,7 +986,7 @@ bool MinidumpGenerator::WriteThreadStream(mach_port_t thread_id,
 }
 
 bool MinidumpGenerator::WriteThreadListStream(
-    MDRawDirectory *thread_list_stream) {
+    MDRawDirectory* thread_list_stream) {
   TypedMDRVA<MDRawThreadList> list(&writer_);
   thread_act_port_array_t threads_for_task;
   mach_msg_type_number_t thread_count;
@@ -998,7 +1027,7 @@ bool MinidumpGenerator::WriteThreadListStream(
 }
 
 bool MinidumpGenerator::WriteMemoryListStream(
-    MDRawDirectory *memory_list_stream) {
+    MDRawDirectory* memory_list_stream) {
   TypedMDRVA<MDRawMemoryList> list(&writer_);
 
   // If the dump has an exception, include some memory around the
@@ -1040,9 +1069,9 @@ bool MinidumpGenerator::WriteMemoryListStream(
         uintptr_t end_of_range = 
           std::min(uintptr_t(ip + (kIPMemorySize / 2)),
                    uintptr_t(addr + size));
-        ip_memory_d.memory.data_size =
-            end_of_range -
+        uintptr_t range_diff = end_of_range -
             static_cast<uintptr_t>(ip_memory_d.start_of_memory_range);
+        ip_memory_d.memory.data_size = static_cast<uint32_t>(range_diff);
         have_ip_memory = true;
         // This needs to get appended to the list even though
         // the memory bytes aren't filled in yet so the entire
@@ -1054,7 +1083,7 @@ bool MinidumpGenerator::WriteMemoryListStream(
   }
 
   // Now fill in the memory list and write it.
-  unsigned memory_count = memory_blocks_.size();
+  size_t memory_count = memory_blocks_.size();
   if (!list.AllocateObjectAndArray(memory_count,
                                    sizeof(MDMemoryDescriptor)))
     return false;
@@ -1062,7 +1091,7 @@ bool MinidumpGenerator::WriteMemoryListStream(
   memory_list_stream->stream_type = MD_MEMORY_LIST_STREAM;
   memory_list_stream->location = list.location();
 
-  list.get()->number_of_memory_ranges = memory_count;
+  list.get()->number_of_memory_ranges = static_cast<uint32_t>(memory_count);
 
   unsigned int i;
   for (i = 0; i < memory_count; ++i) {
@@ -1090,7 +1119,7 @@ bool MinidumpGenerator::WriteMemoryListStream(
     } else {
       // In-process, just copy from local memory.
       ip_memory.Copy(
-        reinterpret_cast<const void *>(ip_memory_d.start_of_memory_range),
+        reinterpret_cast<const void*>(ip_memory_d.start_of_memory_range),
         ip_memory_d.memory.data_size);
     }
 
@@ -1104,7 +1133,7 @@ bool MinidumpGenerator::WriteMemoryListStream(
 }
 
 bool
-MinidumpGenerator::WriteExceptionStream(MDRawDirectory *exception_stream) {
+MinidumpGenerator::WriteExceptionStream(MDRawDirectory* exception_stream) {
   TypedMDRVA<MDRawExceptionStream> exception(&writer_);
 
   if (!exception.Allocate())
@@ -1112,7 +1141,7 @@ MinidumpGenerator::WriteExceptionStream(MDRawDirectory *exception_stream) {
 
   exception_stream->stream_type = MD_EXCEPTION_STREAM;
   exception_stream->location = exception.location();
-  MDRawExceptionStream *exception_ptr = exception.get();
+  MDRawExceptionStream* exception_ptr = exception.get();
   exception_ptr->thread_id = exception_thread_;
 
   // This naming is confusing, but it is the proper translation from
@@ -1139,7 +1168,7 @@ MinidumpGenerator::WriteExceptionStream(MDRawDirectory *exception_stream) {
 }
 
 bool MinidumpGenerator::WriteSystemInfoStream(
-    MDRawDirectory *system_info_stream) {
+    MDRawDirectory* system_info_stream) {
   TypedMDRVA<MDRawSystemInfo> info(&writer_);
 
   if (!info.Allocate())
@@ -1152,7 +1181,7 @@ bool MinidumpGenerator::WriteSystemInfoStream(
   uint32_t number_of_processors;
   size_t len = sizeof(number_of_processors);
   sysctlbyname("hw.ncpu", &number_of_processors, &len, NULL, 0);
-  MDRawSystemInfo *info_ptr = info.get();
+  MDRawSystemInfo* info_ptr = info.get();
 
   switch (cpu_type_) {
 #ifdef HAS_ARM_SUPPORT
@@ -1162,7 +1191,7 @@ bool MinidumpGenerator::WriteSystemInfoStream(
 #endif
 #ifdef HAS_ARM64_SUPPORT
     case CPU_TYPE_ARM64:
-      info_ptr->processor_architecture = MD_CPU_ARCHITECTURE_ARM64;
+      info_ptr->processor_architecture = MD_CPU_ARCHITECTURE_ARM64_OLD;
       break;
 #endif
 #ifdef HAS_PPC_SUPPORT
@@ -1216,9 +1245,9 @@ bool MinidumpGenerator::WriteSystemInfoStream(
       info_ptr->processor_level =
         (info_ptr->cpu.x86_cpu_info.version_information & 0xF00) >> 8;
       // 0xMMSS (Model, Stepping)
-      info_ptr->processor_revision =
-        (info_ptr->cpu.x86_cpu_info.version_information & 0xF) |
-        ((info_ptr->cpu.x86_cpu_info.version_information & 0xF0) << 4);
+      info_ptr->processor_revision = static_cast<uint16_t>(
+          (info_ptr->cpu.x86_cpu_info.version_information & 0xF) |
+          ((info_ptr->cpu.x86_cpu_info.version_information & 0xF0) << 4));
 
       // decode extended model info
       if (info_ptr->processor_level == 0xF ||
@@ -1263,10 +1292,10 @@ bool MinidumpGenerator::WriteSystemInfoStream(
 }
 
 bool MinidumpGenerator::WriteModuleStream(unsigned int index,
-                                          MDRawModule *module) {
+                                          MDRawModule* module) {
   if (dynamic_images_) {
     // we're in a different process than the crashed process
-    DynamicImage *image = dynamic_images_->GetImage(index);
+    DynamicImage* image = dynamic_images_->GetImage(index);
 
     if (!image)
       return false;
@@ -1308,7 +1337,7 @@ bool MinidumpGenerator::WriteModuleStream(unsigned int index,
     }
   } else {
     // Getting module info in the crashed process
-    const breakpad_mach_header *header;
+    const breakpad_mach_header* header;
     header = (breakpad_mach_header*)_dyld_get_image_header(index);
     if (!header)
       return false;
@@ -1328,16 +1357,16 @@ bool MinidumpGenerator::WriteModuleStream(unsigned int index,
     int cpu_type = header->cputype;
     unsigned long slide = _dyld_get_image_vmaddr_slide(index);
     const char* name = _dyld_get_image_name(index);
-    const struct load_command *cmd =
-        reinterpret_cast<const struct load_command *>(header + 1);
+    const struct load_command* cmd =
+        reinterpret_cast<const struct load_command*>(header + 1);
 
     memset(module, 0, sizeof(MDRawModule));
 
     for (unsigned int i = 0; cmd && (i < header->ncmds); i++) {
       if (cmd->cmd == LC_SEGMENT_ARCH) {
 
-        const breakpad_mach_segment_command *seg =
-            reinterpret_cast<const breakpad_mach_segment_command *>(cmd);
+        const breakpad_mach_segment_command* seg =
+            reinterpret_cast<const breakpad_mach_segment_command*>(cmd);
 
         if (!strcmp(seg->segname, "__TEXT")) {
           MDLocationDescriptor string_location;
@@ -1360,7 +1389,7 @@ bool MinidumpGenerator::WriteModuleStream(unsigned int index,
         }
       }
 
-      cmd = reinterpret_cast<struct load_command*>((char *)cmd + cmd->cmdsize);
+      cmd = reinterpret_cast<struct load_command*>((char*)cmd + cmd->cmdsize);
     }
   }
 
@@ -1376,7 +1405,7 @@ int MinidumpGenerator::FindExecutableModule() {
     }
   } else {
     int image_count = _dyld_image_count();
-    const struct mach_header *header;
+    const struct mach_header* header;
 
     for (int index = 0; index < image_count; ++index) {
       header = _dyld_get_image_header(index);
@@ -1390,12 +1419,12 @@ int MinidumpGenerator::FindExecutableModule() {
   return 0;
 }
 
-bool MinidumpGenerator::WriteCVRecord(MDRawModule *module, int cpu_type,
-                                      const char *module_path, bool in_memory) {
+bool MinidumpGenerator::WriteCVRecord(MDRawModule* module, int cpu_type,
+                                      const char* module_path, bool in_memory) {
   TypedMDRVA<MDCVInfoPDB70> cv(&writer_);
 
   // Only return the last path component of the full module path
-  const char *module_name = strrchr(module_path, '/');
+  const char* module_name = strrchr(module_path, '/');
 
   // Increment past the slash
   if (module_name)
@@ -1412,7 +1441,7 @@ bool MinidumpGenerator::WriteCVRecord(MDRawModule *module, int cpu_type,
     return false;
 
   module->cv_record = cv.location();
-  MDCVInfoPDB70 *cv_ptr = cv.get();
+  MDCVInfoPDB70* cv_ptr = cv.get();
   cv_ptr->cv_signature = MD_CVINFOPDB70_SIGNATURE;
   cv_ptr->age = 0;
 
@@ -1421,7 +1450,7 @@ bool MinidumpGenerator::WriteCVRecord(MDRawModule *module, int cpu_type,
   bool result = false;
   if (in_memory) {
     MacFileUtilities::MachoID macho(module_path,
-        reinterpret_cast<void *>(module->base_of_image),
+        reinterpret_cast<void*>(module->base_of_image),
         static_cast<size_t>(module->size_of_image));
     result = macho.UUIDCommand(cpu_type, CPU_SUBTYPE_MULTIPLE, identifier);
     if (!result)
@@ -1458,11 +1487,11 @@ bool MinidumpGenerator::WriteCVRecord(MDRawModule *module, int cpu_type,
 }
 
 bool MinidumpGenerator::WriteModuleListStream(
-    MDRawDirectory *module_list_stream) {
+    MDRawDirectory* module_list_stream) {
   TypedMDRVA<MDRawModuleList> list(&writer_);
 
-  size_t image_count = dynamic_images_ ?
-      static_cast<size_t>(dynamic_images_->GetImageCount()) :
+  uint32_t image_count = dynamic_images_ ?
+      dynamic_images_->GetImageCount() :
       _dyld_image_count();
 
   if (!list.AllocateObjectAndArray(image_count, MD_MODULE_SIZE))
@@ -1470,22 +1499,22 @@ bool MinidumpGenerator::WriteModuleListStream(
 
   module_list_stream->stream_type = MD_MODULE_LIST_STREAM;
   module_list_stream->location = list.location();
-  list.get()->number_of_modules = image_count;
+  list.get()->number_of_modules = static_cast<uint32_t>(image_count);
 
   // Write out the executable module as the first one
   MDRawModule module;
-  size_t executableIndex = FindExecutableModule();
+  uint32_t executableIndex = FindExecutableModule();
 
-  if (!WriteModuleStream(executableIndex, &module)) {
+  if (!WriteModuleStream(static_cast<unsigned>(executableIndex), &module)) {
     return false;
   }
 
   list.CopyIndexAfterObject(0, &module, MD_MODULE_SIZE);
   int destinationIndex = 1;  // Write all other modules after this one
 
-  for (size_t i = 0; i < image_count; ++i) {
+  for (uint32_t i = 0; i < image_count; ++i) {
     if (i != executableIndex) {
-      if (!WriteModuleStream(i, &module)) {
+      if (!WriteModuleStream(static_cast<unsigned>(i), &module)) {
         return false;
       }
 
@@ -1496,7 +1525,7 @@ bool MinidumpGenerator::WriteModuleListStream(
   return true;
 }
 
-bool MinidumpGenerator::WriteMiscInfoStream(MDRawDirectory *misc_info_stream) {
+bool MinidumpGenerator::WriteMiscInfoStream(MDRawDirectory* misc_info_stream) {
   TypedMDRVA<MDRawMiscInfo> info(&writer_);
 
   if (!info.Allocate())
@@ -1505,7 +1534,7 @@ bool MinidumpGenerator::WriteMiscInfoStream(MDRawDirectory *misc_info_stream) {
   misc_info_stream->stream_type = MD_MISC_INFO_STREAM;
   misc_info_stream->location = info.location();
 
-  MDRawMiscInfo *info_ptr = info.get();
+  MDRawMiscInfo* info_ptr = info.get();
   info_ptr->size_of_info = static_cast<uint32_t>(sizeof(MDRawMiscInfo));
   info_ptr->flags1 = MD_MISCINFO_FLAGS1_PROCESS_ID |
     MD_MISCINFO_FLAGS1_PROCESS_TIMES |
@@ -1548,7 +1577,7 @@ bool MinidumpGenerator::WriteMiscInfoStream(MDRawDirectory *misc_info_stream) {
 }
 
 bool MinidumpGenerator::WriteBreakpadInfoStream(
-    MDRawDirectory *breakpad_info_stream) {
+    MDRawDirectory* breakpad_info_stream) {
   TypedMDRVA<MDRawBreakpadInfo> info(&writer_);
 
   if (!info.Allocate())
@@ -1556,7 +1585,7 @@ bool MinidumpGenerator::WriteBreakpadInfoStream(
 
   breakpad_info_stream->stream_type = MD_BREAKPAD_INFO_STREAM;
   breakpad_info_stream->location = info.location();
-  MDRawBreakpadInfo *info_ptr = info.get();
+  MDRawBreakpadInfo* info_ptr = info.get();
 
   if (exception_thread_ && exception_type_) {
     info_ptr->validity = MD_BREAKPAD_INFO_VALID_DUMP_THREAD_ID |
diff --git a/src/MEGASync/google_breakpad/client/mac/handler/minidump_generator.h b/src/MEGASync/google_breakpad/client/mac/handler/minidump_generator.h
index 3f7f8de0..e3a271b0 100644
--- a/src/MEGASync/google_breakpad/client/mac/handler/minidump_generator.h
+++ b/src/MEGASync/google_breakpad/client/mac/handler/minidump_generator.h
@@ -39,7 +39,7 @@
 
 #include "client/mac/handler/ucontext_compat.h"
 #include "client/minidump_file_writer.h"
-#include "common/memory.h"
+#include "common/memory_allocator.h"
 #include "common/mac/macho_utilities.h"
 #include "google_breakpad/common/minidump_format.h"
 
@@ -51,7 +51,7 @@
 #endif
 #if defined(__arm__)
 #define HAS_ARM_SUPPORT
-#elif defined(__arm64__)
+#elif defined(__aarch64__)
 #define HAS_ARM64_SUPPORT
 #elif defined(__i386__) || defined(__x86_64__)
   #define HAS_X86_SUPPORT
@@ -63,14 +63,31 @@ using std::string;
 
 // Use the REGISTER_FROM_THREADSTATE to access a register name from the
 // breakpad_thread_state_t structure.
-#if __DARWIN_UNIX03 || TARGET_CPU_X86_64 || TARGET_CPU_PPC64 || TARGET_CPU_ARM
+#if __DARWIN_OPAQUE_ARM_THREAD_STATE64
+#define ARRAY_REGISTER_FROM_THREADSTATE(a, b, i) ((a)->__##b[i])
+#define GET_REGISTER_FROM_THREADSTATE_fp(a)                                    \
+  (reinterpret_cast<uintptr_t>((a)->__opaque_fp))
+#define GET_REGISTER_FROM_THREADSTATE_lr(a)                                    \
+  (reinterpret_cast<uintptr_t>((a)->__opaque_lr))
+#define GET_REGISTER_FROM_THREADSTATE_sp(a)                                    \
+  (reinterpret_cast<uintptr_t>((a)->__opaque_sp))
+#define GET_REGISTER_FROM_THREADSTATE_pc(a)                                    \
+  (reinterpret_cast<uintptr_t>((a)->__opaque_pc))
+#define GET_REGISTER_FROM_THREADSTATE_cpsr(a) ((a)->__cpsr)
+#define GET_REGISTER_FROM_THREADSTATE_flags(a) ((a)->__opaque_flags)
+#define REGISTER_FROM_THREADSTATE(a, b) (GET_REGISTER_FROM_THREADSTATE_##b(a))
+#elif __DARWIN_UNIX03 || TARGET_CPU_X86_64 || TARGET_CPU_PPC64 || TARGET_CPU_ARM
 // In The 10.5 SDK Headers Apple prepended __ to the variable names in the
 // i386_thread_state_t structure.  There's no good way to tell what version of
 // the SDK we're compiling against so we just toggle on the same preprocessor
 // symbol Apple's headers use.
 #define REGISTER_FROM_THREADSTATE(a, b) ((a)->__ ## b)
+#define ARRAY_REGISTER_FROM_THREADSTATE(a, b, i)                               \
+  REGISTER_FROM_THREADSTATE(a, b[i])
 #else
 #define REGISTER_FROM_THREADSTATE(a, b) (a->b)
+#define ARRAY_REGISTER_FROM_THREADSTATE(a, b, i)                               \
+  REGISTER_FROM_THREADSTATE(a, b[i])
 #endif
 
 // Creates a minidump file of the current process.  If there is exception data,
@@ -89,12 +106,12 @@ class MinidumpGenerator {
 
   // Return <dir>/<unique_name>.dmp
   // Sets |unique_name| (if requested) to the unique name for the minidump
-  static string UniqueNameInDirectory(const string &dir, string *unique_name);
+  static string UniqueNameInDirectory(const string& dir, string* unique_name);
 
   // Write out the minidump into |path|
   // All of the components of |path| must exist and be writable
   // Return true if successful, false otherwise
-  bool Write(const char *path);
+  bool Write(const char* path);
 
   // Specify some exception information, if applicable
   void SetExceptionInformation(int type, int code, int subcode,
@@ -108,7 +125,7 @@ class MinidumpGenerator {
   // Specify the task context. If |task_context| is not NULL, it will be used
   // to retrieve the context of the current thread, instead of using
   // |thread_get_state|.
-  void SetTaskContext(breakpad_ucontext_t *task_context);
+  void SetTaskContext(breakpad_ucontext_t* task_context);
 
   // Gather system information.  This should be call at least once before using
   // the MinidumpGenerator class.
@@ -116,81 +133,81 @@ class MinidumpGenerator {
 
  protected:
   // Overridable Stream writers
-  virtual bool WriteExceptionStream(MDRawDirectory *exception_stream);
+  virtual bool WriteExceptionStream(MDRawDirectory* exception_stream);
 
   // Overridable Helper
-  virtual bool WriteThreadStream(mach_port_t thread_id, MDRawThread *thread);
+  virtual bool WriteThreadStream(mach_port_t thread_id, MDRawThread* thread);
 
  private:
-  typedef bool (MinidumpGenerator::*WriteStreamFN)(MDRawDirectory *);
+  typedef bool (MinidumpGenerator::*WriteStreamFN)(MDRawDirectory*);
 
   // Stream writers
-  bool WriteThreadListStream(MDRawDirectory *thread_list_stream);
-  bool WriteMemoryListStream(MDRawDirectory *memory_list_stream);
-  bool WriteSystemInfoStream(MDRawDirectory *system_info_stream);
-  bool WriteModuleListStream(MDRawDirectory *module_list_stream);
-  bool WriteMiscInfoStream(MDRawDirectory *misc_info_stream);
-  bool WriteBreakpadInfoStream(MDRawDirectory *breakpad_info_stream);
+  bool WriteThreadListStream(MDRawDirectory* thread_list_stream);
+  bool WriteMemoryListStream(MDRawDirectory* memory_list_stream);
+  bool WriteSystemInfoStream(MDRawDirectory* system_info_stream);
+  bool WriteModuleListStream(MDRawDirectory* module_list_stream);
+  bool WriteMiscInfoStream(MDRawDirectory* misc_info_stream);
+  bool WriteBreakpadInfoStream(MDRawDirectory* breakpad_info_stream);
 
   // Helpers
   uint64_t CurrentPCForStack(breakpad_thread_state_data_t state);
   bool GetThreadState(thread_act_t target_thread, thread_state_t state,
-                      mach_msg_type_number_t *count);
+                      mach_msg_type_number_t* count);
   bool WriteStackFromStartAddress(mach_vm_address_t start_addr,
-                                  MDMemoryDescriptor *stack_location);
+                                  MDMemoryDescriptor* stack_location);
   bool WriteStack(breakpad_thread_state_data_t state,
-                  MDMemoryDescriptor *stack_location);
+                  MDMemoryDescriptor* stack_location);
   bool WriteContext(breakpad_thread_state_data_t state,
-                    MDLocationDescriptor *register_location);
-  bool WriteCVRecord(MDRawModule *module, int cpu_type,
-                     const char *module_path, bool in_memory);
-  bool WriteModuleStream(unsigned int index, MDRawModule *module);
+                    MDLocationDescriptor* register_location);
+  bool WriteCVRecord(MDRawModule* module, int cpu_type,
+                     const char* module_path, bool in_memory);
+  bool WriteModuleStream(unsigned int index, MDRawModule* module);
   size_t CalculateStackSize(mach_vm_address_t start_addr);
   int  FindExecutableModule();
 
   // Per-CPU implementations of these methods
 #ifdef HAS_ARM_SUPPORT
   bool WriteStackARM(breakpad_thread_state_data_t state,
-                     MDMemoryDescriptor *stack_location);
+                     MDMemoryDescriptor* stack_location);
   bool WriteContextARM(breakpad_thread_state_data_t state,
-                       MDLocationDescriptor *register_location);
+                       MDLocationDescriptor* register_location);
   uint64_t CurrentPCForStackARM(breakpad_thread_state_data_t state);
 #endif
 #ifdef HAS_ARM64_SUPPORT
   bool WriteStackARM64(breakpad_thread_state_data_t state,
-                       MDMemoryDescriptor *stack_location);
+                       MDMemoryDescriptor* stack_location);
   bool WriteContextARM64(breakpad_thread_state_data_t state,
-                         MDLocationDescriptor *register_location);
+                         MDLocationDescriptor* register_location);
   uint64_t CurrentPCForStackARM64(breakpad_thread_state_data_t state);
 #endif
 #ifdef HAS_PPC_SUPPORT
   bool WriteStackPPC(breakpad_thread_state_data_t state,
-                     MDMemoryDescriptor *stack_location);
+                     MDMemoryDescriptor* stack_location);
   bool WriteContextPPC(breakpad_thread_state_data_t state,
-                       MDLocationDescriptor *register_location);
+                       MDLocationDescriptor* register_location);
   uint64_t CurrentPCForStackPPC(breakpad_thread_state_data_t state);
   bool WriteStackPPC64(breakpad_thread_state_data_t state,
-                       MDMemoryDescriptor *stack_location);
+                       MDMemoryDescriptor* stack_location);
   bool WriteContextPPC64(breakpad_thread_state_data_t state,
-                       MDLocationDescriptor *register_location);
+                       MDLocationDescriptor* register_location);
   uint64_t CurrentPCForStackPPC64(breakpad_thread_state_data_t state);
 #endif
 #ifdef HAS_X86_SUPPORT
   bool WriteStackX86(breakpad_thread_state_data_t state,
-                       MDMemoryDescriptor *stack_location);
+                       MDMemoryDescriptor* stack_location);
   bool WriteContextX86(breakpad_thread_state_data_t state,
-                       MDLocationDescriptor *register_location);
+                       MDLocationDescriptor* register_location);
   uint64_t CurrentPCForStackX86(breakpad_thread_state_data_t state);
   bool WriteStackX86_64(breakpad_thread_state_data_t state,
-                        MDMemoryDescriptor *stack_location);
+                        MDMemoryDescriptor* stack_location);
   bool WriteContextX86_64(breakpad_thread_state_data_t state,
-                          MDLocationDescriptor *register_location);
+                          MDLocationDescriptor* register_location);
   uint64_t CurrentPCForStackX86_64(breakpad_thread_state_data_t state);
 #endif
 
   // disallow copy ctor and operator=
-  explicit MinidumpGenerator(const MinidumpGenerator &);
-  void operator=(const MinidumpGenerator &);
+  explicit MinidumpGenerator(const MinidumpGenerator&);
+  void operator=(const MinidumpGenerator&);
 
  protected:
   // Use this writer to put the data to disk
@@ -207,7 +224,7 @@ class MinidumpGenerator {
 
   // CPU type of the task being dumped.
   cpu_type_t cpu_type_;
-  
+
   // System information
   static char build_string_[16];
   static int os_major_version_;
@@ -215,10 +232,10 @@ class MinidumpGenerator {
   static int os_build_number_;
 
   // Context of the task to dump.
-  breakpad_ucontext_t *task_context_;
+  breakpad_ucontext_t* task_context_;
 
   // Information about dynamically loaded code
-  DynamicImages *dynamic_images_;
+  DynamicImages* dynamic_images_;
 
   // PageAllocator makes it possible to allocate memory
   // directly from the system, even while handling an exception.
diff --git a/src/MEGASync/google_breakpad/client/mac/handler/minidump_test.xcodeproj/project.pbxproj b/src/MEGASync/google_breakpad/client/mac/handler/minidump_test.xcodeproj/project.pbxproj
index 2a597d50..1924ac4d 100644
--- a/src/MEGASync/google_breakpad/client/mac/handler/minidump_test.xcodeproj/project.pbxproj
+++ b/src/MEGASync/google_breakpad/client/mac/handler/minidump_test.xcodeproj/project.pbxproj
@@ -21,13 +21,13 @@
 		8BFC81AE11FF9C8C002CB4DC /* breakpad_nlist_64.cc in Sources */ = {isa = PBXBuildFile; fileRef = F98208A10DB32CAE0017AECA /* breakpad_nlist_64.cc */; };
 		8BFC81AF11FF9C8C002CB4DC /* breakpad_nlist_64.cc in Sources */ = {isa = PBXBuildFile; fileRef = F98208A10DB32CAE0017AECA /* breakpad_nlist_64.cc */; };
 		8BFC81B011FF9C8D002CB4DC /* breakpad_nlist_64.cc in Sources */ = {isa = PBXBuildFile; fileRef = F98208A10DB32CAE0017AECA /* breakpad_nlist_64.cc */; };
-		9B35FF5A0B267D5F008DE8C7 /* convert_UTF.c in Sources */ = {isa = PBXBuildFile; fileRef = 9B35FF560B267D5F008DE8C7 /* convert_UTF.c */; };
+		9B35FF5A0B267D5F008DE8C7 /* convert_UTF.cc in Sources */ = {isa = PBXBuildFile; fileRef = 9B35FF560B267D5F008DE8C7 /* convert_UTF.cc */; };
 		9B35FF5B0B267D5F008DE8C7 /* string_conversion.cc in Sources */ = {isa = PBXBuildFile; fileRef = 9B35FF580B267D5F008DE8C7 /* string_conversion.cc */; };
 		9B37CEEC0AF98ECD00FA4BD4 /* CoreFoundation.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 9B37CEEB0AF98ECD00FA4BD4 /* CoreFoundation.framework */; };
 		9B7CA7700B12873A00CD3A1D /* minidump_file_writer-inl.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = 9BE3C01E0B0CE329009892DF /* minidump_file_writer-inl.h */; };
 		9B7CA8540B12989000CD3A1D /* minidump_file_writer_unittest.cc in Sources */ = {isa = PBXBuildFile; fileRef = 9B7CA8530B12989000CD3A1D /* minidump_file_writer_unittest.cc */; };
 		9B7CA8550B1298A100CD3A1D /* minidump_file_writer.cc in Sources */ = {isa = PBXBuildFile; fileRef = 9BD82C230B01344C0055103E /* minidump_file_writer.cc */; };
-		9BC1D2940B336F2300F2A2B4 /* convert_UTF.c in Sources */ = {isa = PBXBuildFile; fileRef = 9B35FF560B267D5F008DE8C7 /* convert_UTF.c */; };
+		9BC1D2940B336F2300F2A2B4 /* convert_UTF.cc in Sources */ = {isa = PBXBuildFile; fileRef = 9B35FF560B267D5F008DE8C7 /* convert_UTF.cc */; };
 		9BC1D2950B336F2500F2A2B4 /* string_conversion.cc in Sources */ = {isa = PBXBuildFile; fileRef = 9B35FF580B267D5F008DE8C7 /* string_conversion.cc */; };
 		9BD82AC10B0029DF0055103E /* CoreFoundation.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 9B37CEEB0AF98ECD00FA4BD4 /* CoreFoundation.framework */; };
 		9BD82BFF0B01333D0055103E /* exception_handler_test.cc in Sources */ = {isa = PBXBuildFile; fileRef = 9BD82BFD0B01333D0055103E /* exception_handler_test.cc */; };
@@ -56,7 +56,7 @@
 		D2F6510F0BEF94EB00920385 /* macho_walker.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = D2F6510D0BEF94EB00920385 /* macho_walker.h */; };
 		D2F651110BEF951700920385 /* string_conversion.cc in Sources */ = {isa = PBXBuildFile; fileRef = 9B35FF580B267D5F008DE8C7 /* string_conversion.cc */; };
 		D2F651130BEF951C00920385 /* string_conversion.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = 9B35FF590B267D5F008DE8C7 /* string_conversion.h */; };
-		D2F651150BEF953000920385 /* convert_UTF.c in Sources */ = {isa = PBXBuildFile; fileRef = 9B35FF560B267D5F008DE8C7 /* convert_UTF.c */; };
+		D2F651150BEF953000920385 /* convert_UTF.cc in Sources */ = {isa = PBXBuildFile; fileRef = 9B35FF560B267D5F008DE8C7 /* convert_UTF.cc */; };
 		D2F651160BEF953100920385 /* convert_UTF.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = 9B35FF570B267D5F008DE8C7 /* convert_UTF.h */; };
 		D2F6511B0BEF970E00920385 /* dynamic_images.cc in Sources */ = {isa = PBXBuildFile; fileRef = D2F651070BEF949A00920385 /* dynamic_images.cc */; };
 		D2F6511D0BEF973500920385 /* file_id.cc in Sources */ = {isa = PBXBuildFile; fileRef = D2F650FA0BEF947200920385 /* file_id.cc */; };
@@ -68,7 +68,7 @@
 		F93A887F0E8B4C8C0026AF89 /* macho_utilities.cc in Sources */ = {isa = PBXBuildFile; fileRef = D2F650FE0BEF947200920385 /* macho_utilities.cc */; };
 		F93A88800E8B4C8C0026AF89 /* file_id.cc in Sources */ = {isa = PBXBuildFile; fileRef = D2F650FA0BEF947200920385 /* file_id.cc */; };
 		F93A88860E8B4C9A0026AF89 /* dwarftests.mm in Sources */ = {isa = PBXBuildFile; fileRef = F9721F310E8B07E800D7E813 /* dwarftests.mm */; };
-		F93A88870E8B4C9A0026AF89 /* dump_syms.mm in Sources */ = {isa = PBXBuildFile; fileRef = F9721F390E8B0D0D00D7E813 /* dump_syms.mm */; };
+		F93A88870E8B4C9A0026AF89 /* dump_syms.cc in Sources */ = {isa = PBXBuildFile; fileRef = F9721F390E8B0D0D00D7E813 /* dump_syms.cc */; };
 		F93A88880E8B4C9A0026AF89 /* bytereader.cc in Sources */ = {isa = PBXBuildFile; fileRef = F9721F760E8B0DC700D7E813 /* bytereader.cc */; };
 		F93A88890E8B4C9A0026AF89 /* dwarf2reader.cc in Sources */ = {isa = PBXBuildFile; fileRef = F9721F770E8B0DC700D7E813 /* dwarf2reader.cc */; };
 		F93A888A0E8B4C9A0026AF89 /* functioninfo.cc in Sources */ = {isa = PBXBuildFile; fileRef = F9721F780E8B0DC700D7E813 /* functioninfo.cc */; };
@@ -115,7 +115,7 @@
 		8BFC815411FF9B7F002CB4DC /* Carbon.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Carbon.framework; path = System/Library/Frameworks/Carbon.framework; sourceTree = SDKROOT; };
 		8BFC819211FF9C23002CB4DC /* CPlusTest.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = CPlusTest.framework; path = Library/Frameworks/CPlusTest.framework; sourceTree = DEVELOPER_DIR; };
 		8DD76F6C0486A84900D96B5E /* generator_test */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = generator_test; sourceTree = BUILT_PRODUCTS_DIR; };
-		9B35FF560B267D5F008DE8C7 /* convert_UTF.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = convert_UTF.c; path = ../../../common/convert_UTF.c; sourceTree = SOURCE_ROOT; };
+		9B35FF560B267D5F008DE8C7 /* convert_UTF.cc */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; name = convert_UTF.cc; path = ../../../common/convert_UTF.cc; sourceTree = SOURCE_ROOT; };
 		9B35FF570B267D5F008DE8C7 /* convert_UTF.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = convert_UTF.h; path = ../../../common/convert_UTF.h; sourceTree = SOURCE_ROOT; };
 		9B35FF580B267D5F008DE8C7 /* string_conversion.cc */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; name = string_conversion.cc; path = ../../../common/string_conversion.cc; sourceTree = SOURCE_ROOT; };
 		9B35FF590B267D5F008DE8C7 /* string_conversion.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = string_conversion.h; path = ../../../common/string_conversion.h; sourceTree = SOURCE_ROOT; };
@@ -151,7 +151,7 @@
 		F9721F300E8B07E800D7E813 /* dwarftests.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = dwarftests.h; sourceTree = "<group>"; };
 		F9721F310E8B07E800D7E813 /* dwarftests.mm */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.objcpp; path = dwarftests.mm; sourceTree = "<group>"; };
 		F9721F380E8B0CFC00D7E813 /* dump_syms.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = dump_syms.h; path = ../../../common/mac/dump_syms.h; sourceTree = SOURCE_ROOT; };
-		F9721F390E8B0D0D00D7E813 /* dump_syms.mm */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.objcpp; name = dump_syms.mm; path = ../../../common/mac/dump_syms.mm; sourceTree = SOURCE_ROOT; };
+		F9721F390E8B0D0D00D7E813 /* dump_syms.cc */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.objcpp; name = dump_syms.cc; path = ../../../common/mac/dump_syms.cc; sourceTree = SOURCE_ROOT; };
 		F9721F6B0E8B0D7000D7E813 /* Cocoa.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Cocoa.framework; path = System/Library/Frameworks/Cocoa.framework; sourceTree = SDKROOT; };
 		F9721F760E8B0DC700D7E813 /* bytereader.cc */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = bytereader.cc; path = ../../../common/dwarf/bytereader.cc; sourceTree = SOURCE_ROOT; };
 		F9721F770E8B0DC700D7E813 /* dwarf2reader.cc */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = dwarf2reader.cc; path = ../../../common/dwarf/dwarf2reader.cc; sourceTree = SOURCE_ROOT; };
@@ -240,7 +240,7 @@
 				F9721F760E8B0DC700D7E813 /* bytereader.cc */,
 				F9721F770E8B0DC700D7E813 /* dwarf2reader.cc */,
 				F9721F780E8B0DC700D7E813 /* functioninfo.cc */,
-				F9721F390E8B0D0D00D7E813 /* dump_syms.mm */,
+				F9721F390E8B0D0D00D7E813 /* dump_syms.cc */,
 				F9721F380E8B0CFC00D7E813 /* dump_syms.h */,
 				F917C4F70E03265A00F86017 /* breakpad_exc_server.c */,
 				F917C4F80E03265A00F86017 /* breakpad_exc_server.h */,
@@ -307,7 +307,7 @@
 		9BD82C040B0133420055103E /* Breakpad */ = {
 			isa = PBXGroup;
 			children = (
-				9B35FF560B267D5F008DE8C7 /* convert_UTF.c */,
+				9B35FF560B267D5F008DE8C7 /* convert_UTF.cc */,
 				9B35FF570B267D5F008DE8C7 /* convert_UTF.h */,
 				9B35FF580B267D5F008DE8C7 /* string_conversion.cc */,
 				9B35FF590B267D5F008DE8C7 /* string_conversion.h */,
@@ -555,7 +555,7 @@
 				D2F651090BEF949A00920385 /* dynamic_images.cc in Sources */,
 				D2F6510E0BEF94EB00920385 /* macho_walker.cc in Sources */,
 				D2F651110BEF951700920385 /* string_conversion.cc in Sources */,
-				D2F651150BEF953000920385 /* convert_UTF.c in Sources */,
+				D2F651150BEF953000920385 /* convert_UTF.cc in Sources */,
 				8BFC81B011FF9C8D002CB4DC /* breakpad_nlist_64.cc in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
@@ -566,7 +566,7 @@
 			files = (
 				9B7CA8540B12989000CD3A1D /* minidump_file_writer_unittest.cc in Sources */,
 				9B7CA8550B1298A100CD3A1D /* minidump_file_writer.cc in Sources */,
-				9BC1D2940B336F2300F2A2B4 /* convert_UTF.c in Sources */,
+				9BC1D2940B336F2300F2A2B4 /* convert_UTF.cc in Sources */,
 				9BC1D2950B336F2500F2A2B4 /* string_conversion.cc in Sources */,
 				8BFC81AE11FF9C8C002CB4DC /* breakpad_nlist_64.cc in Sources */,
 			);
@@ -581,7 +581,7 @@
 				9BD82C0E0B0133520055103E /* minidump_generator.cc in Sources */,
 				9BD82C250B01344C0055103E /* minidump_file_writer.cc in Sources */,
 				9BD82C2D0B01345E0055103E /* string_utilities.cc in Sources */,
-				9B35FF5A0B267D5F008DE8C7 /* convert_UTF.c in Sources */,
+				9B35FF5A0B267D5F008DE8C7 /* convert_UTF.cc in Sources */,
 				9B35FF5B0B267D5F008DE8C7 /* string_conversion.cc in Sources */,
 				D2F6511B0BEF970E00920385 /* dynamic_images.cc in Sources */,
 				D2F6511D0BEF973500920385 /* file_id.cc in Sources */,
@@ -597,7 +597,7 @@
 			buildActionMask = 2147483647;
 			files = (
 				F93A88860E8B4C9A0026AF89 /* dwarftests.mm in Sources */,
-				F93A88870E8B4C9A0026AF89 /* dump_syms.mm in Sources */,
+				F93A88870E8B4C9A0026AF89 /* dump_syms.cc in Sources */,
 				F93A88880E8B4C9A0026AF89 /* bytereader.cc in Sources */,
 				F93A88890E8B4C9A0026AF89 /* dwarf2reader.cc in Sources */,
 				F93A888A0E8B4C9A0026AF89 /* functioninfo.cc in Sources */,
@@ -636,6 +636,7 @@
 		1DEB923208733DC60010E9CD /* Debug */ = {
 			isa = XCBuildConfiguration;
 			buildSettings = {
+				CLANG_CXX_LANGUAGE_STANDARD = "c++17";
 				FRAMEWORK_SEARCH_PATHS = (
 					"$(inherited)",
 					"\"$(DEVELOPER_FRAMEWORKS_DIR)\"",
@@ -648,6 +649,7 @@
 		1DEB923308733DC60010E9CD /* Release */ = {
 			isa = XCBuildConfiguration;
 			buildSettings = {
+				CLANG_CXX_LANGUAGE_STANDARD = "c++17";
 				FRAMEWORK_SEARCH_PATHS = (
 					"$(inherited)",
 					"\"$(DEVELOPER_FRAMEWORKS_DIR)\"",
diff --git a/src/MEGASync/google_breakpad/client/mac/handler/testcases/DynamicImagesTests.cc b/src/MEGASync/google_breakpad/client/mac/handler/testcases/DynamicImagesTests.cc
index 0fc7825b..0a80e434 100644
--- a/src/MEGASync/google_breakpad/client/mac/handler/testcases/DynamicImagesTests.cc
+++ b/src/MEGASync/google_breakpad/client/mac/handler/testcases/DynamicImagesTests.cc
@@ -42,7 +42,7 @@ DynamicImagesTests test2(TEST_INVOCATION(DynamicImagesTests,
 DynamicImagesTests test3(TEST_INVOCATION(DynamicImagesTests,
                                          ReadLibrariesFromLocalTaskTest));
 
-DynamicImagesTests::DynamicImagesTests(TestInvocation *invocation)
+DynamicImagesTests::DynamicImagesTests(TestInvocation* invocation)
     : TestCase(invocation) {
 }
 
@@ -54,7 +54,7 @@ void DynamicImagesTests::ReadTaskMemoryTest() {
 
   // pick test2 as a symbol we know to be valid to read
   // anything will work, really
-  void *addr = reinterpret_cast<void*>(&test2);
+  void* addr = reinterpret_cast<void*>(&test2);
   std::vector<uint8_t> buf(getpagesize());
 
   fprintf(stderr, "reading 0x%p\n", addr);
@@ -71,7 +71,7 @@ void DynamicImagesTests::ReadTaskMemoryTest() {
 void DynamicImagesTests::ReadLibrariesFromLocalTaskTest() {
 
   mach_port_t me = mach_task_self();
-  google_breakpad::DynamicImages *d = new google_breakpad::DynamicImages(me);
+  google_breakpad::DynamicImages* d = new google_breakpad::DynamicImages(me);
 
   fprintf(stderr,"Local task image count: %d\n", d->GetImageCount());
 
diff --git a/src/MEGASync/google_breakpad/client/mac/handler/testcases/breakpad_nlist_test.cc b/src/MEGASync/google_breakpad/client/mac/handler/testcases/breakpad_nlist_test.cc
index e7332bfb..2014b907 100644
--- a/src/MEGASync/google_breakpad/client/mac/handler/testcases/breakpad_nlist_test.cc
+++ b/src/MEGASync/google_breakpad/client/mac/handler/testcases/breakpad_nlist_test.cc
@@ -40,7 +40,7 @@
 
 BreakpadNlistTest test1(TEST_INVOCATION(BreakpadNlistTest, CompareToNM));
 
-BreakpadNlistTest::BreakpadNlistTest(TestInvocation *invocation)
+BreakpadNlistTest::BreakpadNlistTest(TestInvocation* invocation)
     : TestCase(invocation) {
 }
 
@@ -55,7 +55,7 @@ void BreakpadNlistTest::CompareToNM() {
   system("/usr/bin/nm -arch ppc64 /usr/lib/dyld > /tmp/dyld-namelist.txt");
 #endif
 
-  FILE *fd = fopen("/tmp/dyld-namelist.txt", "rt");
+  FILE* fd = fopen("/tmp/dyld-namelist.txt", "rt");
 
   char oneNMAddr[30];
   char symbolType;
@@ -63,10 +63,10 @@ void BreakpadNlistTest::CompareToNM() {
   while (!feof(fd)) {
     fscanf(fd, "%s %c %s", oneNMAddr, &symbolType, symbolName);
     breakpad_nlist symbolList[2];
-    breakpad_nlist &list = symbolList[0];
+    breakpad_nlist& list = symbolList[0];
 
     memset(symbolList, 0, sizeof(breakpad_nlist)*2);
-    const char *symbolNames[2];
+    const char* symbolNames[2];
     symbolNames[0] = (const char*)symbolName;
     symbolNames[1] = "\0";
     breakpad_nlist_64("/usr/lib/dyld", &list, symbolNames);
@@ -79,12 +79,12 @@ void BreakpadNlistTest::CompareToNM() {
   fclose(fd);
 }
 
-bool BreakpadNlistTest::IsSymbolMoreThanOnceInDyld(const char *symbolName) {
+bool BreakpadNlistTest::IsSymbolMoreThanOnceInDyld(const char* symbolName) {
   // These are the symbols that occur more than once when nm dumps
   // the symbol table of /usr/lib/dyld.  Our nlist program returns
   // the first address because it's doing a search so we need to exclude
   // these from causing the test to fail
-  const char *multipleSymbols[] = {
+  const char* multipleSymbols[] = {
     "__Z41__static_initialization_and_destruction_0ii",
     "___tcf_0",
     "___tcf_1",
diff --git a/src/MEGASync/google_breakpad/client/mac/handler/testcases/breakpad_nlist_test.h b/src/MEGASync/google_breakpad/client/mac/handler/testcases/breakpad_nlist_test.h
index e93657cc..ee8010c7 100644
--- a/src/MEGASync/google_breakpad/client/mac/handler/testcases/breakpad_nlist_test.h
+++ b/src/MEGASync/google_breakpad/client/mac/handler/testcases/breakpad_nlist_test.h
@@ -47,7 +47,7 @@ class BreakpadNlistTest : public TestCase {
   // /usr/lib/dyld. So we track those so we don't report failures
   // in mismatches between what our nlist returns and what nm has
   // for the duplicate symbols.
-  bool IsSymbolMoreThanOnceInDyld(const char *symbolName);
+  bool IsSymbolMoreThanOnceInDyld(const char* symbolName);
 
  public:
   explicit BreakpadNlistTest(TestInvocation* invocation);
diff --git a/src/MEGASync/google_breakpad/client/mac/handler/ucontext_compat.h b/src/MEGASync/google_breakpad/client/mac/handler/ucontext_compat.h
index 093f9a24..1e4b752e 100644
--- a/src/MEGASync/google_breakpad/client/mac/handler/ucontext_compat.h
+++ b/src/MEGASync/google_breakpad/client/mac/handler/ucontext_compat.h
@@ -34,7 +34,7 @@
 
 // The purpose of this file is to work around the fact that ucontext_t's
 // uc_mcontext member is an mcontext_t rather than an mcontext64_t on ARM64.
-#if defined(__arm64__)
+#if defined(__aarch64__)
 // <sys/ucontext.h> doesn't include the below file.
 #include <sys/_types/_ucontext64.h>
 typedef ucontext64_t breakpad_ucontext_t;
@@ -42,6 +42,6 @@ typedef ucontext64_t breakpad_ucontext_t;
 #else
 typedef ucontext_t breakpad_ucontext_t;
 #define breakpad_uc_mcontext uc_mcontext
-#endif  // defined(__arm64__)
+#endif  // defined(__aarch64__)
 
 #endif  // CLIENT_MAC_HANDLER_UCONTEXT_COMPAT_H_
diff --git a/src/MEGASync/google_breakpad/client/mac/sender/Breakpad.xib b/src/MEGASync/google_breakpad/client/mac/sender/Breakpad.xib
index 7966f895..885e39e6 100644
--- a/src/MEGASync/google_breakpad/client/mac/sender/Breakpad.xib
+++ b/src/MEGASync/google_breakpad/client/mac/sender/Breakpad.xib
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <archive type="com.apple.InterfaceBuilder3.Cocoa.XIB" version="7.10">
 	<data>
-		<int key="IBDocument.SystemTarget">1050</int>
+		<int key="IBDocument.SystemTarget">1070</int>
 		<string key="IBDocument.SystemVersion">10F569</string>
 		<string key="IBDocument.InterfaceBuilderVersion">762</string>
 		<string key="IBDocument.AppKitVersion">1038.29</string>
@@ -1114,7 +1114,7 @@ UXVpc3F1ZSBtaS4gRHVpcyBsZWN0dXMuA</string>
 		<string key="IBDocument.TargetRuntimeIdentifier">IBCocoaFramework</string>
 		<object class="NSMutableDictionary" key="IBDocument.PluginDeclaredDependencies">
 			<string key="NS.key.0">com.apple.InterfaceBuilder.CocoaPlugin.macosx</string>
-			<integer value="1050" key="NS.object.0"/>
+			<integer value="1070" key="NS.object.0"/>
 		</object>
 		<object class="NSMutableDictionary" key="IBDocument.PluginDeclaredDevelopmentDependencies">
 			<string key="NS.key.0">com.apple.InterfaceBuilder.CocoaPlugin.InterfaceBuilder3</string>
diff --git a/src/MEGASync/google_breakpad/client/mac/sender/uploader.h b/src/MEGASync/google_breakpad/client/mac/sender/uploader.h
index 318165c9..0897dade 100644
--- a/src/MEGASync/google_breakpad/client/mac/sender/uploader.h
+++ b/src/MEGASync/google_breakpad/client/mac/sender/uploader.h
@@ -42,6 +42,13 @@ extern NSString *const kGoogleServerType;
 extern NSString *const kSocorroServerType;
 extern NSString *const kDefaultServerType;
 
+// Optional user-defined function that will be called after a network upload
+// of a crash report.
+// |report_id| will be the id returned by the server, or "ERR" if an error
+// occurred.
+// |error| will contain the error, or nil if no error occured.
+typedef void (^UploadCompletionBlock)(NSString *reportId, NSError *error);
+
 @interface Uploader : NSObject {
  @private
   NSMutableDictionary *parameters_;        // Key value pairs of data (STRONG)
@@ -61,12 +68,22 @@ extern NSString *const kDefaultServerType;
                                            // that are uploaded to the
                                            // crash server with the
                                            // minidump.
+  UploadCompletionBlock uploadCompletion_;  // A block called on network upload
+                                            // completion. Parameters are:
+                                            // The report ID returned by the
+                                            // server,
+                                            // the NSError triggered during
+                                            // upload.
 }
 
 - (id)initWithConfigFile:(const char *)configFile;
 
 - (id)initWithConfig:(NSDictionary *)config;
 
+// Reads the file |configFile| and returns the corresponding NSDictionary.
+// |configFile| will be deleted after reading.
++ (NSDictionary *)readConfigurationDataFromFile:(NSString *)configFile;
+
 - (NSMutableDictionary *)parameters;
 
 - (void)report;
@@ -78,4 +95,12 @@ extern NSString *const kDefaultServerType;
 // will be uploaded to the crash server.
 - (void)addServerParameter:(id)value forKey:(NSString *)key;
 
+// This method process the HTTP response and renames the minidump file with the
+// new ID.
+- (void)handleNetworkResponse:(NSData *)data withError:(NSError *)error;
+
+// Sets the callback to be called after uploading a crash report to the server.
+// Only the latest callback registered will be called.
+- (void)setUploadCompletionBlock:(UploadCompletionBlock)uploadCompletion;
+
 @end
diff --git a/src/MEGASync/google_breakpad/client/mac/sender/uploader.mm b/src/MEGASync/google_breakpad/client/mac/sender/uploader.mm
index b6da8214..13b6130a 100644
--- a/src/MEGASync/google_breakpad/client/mac/sender/uploader.mm
+++ b/src/MEGASync/google_breakpad/client/mac/sender/uploader.mm
@@ -28,6 +28,7 @@
 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #import <fcntl.h>
+#include <stdio.h>
 #import <sys/stat.h>
 #include <TargetConditionals.h>
 #import <unistd.h>
@@ -38,7 +39,6 @@
 
 #import "client/apple/Framework/BreakpadDefines.h"
 #import "client/mac/sender/uploader.h"
-#import "common/mac/GTMLogger.h"
 
 const int kMinidumpFileLengthLimit = 2 * 1024 * 1024;  // 2MB
 
@@ -89,17 +89,15 @@ NSData *readData(int fileId, ssize_t length) {
 NSDictionary *readConfigurationData(const char *configFile) {
   int fileId = open(configFile, O_RDONLY, 0600);
   if (fileId == -1) {
-    GTMLoggerDebug(@"Couldn't open config file %s - %s",
-                   configFile,
-                   strerror(errno));
+    fprintf(stderr, "Breakpad Uploader: Couldn't open config file %s - %s",
+            configFile, strerror(errno));
   }
 
   // we want to avoid a build-up of old config files even if they
   // have been incorrectly written by the framework
   if (unlink(configFile)) {
-    GTMLoggerDebug(@"Couldn't unlink config file %s - %s",
-                   configFile,
-                   strerror(errno));
+    fprintf(stderr, "Breakpad Uploader: Couldn't unlink config file %s - %s",
+            configFile, strerror(errno));
   }
 
   if (fileId == -1) {
@@ -168,6 +166,12 @@ NSDictionary *readConfigurationData(const char *configFile) {
 
 // Records the uploaded crash ID to the log file.
 - (void)logUploadWithID:(const char *)uploadID;
+
+// Builds an URL parameter for a given dictionary key. Uses Uploader's
+// parameters to provide its value. Returns nil if no item is stored for the
+// given key.
+- (NSURLQueryItem *)queryItemWithName:(NSString *)queryItemName
+                          forParamKey:(NSString *)key;
 @end
 
 @implementation Uploader
@@ -204,6 +208,11 @@ NSDictionary *readConfigurationData(const char *configFile) {
   return self;
 }
 
+//=============================================================================
++ (NSDictionary *)readConfigurationDataFromFile:(NSString *)configFile {
+  return readConfigurationData([configFile fileSystemRepresentation]);
+}
+
 //=============================================================================
 - (void)translateConfigurationData:(NSDictionary *)config {
   parameters_ = [[NSMutableDictionary alloc] init];
@@ -349,7 +358,8 @@ NSDictionary *readConfigurationData(const char *configFile) {
   NSString *logTarFile = [NSString stringWithFormat:@"%s/log.tar.bz2",tmpDir];
   logFileData_ = [[NSData alloc] initWithContentsOfFile:logTarFile];
   if (logFileData_ == nil) {
-    GTMLoggerDebug(@"Cannot find temp tar log file: %@", logTarFile);
+    fprintf(stderr, "Breakpad Uploader: Cannot find temp tar log file: %s",
+            [logTarFile UTF8String]);
     return NO;
   }
   return YES;
@@ -486,9 +496,96 @@ NSDictionary *readConfigurationData(const char *configFile) {
   [extraServerVars_ setObject:value forKey:key];
 }
 
+//=============================================================================
+- (void)handleNetworkResponse:(NSData *)data withError:(NSError *)error {
+  NSString *result = [[NSString alloc] initWithData:data
+                                           encoding:NSUTF8StringEncoding];
+  const char *reportID = "ERR";
+  if (error) {
+    fprintf(stderr, "Breakpad Uploader: Send Error: %s\n",
+            [[error description] UTF8String]);
+  } else {
+    NSCharacterSet *trimSet =
+        [NSCharacterSet whitespaceAndNewlineCharacterSet];
+    reportID = [[result stringByTrimmingCharactersInSet:trimSet] UTF8String];
+    [self logUploadWithID:reportID];
+  }
+  if (uploadCompletion_) {
+    uploadCompletion_([NSString stringWithUTF8String:reportID], error);
+  }
+
+  // rename the minidump file according to the id returned from the server
+  NSString *minidumpDir =
+      [parameters_ objectForKey:@kReporterMinidumpDirectoryKey];
+  NSString *minidumpID = [parameters_ objectForKey:@kReporterMinidumpIDKey];
+
+  NSString *srcString = [NSString stringWithFormat:@"%@/%@.dmp",
+                                  minidumpDir, minidumpID];
+  NSString *destString = [NSString stringWithFormat:@"%@/%s.dmp",
+                                   minidumpDir, reportID];
+
+  const char *src = [srcString fileSystemRepresentation];
+  const char *dest = [destString fileSystemRepresentation];
+
+  if (rename(src, dest) == 0) {
+    fprintf(stderr,
+            "Breakpad Uploader: Renamed %s to %s after successful upload", src,
+            dest);
+  }
+  else {
+    // can't rename - don't worry - it's not important for users
+    fprintf(stderr, "Breakpad Uploader: successful upload report ID = %s\n",
+            reportID);
+  }
+  [result release];
+}
+
+//=============================================================================
+- (NSURLQueryItem *)queryItemWithName:(NSString *)queryItemName
+                          forParamKey:(NSString *)key {
+  NSString *value = [parameters_ objectForKey:key];
+  NSString *escapedValue =
+    [value stringByAddingPercentEncodingWithAllowedCharacters:
+      [NSCharacterSet URLQueryAllowedCharacterSet]];
+  return [NSURLQueryItem queryItemWithName:queryItemName value:escapedValue];
+}
+
+//=============================================================================
+- (void)setUploadCompletionBlock:(UploadCompletionBlock)uploadCompletion {
+  uploadCompletion_ = uploadCompletion;
+}
+
 //=============================================================================
 - (void)report {
   NSURL *url = [NSURL URLWithString:[parameters_ objectForKey:@BREAKPAD_URL]];
+
+  NSString *serverType = [parameters_ objectForKey:@BREAKPAD_SERVER_TYPE];
+  if ([serverType length] == 0 ||
+      [serverType isEqualToString:kGoogleServerType]) {
+    // when communicating to Google's crash collecting service, add URL params
+    // which identify the product
+    NSURLComponents *urlComponents = [NSURLComponents componentsWithURL:url
+                                                resolvingAgainstBaseURL:false];
+    NSMutableArray *queryItemsToAdd = [urlComponents.queryItems mutableCopy];
+    if (queryItemsToAdd == nil) {
+      queryItemsToAdd = [[NSMutableArray alloc] init];
+    }
+
+    NSURLQueryItem *queryItemProduct =
+      [self queryItemWithName:@"product" forParamKey:@BREAKPAD_PRODUCT];
+    NSURLQueryItem *queryItemVersion =
+      [self queryItemWithName:@"version" forParamKey:@BREAKPAD_VERSION];
+    NSURLQueryItem *queryItemGuid =
+      [self queryItemWithName:@"guid" forParamKey:@"guid"];
+
+    if (queryItemProduct != nil) [queryItemsToAdd addObject:queryItemProduct];
+    if (queryItemVersion != nil) [queryItemsToAdd addObject:queryItemVersion];
+    if (queryItemGuid != nil) [queryItemsToAdd addObject:queryItemGuid];
+
+    urlComponents.queryItems = queryItemsToAdd;
+    url = [urlComponents URL];
+  }
+
   HTTPMultipartUpload *upload = [[HTTPMultipartUpload alloc] initWithURL:url];
   NSMutableDictionary *uploadParameters = [NSMutableDictionary dictionary];
 
@@ -511,43 +608,16 @@ NSDictionary *readConfigurationData(const char *configFile) {
     // Send it
     NSError *error = nil;
     NSData *data = [upload send:&error];
-    NSString *result = [[NSString alloc] initWithData:data
-                                         encoding:NSUTF8StringEncoding];
-    const char *reportID = "ERR";
 
-    if (error) {
-      fprintf(stderr, "Breakpad Uploader: Send Error: %s\n",
-              [[error description] UTF8String]);
+    if (![url isFileURL]) {
+      [self handleNetworkResponse:data withError:error];
     } else {
-      NSCharacterSet *trimSet =
-          [NSCharacterSet whitespaceAndNewlineCharacterSet];
-      reportID = [[result stringByTrimmingCharactersInSet:trimSet] UTF8String];
-      [self logUploadWithID:reportID];
+      if (error) {
+        fprintf(stderr, "Breakpad Uploader: Error writing request file: %s\n",
+                [[error description] UTF8String]);
+      }
     }
 
-    // rename the minidump file according to the id returned from the server
-    NSString *minidumpDir =
-        [parameters_ objectForKey:@kReporterMinidumpDirectoryKey];
-    NSString *minidumpID = [parameters_ objectForKey:@kReporterMinidumpIDKey];
-
-    NSString *srcString = [NSString stringWithFormat:@"%@/%@.dmp",
-                                    minidumpDir, minidumpID];
-    NSString *destString = [NSString stringWithFormat:@"%@/%s.dmp",
-                                     minidumpDir, reportID];
-
-    const char *src = [srcString fileSystemRepresentation];
-    const char *dest = [destString fileSystemRepresentation];
-
-    if (rename(src, dest) == 0) {
-      GTMLoggerInfo(@"Breakpad Uploader: Renamed %s to %s after successful " \
-                    "upload",src, dest);
-    }
-    else {
-      // can't rename - don't worry - it's not important for users
-      GTMLoggerDebug(@"Breakpad Uploader: successful upload report ID = %s\n",
-                     reportID );
-    }
-    [result release];
   } else {
     // Minidump is missing -- upload just the log file.
     if (logFileData_) {
diff --git a/src/MEGASync/google_breakpad/client/mac/testapp/crashInMain b/src/MEGASync/google_breakpad/client/mac/testapp/crashInMain
old mode 100644
new mode 100755
diff --git a/src/MEGASync/google_breakpad/client/mac/testapp/crashduringload b/src/MEGASync/google_breakpad/client/mac/testapp/crashduringload
old mode 100644
new mode 100755
diff --git a/src/MEGASync/google_breakpad/client/mac/testapp/main.m b/src/MEGASync/google_breakpad/client/mac/testapp/main.m
index 1ed19bf9..de673326 100644
--- a/src/MEGASync/google_breakpad/client/mac/testapp/main.m
+++ b/src/MEGASync/google_breakpad/client/mac/testapp/main.m
@@ -30,5 +30,5 @@
 #import <Cocoa/Cocoa.h>
 
 int main(int argc, char *argv[]) {
-  return NSApplicationMain(argc,  (const char **) argv);
+  return NSApplicationMain(argc, (const char**)argv);
 }
diff --git a/src/MEGASync/google_breakpad/client/mac/tests/crash_generation_server_test.cc b/src/MEGASync/google_breakpad/client/mac/tests/crash_generation_server_test.cc
index 0164f4a2..128f25c1 100644
--- a/src/MEGASync/google_breakpad/client/mac/tests/crash_generation_server_test.cc
+++ b/src/MEGASync/google_breakpad/client/mac/tests/crash_generation_server_test.cc
@@ -147,8 +147,8 @@ TEST_F(CrashGenerationServerTest, testRequestDumpNoDump) {
     globfree(&dirContents);
 }
 
-void dumpCallback(void *context, const ClientInfo &client_info,
-                  const std::string &file_path) {
+void dumpCallback(void* context, const ClientInfo& client_info,
+                  const std::string& file_path) {
   if (context) {
     CrashGenerationServerTest* self =
         reinterpret_cast<CrashGenerationServerTest*>(context);
@@ -158,7 +158,7 @@ void dumpCallback(void *context, const ClientInfo &client_info,
   }
 }
 
-void *RequestDump(void *context) {
+void* RequestDump(void* context) {
   CrashGenerationClient client((const char*)context);
   bool result = client.RequestDump();
   return (void*)(result ? 0 : 1);
@@ -206,7 +206,7 @@ TEST_F(CrashGenerationServerTest, testRequestDump) {
 }
 
 static void Crasher() {
-  int *a = (int*)0x42;
+  int* a = (int*)0x42;
 
   fprintf(stdout, "Going to crash...\n");
   fprintf(stdout, "A = %d", *a);
diff --git a/src/MEGASync/google_breakpad/client/mac/tests/exception_handler_test.cc b/src/MEGASync/google_breakpad/client/mac/tests/exception_handler_test.cc
index e19944d0..50f03f81 100644
--- a/src/MEGASync/google_breakpad/client/mac/tests/exception_handler_test.cc
+++ b/src/MEGASync/google_breakpad/client/mac/tests/exception_handler_test.cc
@@ -36,6 +36,7 @@
 
 #include "breakpad_googletest_includes.h"
 #include "client/mac/handler/exception_handler.h"
+#include "common/linux/ignore_ret.h"
 #include "common/mac/MachIPC.h"
 #include "common/tests/auto_tempdir.h"
 #include "google_breakpad/processor/minidump.h"
@@ -70,7 +71,7 @@ class ExceptionHandlerTest : public Test {
 };
 
 static void Crasher() {
-  int *a = (int*)0x42;
+  int* a = (int*)0x42;
 
   fprintf(stdout, "Going to crash...\n");
   fprintf(stdout, "A = %d", *a);
@@ -85,15 +86,15 @@ static void SoonToCrash(void(*crasher)()) {
   crasher();
 }
 
-static bool MDCallback(const char *dump_dir, const char *file_name,
-                       void *context, bool success) {
+static bool MDCallback(const char* dump_dir, const char* file_name,
+                       void* context, bool success) {
   string path(dump_dir);
   path.append("/");
   path.append(file_name);
   path.append(".dmp");
 
   int fd = *reinterpret_cast<int*>(context);
-  (void)write(fd, path.c_str(), path.length() + 1);
+  IGNORE_RET(write(fd, path.c_str(), path.length() + 1));
   close(fd);
   exit(0);
   // not reached
@@ -178,9 +179,9 @@ TEST_F(ExceptionHandlerTest, InProcessAbort) {
   InProcessCrash(true);
 }
 
-static bool DumpNameMDCallback(const char *dump_dir, const char *file_name,
-                               void *context, bool success) {
-  ExceptionHandlerTest *self = reinterpret_cast<ExceptionHandlerTest*>(context);
+static bool DumpNameMDCallback(const char* dump_dir, const char* file_name,
+                               void* context, bool success) {
+  ExceptionHandlerTest* self = reinterpret_cast<ExceptionHandlerTest*>(context);
   if (dump_dir && file_name) {
     self->lastDumpName = dump_dir;
     self->lastDumpName += "/";
@@ -293,7 +294,7 @@ TEST_F(ExceptionHandlerTest, DumpChildProcess) {
 
   // Unblock child process
   uint8_t data = 1;
-  (void)write(fds[1], &data, 1);
+  IGNORE_RET(write(fds[1], &data, 1));
 
   // Child process should have exited with a zero status.
   int ret;
@@ -610,7 +611,9 @@ TEST_F(ExceptionHandlerTest, InstructionPointerMemoryNullPointer) {
     ExceptionHandler eh(tempDir.path(), NULL, MDCallback, &fds[1], true, NULL);
     // Try calling a NULL pointer.
     typedef void (*void_function)(void);
-    void_function memory_function =
+    // Volatile markings are needed to keep Clang from generating invalid
+    // opcodes.  See http://crbug.com/498354 for details.
+    volatile void_function memory_function =
       reinterpret_cast<void_function>(NULL);
     memory_function();
     // not reached
@@ -649,7 +652,7 @@ TEST_F(ExceptionHandlerTest, InstructionPointerMemoryNullPointer) {
   ASSERT_EQ((unsigned int)1, memory_list->region_count());
 }
 
-static void *Junk(void *) {
+static void* Junk(void*) {
   sleep(1000000);
   return NULL;
 }
diff --git a/src/MEGASync/google_breakpad/client/mac/tests/minidump_generator_test.cc b/src/MEGASync/google_breakpad/client/mac/tests/minidump_generator_test.cc
index d40c7d98..1f374657 100644
--- a/src/MEGASync/google_breakpad/client/mac/tests/minidump_generator_test.cc
+++ b/src/MEGASync/google_breakpad/client/mac/tests/minidump_generator_test.cc
@@ -42,6 +42,7 @@
 #include "breakpad_googletest_includes.h"
 #include "client/mac/handler/minidump_generator.h"
 #include "client/mac/tests/spawn_child_process.h"
+#include "common/linux/ignore_ret.h"
 #include "common/mac/MachIPC.h"
 #include "common/tests/auto_tempdir.h"
 #include "google_breakpad/processor/minidump.h"
@@ -78,7 +79,7 @@ class MinidumpGeneratorTest : public Test {
   AutoTempDir tempDir;
 };
 
-static void *Junk(void* data) {
+static void* Junk(void* data) {
   bool* wait = reinterpret_cast<bool*>(data);
   while (!*wait) {
     usleep(10000);
@@ -190,7 +191,7 @@ TEST_F(MinidumpGeneratorTest, OutOfProcess) {
 
   // Unblock child process
   uint8_t data = 1;
-  (void)write(fds[1], &data, 1);
+  IGNORE_RET(write(fds[1], &data, 1));
 
   // Child process should have exited with a zero status.
   int ret;
diff --git a/src/MEGASync/google_breakpad/client/minidump_file_writer-inl.h b/src/MEGASync/google_breakpad/client/minidump_file_writer-inl.h
index 0e12e00b..bdac2dae 100644
--- a/src/MEGASync/google_breakpad/client/minidump_file_writer-inl.h
+++ b/src/MEGASync/google_breakpad/client/minidump_file_writer-inl.h
@@ -69,7 +69,7 @@ inline bool TypedMDRVA<MDType>::AllocateObjectAndArray(size_t count,
 }
 
 template<typename MDType>
-inline bool TypedMDRVA<MDType>::CopyIndex(unsigned int index, MDType *item) {
+inline bool TypedMDRVA<MDType>::CopyIndex(unsigned int index, MDType* item) {
   assert(allocation_state_ == ARRAY);
   return writer_->Copy(
       static_cast<MDRVA>(position_ + index * minidump_size<MDType>::size()), 
@@ -78,7 +78,7 @@ inline bool TypedMDRVA<MDType>::CopyIndex(unsigned int index, MDType *item) {
 
 template<typename MDType>
 inline bool TypedMDRVA<MDType>::CopyIndexAfterObject(unsigned int index,
-                                                     const void *src, 
+                                                     const void* src,
                                                      size_t length) {
   assert(allocation_state_ == SINGLE_OBJECT_WITH_ARRAY);
   return writer_->Copy(
diff --git a/src/MEGASync/google_breakpad/client/minidump_file_writer.cc b/src/MEGASync/google_breakpad/client/minidump_file_writer.cc
index 1e18d24b..5c3c5cbb 100644
--- a/src/MEGASync/google_breakpad/client/minidump_file_writer.cc
+++ b/src/MEGASync/google_breakpad/client/minidump_file_writer.cc
@@ -40,10 +40,51 @@
 #include "client/minidump_file_writer-inl.h"
 #include "common/linux/linux_libc_support.h"
 #include "common/string_conversion.h"
-#if __linux__
+#if defined(__linux__) && __linux__
 #include "third_party/lss/linux_syscall_support.h"
 #endif
 
+#if defined(__ANDROID__)
+#include <errno.h>
+
+namespace {
+
+bool g_need_ftruncate_workaround = false;
+bool g_checked_need_ftruncate_workaround = false;
+
+void CheckNeedsFTruncateWorkAround(int file) {
+  if (g_checked_need_ftruncate_workaround) {
+    return;
+  }
+  g_checked_need_ftruncate_workaround = true;
+
+  // Attempt an idempotent truncate that chops off nothing and see if we
+  // run into any sort of errors.
+  off_t offset = sys_lseek(file, 0, SEEK_END);
+  if (offset == -1) {
+    // lseek failed. Don't apply work around. It's unlikely that we can write
+    // to a minidump with either method.
+    return;
+  }
+
+  int result = ftruncate(file, offset);
+  if (result == -1 && errno == EACCES) {
+    // It very likely that we are running into the kernel bug in M devices.
+    // We are going to deploy the workaround for writing minidump files
+    // without uses of ftruncate(). This workaround should be fine even
+    // for kernels without the bug.
+    // See http://crbug.com/542840 for more details.
+    g_need_ftruncate_workaround = true;
+  }
+}
+
+bool NeedsFTruncateWorkAround() {
+  return g_need_ftruncate_workaround;
+}
+
+}  // namespace
+#endif  // defined(__ANDROID__)
+
 namespace google_breakpad {
 
 const MDRVA MinidumpFileWriter::kInvalidMDRVA = static_cast<MDRVA>(-1);
@@ -60,9 +101,9 @@ MinidumpFileWriter::~MinidumpFileWriter() {
     Close();
 }
 
-bool MinidumpFileWriter::Open(const char *path) {
+bool MinidumpFileWriter::Open(const char* path) {
   assert(file_ == -1);
-#if __linux__
+#if defined(__linux__) && __linux__
   file_ = sys_open(path, O_WRONLY | O_CREAT | O_EXCL, 0600);
 #else
   file_ = open(path, O_WRONLY | O_CREAT | O_EXCL, 0600);
@@ -75,16 +116,25 @@ void MinidumpFileWriter::SetFile(const int file) {
   assert(file_ == -1);
   file_ = file;
   close_file_when_destroyed_ = false;
+#if defined(__ANDROID__)
+  CheckNeedsFTruncateWorkAround(file);
+#endif
 }
 
 bool MinidumpFileWriter::Close() {
   bool result = true;
 
   if (file_ != -1) {
-    if (-1 == ftruncate(file_, position_)) {
+#if defined(__ANDROID__)
+    if (!NeedsFTruncateWorkAround() && ftruncate(file_, position_)) {
        return false;
     }
-#if __linux__
+#else
+    if (ftruncate(file_, position_)) {
+       return false;
+    }
+#endif
+#if defined(__linux__) && __linux__
     result = (sys_close(file_) == 0);
 #else
     result = (close(file_) == 0);
@@ -95,9 +145,9 @@ bool MinidumpFileWriter::Close() {
   return result;
 }
 
-bool MinidumpFileWriter::CopyStringToMDString(const wchar_t *str,
+bool MinidumpFileWriter::CopyStringToMDString(const wchar_t* str,
                                               unsigned int length,
-                                              TypedMDRVA<MDString> *mdstring) {
+                                              TypedMDRVA<MDString>* mdstring) {
   bool result = true;
   if (sizeof(wchar_t) == sizeof(uint16_t)) {
     // Shortcut if wchar_t is the same size as MDString's buffer
@@ -128,9 +178,9 @@ bool MinidumpFileWriter::CopyStringToMDString(const wchar_t *str,
   return result;
 }
 
-bool MinidumpFileWriter::CopyStringToMDString(const char *str,
+bool MinidumpFileWriter::CopyStringToMDString(const char* str,
                                               unsigned int length,
-                                              TypedMDRVA<MDString> *mdstring) {
+                                              TypedMDRVA<MDString>* mdstring) {
   bool result = true;
   uint16_t out[2];
   int out_idx = 0;
@@ -155,9 +205,9 @@ bool MinidumpFileWriter::CopyStringToMDString(const char *str,
 }
 
 template <typename CharType>
-bool MinidumpFileWriter::WriteStringCore(const CharType *str,
+bool MinidumpFileWriter::WriteStringCore(const CharType* str,
                                          unsigned int length,
-                                         MDLocationDescriptor *location) {
+                                         MDLocationDescriptor* location) {
   assert(str);
   assert(location);
   // Calculate the mdstring length by either limiting to |length| as passed in
@@ -190,18 +240,18 @@ bool MinidumpFileWriter::WriteStringCore(const CharType *str,
   return result;
 }
 
-bool MinidumpFileWriter::WriteString(const wchar_t *str, unsigned int length,
-                 MDLocationDescriptor *location) {
+bool MinidumpFileWriter::WriteString(const wchar_t* str, unsigned int length,
+                                     MDLocationDescriptor* location) {
   return WriteStringCore(str, length, location);
 }
 
-bool MinidumpFileWriter::WriteString(const char *str, unsigned int length,
-                 MDLocationDescriptor *location) {
+bool MinidumpFileWriter::WriteString(const char* str, unsigned int length,
+                                     MDLocationDescriptor* location) {
   return WriteStringCore(str, length, location);
 }
 
-bool MinidumpFileWriter::WriteMemory(const void *src, size_t size,
-                                     MDMemoryDescriptor *output) {
+bool MinidumpFileWriter::WriteMemory(const void* src, size_t size,
+                                     MDMemoryDescriptor* output) {
   assert(src);
   assert(output);
   UntypedMDRVA mem(this);
@@ -220,6 +270,20 @@ bool MinidumpFileWriter::WriteMemory(const void *src, size_t size,
 MDRVA MinidumpFileWriter::Allocate(size_t size) {
   assert(size);
   assert(file_ != -1);
+#if defined(__ANDROID__)
+  if (NeedsFTruncateWorkAround()) {
+    // If ftruncate() is not available. We simply increase the size beyond the
+    // current file size. sys_write() will expand the file when data is written
+    // to it. Because we did not over allocate to fit memory pages, we also
+    // do not need to ftruncate() the file once we are done.
+    size_ += size;
+
+    // We don't need to seek since the file is unchanged.
+    MDRVA current_position = position_;
+    position_ += static_cast<MDRVA>(size);
+    return current_position;
+  }
+#endif
   size_t aligned_size = (size + 7) & ~7;  // 64-bit alignment
 
   if (position_ + aligned_size > size_) {
@@ -243,7 +307,7 @@ MDRVA MinidumpFileWriter::Allocate(size_t size) {
   return current_position;
 }
 
-bool MinidumpFileWriter::Copy(MDRVA position, const void *src, ssize_t size) {
+bool MinidumpFileWriter::Copy(MDRVA position, const void* src, ssize_t size) {
   assert(src);
   assert(size);
   assert(file_ != -1);
@@ -253,17 +317,19 @@ bool MinidumpFileWriter::Copy(MDRVA position, const void *src, ssize_t size) {
     return false;
 
   // Seek and write the data
-#if __linux__
+#if defined(__linux__) && __linux__
   if (sys_lseek(file_, position, SEEK_SET) == static_cast<off_t>(position)) {
     if (sys_write(file_, src, size) == size) {
+      return true;
+    }
+  }
 #else
   if (lseek(file_, position, SEEK_SET) == static_cast<off_t>(position)) {
     if (write(file_, src, size) == size) {
-#endif
       return true;
     }
   }
-
+#endif
   return false;
 }
 
@@ -274,7 +340,7 @@ bool UntypedMDRVA::Allocate(size_t size) {
   return position_ != MinidumpFileWriter::kInvalidMDRVA;
 }
 
-bool UntypedMDRVA::Copy(MDRVA pos, const void *src, size_t size) {
+bool UntypedMDRVA::Copy(MDRVA pos, const void* src, size_t size) {
   assert(src);
   assert(size);
   assert(pos + size <= position_ + size_);
diff --git a/src/MEGASync/google_breakpad/client/minidump_file_writer.h b/src/MEGASync/google_breakpad/client/minidump_file_writer.h
index 538e8545..c66dc591 100644
--- a/src/MEGASync/google_breakpad/client/minidump_file_writer.h
+++ b/src/MEGASync/google_breakpad/client/minidump_file_writer.h
@@ -74,10 +74,10 @@ public:
   MinidumpFileWriter();
   ~MinidumpFileWriter();
 
-  // Open |path| as the destination of the minidump data.  Any existing file
-  // will be overwritten.
+  // Open |path| as the destination of the minidump data. If |path| already
+  // exists, then Open() will fail.
   // Return true on success, or false on failure.
-  bool Open(const char *path);
+  bool Open(const char* path);
 
   // Sets the file descriptor |file| as the destination of the minidump data.
   // Can be used as an alternative to Open() when a file descriptor is
@@ -98,20 +98,20 @@ public:
   // entire NULL terminated string.  Copying will stop at the first NULL.
   // |location| the allocated location
   // Return true on success, or false on failure
-  bool WriteString(const wchar_t *str, unsigned int length,
-                   MDLocationDescriptor *location);
+  bool WriteString(const wchar_t* str, unsigned int length,
+                   MDLocationDescriptor* location);
 
   // Same as above, except with |str| as a UTF-8 string
-  bool WriteString(const char *str, unsigned int length,
-                   MDLocationDescriptor *location);
+  bool WriteString(const char* str, unsigned int length,
+                   MDLocationDescriptor* location);
 
   // Write |size| bytes starting at |src| into the current position.
   // Return true on success and set |output| to position, or false on failure
-  bool WriteMemory(const void *src, size_t size, MDMemoryDescriptor *output);
+  bool WriteMemory(const void* src, size_t size, MDMemoryDescriptor* output);
 
   // Copies |size| bytes from |src| to |position|
   // Return true on success, or false on failure
-  bool Copy(MDRVA position, const void *src, ssize_t size);
+  bool Copy(MDRVA position, const void* src, ssize_t size);
 
   // Return the current position for writing to the minidump
   inline MDRVA position() const { return position_; }
@@ -141,21 +141,21 @@ public:
   // variant may need to create a MDString that has more characters than the
   // source |str|, whereas the UTF-8 variant may coalesce characters to form
   // a single UTF-16 character.
-  bool CopyStringToMDString(const wchar_t *str, unsigned int length,
-                            TypedMDRVA<MDString> *mdstring);
-  bool CopyStringToMDString(const char *str, unsigned int length,
-                            TypedMDRVA<MDString> *mdstring);
+  bool CopyStringToMDString(const wchar_t* str, unsigned int length,
+                            TypedMDRVA<MDString>* mdstring);
+  bool CopyStringToMDString(const char* str, unsigned int length,
+                            TypedMDRVA<MDString>* mdstring);
 
   // The common templated code for writing a string
   template <typename CharType>
-  bool WriteStringCore(const CharType *str, unsigned int length,
-                       MDLocationDescriptor *location);
+  bool WriteStringCore(const CharType* str, unsigned int length,
+                       MDLocationDescriptor* location);
 };
 
 // Represents an untyped allocated chunk
 class UntypedMDRVA {
  public:
-  explicit UntypedMDRVA(MinidumpFileWriter *writer)
+  explicit UntypedMDRVA(MinidumpFileWriter* writer)
       : writer_(writer),
         position_(writer->position()),
         size_(0) {}
@@ -179,16 +179,16 @@ class UntypedMDRVA {
 
   // Copy |size| bytes starting at |src| into the minidump at |position|
   // Return true on success, or false on failure
-  bool Copy(MDRVA position, const void *src, size_t size);
+  bool Copy(MDRVA position, const void* src, size_t size);
 
   // Copy |size| bytes from |src| to the current position
-  inline bool Copy(const void *src, size_t size) {
+  inline bool Copy(const void* src, size_t size) {
     return Copy(position_, src, size);
   }
 
  protected:
   // Writer we associate with
-  MinidumpFileWriter *writer_;
+  MinidumpFileWriter* writer_;
 
   // Position of the start of the data
   MDRVA position_;
@@ -206,7 +206,7 @@ template<typename MDType>
 class TypedMDRVA : public UntypedMDRVA {
  public:
   // Constructs an unallocated MDRVA
-  explicit TypedMDRVA(MinidumpFileWriter *writer)
+  explicit TypedMDRVA(MinidumpFileWriter* writer)
       : UntypedMDRVA(writer),
         data_(),
         allocation_state_(UNALLOCATED) {}
@@ -220,7 +220,7 @@ class TypedMDRVA : public UntypedMDRVA {
   // Address of object data_ of MDType.  This is not declared const as the
   // typical usage will be to access the underlying |data_| object as to
   // alter its contents.
-  MDType *get() { return &data_; }
+  MDType* get() { return &data_; }
 
   // Allocates minidump_size<MDType>::size() bytes.
   // Must not call more than once.
@@ -245,12 +245,12 @@ class TypedMDRVA : public UntypedMDRVA {
   // Copy |item| to |index|
   // Must have been allocated using AllocateArray().
   // Return true on success, or false on failure
-  bool CopyIndex(unsigned int index, MDType *item);
+  bool CopyIndex(unsigned int index, MDType* item);
 
   // Copy |size| bytes starting at |str| to |index|
   // Must have been allocated using AllocateObjectAndArray().
   // Return true on success, or false on failure
-  bool CopyIndexAfterObject(unsigned int index, const void *src, size_t size);
+  bool CopyIndexAfterObject(unsigned int index, const void* src, size_t size);
 
   // Write data_
   bool Flush();
diff --git a/src/MEGASync/google_breakpad/client/minidump_file_writer_unittest.cc b/src/MEGASync/google_breakpad/client/minidump_file_writer_unittest.cc
index 60c364e6..16c407d2 100644
--- a/src/MEGASync/google_breakpad/client/minidump_file_writer_unittest.cc
+++ b/src/MEGASync/google_breakpad/client/minidump_file_writer_unittest.cc
@@ -30,7 +30,7 @@
 // Author: waylonis@google.com (Dan Waylonis)
 
 /*
- g++ -I../ ../common/convert_UTF.c \
+ g++ -I../ ../common/convert_UTF.cc \
  ../common/string_conversion.cc \
  minidump_file_writer.cc \
  minidump_file_writer_unittest.cc \
@@ -70,16 +70,16 @@ typedef struct {
   ArrayStructure array[0];
 } ObjectAndArrayStructure;
 
-static bool WriteFile(const char *path) {
+static bool WriteFile(const char* path) {
   MinidumpFileWriter writer;
   if (writer.Open(path)) {
     // Test a single structure
     google_breakpad::TypedMDRVA<StringStructure> strings(&writer);
     ASSERT_TRUE(strings.Allocate());
     strings.get()->integer_value = 0xBEEF;
-    const char *first = "First String";
+    const char* first = "First String";
     ASSERT_TRUE(writer.WriteString(first, 0, &strings.get()->first_string));
-    const wchar_t *second = L"Second String";
+    const wchar_t* second = L"Second String";
     ASSERT_TRUE(writer.WriteString(second, 0, &strings.get()->second_string));
 
     // Test an array structure
@@ -111,7 +111,7 @@ static bool WriteFile(const char *path) {
   return writer.Close();
 }
 
-static bool CompareFile(const char *path) {
+static bool CompareFile(const char* path) {
   unsigned long expected[] = {
 #if defined(__BIG_ENDIAN__)
     0x0000beef, 0x0000001e, 0x00000018, 0x00000020, 0x00000038, 0x00000000, 
@@ -146,13 +146,14 @@ static bool CompareFile(const char *path) {
   };
   size_t expected_byte_count = sizeof(expected);
   int fd = open(path, O_RDONLY, 0600);
-  void *buffer = malloc(expected_byte_count);
+  void* buffer = malloc(expected_byte_count);
   ASSERT_NE(fd, -1);
   ASSERT_TRUE(buffer);
   ASSERT_EQ(read(fd, buffer, expected_byte_count), 
             static_cast<ssize_t>(expected_byte_count));
 
-  char *b1, *b2;
+  char* b1;
+  char* b2;
   b1 = reinterpret_cast<char*>(buffer);
   b2 = reinterpret_cast<char*>(expected);
   while (*b1 == *b2) {
@@ -167,13 +168,13 @@ static bool CompareFile(const char *path) {
 }
 
 static bool RunTests() {
-  const char *path = "/tmp/minidump_file_writer_unittest.dmp";
+  const char* path = "/tmp/minidump_file_writer_unittest.dmp";
   ASSERT_TRUE(WriteFile(path));
   ASSERT_TRUE(CompareFile(path));
   unlink(path);
   return true;
 }
 
-extern "C" int main(int argc, const char *argv[]) {
+extern "C" int main(int argc, const char* argv[]) {
   return RunTests() ? 0 : 1;
 }
diff --git a/src/MEGASync/google_breakpad/client/solaris/handler/Makefile b/src/MEGASync/google_breakpad/client/solaris/handler/Makefile
index beeb9448..6da9464e 100644
--- a/src/MEGASync/google_breakpad/client/solaris/handler/Makefile
+++ b/src/MEGASync/google_breakpad/client/solaris/handler/Makefile
@@ -40,13 +40,13 @@ BIN_DIR=.
 
 THREAD_SRC=solaris_lwp.cc
 SHARE_SRC=../../minidump_file_writer.cc\
+	  ../../../common/convert_UTF.cc\
 	  ../../../common/md5.cc\
 	  ../../../common/string_conversion.cc\
 	  ../../../common/solaris/file_id.cc\
 	  minidump_generator.cc
 HANDLER_SRC=exception_handler.cc\
 	  ../../../common/solaris/guid_creator.cc
-SHARE_C_SRC=../../../common/convert_UTF.c
 
 MINIDUMP_TEST_SRC=minidump_test.cc
 EXCEPTION_TEST_SRC=exception_handler_test.cc
@@ -54,11 +54,10 @@ EXCEPTION_TEST_SRC=exception_handler_test.cc
 THREAD_OBJ=$(patsubst %.cc,$(OBJ_DIR)/%.o,$(THREAD_SRC))
 SHARE_OBJ=$(patsubst %.cc,$(OBJ_DIR)/%.o,$(SHARE_SRC))
 HANDLER_OBJ=$(patsubst %.cc,$(OBJ_DIR)/%.o,$(HANDLER_SRC))
-SHARE_C_OBJ=$(patsubst %.c,$(OBJ_DIR)/%.o,$(SHARE_C_SRC))
 MINIDUMP_TEST_OBJ=$(patsubst %.cc,$(OBJ_DIR)/%.o, $(MINIDUMP_TEST_SRC))\
-		  $(THREAD_OBJ) $(SHARE_OBJ) $(SHARE_C_OBJ) $(HANDLER_OBJ)
+		  $(THREAD_OBJ) $(SHARE_OBJ) $(HANDLER_OBJ)
 EXCEPTION_TEST_OBJ=$(patsubst %.cc,$(OBJ_DIR)/%.o, $(EXCEPTION_TEST_SRC))\
-          $(THREAD_OBJ) $(SHARE_OBJ) $(SHARE_C_OBJ) $(HANDLER_OBJ)
+          $(THREAD_OBJ) $(SHARE_OBJ) $(HANDLER_OBJ)
 
 BIN=$(BIN_DIR)/minidump_test\
     $(BIN_DIR)/exception_handler_test
diff --git a/src/MEGASync/google_breakpad/client/solaris/handler/exception_handler.cc b/src/MEGASync/google_breakpad/client/solaris/handler/exception_handler.cc
index 7fc8d255..c96683f6 100644
--- a/src/MEGASync/google_breakpad/client/solaris/handler/exception_handler.cc
+++ b/src/MEGASync/google_breakpad/client/solaris/handler/exception_handler.cc
@@ -54,15 +54,15 @@ static const int kSigTable[] = {
   SIGBUS
 };
 
-std::vector<ExceptionHandler*> *ExceptionHandler::handler_stack_ = NULL;
+std::vector<ExceptionHandler*>* ExceptionHandler::handler_stack_ = NULL;
 int ExceptionHandler::handler_stack_index_ = 0;
 pthread_mutex_t ExceptionHandler::handler_stack_mutex_ =
   PTHREAD_MUTEX_INITIALIZER;
 
-ExceptionHandler::ExceptionHandler(const string &dump_path,
+ExceptionHandler::ExceptionHandler(const string& dump_path,
                                    FilterCallback filter,
                                    MinidumpCallback callback,
-                                   void *callback_context,
+                                   void* callback_context,
                                    bool install_handler)
     : filter_(filter),
       callback_(callback),
@@ -79,7 +79,7 @@ ExceptionHandler::ExceptionHandler(const string &dump_path,
     pthread_mutex_lock(&handler_stack_mutex_);
 
     if (handler_stack_ == NULL)
-      handler_stack_ = new std::vector<ExceptionHandler *>;
+      handler_stack_ = new std::vector<ExceptionHandler*>;
     handler_stack_->push_back(this);
     pthread_mutex_unlock(&handler_stack_mutex_);
   }
@@ -92,7 +92,7 @@ ExceptionHandler::~ExceptionHandler() {
     handler_stack_->pop_back();
   } else {
     print_message1(2, "warning: removing Breakpad handler out of order\n");
-    for (std::vector<ExceptionHandler *>::iterator iterator =
+    for (std::vector<ExceptionHandler*>::iterator iterator =
          handler_stack_->begin();
          iterator != handler_stack_->end();
          ++iterator) {
@@ -116,9 +116,9 @@ bool ExceptionHandler::WriteMinidump() {
 }
 
 // static
-bool ExceptionHandler::WriteMinidump(const string &dump_path,
+bool ExceptionHandler::WriteMinidump(const string& dump_path,
                                      MinidumpCallback callback,
-                                     void *callback_context) {
+                                     void* callback_context) {
   ExceptionHandler handler(dump_path, NULL, callback,
                            callback_context, false);
   return handler.InternalWriteMinidump(0, 0, NULL);
@@ -166,7 +166,7 @@ void ExceptionHandler::TeardownAllHandlers() {
 
 // static
 void ExceptionHandler::HandleException(int signo) {
-//void ExceptionHandler::HandleException(int signo, siginfo_t *sip, ucontext_t *sig_ctx) {
+//void ExceptionHandler::HandleException(int signo, siginfo_t* sip, ucontext_t* sig_ctx) {
   // The context information about the signal is put on the stack of
   // the signal handler frame as value parameter. For some reasons, the
   // prototype of the handler doesn't declare this information as parameter, we
@@ -181,14 +181,14 @@ void ExceptionHandler::HandleException(int signo) {
   uintptr_t current_ebp = (uintptr_t)_getfp();
 
   pthread_mutex_lock(&handler_stack_mutex_);
-  ExceptionHandler *current_handler =
+  ExceptionHandler* current_handler =
     handler_stack_->at(handler_stack_->size() - ++handler_stack_index_);
   pthread_mutex_unlock(&handler_stack_mutex_);
 
   // Restore original handler.
   current_handler->TeardownHandler(signo);
 
-  ucontext_t *sig_ctx = NULL;
+  ucontext_t* sig_ctx = NULL;
   if (current_handler->InternalWriteMinidump(signo, current_ebp, &sig_ctx)) {
 //  if (current_handler->InternalWriteMinidump(signo, &sig_ctx)) {
     // Fully handled this exception, safe to exit.
@@ -218,7 +218,7 @@ void ExceptionHandler::HandleException(int signo) {
 
 bool ExceptionHandler::InternalWriteMinidump(int signo,
                                              uintptr_t sighandler_ebp,
-                                             ucontext_t **sig_ctx) {
+                                             ucontext_t** sig_ctx) {
   if (filter_ && !filter_(callback_context_))
     return false;
 
diff --git a/src/MEGASync/google_breakpad/client/solaris/handler/exception_handler.h b/src/MEGASync/google_breakpad/client/solaris/handler/exception_handler.h
index 4d72485f..cd6c85ea 100644
--- a/src/MEGASync/google_breakpad/client/solaris/handler/exception_handler.h
+++ b/src/MEGASync/google_breakpad/client/solaris/handler/exception_handler.h
@@ -79,7 +79,7 @@ class ExceptionHandler {
   // attempting to write a minidump.  If a FilterCallback returns false,
   // Breakpad  will immediately report the exception as unhandled without
   // writing a minidump, allowing another handler the opportunity to handle it.
-  typedef bool (*FilterCallback)(void *context);
+  typedef bool (*FilterCallback)(void* context);
 
   // A callback function to run after the minidump has been written.
   // minidump_id is a unique id for the dump, so the minidump
@@ -97,9 +97,9 @@ class ExceptionHandler {
   // should normally return the value of |succeeded|, or when they wish to
   // not report an exception of handled, false.  Callbacks will rarely want to
   // return true directly (unless |succeeded| is true).
-  typedef bool (*MinidumpCallback)(const char *dump_path,
-                                   const char *minidump_id,
-                                   void *context,
+  typedef bool (*MinidumpCallback)(const char* dump_path,
+                                   const char* minidump_id,
+                                   void* context,
                                    bool succeeded);
 
   // Creates a new ExceptionHandler instance to handle writing minidumps.
@@ -110,15 +110,15 @@ class ExceptionHandler {
   // If install_handler is true, then a minidump will be written whenever
   // an unhandled exception occurs.  If it is false, minidumps will only
   // be written when WriteMinidump is called.
-  ExceptionHandler(const string &dump_path,
+  ExceptionHandler(const string& dump_path,
                    FilterCallback filter, MinidumpCallback callback,
-                   void *callback_context,
+                   void* callback_context,
                    bool install_handler);
   ~ExceptionHandler();
 
   // Get and Set the minidump path.
   string dump_path() const { return dump_path_; }
-  void set_dump_path(const string &dump_path) {
+  void set_dump_path(const string& dump_path) {
     dump_path_ = dump_path;
     dump_path_c_ = dump_path_.c_str();
   }
@@ -129,9 +129,9 @@ class ExceptionHandler {
 
   // Convenience form of WriteMinidump which does not require an
   // ExceptionHandler instance.
-  static bool WriteMinidump(const string &dump_path,
+  static bool WriteMinidump(const string& dump_path,
                             MinidumpCallback callback,
-                            void *callback_context);
+                            void* callback_context);
 
  private:
   // Setup crash handler.
@@ -144,7 +144,7 @@ class ExceptionHandler {
   void TeardownAllHandlers();
 
   // Runs the main loop for the exception handler thread.
-  static void* ExceptionHandlerThreadMain(void *lpParameter);
+  static void* ExceptionHandlerThreadMain(void* lpParameter);
 
   // Signal handler.
   static void HandleException(int signo);
@@ -157,20 +157,20 @@ class ExceptionHandler {
   // for the second and third parameters if you are not calling
   // this from a signal handler.
   bool InternalWriteMinidump(int signo, uintptr_t sighandler_ebp,
-                             ucontext_t **sig_ctx);
+                             ucontext_t** sig_ctx);
 
  private:
   // The callbacks before and after writing the dump file.
   FilterCallback filter_;
   MinidumpCallback callback_;
-  void *callback_context_;
+  void* callback_context_;
 
   // The directory in which a minidump will be written, set by the dump_path
   // argument to the constructor, or set_dump_path.
   string dump_path_;
   // C style dump path. Keep this when setting dump path, since calling
   // c_str() of std::string when crashing may not be safe.
-  const char *dump_path_c_;
+  const char* dump_path_c_;
 
   // True if the ExceptionHandler installed an unhandled exception filter
   // when created (with an install_handler parameter set to true).
@@ -183,7 +183,7 @@ class ExceptionHandler {
   // The global exception handler stack. This is need becuase there may exist
   // multiple ExceptionHandler instances in a process. Each will have itself
   // registered in this stack.
-  static std::vector<ExceptionHandler *> *handler_stack_;
+  static std::vector<ExceptionHandler*>* handler_stack_;
   // The index of the handler that should handle the next exception.
   static int handler_stack_index_;
   static pthread_mutex_t handler_stack_mutex_;
@@ -192,8 +192,8 @@ class ExceptionHandler {
   MinidumpGenerator minidump_generator_;
 
   // disallow copy ctor and operator=
-  explicit ExceptionHandler(const ExceptionHandler &);
-  void operator=(const ExceptionHandler &);
+  explicit ExceptionHandler(const ExceptionHandler&);
+  void operator=(const ExceptionHandler&);
 };
 
 }  // namespace google_breakpad
diff --git a/src/MEGASync/google_breakpad/client/solaris/handler/exception_handler_test.cc b/src/MEGASync/google_breakpad/client/solaris/handler/exception_handler_test.cc
index 6bb8e18d..4d2b33fa 100644
--- a/src/MEGASync/google_breakpad/client/solaris/handler/exception_handler_test.cc
+++ b/src/MEGASync/google_breakpad/client/solaris/handler/exception_handler_test.cc
@@ -49,7 +49,7 @@ static int foo2(int arg) {
   // Stack variable, used for debugging stack dumps.
   int c = 0xcccccccc;
   fprintf(stderr, "Thread trying to crash: %x\n", getpid());
-  c = *reinterpret_cast<int *>(0x5);
+  c = *reinterpret_cast<int*>(0x5);
   return c;
 }
 
@@ -60,7 +60,7 @@ static int foo(int arg) {
   return b;
 }
 
-static void *thread_crash(void *) {
+static void* thread_crash(void*) {
   // Stack variable, used for debugging stack dumps.
   int a = 0xaaaaaaaa;
   sleep(3);
@@ -69,7 +69,7 @@ static void *thread_crash(void *) {
   return NULL;
 }
 
-static void *thread_main(void *) {
+static void* thread_main(void*) {
   while (!should_exit)
     sleep(1);
   return NULL;
@@ -91,9 +91,9 @@ static void CreateThread(int num) {
 }
 
 // Callback when minidump written.
-static bool MinidumpCallback(const char *dump_path,
-                             const char *minidump_id,
-                             void *context,
+static bool MinidumpCallback(const char* dump_path,
+                             const char* minidump_id,
+                             void* context,
                              bool succeeded) {
   int index = reinterpret_cast<int>(context);
   if (index == 0) {
@@ -104,7 +104,7 @@ static bool MinidumpCallback(const char *dump_path,
   return false;
 }
 
-int main(int argc, char *argv[]) {
+int main(int argc, char* argv[]) {
   int handler_index = 1;
   ExceptionHandler handler_ignore(".", NULL, MinidumpCallback,
                                   (void*)handler_index, true);
diff --git a/src/MEGASync/google_breakpad/client/solaris/handler/minidump_generator.cc b/src/MEGASync/google_breakpad/client/solaris/handler/minidump_generator.cc
index 7485025f..56756665 100644
--- a/src/MEGASync/google_breakpad/client/solaris/handler/minidump_generator.cc
+++ b/src/MEGASync/google_breakpad/client/solaris/handler/minidump_generator.cc
@@ -50,7 +50,7 @@ using namespace google_breakpad;
 
 // Argument for the writer function.
 struct WriterArgument {
-  MinidumpFileWriter *minidump_writer;
+  MinidumpFileWriter* minidump_writer;
 
   // Pid of the lwp who called WriteMinidumpToFile
   int requester_pid;
@@ -73,15 +73,15 @@ struct WriterArgument {
   // User context when crash happens. Can be NULL if this is a requested dump.
   // This is actually an out parameter, but it will be filled in at the start
   // of the writer LWP.
-  ucontext_t *sig_ctx;
+  ucontext_t* sig_ctx;
 
   // Used to get information about the lwps.
-  SolarisLwp *lwp_lister;
+  SolarisLwp* lwp_lister;
 };
 
 // Holding context information for the callback of finding the crashing lwp.
 struct FindCrashLwpContext {
-  const SolarisLwp *lwp_lister;
+  const SolarisLwp* lwp_lister;
   uintptr_t crashing_stack_bottom;
   int crashing_lwpid;
 
@@ -96,11 +96,11 @@ struct FindCrashLwpContext {
 // It will compare the stack bottom of the provided lwp with the stack
 // bottom of the crashed lwp, it they are eqaul, this lwp is the one
 // who crashed.
-bool IsLwpCrashedCallback(lwpstatus_t *lsp, void *context) {
-  FindCrashLwpContext *crashing_context =
-    static_cast<FindCrashLwpContext *>(context);
-  const SolarisLwp *lwp_lister = crashing_context->lwp_lister;
-  const prgregset_t *gregs = &(lsp->pr_reg);
+bool IsLwpCrashedCallback(lwpstatus_t* lsp, void* context) {
+  FindCrashLwpContext* crashing_context =
+    static_cast<FindCrashLwpContext*>(context);
+  const SolarisLwp* lwp_lister = crashing_context->lwp_lister;
+  const prgregset_t* gregs = &(lsp->pr_reg);
 #if TARGET_CPU_SPARC
   uintptr_t last_ebp = (*gregs)[R_FP];
 #elif TARGET_CPU_X86
@@ -121,7 +121,7 @@ bool IsLwpCrashedCallback(lwpstatus_t *lsp, void *context) {
 // This is done based on stack bottom comparing.
 int FindCrashingLwp(uintptr_t crashing_stack_bottom,
                     int requester_pid,
-                    const SolarisLwp *lwp_lister) {
+                    const SolarisLwp* lwp_lister) {
   FindCrashLwpContext context;
   context.lwp_lister = lwp_lister;
   context.crashing_stack_bottom = crashing_stack_bottom;
@@ -131,17 +131,17 @@ int FindCrashingLwp(uintptr_t crashing_stack_bottom,
   return context.crashing_lwpid;
 }
 
-bool WriteLwpStack(const SolarisLwp *lwp_lister,
+bool WriteLwpStack(const SolarisLwp* lwp_lister,
                    uintptr_t last_esp,
-                   UntypedMDRVA *memory,
-                   MDMemoryDescriptor *loc) {
+                   UntypedMDRVA* memory,
+                   MDMemoryDescriptor* loc) {
   uintptr_t stack_bottom = lwp_lister->GetLwpStackBottom(last_esp);
   if (stack_bottom >= last_esp) {
     int size = stack_bottom - last_esp;
     if (size > 0) {
       if (!memory->Allocate(size))
         return false;
-      memory->Copy(reinterpret_cast<void *>(last_esp), size);
+      memory->Copy(reinterpret_cast<void*>(last_esp), size);
       loc->start_of_memory_range = last_esp;
       loc->memory = memory->location();
     }
@@ -151,7 +151,7 @@ bool WriteLwpStack(const SolarisLwp *lwp_lister,
 }
 
 #if TARGET_CPU_SPARC
-bool WriteContext(MDRawContextSPARC *context, ucontext_t *sig_ctx) {
+bool WriteContext(MDRawContextSPARC* context, ucontext_t* sig_ctx) {
   assert(sig_ctx != NULL);
   int* regs = sig_ctx->uc_mcontext.gregs;
   context->context_flags = MD_CONTEXT_SPARC_FULL;
@@ -170,13 +170,13 @@ bool WriteContext(MDRawContextSPARC *context, ucontext_t *sig_ctx) {
   for ( int i = 1 ; i < 16; ++i ) {
     context->g_r[i] = (uintptr_t)(sig_ctx->uc_mcontext.gregs[i + 3]);
   }
-  context->g_r[30] = (uintptr_t)(((struct frame *)context->g_r[14])->fr_savfp);
+  context->g_r[30] = (uintptr_t)(((struct frame*)context->g_r[14])->fr_savfp);
 
   return true;
 }
 
-bool WriteContext(MDRawContextSPARC *context, prgregset_t regs,
-                  prfpregset_t *fp_regs) {
+bool WriteContext(MDRawContextSPARC* context, prgregset_t regs,
+                  prfpregset_t* fp_regs) {
   if (!context || !regs)
     return false;
 
@@ -195,8 +195,8 @@ bool WriteContext(MDRawContextSPARC *context, prgregset_t regs,
   return true;
 }
 #elif TARGET_CPU_X86
-bool WriteContext(MDRawContextX86 *context, prgregset_t regs,
-                  prfpregset_t *fp_regs) {
+bool WriteContext(MDRawContextX86* context, prgregset_t regs,
+                  prfpregset_t* fp_regs) {
   if (!context || !regs)
     return false;
 
@@ -228,10 +228,10 @@ bool WriteContext(MDRawContextX86 *context, prgregset_t regs,
 // signal. This makes the current stack not reliable, and our stack walker
 // won't figure out the whole call stack for this. So we write the stack at the
 // time of the crash into the minidump file, not the current stack.
-bool WriteCrashedLwpStream(MinidumpFileWriter *minidump_writer,
-                           const WriterArgument *writer_args,
-                           const lwpstatus_t *lsp,
-                           MDRawThread *lwp) {
+bool WriteCrashedLwpStream(MinidumpFileWriter* minidump_writer,
+                           const WriterArgument* writer_args,
+                           const lwpstatus_t* lsp,
+                           MDRawThread* lwp) {
   assert(writer_args->sig_ctx != NULL);
 
   lwp->thread_id = lsp->pr_lwpid;
@@ -264,16 +264,16 @@ bool WriteCrashedLwpStream(MinidumpFileWriter *minidump_writer,
   lwp->thread_context = context.location();
   memset(context.get(), 0, sizeof(MDRawContextX86));
   return WriteContext(context.get(),
-                      (int *)&writer_args->sig_ctx->uc_mcontext.gregs,
+                      (int*)&writer_args->sig_ctx->uc_mcontext.gregs,
                       &writer_args->sig_ctx->uc_mcontext.fpregs);
 #endif
 }
 
-bool WriteLwpStream(MinidumpFileWriter *minidump_writer,
-                    const SolarisLwp *lwp_lister,
-                    const lwpstatus_t *lsp, MDRawThread *lwp) {
+bool WriteLwpStream(MinidumpFileWriter* minidump_writer,
+                    const SolarisLwp* lwp_lister,
+                    const lwpstatus_t* lsp, MDRawThread* lwp) {
   prfpregset_t fp_regs = lsp->pr_fpreg;
-  const prgregset_t *gregs = &(lsp->pr_reg);
+  const prgregset_t* gregs = &(lsp->pr_reg);
   UntypedMDRVA memory(minidump_writer);
 #if TARGET_CPU_SPARC
   if (!WriteLwpStack(lwp_lister,
@@ -306,10 +306,10 @@ bool WriteLwpStream(MinidumpFileWriter *minidump_writer,
   lwp->thread_context = context.location();
   memset(context.get(), 0, sizeof(MDRawContextX86));
 #endif /* TARGET_CPU_XXX */
-  return WriteContext(context.get(), (int *)gregs, &fp_regs);
+  return WriteContext(context.get(), (int*)gregs, &fp_regs);
 }
 
-bool WriteCPUInformation(MDRawSystemInfo *sys_info) {
+bool WriteCPUInformation(MDRawSystemInfo* sys_info) {
   struct utsname uts;
   char *major, *minor, *build;
 
@@ -337,8 +337,8 @@ bool WriteCPUInformation(MDRawSystemInfo *sys_info) {
   return true;
 }
 
-bool WriteOSInformation(MinidumpFileWriter *minidump_writer,
-                        MDRawSystemInfo *sys_info) {
+bool WriteOSInformation(MinidumpFileWriter* minidump_writer,
+                        MDRawSystemInfo* sys_info) {
   sys_info->platform_id = MD_OS_SOLARIS;
 
   struct utsname uts;
@@ -346,7 +346,7 @@ bool WriteOSInformation(MinidumpFileWriter *minidump_writer,
     char os_version[512];
     size_t space_left = sizeof(os_version);
     memset(os_version, 0, space_left);
-    const char *os_info_table[] = {
+    const char* os_info_table[] = {
       uts.sysname,
       uts.release,
       uts.version,
@@ -354,7 +354,7 @@ bool WriteOSInformation(MinidumpFileWriter *minidump_writer,
       "OpenSolaris",
       NULL
     };
-    for (const char **cur_os_info = os_info_table;
+    for (const char** cur_os_info = os_info_table;
          *cur_os_info != NULL;
          ++cur_os_info) {
       if (cur_os_info != os_info_table && space_left > 1) {
@@ -379,21 +379,21 @@ bool WriteOSInformation(MinidumpFileWriter *minidump_writer,
 
 // Callback context for get writting lwp information.
 struct LwpInfoCallbackCtx {
-  MinidumpFileWriter *minidump_writer;
-  const WriterArgument *writer_args;
-  TypedMDRVA<MDRawThreadList> *list;
+  MinidumpFileWriter* minidump_writer;
+  const WriterArgument* writer_args;
+  TypedMDRVA<MDRawThreadList>* list;
   int lwp_index;
 };
 
-bool LwpInformationCallback(lwpstatus_t *lsp, void *context) {
+bool LwpInformationCallback(lwpstatus_t* lsp, void* context) {
   bool success = true;
-  LwpInfoCallbackCtx *callback_context =
-    static_cast<LwpInfoCallbackCtx *>(context);
+  LwpInfoCallbackCtx* callback_context =
+    static_cast<LwpInfoCallbackCtx*>(context);
 
   // The current lwp is the one to handle the crash. Ignore it.
   if (lsp->pr_lwpid != pthread_self()) {
-    LwpInfoCallbackCtx *callback_context =
-      static_cast<LwpInfoCallbackCtx *>(context);
+    LwpInfoCallbackCtx* callback_context =
+      static_cast<LwpInfoCallbackCtx*>(context);
     MDRawThread lwp;
     memset(&lwp, 0, sizeof(MDRawThread));
 
@@ -417,11 +417,11 @@ bool LwpInformationCallback(lwpstatus_t *lsp, void *context) {
   return success;
 }
 
-bool WriteLwpListStream(MinidumpFileWriter *minidump_writer,
-                        const WriterArgument *writer_args,
-                        MDRawDirectory *dir) {
+bool WriteLwpListStream(MinidumpFileWriter* minidump_writer,
+                        const WriterArgument* writer_args,
+                        MDRawDirectory* dir) {
   // Get the lwp information.
-  const SolarisLwp *lwp_lister = writer_args->lwp_lister;
+  const SolarisLwp* lwp_lister = writer_args->lwp_lister;
   int lwp_count = lwp_lister->GetLwpCount();
   if (lwp_count < 0)
     return false;
@@ -444,14 +444,14 @@ bool WriteLwpListStream(MinidumpFileWriter *minidump_writer,
   return written == lwp_count;
 }
 
-bool WriteCVRecord(MinidumpFileWriter *minidump_writer,
-                   MDRawModule *module,
-                   const char *module_path,
-                   char *realname) {
+bool WriteCVRecord(MinidumpFileWriter* minidump_writer,
+                   MDRawModule* module,
+                   const char* module_path,
+                   char* realname) {
   TypedMDRVA<MDCVInfoPDB70> cv(minidump_writer);
 
   char path[PATH_MAX];
-  const char *module_name = module_path ? module_path : "<Unknown>";
+  const char* module_name = module_path ? module_path : "<Unknown>";
   snprintf(path, sizeof(path), "/proc/self/object/%s", module_name);
 
   size_t module_name_length = strlen(realname);
@@ -461,7 +461,7 @@ bool WriteCVRecord(MinidumpFileWriter *minidump_writer,
     return false;
 
   module->cv_record = cv.location();
-  MDCVInfoPDB70 *cv_ptr = cv.get();
+  MDCVInfoPDB70* cv_ptr = cv.get();
   memset(cv_ptr, 0, sizeof(MDCVInfoPDB70));
   cv_ptr->cv_signature = MD_CVINFOPDB70_SIGNATURE;
   cv_ptr->age = 0;
@@ -489,15 +489,15 @@ bool WriteCVRecord(MinidumpFileWriter *minidump_writer,
 }
 
 struct ModuleInfoCallbackCtx {
-  MinidumpFileWriter *minidump_writer;
-  const WriterArgument *writer_args;
-  TypedMDRVA<MDRawModuleList> *list;
+  MinidumpFileWriter* minidump_writer;
+  const WriterArgument* writer_args;
+  TypedMDRVA<MDRawModuleList>* list;
   int module_index;
 };
 
-bool ModuleInfoCallback(const ModuleInfo &module_info, void *context) {
-  ModuleInfoCallbackCtx *callback_context =
-    static_cast<ModuleInfoCallbackCtx *>(context);
+bool ModuleInfoCallback(const ModuleInfo& module_info, void* context) {
+  ModuleInfoCallbackCtx* callback_context =
+    static_cast<ModuleInfoCallbackCtx*>(context);
   // Skip those modules without name, or those that are not modules.
   if (strlen(module_info.name) == 0)
     return true;
@@ -507,7 +507,7 @@ bool ModuleInfoCallback(const ModuleInfo &module_info, void *context) {
   MDLocationDescriptor loc;
   char path[PATH_MAX];
   char buf[PATH_MAX];
-  char *realname;
+  char* realname;
   int count;
 
   snprintf(path, sizeof (path), "/proc/self/path/%s", module_info.name);
@@ -535,9 +535,9 @@ bool ModuleInfoCallback(const ModuleInfo &module_info, void *context) {
   return true;
 }
 
-bool WriteModuleListStream(MinidumpFileWriter *minidump_writer,
-                           const WriterArgument *writer_args,
-                           MDRawDirectory *dir) {
+bool WriteModuleListStream(MinidumpFileWriter* minidump_writer,
+                           const WriterArgument* writer_args,
+                           MDRawDirectory* dir) {
   TypedMDRVA<MDRawModuleList> list(minidump_writer);
   int module_count = writer_args->lwp_lister->GetModuleCount();
 
@@ -558,9 +558,9 @@ bool WriteModuleListStream(MinidumpFileWriter *minidump_writer,
   return writer_args->lwp_lister->ListModules(&callback) == module_count;
 }
 
-bool WriteSystemInfoStream(MinidumpFileWriter *minidump_writer,
-                           const WriterArgument *writer_args,
-                           MDRawDirectory *dir) {
+bool WriteSystemInfoStream(MinidumpFileWriter* minidump_writer,
+                           const WriterArgument* writer_args,
+                           MDRawDirectory* dir) {
   TypedMDRVA<MDRawSystemInfo> sys_info(minidump_writer);
 
   if (!sys_info.Allocate())
@@ -573,9 +573,9 @@ bool WriteSystemInfoStream(MinidumpFileWriter *minidump_writer,
          WriteOSInformation(minidump_writer, sys_info.get());
 }
 
-bool WriteExceptionStream(MinidumpFileWriter *minidump_writer,
-                          const WriterArgument *writer_args,
-                          MDRawDirectory *dir) {
+bool WriteExceptionStream(MinidumpFileWriter* minidump_writer,
+                          const WriterArgument* writer_args,
+                          MDRawDirectory* dir) {
   // This happenes when this is not a crash, but a requested dump.
   if (writer_args->sig_ctx == NULL)
     return false;
@@ -620,14 +620,14 @@ bool WriteExceptionStream(MinidumpFileWriter *minidump_writer,
   exception.get()->thread_context = context.location();
   memset(context.get(), 0, sizeof(MDRawContextX86));
   return WriteContext(context.get(),
-                      (int *)&writer_args->sig_ctx->uc_mcontext.gregs,
+                      (int*)&writer_args->sig_ctx->uc_mcontext.gregs,
                       NULL);
 #endif
 }
 
-bool WriteMiscInfoStream(MinidumpFileWriter *minidump_writer,
-                         const WriterArgument *writer_args,
-                         MDRawDirectory *dir) {
+bool WriteMiscInfoStream(MinidumpFileWriter* minidump_writer,
+                         const WriterArgument* writer_args,
+                         MDRawDirectory* dir) {
   TypedMDRVA<MDRawMiscInfo> info(minidump_writer);
 
   if (!info.Allocate())
@@ -642,9 +642,9 @@ bool WriteMiscInfoStream(MinidumpFileWriter *minidump_writer,
   return true;
 }
 
-bool WriteBreakpadInfoStream(MinidumpFileWriter *minidump_writer,
-                             const WriterArgument *writer_args,
-                             MDRawDirectory *dir) {
+bool WriteBreakpadInfoStream(MinidumpFileWriter* minidump_writer,
+                             const WriterArgument* writer_args,
+                             MDRawDirectory* dir) {
   TypedMDRVA<MDRawBreakpadInfo> info(minidump_writer);
 
   if (!info.Allocate())
@@ -662,16 +662,16 @@ bool WriteBreakpadInfoStream(MinidumpFileWriter *minidump_writer,
 
 class AutoLwpResumer {
  public:
-  AutoLwpResumer(SolarisLwp *lwp) : lwp_(lwp) {}
+  AutoLwpResumer(SolarisLwp* lwp) : lwp_(lwp) {}
   ~AutoLwpResumer() { lwp_->ControlAllLwps(false); }
  private:
-  SolarisLwp *lwp_;
+  SolarisLwp* lwp_;
 };
 
 // Prototype of writer functions.
-typedef bool (*WriteStreamFN)(MinidumpFileWriter *,
-                              const WriterArgument *,
-                              MDRawDirectory *);
+typedef bool (*WriteStreamFN)(MinidumpFileWriter*,
+                              const WriterArgument*,
+                              MDRawDirectory*);
 
 // Function table to writer a full minidump.
 const WriteStreamFN writers[] = {
@@ -684,9 +684,9 @@ const WriteStreamFN writers[] = {
 };
 
 // Will call each writer function in the writers table.
-//void* MinidumpGenerator::Write(void *argument) {
-void* Write(void *argument) {
-  WriterArgument *writer_args = static_cast<WriterArgument *>(argument);
+//void* MinidumpGenerator::Write(void* argument) {
+void* Write(void* argument) {
+  WriterArgument* writer_args = static_cast<WriterArgument*>(argument);
 
   if (!writer_args->lwp_lister->ControlAllLwps(true))
     return NULL;
@@ -712,7 +712,7 @@ void* Write(void *argument) {
       writer_args->crashed_lwpid = crashed_lwpid;
   }
 
-  MinidumpFileWriter *minidump_writer = writer_args->minidump_writer;
+  MinidumpFileWriter* minidump_writer = writer_args->minidump_writer;
   TypedMDRVA<MDRawHeader> header(minidump_writer);
   TypedMDRVA<MDRawDirectory> dir(minidump_writer);
   if (!header.Allocate())
@@ -750,10 +750,10 @@ MinidumpGenerator::~MinidumpGenerator() {
 
 // Write minidump into file.
 // It runs in a different thread from the crashing thread.
-bool MinidumpGenerator::WriteMinidumpToFile(const char *file_pathname,
+bool MinidumpGenerator::WriteMinidumpToFile(const char* file_pathname,
                                             int signo,
                                             uintptr_t sighandler_ebp,
-                                            ucontext_t **sig_ctx) const {
+                                            ucontext_t** sig_ctx) const {
   // The exception handler thread.
   pthread_t handler_thread;
 
@@ -775,7 +775,7 @@ bool MinidumpGenerator::WriteMinidumpToFile(const char *file_pathname,
     argument.sighandler_ebp = sighandler_ebp;
     argument.sig_ctx = NULL;
 
-    pthread_create(&handler_thread, NULL, Write, (void *)&argument);
+    pthread_create(&handler_thread, NULL, Write, (void*)&argument);
     pthread_join(handler_thread, NULL);
     return true;
   }
diff --git a/src/MEGASync/google_breakpad/client/solaris/handler/minidump_generator.h b/src/MEGASync/google_breakpad/client/solaris/handler/minidump_generator.h
index 882f9e1d..daa6fe01 100644
--- a/src/MEGASync/google_breakpad/client/solaris/handler/minidump_generator.h
+++ b/src/MEGASync/google_breakpad/client/solaris/handler/minidump_generator.h
@@ -48,10 +48,10 @@ namespace google_breakpad {
 //
 class MinidumpGenerator {
   // Callback run for writing lwp information in the process.
-  friend bool LwpInformationCallback(lwpstatus_t *lsp, void *context);
+  friend bool LwpInformationCallback(lwpstatus_t* lsp, void* context);
 
   // Callback run for writing module information in the process.
-  friend bool ModuleInfoCallback(const ModuleInfo &module_info, void *context);
+  friend bool ModuleInfoCallback(const ModuleInfo& module_info, void* context);
 
  public:
   MinidumpGenerator();
@@ -59,10 +59,10 @@ class MinidumpGenerator {
   ~MinidumpGenerator();
 
   // Write minidump.
-  bool WriteMinidumpToFile(const char *file_pathname,
+  bool WriteMinidumpToFile(const char* file_pathname,
                            int signo,
                            uintptr_t sighandler_ebp,
-                           ucontext_t **sig_ctx) const;
+                           ucontext_t** sig_ctx) const;
 };
 
 }  // namespace google_breakpad
diff --git a/src/MEGASync/google_breakpad/client/solaris/handler/minidump_test.cc b/src/MEGASync/google_breakpad/client/solaris/handler/minidump_test.cc
index 33302d86..5f685ef2 100644
--- a/src/MEGASync/google_breakpad/client/solaris/handler/minidump_test.cc
+++ b/src/MEGASync/google_breakpad/client/solaris/handler/minidump_test.cc
@@ -40,7 +40,7 @@ using google_breakpad::MinidumpGenerator;
 
 static bool doneWritingReport = false;
 
-static void *Reporter(void *) {
+static void* Reporter(void*) {
   char buffer[PATH_MAX];
   MinidumpGenerator md;
 
diff --git a/src/MEGASync/google_breakpad/client/solaris/handler/solaris_lwp.cc b/src/MEGASync/google_breakpad/client/solaris/handler/solaris_lwp.cc
index 0148997a..cb6cc8ab 100644
--- a/src/MEGASync/google_breakpad/client/solaris/handler/solaris_lwp.cc
+++ b/src/MEGASync/google_breakpad/client/solaris/handler/solaris_lwp.cc
@@ -69,10 +69,10 @@ struct AddressValidatingContext {
 };
 
 // Convert from string to int.
-static bool LocalAtoi(char *s, int *r) {
+static bool LocalAtoi(char* s, int* r) {
   assert(s != NULL);
   assert(r != NULL);
-  char *endptr = NULL;
+  char* endptr = NULL;
   int ret = strtol(s, &endptr, 10);
   if (endptr == s)
     return false;
@@ -82,10 +82,10 @@ static bool LocalAtoi(char *s, int *r) {
 
 // Callback invoked for each mapped module.
 // It uses the module's adderss range to validate the address.
-static bool AddressNotInModuleCallback(const ModuleInfo &module_info,
-                                       void *context) {
-  AddressValidatingContext *addr =
-    reinterpret_cast<AddressValidatingContext *>(context);
+static bool AddressNotInModuleCallback(const ModuleInfo& module_info,
+                                       void* context) {
+  AddressValidatingContext* addr =
+    reinterpret_cast<AddressValidatingContext*>(context);
   if (addr->is_mapped = ((module_info.start_addr > 0) &&
                          (addr->address >= module_info.start_addr) &&
                          (addr->address <= module_info.start_addr +
@@ -97,16 +97,16 @@ static bool AddressNotInModuleCallback(const ModuleInfo &module_info,
 }
 
 static int IterateLwpAll(int pid,
-                         CallbackParam<LwpidCallback> *callback_param) {
+                         CallbackParam<LwpidCallback>* callback_param) {
   char lwp_path[40];
-  DIR *dir;
+  DIR* dir;
   int count = 0;
 
   snprintf(lwp_path, sizeof (lwp_path), "/proc/%d/lwp", (int)pid);
   if ((dir = opendir(lwp_path)) == NULL)
     return -1;
 
-  struct dirent *entry = NULL;
+  struct dirent* entry = NULL;
   while ((entry = readdir(dir)) != NULL) {
     if ((strcmp(entry->d_name, ".") != 0) &&
         (strcmp(entry->d_name, "..") != 0)) {
@@ -128,22 +128,22 @@ static int IterateLwpAll(int pid,
 }
 
 #if defined(__i386) && !defined(NO_FRAME_POINTER)
-void *GetNextFrame(void **last_ebp) {
-  void *sp = *last_ebp;
+void* GetNextFrame(void** last_ebp) {
+  void* sp = *last_ebp;
   if ((unsigned long)sp == (unsigned long)last_ebp)
     return NULL;
-  if ((unsigned long)sp & (sizeof(void *) - 1))
+  if ((unsigned long)sp & (sizeof(void*) - 1))
     return NULL;
   if ((unsigned long)sp - (unsigned long)last_ebp > 100000)
     return NULL;
   return sp;
 }
 #elif defined(__sparc)
-void *GetNextFrame(void *last_ebp) {
-  return reinterpret_cast<struct frame *>(last_ebp)->fr_savfp;
+void* GetNextFrame(void* last_ebp) {
+  return reinterpret_cast<struct frame*>(last_ebp)->fr_savfp;
 }
 #else
-void *GetNextFrame(void **last_ebp) {
+void* GetNextFrame(void** last_ebp) {
   return reinterpret_cast<void*>(last_ebp);
 }
 #endif
@@ -159,12 +159,12 @@ class AutoCloser {
 
 // Control the execution of the lwp.
 // Suspend/Resume lwp based on the value of context.
-static bool ControlLwp(int lwpid, void *context) {
+static bool ControlLwp(int lwpid, void* context) {
   // The current thread is the one to handle the crash. Ignore it.
   if (lwpid != pthread_self()) {
     int ctlfd;
     char procname[PATH_MAX];
-    bool suspend = *(bool *)context;
+    bool suspend = *(bool*)context;
 
     // Open the /proc/$pid/lwp/$lwpid/lwpctl files
     snprintf(procname, sizeof (procname), "/proc/self/lwp/%d/lwpctl", lwpid);
@@ -193,7 +193,7 @@ static bool ControlLwp(int lwpid, void *context) {
  * prheader_t at the start (/proc/$pid/lstatus or /proc/$pid/lpsinfo).
  * Return true on success.
  */
-static bool read_lfile(int pid, const char *lname, prheader_t *lhp) {
+static bool read_lfile(int pid, const char* lname, prheader_t* lhp) {
   char lpath[PATH_MAX];
   struct stat statb;
   int fd;
@@ -242,14 +242,14 @@ int SolarisLwp::GetLwpCount() const {
 }
 
 int SolarisLwp::Lwp_iter_all(int pid,
-                             CallbackParam<LwpCallback> *callback_param) const {
-  lwpstatus_t *Lsp;
-  lwpstatus_t *sp;
+                             CallbackParam<LwpCallback>* callback_param) const {
+  lwpstatus_t* Lsp;
+  lwpstatus_t* sp;
   prheader_t lphp[HEADER_MAX];
   prheader_t lhp[HEADER_MAX];
-  prheader_t *Lphp = lphp;
-  prheader_t *Lhp = lhp;
-  lwpsinfo_t *Lpsp;
+  prheader_t* Lphp = lphp;
+  prheader_t* Lhp = lhp;
+  lwpsinfo_t* Lpsp;
   long nstat;
   long ninfo;
   int rv = 0;
@@ -264,13 +264,13 @@ int SolarisLwp::Lwp_iter_all(int pid,
     return -1;
   }
 
-  Lsp = (lwpstatus_t *)(uintptr_t)(Lhp + 1);
-  Lpsp = (lwpsinfo_t *)(uintptr_t)(Lphp + 1);
+  Lsp = (lwpstatus_t*)(uintptr_t)(Lhp + 1);
+  Lpsp = (lwpsinfo_t*)(uintptr_t)(Lphp + 1);
 
   for (ninfo = Lphp->pr_nent; ninfo != 0; --ninfo) {
     if (Lpsp->pr_sname != 'Z') {
       sp = Lsp;
-      Lsp = (lwpstatus_t *)((uintptr_t)Lsp + Lhp->pr_entsize);
+      Lsp = (lwpstatus_t*)((uintptr_t)Lsp + Lhp->pr_entsize);
     } else {
       sp = NULL;
     }
@@ -278,7 +278,7 @@ int SolarisLwp::Lwp_iter_all(int pid,
         !(callback_param->call_back)(sp, callback_param->context))
       break;
     ++rv;
-    Lpsp = (lwpsinfo_t *)((uintptr_t)Lpsp + Lphp->pr_entsize);
+    Lpsp = (lwpsinfo_t*)((uintptr_t)Lpsp + Lphp->pr_entsize);
   }
 
   return rv;
@@ -298,12 +298,12 @@ int SolarisLwp::GetModuleCount() const {
 }
 
 int SolarisLwp::ListModules(
-    CallbackParam<ModuleCallback> *callback_param) const {
-  const char *maps_path = "/proc/self/map";
+    CallbackParam<ModuleCallback>* callback_param) const {
+  const char* maps_path = "/proc/self/map";
   struct stat status;
   int fd = 0, num;
   prmap_t map_array[MAP_MAX];
-  prmap_t *maps = map_array;
+  prmap_t* maps = map_array;
   size_t size;
 
   if ((fd = open(maps_path, O_RDONLY)) == -1) {
@@ -326,12 +326,12 @@ int SolarisLwp::ListModules(
     return -1;
   }
 
-  if (read(fd, (void *)maps, size) < 0) {
+  if (read(fd, (void*)maps, size) < 0) {
     print_message2(2, "failed to read %d\n", fd);
     return -1;
   }
 
-  prmap_t *_maps;
+  prmap_t* _maps;
   int _num;
   int module_count = 0;
   
@@ -345,7 +345,7 @@ int SolarisLwp::ListModules(
    */
   for (_num = 0, _maps = maps; _num < num; ++_num, ++_maps) {
     ModuleInfo module;
-    char *name = _maps->pr_mapname;
+    char* name = _maps->pr_mapname;
 
     memset(&module, 0, sizeof (module));
     module.start_addr = _maps->pr_vaddr;
@@ -403,7 +403,7 @@ bool SolarisLwp::IsAddressMapped(uintptr_t address) const {
 // The Solaris stack looks like this:
 // http://src.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/lib/libproc/common/Pstack.c#81
 bool SolarisLwp::FindSigContext(uintptr_t sighandler_ebp,
-                                ucontext_t **sig_ctx) {
+                                ucontext_t** sig_ctx) {
   uintptr_t previous_ebp;
   uintptr_t sig_ebp;
   const int MAX_STACK_DEPTH = 50;
@@ -416,7 +416,7 @@ bool SolarisLwp::FindSigContext(uintptr_t sighandler_ebp,
     *sig_ctx = reinterpret_cast<ucontext_t*>(sighandler_ebp + sizeof (struct frame));
     uintptr_t sig_esp = (*sig_ctx)->uc_mcontext.gregs[REG_O6];
     if (sig_esp < previous_ebp && sig_esp > sighandler_ebp)
-      sig_ebp = (uintptr_t)(((struct frame *)sig_esp)->fr_savfp);
+      sig_ebp = (uintptr_t)(((struct frame*)sig_esp)->fr_savfp);
 
 #elif TARGET_CPU_X86
     previous_ebp = reinterpret_cast<uintptr_t>(GetNextFrame(
diff --git a/src/MEGASync/google_breakpad/client/solaris/handler/solaris_lwp.h b/src/MEGASync/google_breakpad/client/solaris/handler/solaris_lwp.h
index 0914cfcd..afe352ce 100644
--- a/src/MEGASync/google_breakpad/client/solaris/handler/solaris_lwp.h
+++ b/src/MEGASync/google_breakpad/client/solaris/handler/solaris_lwp.h
@@ -70,17 +70,17 @@ struct ModuleInfo {
 // A callback to run when getting a lwp in the process.
 // Return true will go on to the next lwp while return false will stop the
 // iteration.
-typedef bool (*LwpCallback)(lwpstatus_t* lsp, void *context); 
+typedef bool (*LwpCallback)(lwpstatus_t* lsp, void* context);
 
 // A callback to run when a new module is found in the process.
 // Return true will go on to the next module while return false will stop the
 // iteration.
-typedef bool (*ModuleCallback)(const ModuleInfo &module_info, void *context);
+typedef bool (*ModuleCallback)(const ModuleInfo& module_info, void* context);
 
 // A callback to run when getting a lwpid in the process.
 // Return true will go on to the next lwp while return false will stop the
 // iteration.
-typedef bool (*LwpidCallback)(int lwpid, void *context);
+typedef bool (*LwpidCallback)(int lwpid, void* context);
 
 // Holding the callback information.
 template<class CallbackFunc>
@@ -88,12 +88,12 @@ struct CallbackParam {
   // Callback function address.
   CallbackFunc call_back;
   // Callback context;
-  void *context;
+  void* context;
 
   CallbackParam() : call_back(NULL), context(NULL) {
   }
 
-  CallbackParam(CallbackFunc func, void *func_context) :
+  CallbackParam(CallbackFunc func, void* func_context) :
     call_back(func), context(func_context) {
   }
 };
@@ -129,7 +129,7 @@ class SolarisLwp {
   // Whenever there is a lwp found, the callback will be invoked to process
   // the information.
   // Return the callback return value or -1 on error.
-  int Lwp_iter_all(int pid, CallbackParam<LwpCallback> *callback_param) const;
+  int Lwp_iter_all(int pid, CallbackParam<LwpCallback>* callback_param) const;
 
   // Get the module count of the current process.
   int GetModuleCount() const;
@@ -138,13 +138,13 @@ class SolarisLwp {
   // Whenever a module is found, the callback will be invoked to process the
   // information.
   // Return how may modules are found.
-  int ListModules(CallbackParam<ModuleCallback> *callback_param) const;
+  int ListModules(CallbackParam<ModuleCallback>* callback_param) const;
 
   // Get the bottom of the stack from esp.
   uintptr_t GetLwpStackBottom(uintptr_t current_esp) const;
 
   // Finds a signal context on the stack given the ebp of our signal handler.
-  bool FindSigContext(uintptr_t sighandler_ebp, ucontext_t **sig_ctx);
+  bool FindSigContext(uintptr_t sighandler_ebp, ucontext_t** sig_ctx);
 
  private:
   // Check if the address is a valid virtual address.
diff --git a/src/MEGASync/google_breakpad/client/windows/breakpad_client.gyp b/src/MEGASync/google_breakpad/client/windows/breakpad_client.gyp
index ae26b91d..64797534 100644
--- a/src/MEGASync/google_breakpad/client/windows/breakpad_client.gyp
+++ b/src/MEGASync/google_breakpad/client/windows/breakpad_client.gyp
@@ -1,5 +1,4 @@
-# Copyright (c) 2010, Google Inc.
-# All rights reserved.
+# Copyright 2010 Google Inc. All rights reserved.
 #
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions are
@@ -29,7 +28,7 @@
 
 {
   'includes': [
-    'build/common.gypi',
+    '../../build/common.gypi',
   ],
   'targets': [
     {
diff --git a/src/MEGASync/google_breakpad/client/windows/common/auto_critical_section.h b/src/MEGASync/google_breakpad/client/windows/common/auto_critical_section.h
index 40287427..3fd4b9b7 100644
--- a/src/MEGASync/google_breakpad/client/windows/common/auto_critical_section.h
+++ b/src/MEGASync/google_breakpad/client/windows/common/auto_critical_section.h
@@ -30,7 +30,7 @@
 #ifndef CLIENT_WINDOWS_COMMON_AUTO_CRITICAL_SECTION_H__
 #define CLIENT_WINDOWS_COMMON_AUTO_CRITICAL_SECTION_H__
 
-#include <Windows.h>
+#include <windows.h>
 
 namespace google_breakpad {
 
diff --git a/src/MEGASync/google_breakpad/client/windows/common/ipc_protocol.h b/src/MEGASync/google_breakpad/client/windows/common/ipc_protocol.h
index b03c032b..c7486819 100644
--- a/src/MEGASync/google_breakpad/client/windows/common/ipc_protocol.h
+++ b/src/MEGASync/google_breakpad/client/windows/common/ipc_protocol.h
@@ -30,8 +30,8 @@
 #ifndef CLIENT_WINDOWS_COMMON_IPC_PROTOCOL_H__
 #define CLIENT_WINDOWS_COMMON_IPC_PROTOCOL_H__
 
-#include <Windows.h>
-#include <DbgHelp.h>
+#include <windows.h>
+#include <dbghelp.h>
 #include <string>
 #include <utility>
 #include "common/windows/string_utils-inl.h"
diff --git a/src/MEGASync/google_breakpad/client/windows/crash_generation/client_info.cc b/src/MEGASync/google_breakpad/client/windows/crash_generation/client_info.cc
index cd3a18de..ed312638 100644
--- a/src/MEGASync/google_breakpad/client/windows/crash_generation/client_info.cc
+++ b/src/MEGASync/google_breakpad/client/windows/crash_generation/client_info.cc
@@ -67,8 +67,10 @@ bool ClientInfo::Initialize() {
   // The crash_id will be the low order word of the process creation time.
   FILETIME creation_time, exit_time, kernel_time, user_time;
   if (GetProcessTimes(process_handle_, &creation_time, &exit_time,
-                      &kernel_time, &user_time))
-    crash_id_ = creation_time.dwLowDateTime;
+                      &kernel_time, &user_time)) {
+    start_time_ = creation_time;
+  }
+  crash_id_ = start_time_.dwLowDateTime;
 
   dump_requested_handle_ = CreateEvent(NULL,    // Security attributes.
                                        TRUE,    // Manual reset.
diff --git a/src/MEGASync/google_breakpad/client/windows/crash_generation/client_info.h b/src/MEGASync/google_breakpad/client/windows/crash_generation/client_info.h
index 9f94bec8..6a8fba31 100644
--- a/src/MEGASync/google_breakpad/client/windows/crash_generation/client_info.h
+++ b/src/MEGASync/google_breakpad/client/windows/crash_generation/client_info.h
@@ -30,8 +30,8 @@
 #ifndef CLIENT_WINDOWS_CRASH_GENERATION_CLIENT_INFO_H__
 #define CLIENT_WINDOWS_CRASH_GENERATION_CLIENT_INFO_H__
 
-#include <Windows.h>
-#include <DbgHelp.h>
+#include <windows.h>
+#include <dbghelp.h>
 #include "client/windows/common/ipc_protocol.h"
 #include "common/scoped_ptr.h"
 #include "google_breakpad/common/minidump_format.h"
diff --git a/src/MEGASync/google_breakpad/client/windows/crash_generation/crash_generation.gyp b/src/MEGASync/google_breakpad/client/windows/crash_generation/crash_generation.gyp
index 23862d75..ba343768 100644
--- a/src/MEGASync/google_breakpad/client/windows/crash_generation/crash_generation.gyp
+++ b/src/MEGASync/google_breakpad/client/windows/crash_generation/crash_generation.gyp
@@ -1,5 +1,4 @@
-# Copyright (c) 2010, Google Inc.
-# All rights reserved.
+# Copyright 2010 Google Inc. All rights reserved.
 #
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions are
@@ -29,7 +28,7 @@
 
 {
   'includes': [
-    '../build/common.gypi',
+    '../../../build/common.gypi',
   ],
   'targets': [
     {
diff --git a/src/MEGASync/google_breakpad/client/windows/crash_generation/crash_generation_client.cc b/src/MEGASync/google_breakpad/client/windows/crash_generation/crash_generation_client.cc
index 1e86dcec..3ba5d4e4 100644
--- a/src/MEGASync/google_breakpad/client/windows/crash_generation/crash_generation_client.cc
+++ b/src/MEGASync/google_breakpad/client/windows/crash_generation/crash_generation_client.cc
@@ -96,14 +96,14 @@ CrashGenerationClient::CrashGenerationClient(
     const CustomClientInfo* custom_info)
         : pipe_name_(pipe_name),
           pipe_handle_(NULL),
+          custom_info_(),
           dump_type_(dump_type),
-          thread_id_(0),
-          server_process_id_(0),
           crash_event_(NULL),
           crash_generated_(NULL),
           server_alive_(NULL),
-          exception_pointers_(NULL),
-          custom_info_() {
+          server_process_id_(0),
+          thread_id_(0),
+          exception_pointers_(NULL) {
   memset(&assert_info_, 0, sizeof(assert_info_));
   if (custom_info) {
     custom_info_ = *custom_info;
@@ -116,14 +116,14 @@ CrashGenerationClient::CrashGenerationClient(
     const CustomClientInfo* custom_info)
         : pipe_name_(),
           pipe_handle_(pipe_handle),
+          custom_info_(),
           dump_type_(dump_type),
-          thread_id_(0),
-          server_process_id_(0),
           crash_event_(NULL),
           crash_generated_(NULL),
           server_alive_(NULL),
-          exception_pointers_(NULL),
-          custom_info_() {
+          server_process_id_(0),
+          thread_id_(0),
+          exception_pointers_(NULL) {
   memset(&assert_info_, 0, sizeof(assert_info_));
   if (custom_info) {
     custom_info_ = *custom_info;
diff --git a/src/MEGASync/google_breakpad/client/windows/crash_generation/crash_generation_server.cc b/src/MEGASync/google_breakpad/client/windows/crash_generation/crash_generation_server.cc
index b4bb5c95..0af213ba 100644
--- a/src/MEGASync/google_breakpad/client/windows/crash_generation/crash_generation_server.cc
+++ b/src/MEGASync/google_breakpad/client/windows/crash_generation/crash_generation_server.cc
@@ -85,7 +85,7 @@ static bool IsClientRequestValid(const ProtocolMessage& msg) {
           msg.assert_info != NULL);
 }
 
-#ifdef _DEBUG
+#ifndef NDEBUG
 static bool CheckForIOIncomplete(bool success) {
   // We should never get an I/O incomplete since we should not execute this
   // unless the operation has finished and the overlapped event is signaled. If
@@ -121,17 +121,13 @@ CrashGenerationServer::CrashGenerationServer(
       upload_request_callback_(upload_request_callback),
       upload_context_(upload_context),
       generate_dumps_(generate_dumps),
-      dump_generator_(NULL),
+      pre_fetch_custom_info_(true),
+      dump_path_(dump_path ? *dump_path : L""),
       server_state_(IPC_SERVER_STATE_UNINITIALIZED),
       shutting_down_(false),
       overlapped_(),
-      client_info_(NULL),
-      pre_fetch_custom_info_(true) {
+      client_info_(NULL) {
   InitializeCriticalSection(&sync_);
-
-  if (dump_path) {
-    dump_generator_.reset(new MinidumpGenerator(*dump_path));
-  }
 }
 
 // This should never be called from the OnPipeConnected callback.
@@ -917,15 +913,31 @@ bool CrashGenerationServer::GenerateDump(const ClientInfo& client,
     return false;
   }
 
-  return dump_generator_->WriteMinidump(client.process_handle(),
-                                        client.pid(),
-                                        client_thread_id,
-                                        GetCurrentThreadId(),
-                                        client_ex_info,
-                                        client.assert_info(),
-                                        client.dump_type(),
-                                        true,
-                                        dump_path);
+  MinidumpGenerator dump_generator(dump_path_,
+                                   client.process_handle(),
+                                   client.pid(),
+                                   client_thread_id,
+                                   GetCurrentThreadId(),
+                                   client_ex_info,
+                                   client.assert_info(),
+                                   client.dump_type(),
+                                   true);
+
+  if (!dump_generator.GenerateDumpFile(dump_path)) {
+    return false;
+  }
+
+  // If the client requests a full memory dump, we will write a normal mini
+  // dump and a full memory dump. Both dump files use the same uuid as file
+  // name prefix.
+  if (client.dump_type() & MiniDumpWithFullMemory) {
+    std::wstring full_dump_path;
+    if (!dump_generator.GenerateFullDumpFile(&full_dump_path)) {
+      return false;
+    }
+  }
+
+  return dump_generator.WriteMinidump();
 }
 
 }  // namespace google_breakpad
diff --git a/src/MEGASync/google_breakpad/client/windows/crash_generation/crash_generation_server.h b/src/MEGASync/google_breakpad/client/windows/crash_generation/crash_generation_server.h
index 07019858..0ea90e51 100644
--- a/src/MEGASync/google_breakpad/client/windows/crash_generation/crash_generation_server.h
+++ b/src/MEGASync/google_breakpad/client/windows/crash_generation/crash_generation_server.h
@@ -268,8 +268,8 @@ class CrashGenerationServer {
   // Wether to populate custom information up-front.
   bool pre_fetch_custom_info_;
 
-  // Instance of a mini dump generator.
-  scoped_ptr<MinidumpGenerator> dump_generator_;
+  // The dump path for the server.
+  const std::wstring dump_path_;
 
   // State of the server in performing the IPC with the client.
   // Note that since we restrict the pipe to one instance, we
diff --git a/src/MEGASync/google_breakpad/client/windows/crash_generation/minidump_generator.cc b/src/MEGASync/google_breakpad/client/windows/crash_generation/minidump_generator.cc
index 652c1c9a..573c2786 100644
--- a/src/MEGASync/google_breakpad/client/windows/crash_generation/minidump_generator.cc
+++ b/src/MEGASync/google_breakpad/client/windows/crash_generation/minidump_generator.cc
@@ -176,9 +176,14 @@ bool HandleTraceData::CollectHandleData(
   stream_data->Reserved = 0;
   std::copy(operations_.begin(),
             operations_.end(),
+#if defined(_MSC_VER) && !defined(_LIBCPP_STD_VER)
             stdext::checked_array_iterator<AVRF_HANDLE_OPERATION*>(
                 reinterpret_cast<AVRF_HANDLE_OPERATION*>(stream_data + 1),
-                operations_.size()));
+                operations_.size())
+#else
+            reinterpret_cast<AVRF_HANDLE_OPERATION*>(stream_data + 1)
+#endif
+            );
 
   return true;
 }
@@ -243,17 +248,50 @@ ULONG CALLBACK HandleTraceData::RecordHandleOperations(
 
 namespace google_breakpad {
 
-MinidumpGenerator::MinidumpGenerator(const wstring& dump_path)
+MinidumpGenerator::MinidumpGenerator(
+    const std::wstring& dump_path,
+    const HANDLE process_handle,
+    const DWORD process_id,
+    const DWORD thread_id,
+    const DWORD requesting_thread_id,
+    EXCEPTION_POINTERS* exception_pointers,
+    MDRawAssertionInfo* assert_info,
+    const MINIDUMP_TYPE dump_type,
+    const bool is_client_pointers)
     : dbghelp_module_(NULL),
+      write_dump_(NULL),
       rpcrt4_module_(NULL),
+      create_uuid_(NULL),
+      process_handle_(process_handle),
+      process_id_(process_id),
+      thread_id_(thread_id),
+      requesting_thread_id_(requesting_thread_id),
+      exception_pointers_(exception_pointers),
+      assert_info_(assert_info),
+      dump_type_(dump_type),
+      is_client_pointers_(is_client_pointers),
       dump_path_(dump_path),
-      write_dump_(NULL),
-      create_uuid_(NULL) {
+      uuid_generated_(false),
+      dump_file_(INVALID_HANDLE_VALUE),
+      full_dump_file_(INVALID_HANDLE_VALUE),
+      dump_file_is_internal_(false),
+      full_dump_file_is_internal_(false),
+      additional_streams_(NULL),
+      callback_info_(NULL) {
+  uuid_ = {0};
   InitializeCriticalSection(&module_load_sync_);
   InitializeCriticalSection(&get_proc_address_sync_);
 }
 
 MinidumpGenerator::~MinidumpGenerator() {
+  if (dump_file_is_internal_ && dump_file_ != INVALID_HANDLE_VALUE) {
+    CloseHandle(dump_file_);
+  }
+
+  if (full_dump_file_is_internal_ && full_dump_file_ != INVALID_HANDLE_VALUE) {
+    CloseHandle(full_dump_file_);
+  }
+
   if (dbghelp_module_) {
     FreeLibrary(dbghelp_module_);
   }
@@ -266,141 +304,10 @@ MinidumpGenerator::~MinidumpGenerator() {
   DeleteCriticalSection(&module_load_sync_);
 }
 
-bool MinidumpGenerator::WriteMinidump(HANDLE process_handle,
-                                      DWORD process_id,
-                                      DWORD thread_id,
-                                      DWORD requesting_thread_id,
-                                      EXCEPTION_POINTERS* exception_pointers,
-                                      MDRawAssertionInfo* assert_info,
-                                      MINIDUMP_TYPE dump_type,
-                                      bool is_client_pointers,
-                                      wstring* dump_path) {
-  // Just call the full WriteMinidump with NULL as the full_dump_path.
-  return this->WriteMinidump(process_handle, process_id, thread_id,
-                             requesting_thread_id, exception_pointers,
-                             assert_info, dump_type, is_client_pointers,
-                             dump_path, NULL);
-}
-
-bool MinidumpGenerator::WriteMinidump(HANDLE process_handle,
-                                      DWORD process_id,
-                                      DWORD thread_id,
-                                      DWORD requesting_thread_id,
-                                      EXCEPTION_POINTERS* exception_pointers,
-                                      MDRawAssertionInfo* assert_info,
-                                      MINIDUMP_TYPE dump_type,
-                                      bool is_client_pointers,
-                                      wstring* dump_path,
-                                      wstring* full_dump_path) {
-  wstring dump_file_path;
-  if (!GenerateDumpFilePath(&dump_file_path)) {
-    return false;
-  }
-
-  // If the client requests a full memory dump, we will write a normal mini
-  // dump and a full memory dump. Both dump files use the same uuid as file
-  // name prefix.
-  bool full_memory_dump = (dump_type & MiniDumpWithFullMemory) != 0;
-  wstring full_dump_file_path;
-  if (full_memory_dump) {
-    full_dump_file_path.assign(dump_file_path);
-    full_dump_file_path.resize(full_dump_file_path.size() - 4);  // strip .dmp
-    full_dump_file_path.append(TEXT("-full.dmp"));
-  }
-
-  HANDLE dump_file = CreateFile(dump_file_path.c_str(),
-                                GENERIC_WRITE,
-                                0,
-                                NULL,
-                                CREATE_NEW,
-                                FILE_ATTRIBUTE_NORMAL,
-                                NULL);
-
-  if (dump_file == INVALID_HANDLE_VALUE) {
-    return false;
-  }
-
-  HANDLE full_dump_file = INVALID_HANDLE_VALUE;
-  if (full_memory_dump) {
-    full_dump_file = CreateFile(full_dump_file_path.c_str(),
-                                GENERIC_WRITE,
-                                0,
-                                NULL,
-                                CREATE_NEW,
-                                FILE_ATTRIBUTE_NORMAL,
-                                NULL);
-
-    if (full_dump_file == INVALID_HANDLE_VALUE) {
-      CloseHandle(dump_file);
-      return false;
-    }
-  }
-
-  bool result = WriteMinidump(process_handle,
-                              process_id,
-                              thread_id,
-                              requesting_thread_id,
-                              exception_pointers,
-                              assert_info,
-                              dump_type,
-                              is_client_pointers,
-                              dump_file,
-                              full_dump_file);
-
-  // Store the path of the dump file in the out parameter if dump generation
-  // succeeded.
-  if (result && dump_path) {
-    *dump_path = dump_file_path;
-  }
-  if (result && full_memory_dump && full_dump_path) {
-    *full_dump_path = full_dump_file_path;
-  }
-
-  CloseHandle(dump_file);
-  if (full_dump_file != INVALID_HANDLE_VALUE)
-    CloseHandle(full_dump_file);
-
-  return result;
-}
-
-bool MinidumpGenerator::WriteMinidump(HANDLE process_handle,
-                                      DWORD process_id,
-                                      DWORD thread_id,
-                                      DWORD requesting_thread_id,
-                                      EXCEPTION_POINTERS* exception_pointers,
-                                      MDRawAssertionInfo* assert_info,
-                                      MINIDUMP_TYPE dump_type,
-                                      bool is_client_pointers,
-                                      HANDLE dump_file,
-                                      HANDLE full_dump_file) {
-  return WriteMinidump(process_handle,
-                       process_id,
-                       thread_id,
-                       requesting_thread_id,
-                       exception_pointers,
-                       assert_info,
-                       dump_type,
-                       is_client_pointers,
-                       dump_file,
-                       full_dump_file,
-                       NULL);
-}
-
-bool MinidumpGenerator::WriteMinidump(
-    HANDLE process_handle,
-    DWORD process_id,
-    DWORD thread_id,
-    DWORD requesting_thread_id,
-    EXCEPTION_POINTERS* exception_pointers,
-    MDRawAssertionInfo* assert_info,
-    MINIDUMP_TYPE dump_type,
-    bool is_client_pointers,
-    HANDLE dump_file,
-    HANDLE full_dump_file,
-    MINIDUMP_USER_STREAM_INFORMATION* additional_streams) {
-  bool full_memory_dump = (dump_type & MiniDumpWithFullMemory) != 0;
-  if (dump_file == INVALID_HANDLE_VALUE ||
-      (full_memory_dump && full_dump_file == INVALID_HANDLE_VALUE)) {
+bool MinidumpGenerator::WriteMinidump() {
+  bool full_memory_dump = (dump_type_ & MiniDumpWithFullMemory) != 0;
+  if (dump_file_ == INVALID_HANDLE_VALUE ||
+      (full_memory_dump && full_dump_file_ == INVALID_HANDLE_VALUE)) {
     return false;
   }
 
@@ -414,11 +321,11 @@ bool MinidumpGenerator::WriteMinidump(
 
   // Setup the exception information object only if it's a dump
   // due to an exception.
-  if (exception_pointers) {
+  if (exception_pointers_) {
     dump_exception_pointers = &dump_exception_info;
-    dump_exception_info.ThreadId = thread_id;
-    dump_exception_info.ExceptionPointers = exception_pointers;
-    dump_exception_info.ClientPointers = is_client_pointers;
+    dump_exception_info.ThreadId = thread_id_;
+    dump_exception_info.ExceptionPointers = exception_pointers_;
+    dump_exception_info.ClientPointers = is_client_pointers_;
   }
 
   // Add an MDRawBreakpadInfo stream to the minidump, to provide additional
@@ -428,17 +335,17 @@ bool MinidumpGenerator::WriteMinidump(
   // can function better with Breakpad-generated dumps when it is present.
   // The native debugger is not harmed by the presence of this information.
   MDRawBreakpadInfo breakpad_info = {0};
-  if (!is_client_pointers) {
+  if (!is_client_pointers_) {
     // Set the dump thread id and requesting thread id only in case of
     // in-process dump generation.
     breakpad_info.validity = MD_BREAKPAD_INFO_VALID_DUMP_THREAD_ID |
                              MD_BREAKPAD_INFO_VALID_REQUESTING_THREAD_ID;
-    breakpad_info.dump_thread_id = thread_id;
-    breakpad_info.requesting_thread_id = requesting_thread_id;
+    breakpad_info.dump_thread_id = thread_id_;
+    breakpad_info.requesting_thread_id = requesting_thread_id_;
   }
 
-  int additional_streams_count = additional_streams ?
-      additional_streams->UserStreamCount : 0;
+  int additional_streams_count = additional_streams_ ?
+      additional_streams_->UserStreamCount : 0;
   scoped_array<MINIDUMP_USER_STREAM> user_stream_array(
       new MINIDUMP_USER_STREAM[3 + additional_streams_count]);
   user_stream_array[0].Type = MD_BREAKPAD_INFO_STREAM;
@@ -449,29 +356,33 @@ bool MinidumpGenerator::WriteMinidump(
   user_streams.UserStreamCount = 1;
   user_streams.UserStreamArray = user_stream_array.get();
 
-  MDRawAssertionInfo* actual_assert_info = assert_info;
-  MDRawAssertionInfo client_assert_info = {0};
+  MDRawAssertionInfo* actual_assert_info = assert_info_;
+  MDRawAssertionInfo client_assert_info = {{0}};
 
-  if (assert_info) {
+  if (assert_info_) {
     // If the assertion info object lives in the client process,
     // read the memory of the client process.
-    if (is_client_pointers) {
+    if (is_client_pointers_) {
       SIZE_T bytes_read = 0;
-      if (!ReadProcessMemory(process_handle,
-                             assert_info,
+      if (!ReadProcessMemory(process_handle_,
+                             assert_info_,
                              &client_assert_info,
                              sizeof(client_assert_info),
                              &bytes_read)) {
-        CloseHandle(dump_file);
-        if (full_dump_file != INVALID_HANDLE_VALUE)
-          CloseHandle(full_dump_file);
+        if (dump_file_is_internal_)
+          CloseHandle(dump_file_);
+        if (full_dump_file_is_internal_ &&
+            full_dump_file_ != INVALID_HANDLE_VALUE)
+          CloseHandle(full_dump_file_);
         return false;
       }
 
       if (bytes_read != sizeof(client_assert_info)) {
-        CloseHandle(dump_file);
-        if (full_dump_file != INVALID_HANDLE_VALUE)
-          CloseHandle(full_dump_file);
+        if (dump_file_is_internal_)
+          CloseHandle(dump_file_);
+        if (full_dump_file_is_internal_ &&
+            full_dump_file_ != INVALID_HANDLE_VALUE)
+          CloseHandle(full_dump_file_);
         return false;
       }
 
@@ -484,16 +395,16 @@ bool MinidumpGenerator::WriteMinidump(
     ++user_streams.UserStreamCount;
   }
 
-  if (additional_streams) {
+  if (additional_streams_) {
     for (size_t i = 0;
-         i < additional_streams->UserStreamCount;
+         i < additional_streams_->UserStreamCount;
          i++, user_streams.UserStreamCount++) {
       user_stream_array[user_streams.UserStreamCount].Type =
-          additional_streams->UserStreamArray[i].Type;
+          additional_streams_->UserStreamArray[i].Type;
       user_stream_array[user_streams.UserStreamCount].BufferSize =
-          additional_streams->UserStreamArray[i].BufferSize;
+          additional_streams_->UserStreamArray[i].BufferSize;
       user_stream_array[user_streams.UserStreamCount].Buffer =
-          additional_streams->UserStreamArray[i].Buffer;
+          additional_streams_->UserStreamArray[i].Buffer;
     }
   }
 
@@ -501,12 +412,14 @@ bool MinidumpGenerator::WriteMinidump(
   // the trace of operations for the offending handle value. Do nothing special
   // if the client already requested the handle trace to be stored in the dump.
   HandleTraceData handle_trace_data;
-  if (exception_pointers && (dump_type & MiniDumpWithHandleData) == 0) {
-    if (!handle_trace_data.CollectHandleData(process_handle,
-                                             exception_pointers)) {
-      CloseHandle(dump_file);
-      if (full_dump_file != INVALID_HANDLE_VALUE)
-        CloseHandle(full_dump_file);
+  if (exception_pointers_ && (dump_type_ & MiniDumpWithHandleData) == 0) {
+    if (!handle_trace_data.CollectHandleData(process_handle_,
+                                             exception_pointers_)) {
+      if (dump_file_is_internal_)
+        CloseHandle(dump_file_);
+      if (full_dump_file_is_internal_ &&
+          full_dump_file_ != INVALID_HANDLE_VALUE)
+        CloseHandle(full_dump_file_);
       return false;
     }
   }
@@ -514,12 +427,12 @@ bool MinidumpGenerator::WriteMinidump(
   bool result_full_memory = true;
   if (full_memory_dump) {
     result_full_memory = write_dump(
-        process_handle,
-        process_id,
-        full_dump_file,
-        static_cast<MINIDUMP_TYPE>((dump_type & (~MiniDumpNormal))
+        process_handle_,
+        process_id_,
+        full_dump_file_,
+        static_cast<MINIDUMP_TYPE>((dump_type_ & (~MiniDumpNormal))
                                     | MiniDumpWithHandleData),
-        exception_pointers ? &dump_exception_info : NULL,
+        exception_pointers_ ? &dump_exception_info : NULL,
         &user_streams,
         NULL) != FALSE;
   }
@@ -531,18 +444,81 @@ bool MinidumpGenerator::WriteMinidump(
   }
 
   bool result_minidump = write_dump(
-      process_handle,
-      process_id,
-      dump_file,
-      static_cast<MINIDUMP_TYPE>((dump_type & (~MiniDumpWithFullMemory))
+      process_handle_,
+      process_id_,
+      dump_file_,
+      static_cast<MINIDUMP_TYPE>((dump_type_ & (~MiniDumpWithFullMemory))
                                   | MiniDumpNormal),
-      exception_pointers ? &dump_exception_info : NULL,
+      exception_pointers_ ? &dump_exception_info : NULL,
       &user_streams,
-      NULL) != FALSE;
+      callback_info_) != FALSE;
 
   return result_minidump && result_full_memory;
 }
 
+bool MinidumpGenerator::GenerateDumpFile(wstring* dump_path) {
+  // The dump file was already set by handle or this function was previously
+  // called.
+  if (dump_file_ != INVALID_HANDLE_VALUE) {
+    return false;
+  }
+
+  wstring dump_file_path;
+  if (!GenerateDumpFilePath(&dump_file_path)) {
+    return false;
+  }
+
+  dump_file_ = CreateFile(dump_file_path.c_str(),
+                          GENERIC_WRITE,
+                          0,
+                          NULL,
+                          CREATE_NEW,
+                          FILE_ATTRIBUTE_NORMAL,
+                          NULL);
+  if (dump_file_ == INVALID_HANDLE_VALUE) {
+    return false;
+  }
+
+  dump_file_is_internal_ = true;
+  *dump_path = dump_file_path;
+  return true;
+}
+
+bool MinidumpGenerator::GenerateFullDumpFile(wstring* full_dump_path) {
+  // A full minidump was not requested.
+  if ((dump_type_ & MiniDumpWithFullMemory) == 0) {
+    return false;
+  }
+
+  // The dump file was already set by handle or this function was previously
+  // called.
+  if (full_dump_file_ != INVALID_HANDLE_VALUE) {
+    return false;
+  }
+
+  wstring full_dump_file_path;
+  if (!GenerateDumpFilePath(&full_dump_file_path)) {
+    return false;
+  }
+  full_dump_file_path.resize(full_dump_file_path.size() - 4);  // strip .dmp
+  full_dump_file_path.append(TEXT("-full.dmp"));
+
+  full_dump_file_ = CreateFile(full_dump_file_path.c_str(),
+                               GENERIC_WRITE,
+                               0,
+                               NULL,
+                               CREATE_NEW,
+                               FILE_ATTRIBUTE_NORMAL,
+                               NULL);
+  if (full_dump_file_ == INVALID_HANDLE_VALUE) {
+    return false;
+  }
+
+  full_dump_file_is_internal_ = true;
+  *full_dump_path = full_dump_file_path;
+  return true;
+}
+
 HMODULE MinidumpGenerator::GetDbghelpModule() {
   AutoCriticalSection lock(&module_load_sync_);
   if (!dbghelp_module_) {
@@ -588,15 +564,17 @@ MinidumpGenerator::UuidCreateType MinidumpGenerator::GetCreateUuid() {
 }
 
 bool MinidumpGenerator::GenerateDumpFilePath(wstring* file_path) {
-  UUID id = {0};
+  if (!uuid_generated_) {
+    UuidCreateType create_uuid = GetCreateUuid();
+    if (!create_uuid) {
+      return false;
+    }
 
-  UuidCreateType create_uuid = GetCreateUuid();
-  if (!create_uuid) {
-    return false;
+    create_uuid(&uuid_);
+    uuid_generated_ = true;
   }
 
-  create_uuid(&id);
-  wstring id_str = GUIDString::GUIDToWString(&id);
+  wstring id_str = GUIDString::GUIDToWString(&uuid_);
 
   *file_path = dump_path_ + TEXT("\\") + id_str + TEXT(".dmp");
   return true;
diff --git a/src/MEGASync/google_breakpad/client/windows/crash_generation/minidump_generator.h b/src/MEGASync/google_breakpad/client/windows/crash_generation/minidump_generator.h
index c4c8fc3e..a707c0bb 100644
--- a/src/MEGASync/google_breakpad/client/windows/crash_generation/minidump_generator.h
+++ b/src/MEGASync/google_breakpad/client/windows/crash_generation/minidump_generator.h
@@ -34,6 +34,7 @@
 #include <dbghelp.h>
 #include <rpc.h>
 #include <list>
+#include <string>
 #include "google_breakpad/common/minidump_format.h"
 
 namespace google_breakpad {
@@ -44,66 +45,55 @@ namespace google_breakpad {
 // the clients to generate minidumps.
 class MinidumpGenerator {
  public:
-  // Creates an instance with the given dump path.
-  explicit MinidumpGenerator(const std::wstring& dump_path);
+  // Creates an instance with the given parameters.
+  // is_client_pointers specifies whether the exception_pointers and
+  // assert_info point into the process that is being dumped.
+  // Before calling WriteMinidump on the returned instance a dump file muct be
+  // specified by a call to either SetDumpFile() or GenerateDumpFile().
+  // If a full dump file will be requested via a subsequent call to either
+  // SetFullDumpFile or GenerateFullDumpFile() dump_type must include
+  // MiniDumpWithFullMemory.
+  MinidumpGenerator(const std::wstring& dump_path,
+                    const HANDLE process_handle,
+                    const DWORD process_id,
+                    const DWORD thread_id,
+                    const DWORD requesting_thread_id,
+                    EXCEPTION_POINTERS* exception_pointers,
+                    MDRawAssertionInfo* assert_info,
+                    const MINIDUMP_TYPE dump_type,
+                    const bool is_client_pointers);
 
   ~MinidumpGenerator();
 
+  void SetDumpFile(const HANDLE dump_file) { dump_file_ = dump_file; }
+  void SetFullDumpFile(const HANDLE full_dump_file) {
+    full_dump_file_ = full_dump_file;
+  }
+
+  // Generate the name for the dump file that will be written to once
+  // WriteMinidump() is called. Can only be called once and cannot be called
+  // if the dump file is set via SetDumpFile().
+  bool GenerateDumpFile(std::wstring* dump_path);
+
+  // Generate the name for the full dump file that will be written to once
+  // WriteMinidump() is called. Cannot be called unless the minidump type
+  // includes MiniDumpWithFullMemory. Can only be called once and cannot be
+  // called if the dump file is set via SetFullDumpFile().
+  bool GenerateFullDumpFile(std::wstring* full_dump_path);
+
+  void SetAdditionalStreams(
+      MINIDUMP_USER_STREAM_INFORMATION* additional_streams) {
+    additional_streams_ = additional_streams;
+  }
+
+  void SetCallback(MINIDUMP_CALLBACK_INFORMATION* callback_info) {
+    callback_info_ = callback_info;
+  }
+
   // Writes the minidump with the given parameters. Stores the
   // dump file path in the dump_path parameter if dump generation
   // succeeds.
-  bool WriteMinidump(HANDLE process_handle,
-                     DWORD process_id,
-                     DWORD thread_id,
-                     DWORD requesting_thread_id,
-                     EXCEPTION_POINTERS* exception_pointers,
-                     MDRawAssertionInfo* assert_info,
-                     MINIDUMP_TYPE dump_type,
-                     bool is_client_pointers,
-                     std::wstring* dump_path);
-
-  // Writes the minidump with the given parameters. Stores the dump file
-  // path in the dump_path (and full_dump_path) parameter if dump
-  // generation succeeds. full_dump_path and dump_path can be NULL.
-  bool WriteMinidump(HANDLE process_handle,
-                     DWORD process_id,
-                     DWORD thread_id,
-                     DWORD requesting_thread_id,
-                     EXCEPTION_POINTERS* exception_pointers,
-                     MDRawAssertionInfo* assert_info,
-                     MINIDUMP_TYPE dump_type,
-                     bool is_client_pointers,
-                     std::wstring* dump_path,
-                     std::wstring* full_dump_path);
-
-  // Writes the minidump with the given parameters. Writes the minidump and
-  // full dump to the file handles supplied. This allows the caller to handle
-  // the creation of the files for the dump. The file handles are not closed
-  // by this function.
-  bool WriteMinidump(HANDLE process_handle,
-                     DWORD process_id,
-                     DWORD thread_id,
-                     DWORD requesting_thread_id,
-                     EXCEPTION_POINTERS* exception_pointers,
-                     MDRawAssertionInfo* assert_info,
-                     MINIDUMP_TYPE dump_type,
-                     bool is_client_pointers,
-                     HANDLE dump_file,
-                     HANDLE full_dump_file);
-
-  // Writes the minidump with the given parameters. Allows the user to include
-  // additional streams in the dump that would not otherwise be included.
-  bool WriteMinidump(HANDLE process_handle,
-                     DWORD process_id,
-                     DWORD thread_id,
-                     DWORD requesting_thread_id,
-                     EXCEPTION_POINTERS* exception_pointers,
-                     MDRawAssertionInfo* assert_info,
-                     MINIDUMP_TYPE dump_type,
-                     bool is_client_pointers,
-                     HANDLE dump_file,
-                     HANDLE full_dump_file,
-                     MINIDUMP_USER_STREAM_INFORMATION* additional_streams);
+  bool WriteMinidump();
 
  private:
   // Function pointer type for MiniDumpWriteDump, which is looked up
@@ -149,9 +139,57 @@ class MinidumpGenerator {
   // Pointer to the UuidCreate function.
   UuidCreateType create_uuid_;
 
+  // Handle for the process to dump.
+  HANDLE process_handle_;
+
+  // Process ID for the process to dump.
+  DWORD process_id_;
+
+  // The crashing thread ID.
+  DWORD thread_id_;
+
+  // The thread ID which is requesting the dump.
+  DWORD requesting_thread_id_;
+
+  // Pointer to the exception information for the crash. This may point to an
+  // address in the crashing process so it should not be dereferenced.
+  EXCEPTION_POINTERS* exception_pointers_;
+
+  // Assertion info for the report.
+  MDRawAssertionInfo* assert_info_;
+
+  // Type of minidump to generate.
+  MINIDUMP_TYPE dump_type_;
+
+  // Specifies whether the exception_pointers_ reference memory in the crashing
+  // process.
+  bool is_client_pointers_;
+
   // Folder path to store dump files.
   std::wstring dump_path_;
 
+  // UUID used to make dump file names.
+  UUID uuid_;
+  bool uuid_generated_;
+
+  // The file where the dump will be written.
+  HANDLE dump_file_;
+
+  // The file where the full dump will be written.
+  HANDLE full_dump_file_;
+
+  // Tracks whether the dump file handle is managed externally.
+  bool dump_file_is_internal_;
+
+  // Tracks whether the full dump file handle is managed externally.
+  bool full_dump_file_is_internal_;
+
+  // Additional streams to be written to the dump.
+  MINIDUMP_USER_STREAM_INFORMATION* additional_streams_;
+
+  // The user defined callback for the various stages of the dump process.
+  MINIDUMP_CALLBACK_INFORMATION* callback_info_;
+
   // Critical section to sychronize action of loading modules dynamically.
   CRITICAL_SECTION module_load_sync_;
 
diff --git a/src/MEGASync/google_breakpad/client/windows/handler/exception_handler.cc b/src/MEGASync/google_breakpad/client/windows/handler/exception_handler.cc
index 699f45ad..e0bd0040 100644
--- a/src/MEGASync/google_breakpad/client/windows/handler/exception_handler.cc
+++ b/src/MEGASync/google_breakpad/client/windows/handler/exception_handler.cc
@@ -27,10 +27,7 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-#include "MegaApplication.h"
-#include <ObjBase.h>
-#include <Psapi.h>
-#include <Strsafe.h>
+#include <objbase.h>
 
 #include <algorithm>
 #include <cassert>
@@ -44,18 +41,17 @@
 
 namespace google_breakpad {
 
-static const int kWaitForHandlerThreadMs = 60000;
-static const int kExceptionHandlerThreadInitialStackSize = 64 * 1024;
-
-// As documented on MSDN, on failure SuspendThread returns (DWORD) -1
-static const DWORD kFailedToSuspendThread = static_cast<DWORD>(-1);
-
 // This is passed as the context to the MinidumpWriteDump callback.
 typedef struct {
   AppMemoryList::const_iterator iter;
   AppMemoryList::const_iterator end;
 } MinidumpCallbackContext;
 
+// This define is new to Windows 10.
+#ifndef DBG_PRINTEXCEPTION_WIDE_C
+#define DBG_PRINTEXCEPTION_WIDE_C ((DWORD)0x4001000A)
+#endif
+
 vector<ExceptionHandler*>* ExceptionHandler::handler_stack_ = NULL;
 LONG ExceptionHandler::handler_stack_index_ = 0;
 CRITICAL_SECTION ExceptionHandler::handler_stack_critical_section_;
@@ -122,7 +118,7 @@ ExceptionHandler::ExceptionHandler(
              NULL);                    // custom_info - not used
 }
 
-ExceptionHandler::ExceptionHandler(const wstring &dump_path,
+ExceptionHandler::ExceptionHandler(const wstring& dump_path,
                                    FilterCallback filter,
                                    MinidumpCallback callback,
                                    void* callback_context,
@@ -177,6 +173,7 @@ void ExceptionHandler::Initialize(
   assertion_ = NULL;
   handler_return_value_ = false;
   handle_debug_exceptions_ = false;
+  consume_invalid_handle_exceptions_ = false;
 
   // Attempt to use out-of-process if user has specified a pipe or a
   // crash generation client.
@@ -219,6 +216,7 @@ void ExceptionHandler::Initialize(
     // Don't attempt to create the thread if we could not create the semaphores.
     if (handler_finish_semaphore_ != NULL && handler_start_semaphore_ != NULL) {
       DWORD thread_id;
+      const int kExceptionHandlerThreadInitialStackSize = 64 * 1024;
       handler_thread_ = CreateThread(NULL,         // lpThreadAttributes
                                      kExceptionHandlerThreadInitialStackSize,
                                      ExceptionHandlerThreadMain,
@@ -228,22 +226,7 @@ void ExceptionHandler::Initialize(
       assert(handler_thread_ != NULL);
     }
 
-    WCHAR systemPath[MAX_PATH];
-    UINT len = GetSystemDirectory(systemPath, MAX_PATH);
-    if (len + 20 >= MAX_PATH)
-    {
-        dbghelp_module_ = LoadLibrary(L"dbghelp.dll");
-        rpcrt4_module_ = LoadLibrary(L"rpcrt4.dll");
-    }
-    else
-    {
-        StringCchPrintfW(systemPath + len, MAX_PATH - len, L"\\dbghelp.dll");
-        dbghelp_module_ = LoadLibrary(systemPath);
-
-        StringCchPrintfW(systemPath + len, MAX_PATH - len, L"\\rpcrt4.dll");
-        rpcrt4_module_ = LoadLibrary(systemPath);
-    }
-
+    dbghelp_module_ = LoadLibrary(L"dbghelp.dll");
     if (dbghelp_module_) {
       minidump_write_dump_ = reinterpret_cast<MiniDumpWriteDump_type>(
           GetProcAddress(dbghelp_module_, "MiniDumpWriteDump"));
@@ -252,6 +235,7 @@ void ExceptionHandler::Initialize(
     // Load this library dynamically to not affect existing projects.  Most
     // projects don't link against this directly, it's usually dynamically
     // loaded by dependent code.
+    rpcrt4_module_ = LoadLibrary(L"rpcrt4.dll");
     if (rpcrt4_module_) {
       uuid_create_ = reinterpret_cast<UuidCreate_type>(
           GetProcAddress(rpcrt4_module_, "UuidCreate"));
@@ -369,6 +353,7 @@ ExceptionHandler::~ExceptionHandler() {
     // inside DllMain.
     is_shutdown_ = true;
     ReleaseSemaphore(handler_start_semaphore_, 1, NULL);
+    const int kWaitForHandlerThreadMs = 60000;
     WaitForSingleObject(handler_thread_, kWaitForHandlerThreadMs);
 #else
     TerminateThread(handler_thread_, 1);
@@ -398,12 +383,12 @@ bool ExceptionHandler::RequestUpload(DWORD crash_id) {
 
 // static
 DWORD ExceptionHandler::ExceptionHandlerThreadMain(void* lpParameter) {
-  ExceptionHandler* self = reinterpret_cast<ExceptionHandler *>(lpParameter);
+  ExceptionHandler* self = reinterpret_cast<ExceptionHandler*>(lpParameter);
   assert(self);
   assert(self->handler_start_semaphore_ != NULL);
   assert(self->handler_finish_semaphore_ != NULL);
 
-  while (true) {
+  for (;;) {
     if (WaitForSingleObject(self->handler_start_semaphore_, INFINITE) ==
         WAIT_OBJECT_0) {
       // Perform the requested action.
@@ -496,7 +481,14 @@ LONG ExceptionHandler::HandleException(EXCEPTION_POINTERS* exinfo) {
   DWORD code = exinfo->ExceptionRecord->ExceptionCode;
   LONG action;
   bool is_debug_exception = (code == EXCEPTION_BREAKPOINT) ||
-                            (code == EXCEPTION_SINGLE_STEP);
+                            (code == EXCEPTION_SINGLE_STEP) ||
+                            (code == DBG_PRINTEXCEPTION_C) ||
+                            (code == DBG_PRINTEXCEPTION_WIDE_C);
+
+  if (code == EXCEPTION_INVALID_HANDLE &&
+      current_handler->consume_invalid_handle_exceptions_) {
+    return EXCEPTION_CONTINUE_EXECUTION;
+  }
 
   bool success = false;
 
@@ -773,11 +765,12 @@ bool ExceptionHandler::WriteMinidumpForException(EXCEPTION_POINTERS* exinfo) {
 }
 
 // static
-bool ExceptionHandler::WriteMinidump(const wstring &dump_path,
+bool ExceptionHandler::WriteMinidump(const wstring& dump_path,
                                      MinidumpCallback callback,
-                                     void* callback_context) {
+                                     void* callback_context,
+                                     MINIDUMP_TYPE dump_type) {
   ExceptionHandler handler(dump_path, NULL, callback, callback_context,
-                           HANDLER_NONE);
+                           HANDLER_NONE, dump_type, (HANDLE)NULL, NULL);
   return handler.WriteMinidump();
 }
 
@@ -786,10 +779,13 @@ bool ExceptionHandler::WriteMinidumpForChild(HANDLE child,
                                              DWORD child_blamed_thread,
                                              const wstring& dump_path,
                                              MinidumpCallback callback,
-                                             void* callback_context) {
+                                             void* callback_context,
+                                             MINIDUMP_TYPE dump_type) {
   EXCEPTION_RECORD ex;
   CONTEXT ctx;
   EXCEPTION_POINTERS exinfo = { NULL, NULL };
+  // As documented on MSDN, on failure SuspendThread returns (DWORD) -1
+  const DWORD kFailedToSuspendThread = static_cast<DWORD>(-1);
   DWORD last_suspend_count = kFailedToSuspendThread;
   HANDLE child_thread_handle = OpenThread(THREAD_GET_CONTEXT |
                                           THREAD_QUERY_INFORMATION |
@@ -817,7 +813,7 @@ bool ExceptionHandler::WriteMinidumpForChild(HANDLE child,
   }
 
   ExceptionHandler handler(dump_path, NULL, callback, callback_context,
-                           HANDLER_NONE);
+                           HANDLER_NONE, dump_type, (HANDLE)NULL, NULL);
   bool success = handler.WriteMinidumpWithExceptionForProcess(
       child_blamed_thread,
       exinfo.ExceptionRecord ? &exinfo : NULL,
@@ -913,47 +909,6 @@ BOOL CALLBACK ExceptionHandler::MinidumpWriteDumpCallback(
   return FALSE;
 }
 
-void TranslateOffset(DWORD64 absoluteoffset, DWORD64 *offset, string *modulename)
-{
-    HMODULE hMods[256];
-    MODULEINFO moduleInfo = {0};
-    DWORD cbNeeded;
-    WCHAR ModuleName[MAX_PATH];
-    int i;
-
-    *offset = 0;
-    modulename->clear();
-    if (EnumProcessModules(GetCurrentProcess(), hMods, sizeof(hMods), &cbNeeded))
-    {
-        for ( i = 0; !*offset && i < (cbNeeded / sizeof(HMODULE)); i++)
-        {
-            if (GetModuleInformation(GetCurrentProcess(), hMods[i], &moduleInfo, sizeof(moduleInfo)))
-            {
-                *offset = (DWORD64)absoluteoffset - (DWORD64)moduleInfo.lpBaseOfDll;
-                if ((*offset >= 0) && (*offset < (DWORD64)moduleInfo.SizeOfImage))
-                {
-                    int s;
-                    if ((s = GetModuleFileNameW(hMods[i], ModuleName, MAX_PATH)) && s != MAX_PATH)
-                    {
-                        mega::MegaApi::utf16ToUtf8(ModuleName, s, modulename);
-                        int index = modulename->find_last_of("\\");
-                        if (index <= string::npos && index < (modulename->size() - 1))
-                        {
-                            *modulename = modulename->substr(index + 1, modulename->size() - (index + 1));
-                        }
-                        return;
-                    }
-                }
-                else
-                {
-                    *offset = 0;
-                }
-            }
-        }
-    }
-}
-
-
 bool ExceptionHandler::WriteMinidumpWithExceptionForProcess(
     DWORD requesting_thread_id,
     EXCEPTION_POINTERS* exinfo,
@@ -1183,7 +1138,9 @@ bool ExceptionHandler::WriteMinidumpWithExceptionForProcess(
 #if defined(_M_IX86)
           exinfo->ContextRecord->Eip;
 #elif defined(_M_AMD64)
-        exinfo->ContextRecord->Rip;
+          exinfo->ContextRecord->Rip;
+#elif defined(_M_ARM64)
+          exinfo->ContextRecord->Pc;
 #else
 #error Unsupported platform
 #endif
diff --git a/src/MEGASync/google_breakpad/client/windows/handler/exception_handler.gyp b/src/MEGASync/google_breakpad/client/windows/handler/exception_handler.gyp
index 77293627..c5733277 100644
--- a/src/MEGASync/google_breakpad/client/windows/handler/exception_handler.gyp
+++ b/src/MEGASync/google_breakpad/client/windows/handler/exception_handler.gyp
@@ -1,5 +1,4 @@
-# Copyright (c) 2010, Google Inc.
-# All rights reserved.
+# Copyright 2010 Google Inc. All rights reserved.
 #
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions are
@@ -29,7 +28,7 @@
 
 {
   'includes': [
-    '../build/common.gypi',
+    '../../../build/common.gypi',
   ],
   'targets': [
     {
diff --git a/src/MEGASync/google_breakpad/client/windows/handler/exception_handler.h b/src/MEGASync/google_breakpad/client/windows/handler/exception_handler.h
index c88d726c..eb5adaac 100644
--- a/src/MEGASync/google_breakpad/client/windows/handler/exception_handler.h
+++ b/src/MEGASync/google_breakpad/client/windows/handler/exception_handler.h
@@ -57,11 +57,9 @@
 #define CLIENT_WINDOWS_HANDLER_EXCEPTION_HANDLER_H__
 
 #include <stdlib.h>
-#include <Windows.h>
-#include <DbgHelp.h>
+#include <windows.h>
+#include <dbghelp.h>
 #include <rpc.h>
-#include <sstream>
-#include <QApplication>
 
 #pragma warning(push)
 // Disable exception handler warnings.
@@ -220,7 +218,7 @@ class ExceptionHandler {
 
   // Get and set the minidump path.
   wstring dump_path() const { return dump_path_; }
-  void set_dump_path(const wstring &dump_path) {
+  void set_dump_path(const wstring& dump_path) {
     dump_path_ = dump_path;
     dump_path_c_ = dump_path_.c_str();
     UpdateNextID();  // Necessary to put dump_path_ in next_minidump_path_.
@@ -239,8 +237,9 @@ class ExceptionHandler {
 
   // Convenience form of WriteMinidump which does not require an
   // ExceptionHandler instance.
-  static bool WriteMinidump(const wstring &dump_path,
-                            MinidumpCallback callback, void* callback_context);
+  static bool WriteMinidump(const wstring& dump_path,
+                            MinidumpCallback callback, void* callback_context,
+                            MINIDUMP_TYPE dump_type = MiniDumpNormal);
 
   // Write a minidump of |child| immediately.  This can be used to
   // capture the execution state of |child| independently of a crash.
@@ -251,7 +250,8 @@ class ExceptionHandler {
                                     DWORD child_blamed_thread,
                                     const wstring& dump_path,
                                     MinidumpCallback callback,
-                                    void* callback_context);
+                                    void* callback_context,
+                                    MINIDUMP_TYPE dump_type = MiniDumpNormal);
 
   // Get the thread ID of the thread requesting the dump (either the exception
   // thread or any other thread that called WriteMinidump directly).  This
@@ -265,6 +265,15 @@ class ExceptionHandler {
     handle_debug_exceptions_ = handle_debug_exceptions;
   }
 
+  // Controls behavior of EXCEPTION_INVALID_HANDLE.
+  bool get_consume_invalid_handle_exceptions() const {
+    return consume_invalid_handle_exceptions_;
+  }
+  void set_consume_invalid_handle_exceptions(
+      bool consume_invalid_handle_exceptions) {
+    consume_invalid_handle_exceptions_ = consume_invalid_handle_exceptions;
+  }
+
   // Returns whether out-of-process dump generation is used or not.
   bool IsOutOfProcess() const { return crash_generation_client_.get() != NULL; }
 
@@ -299,17 +308,6 @@ class ExceptionHandler {
       CONST PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam,
       CONST PMINIDUMP_CALLBACK_INFORMATION CallbackParam);
 
-  typedef BOOL (WINAPI *StackWalk64_type)(
-          DWORD MachineType,
-          HANDLE hProcess,
-          HANDLE hThread,
-          LPSTACKFRAME64 StackFrame,
-          PVOID ContextRecord,
-          PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemoryRoutine,
-          PFUNCTION_TABLE_ACCESS_ROUTINE64 FunctionTableAccessRoutine,
-          PGET_MODULE_BASE_ROUTINE64 GetModuleBaseRoutine,
-          PTRANSLATE_ADDRESS_ROUTINE64 TranslateAddress);
-
   // Function pointer type for UuidCreate, which is looked up dynamically.
   typedef RPC_STATUS (RPC_ENTRY *UuidCreate_type)(UUID* Uuid);
 
@@ -485,6 +483,10 @@ class ExceptionHandler {
   // to not interfere with debuggers.
   bool handle_debug_exceptions_;
 
+  // If true, the handler will consume any EXCEPTION_INVALID_HANDLE exceptions.
+  // Leave this false (the default) to handle these exceptions as normal.
+  bool consume_invalid_handle_exceptions_;
+
   // Callers can request additional memory regions to be included in
   // the dump.
   AppMemoryList app_memory_info_;
@@ -511,8 +513,8 @@ class ExceptionHandler {
   static volatile LONG instance_count_;
 
   // disallow copy ctor and operator=
-  explicit ExceptionHandler(const ExceptionHandler &);
-  void operator=(const ExceptionHandler &);
+  explicit ExceptionHandler(const ExceptionHandler&);
+  void operator=(const ExceptionHandler&);
 };
 
 }  // namespace google_breakpad
diff --git a/src/MEGASync/google_breakpad/client/windows/sender/crash_report_sender.cc b/src/MEGASync/google_breakpad/client/windows/sender/crash_report_sender.cc
index ecf626d8..7fc64483 100644
--- a/src/MEGASync/google_breakpad/client/windows/sender/crash_report_sender.cc
+++ b/src/MEGASync/google_breakpad/client/windows/sender/crash_report_sender.cc
@@ -45,12 +45,12 @@ namespace google_breakpad {
 
 static const char kCheckpointSignature[] = "GBP1\n";
 
-CrashReportSender::CrashReportSender(const wstring &checkpoint_file)
+CrashReportSender::CrashReportSender(const wstring& checkpoint_file)
     : checkpoint_file_(checkpoint_file),
       max_reports_per_day_(-1),
       last_sent_date_(-1),
       reports_sent_(0) {
-  FILE *fd;
+  FILE* fd;
   if (OpenCheckpointFile(L"r", &fd) == 0) {
     ReadCheckpoint(fd);
     fclose(fd);
@@ -58,8 +58,8 @@ CrashReportSender::CrashReportSender(const wstring &checkpoint_file)
 }
 
 ReportResult CrashReportSender::SendCrashReport(
-    const wstring &url, const map<wstring, wstring> &parameters,
-    const wstring &dump_file_name, wstring *report_code) {
+    const wstring& url, const map<wstring, wstring>& parameters,
+    const map<wstring, wstring>& files, wstring* report_code) {
   int today = GetCurrentDate();
   if (today == last_sent_date_ &&
       max_reports_per_day_ != -1 &&
@@ -68,8 +68,8 @@ ReportResult CrashReportSender::SendCrashReport(
   }
 
   int http_response = 0;
-  bool result = HTTPUpload::SendRequest(
-    url, parameters, dump_file_name, L"upload_file_minidump", NULL, report_code,
+  bool result = HTTPUpload::SendMultipartPostRequest(
+    url, parameters, files, NULL, report_code,
     &http_response);
 
   if (result) {
@@ -82,7 +82,7 @@ ReportResult CrashReportSender::SendCrashReport(
   }
 }
 
-void CrashReportSender::ReadCheckpoint(FILE *fd) {
+void CrashReportSender::ReadCheckpoint(FILE* fd) {
   char buf[128];
   if (!fgets(buf, sizeof(buf), fd) ||
       strcmp(buf, kCheckpointSignature) != 0) {
@@ -108,7 +108,7 @@ void CrashReportSender::ReportSent(int today) {
   ++reports_sent_;
 
   // Update the checkpoint file
-  FILE *fd;
+  FILE* fd;
   if (OpenCheckpointFile(L"w", &fd) == 0) {
     fputs(kCheckpointSignature, fd);
     fprintf(fd, "%d\n", last_sent_date_);
@@ -124,7 +124,7 @@ int CrashReportSender::GetCurrentDate() const {
       system_time.wDay;
 }
 
-int CrashReportSender::OpenCheckpointFile(const wchar_t *mode, FILE **fd) {
+int CrashReportSender::OpenCheckpointFile(const wchar_t* mode, FILE** fd) {
   if (checkpoint_file_.empty()) {
     return ENOENT;
   }
diff --git a/src/MEGASync/google_breakpad/client/windows/sender/crash_report_sender.gyp b/src/MEGASync/google_breakpad/client/windows/sender/crash_report_sender.gyp
index e4db3a86..dc8583a0 100644
--- a/src/MEGASync/google_breakpad/client/windows/sender/crash_report_sender.gyp
+++ b/src/MEGASync/google_breakpad/client/windows/sender/crash_report_sender.gyp
@@ -1,5 +1,4 @@
-# Copyright (c) 2010, Google Inc.
-# All rights reserved.
+# Copyright 2010 Google Inc. All rights reserved.
 #
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions are
@@ -29,7 +28,7 @@
 
 {
   'includes': [
-    '../build/common.gypi',
+    '../../../build/common.gypi',
   ],
   'targets': [
     {
diff --git a/src/MEGASync/google_breakpad/client/windows/sender/crash_report_sender.h b/src/MEGASync/google_breakpad/client/windows/sender/crash_report_sender.h
index da1ed0af..e6055857 100644
--- a/src/MEGASync/google_breakpad/client/windows/sender/crash_report_sender.h
+++ b/src/MEGASync/google_breakpad/client/windows/sender/crash_report_sender.h
@@ -65,7 +65,7 @@ class CrashReportSender {
   // If checkpoint_file is non-empty, breakpad will persist crash report
   // state to this file.  A checkpoint file is required for
   // set_max_reports_per_day() to function properly.
-  explicit CrashReportSender(const wstring &checkpoint_file);
+  explicit CrashReportSender(const wstring& checkpoint_file);
   ~CrashReportSender() {}
 
   // Sets the maximum number of crash reports that will be sent in a 24-hour
@@ -77,7 +77,7 @@ class CrashReportSender {
 
   int max_reports_per_day() const { return max_reports_per_day_; }
 
-  // Sends the specified minidump file, along with the map of
+  // Sends the specified files, along with the map of
   // name value pairs, as a multipart POST request to the given URL.
   // Parameter names must contain only printable ASCII characters,
   // and may not contain a quote (") character.
@@ -87,14 +87,14 @@ class CrashReportSender {
   // the return value is RESULT_SUCCEEDED), a code uniquely identifying the
   // report will be returned in report_code.
   // (Otherwise, report_code will be unchanged.)
-  ReportResult SendCrashReport(const wstring &url,
-                               const map<wstring, wstring> &parameters,
-                               const wstring &dump_file_name,
-                               wstring *report_code);
+  ReportResult SendCrashReport(const wstring& url,
+                               const map<wstring, wstring>& parameters,
+                               const map<wstring, wstring>& files,
+                               wstring* report_code);
 
  private:
   // Reads persistent state from a checkpoint file.
-  void ReadCheckpoint(FILE *fd);
+  void ReadCheckpoint(FILE* fd);
 
   // Called when a new report has been sent, to update the checkpoint state.
   void ReportSent(int today);
@@ -104,7 +104,7 @@ class CrashReportSender {
 
   // Opens the checkpoint file with the specified mode.
   // Returns zero on success, or an error code on failure.
-  int OpenCheckpointFile(const wchar_t *mode, FILE **fd);
+  int OpenCheckpointFile(const wchar_t* mode, FILE** fd);
 
   wstring checkpoint_file_;
   int max_reports_per_day_;
@@ -114,8 +114,8 @@ class CrashReportSender {
   int reports_sent_;
 
   // Disallow copy constructor and operator=
-  explicit CrashReportSender(const CrashReportSender &);
-  void operator=(const CrashReportSender &);
+  explicit CrashReportSender(const CrashReportSender&);
+  void operator=(const CrashReportSender&);
 };
 
 }  // namespace google_breakpad
diff --git a/src/MEGASync/google_breakpad/client/windows/tests/crash_generation_app/crash_generation_app.cc b/src/MEGASync/google_breakpad/client/windows/tests/crash_generation_app/crash_generation_app.cc
index 12449ce9..0d837e52 100644
--- a/src/MEGASync/google_breakpad/client/windows/tests/crash_generation_app/crash_generation_app.cc
+++ b/src/MEGASync/google_breakpad/client/windows/tests/crash_generation_app/crash_generation_app.cc
@@ -73,7 +73,7 @@ BOOL InitInstance(HINSTANCE, int);
 LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
 INT_PTR CALLBACK About(HWND, UINT, WPARAM, LPARAM);
 
-static int kCustomInfoCount = 2;
+static size_t kCustomInfoCount = 2;
 static CustomInfoEntry kCustomInfoEntries[] = {
     CustomInfoEntry(L"prod", L"CrashTestApp"),
     CustomInfoEntry(L"ver", L"1.0"),
@@ -197,8 +197,8 @@ bool ShowDumpResults(const wchar_t* dump_path,
   return succeeded;
 }
 
-static void _cdecl ShowClientConnected(void* context,
-                                       const ClientInfo* client_info) {
+static void ShowClientConnected(void* context,
+                                const ClientInfo* client_info) {
   TCHAR* line = new TCHAR[kMaximumLineLength];
   line[0] = _T('\0');
   int result = swprintf_s(line,
@@ -214,9 +214,9 @@ static void _cdecl ShowClientConnected(void* context,
   QueueUserWorkItem(AppendTextWorker, line, WT_EXECUTEDEFAULT);
 }
 
-static void _cdecl ShowClientCrashed(void* context,
-                                     const ClientInfo* client_info,
-                                     const wstring* dump_path) {
+static void ShowClientCrashed(void* context,
+                              const ClientInfo* client_info,
+                              const wstring* dump_path) {
   TCHAR* line = new TCHAR[kMaximumLineLength];
   line[0] = _T('\0');
   int result = swprintf_s(line,
@@ -259,8 +259,8 @@ static void _cdecl ShowClientCrashed(void* context,
   QueueUserWorkItem(AppendTextWorker, line, WT_EXECUTEDEFAULT);
 }
 
-static void _cdecl ShowClientExited(void* context,
-                                    const ClientInfo* client_info) {
+static void ShowClientExited(void* context,
+                             const ClientInfo* client_info) {
   TCHAR* line = new TCHAR[kMaximumLineLength];
   line[0] = _T('\0');
   int result = swprintf_s(line,
@@ -283,6 +283,12 @@ void CrashServerStart() {
   }
 
   std::wstring dump_path = L"C:\\Dumps\\";
+
+  if (_wmkdir(dump_path.c_str()) && (errno != EEXIST)) {
+    MessageBoxW(NULL, L"Unable to create dump directory", L"Dumper", MB_OK);
+    return;
+  }
+
   crash_server = new CrashGenerationServer(kPipeName,
                                            NULL,
                                            ShowClientConnected,
@@ -357,13 +363,7 @@ LRESULT CALLBACK WndProc(HWND wnd,
   PAINTSTRUCT ps;
   HDC hdc;
 
-#pragma warning(push)
-#pragma warning(disable:4312)
-  // Disable warning C4312: 'type cast' : conversion from 'LONG' to
-  // 'HINSTANCE' of greater size.
-  // The value returned by GetwindowLong in the case below returns unsigned.
-  HINSTANCE instance = (HINSTANCE)GetWindowLong(wnd, GWL_HINSTANCE);
-#pragma warning(pop)
+  HINSTANCE instance = (HINSTANCE)GetWindowLongPtr(wnd, GWLP_HINSTANCE);
 
   switch (message) {
     case WM_COMMAND:
diff --git a/src/MEGASync/google_breakpad/client/windows/tests/crash_generation_app/crash_generation_app.gyp b/src/MEGASync/google_breakpad/client/windows/tests/crash_generation_app/crash_generation_app.gyp
index b5dabc54..3ce307da 100644
--- a/src/MEGASync/google_breakpad/client/windows/tests/crash_generation_app/crash_generation_app.gyp
+++ b/src/MEGASync/google_breakpad/client/windows/tests/crash_generation_app/crash_generation_app.gyp
@@ -1,5 +1,4 @@
-# Copyright (c) 2010, Google Inc.
-# All rights reserved.
+# Copyright 2010 Google Inc. All rights reserved.
 #
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions are
@@ -29,7 +28,7 @@
 
 {
   'includes': [
-    '../../build/common.gypi',
+    '../../../../build/common.gypi',
   ],
   'targets': [
     {
@@ -45,6 +44,9 @@
         'resource.h',
         'small.ico',
       ],
+      'libraries': [
+        'user32.lib',
+      ],
       'dependencies': [
         '../../breakpad_client.gyp:common',
         '../../crash_generation/crash_generation.gyp:crash_generation_server',
diff --git a/src/MEGASync/google_breakpad/client/windows/unittests/client_tests.gyp b/src/MEGASync/google_breakpad/client/windows/unittests/client_tests.gyp
index 6dc9fe71..768f8fd8 100644
--- a/src/MEGASync/google_breakpad/client/windows/unittests/client_tests.gyp
+++ b/src/MEGASync/google_breakpad/client/windows/unittests/client_tests.gyp
@@ -1,5 +1,4 @@
-# Copyright (c) 2010, Google Inc.
-# All rights reserved.
+# Copyright 2010 Google Inc. All rights reserved.
 #
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions are
@@ -29,7 +28,7 @@
 
 {
   'includes': [
-    '../build/common.gypi',
+    '../../../build/common.gypi',
   ],
   'targets': [
     {
@@ -69,9 +68,13 @@
       'sources': [
         '<(DEPTH)/common/string_conversion.cc',
         '<(DEPTH)/processor/basic_code_modules.cc',
+        '<(DEPTH)/processor/convert_old_arm64_context.cc',
+        '<(DEPTH)/processor/dump_context.cc',
+        '<(DEPTH)/processor/dump_object.cc',
         '<(DEPTH)/processor/logging.cc',
         '<(DEPTH)/processor/minidump.cc',
         '<(DEPTH)/processor/pathname_stripper.cc',
+        '<(DEPTH)/processor/proc_maps_linux.cc',
       ]
     }
   ],
diff --git a/src/MEGASync/google_breakpad/client/windows/unittests/crash_generation_server_test.cc b/src/MEGASync/google_breakpad/client/windows/unittests/crash_generation_server_test.cc
index cf95d43f..09f2dd20 100644
--- a/src/MEGASync/google_breakpad/client/windows/unittests/crash_generation_server_test.cc
+++ b/src/MEGASync/google_breakpad/client/windows/unittests/crash_generation_server_test.cc
@@ -28,9 +28,7 @@
 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 
-#include "testing/gtest/include/gtest/gtest.h"
-#include "testing/include/gmock/gmock.h"
-
+#include "breakpad_googletest_includes.h"
 #include "client/windows/crash_generation/crash_generation_server.h"
 #include "client/windows/common/ipc_protocol.h"
 
@@ -50,9 +48,8 @@ const DWORD kPipeFlagsAndAttributes = SECURITY_IDENTIFICATION |
 
 const DWORD kPipeMode = PIPE_READMODE_MESSAGE;
 
-int kCustomInfoCount = 2;
-
-google_breakpad::CustomInfoEntry kCustomInfoEntries[] = {
+#define arraysize(f) (sizeof(f) / sizeof(*f))
+const google_breakpad::CustomInfoEntry kCustomInfoEntries[] = {
     google_breakpad::CustomInfoEntry(L"prod", L"CrashGenerationServerTest"),
     google_breakpad::CustomInfoEntry(L"ver", L"1.0"),
 };
@@ -165,7 +162,7 @@ class CrashGenerationServerTest : public ::testing::Test {
     }
 
     google_breakpad::CustomClientInfo custom_info = {kCustomInfoEntries,
-                                                     kCustomInfoCount};
+                                                     arraysize(kCustomInfoEntries)};
 
     google_breakpad::ProtocolMessage msg(
       fault_type == SEND_INVALID_REGISTRATION ?
diff --git a/src/MEGASync/google_breakpad/client/windows/unittests/dump_analysis.cc b/src/MEGASync/google_breakpad/client/windows/unittests/dump_analysis.cc
index 6bf85471..0bb8f6c4 100644
--- a/src/MEGASync/google_breakpad/client/windows/unittests/dump_analysis.cc
+++ b/src/MEGASync/google_breakpad/client/windows/unittests/dump_analysis.cc
@@ -31,8 +31,8 @@
 #include <objbase.h>
 #include <dbghelp.h>
 
+#include "breakpad_googletest_includes.h"
 #include "client/windows/unittests/dump_analysis.h"  // NOLINT
-#include "testing/gtest/include/gtest/gtest.h"
 
 DumpAnalysis::~DumpAnalysis() {
   if (dump_file_view_ != NULL) {
@@ -127,8 +127,8 @@ size_t DumpAnalysis::GetStreamImpl(ULONG stream_number, void** stream) const {
   return ret ? memory_list_size : 0;
 }
 
-bool DumpAnalysis::HasMemoryImpl(const void *addr_in, size_t structuresize,
-                                 void **structure) const {
+bool DumpAnalysis::HasMemoryImpl(const void* addr_in, size_t structuresize,
+                                 void** structure) const {
   uintptr_t address = reinterpret_cast<uintptr_t>(addr_in);
   MINIDUMP_MEMORY_LIST* memory_list = NULL;
   size_t memory_list_size = GetStream(MemoryListStream, &memory_list);
diff --git a/src/MEGASync/google_breakpad/client/windows/unittests/exception_handler_death_test.cc b/src/MEGASync/google_breakpad/client/windows/unittests/exception_handler_death_test.cc
index 079ca3d6..04034e8d 100644
--- a/src/MEGASync/google_breakpad/client/windows/unittests/exception_handler_death_test.cc
+++ b/src/MEGASync/google_breakpad/client/windows/unittests/exception_handler_death_test.cc
@@ -52,7 +52,7 @@ const char kSuccessIndicator[] = "success";
 const char kFailureIndicator[] = "failure";
 
 // Utility function to test for a path's existence.
-BOOL DoesPathExist(const TCHAR *path_name);
+BOOL DoesPathExist(const TCHAR* path_name);
 
 enum OutOfProcGuarantee {
   OUT_OF_PROC_GUARANTEED,
@@ -82,7 +82,7 @@ void ExceptionHandlerDeathTest::SetUp() {
   // The test case name is exposed as a c-style string,
   // convert it to a wchar_t string.
   int dwRet = MultiByteToWideChar(CP_ACP, 0, test_info->name(),
-                                  strlen(test_info->name()),
+                                  static_cast<int>(strlen(test_info->name())),
                                   test_name_wide,
                                   MAX_PATH);
   if (!dwRet) {
@@ -92,7 +92,7 @@ void ExceptionHandlerDeathTest::SetUp() {
   CreateDirectory(temp_path_, NULL);
 }
 
-BOOL DoesPathExist(const TCHAR *path_name) {
+BOOL DoesPathExist(const TCHAR* path_name) {
   DWORD flags = GetFileAttributes(path_name);
   if (flags == INVALID_FILE_ATTRIBUTES) {
     return FALSE;
@@ -135,15 +135,15 @@ TEST_F(ExceptionHandlerDeathTest, InProcTest) {
   // Disable GTest SEH handler
   testing::DisableExceptionHandlerInScope disable_exception_handler;
 
-  int *i = NULL;
+  int* i = NULL;
   ASSERT_DEATH((*i)++, kSuccessIndicator);
 }
 
 static bool gDumpCallbackCalled = false;
 
-void clientDumpCallback(void *dump_context,
-                        const google_breakpad::ClientInfo *client_info,
-                        const std::wstring *dump_path) {
+void clientDumpCallback(void* dump_context,
+                        const google_breakpad::ClientInfo* client_info,
+                        const std::wstring* dump_path) {
   gDumpCallbackCalled = true;
 }
 
@@ -152,7 +152,7 @@ void ExceptionHandlerDeathTest::DoCrashAccessViolation(
   scoped_ptr<google_breakpad::ExceptionHandler> exc;
 
   if (out_of_proc_guarantee == OUT_OF_PROC_GUARANTEED) {
-    google_breakpad::CrashGenerationClient *client =
+    google_breakpad::CrashGenerationClient* client =
         new google_breakpad::CrashGenerationClient(kPipeName,
                                                    MiniDumpNormal,
                                                    NULL);  // custom_info
@@ -184,7 +184,7 @@ void ExceptionHandlerDeathTest::DoCrashAccessViolation(
   // if it's not true we'll still get an error rather than the crash
   // being expected.
   ASSERT_TRUE(exc->IsOutOfProcess());
-  int *i = NULL;
+  int* i = NULL;
   printf("%d\n", (*i)++);
 }
 
@@ -283,7 +283,7 @@ TEST_F(ExceptionHandlerDeathTest, PureVirtualCallTest) {
   EXPECT_EXIT(DoCrashPureVirtualCall(), ::testing::ExitedWithCode(0), "");
 }
 
-wstring find_minidump_in_directory(const wstring &directory) {
+wstring find_minidump_in_directory(const wstring& directory) {
   wstring search_path = directory + L"\\*";
   WIN32_FIND_DATA find_data;
   HANDLE find_handle = FindFirstFileW(search_path.c_str(), &find_data);
@@ -293,8 +293,8 @@ wstring find_minidump_in_directory(const wstring &directory) {
   wstring filename;
   do {
     const wchar_t extension[] = L".dmp";
-    const int extension_length = sizeof(extension) / sizeof(extension[0]) - 1;
-    const int filename_length = wcslen(find_data.cFileName);
+    const size_t extension_length = sizeof(extension) / sizeof(extension[0]) - 1;
+    const size_t filename_length = wcslen(find_data.cFileName);
     if (filename_length > extension_length &&
     wcsncmp(extension,
             find_data.cFileName + filename_length - extension_length,
@@ -357,8 +357,8 @@ TEST_F(ExceptionHandlerDeathTest, InstructionPointerMemory) {
 
   // Read the minidump. Locate the exception record and the
   // memory list, and then ensure that there is a memory region
-  // in the memory list that covers the instruction pointer from
-  // the exception record.
+  // in the memory list that covers at least 128 bytes on either
+  // side of the instruction pointer from the exception record.
   {
     Minidump minidump(minidump_filename);
     ASSERT_TRUE(minidump.Read());
@@ -379,18 +379,23 @@ TEST_F(ExceptionHandlerDeathTest, InstructionPointerMemory) {
         memory_list->GetMemoryRegionForAddress(instruction_pointer);
     ASSERT_TRUE(region);
 
-    EXPECT_EQ(kMemorySize, region->GetSize());
+    EXPECT_LE(kMemorySize, region->GetSize());
     const uint8_t* bytes = region->GetMemory();
     ASSERT_TRUE(bytes);
 
+    uint64_t ip_offset = instruction_pointer - region->GetBase();
+    EXPECT_GE(region->GetSize() - kOffset, ip_offset);
+    EXPECT_LE(kOffset, ip_offset);
+
     uint8_t prefix_bytes[kOffset];
     uint8_t suffix_bytes[kMemorySize - kOffset - sizeof(instructions)];
     memset(prefix_bytes, 0, sizeof(prefix_bytes));
     memset(suffix_bytes, 0, sizeof(suffix_bytes));
-    EXPECT_EQ(0, memcmp(bytes, prefix_bytes, sizeof(prefix_bytes)));
-    EXPECT_EQ(0, memcmp(bytes + kOffset, instructions, sizeof(instructions)));
-    EXPECT_EQ(0, memcmp(bytes + kOffset + sizeof(instructions),
-                        suffix_bytes, sizeof(suffix_bytes)));
+    EXPECT_EQ(0, memcmp(bytes + ip_offset - kOffset, prefix_bytes,
+                        sizeof(prefix_bytes)));
+    EXPECT_EQ(0, memcmp(bytes + ip_offset, instructions, sizeof(instructions)));
+    EXPECT_EQ(0, memcmp(bytes + ip_offset + sizeof(instructions), suffix_bytes,
+                        sizeof(suffix_bytes)));
   }
 
   DeleteFileW(minidump_filename_wide.c_str());
diff --git a/src/MEGASync/google_breakpad/client/windows/unittests/exception_handler_nesting_test.cc b/src/MEGASync/google_breakpad/client/windows/unittests/exception_handler_nesting_test.cc
index 3ae1d7cd..e24bd18b 100644
--- a/src/MEGASync/google_breakpad/client/windows/unittests/exception_handler_nesting_test.cc
+++ b/src/MEGASync/google_breakpad/client/windows/unittests/exception_handler_nesting_test.cc
@@ -49,7 +49,7 @@ const char kFilterReturnsFalse[] = "filter_returns_false";
 const char kCallbackReturnsTrue[] = "callback_returns_true";
 const char kCallbackReturnsFalse[] = "callback_returns_false";
 
-bool DoesPathExist(const wchar_t *path_name) {
+bool DoesPathExist(const wchar_t* path_name) {
   DWORD flags = GetFileAttributes(path_name);
   if (flags == INVALID_FILE_ATTRIBUTES) {
     return false;
@@ -128,12 +128,12 @@ bool MinidumpWrittenCallback(const wchar_t* dump_path,
 }
 
 
-void DoCrash(const char *message) {
+void DoCrash(const char* message) {
   if (message) {
     fprintf(stderr, "%s", message);
     fflush(stderr);
   }
-  int *i = NULL;
+  int* i = NULL;
   (*i)++;
 
   ASSERT_TRUE(false);
diff --git a/src/MEGASync/google_breakpad/client/windows/unittests/exception_handler_test.cc b/src/MEGASync/google_breakpad/client/windows/unittests/exception_handler_test.cc
index 55275323..51196ca0 100644
--- a/src/MEGASync/google_breakpad/client/windows/unittests/exception_handler_test.cc
+++ b/src/MEGASync/google_breakpad/client/windows/unittests/exception_handler_test.cc
@@ -87,13 +87,13 @@ class ExceptionHandlerTest : public ::testing::Test {
   void DoCrashPureVirtualCall();
 
   // Utility function to test for a path's existence.
-  static BOOL DoesPathExist(const TCHAR *path_name);
+  static BOOL DoesPathExist(const TCHAR* path_name);
 
   // Client callback.
   static void ClientDumpCallback(
-      void *dump_context,
-      const google_breakpad::ClientInfo *client_info,
-      const std::wstring *dump_path);
+      void* dump_context,
+      const google_breakpad::ClientInfo* client_info,
+      const std::wstring* dump_path);
 
   static bool DumpCallback(const wchar_t* dump_path,
                            const wchar_t* minidump_id,
@@ -120,7 +120,7 @@ void ExceptionHandlerTest::SetUp() {
   // THe test case name is exposed to use as a c-style string,
   // But we might be working in UNICODE here on Windows.
   int dwRet = MultiByteToWideChar(CP_ACP, 0, test_info->name(),
-                                  strlen(test_info->name()),
+                                  static_cast<int>(strlen(test_info->name())),
                                   test_name_wide,
                                   MAX_PATH);
   if (!dwRet) {
@@ -141,7 +141,7 @@ void ExceptionHandlerTest::TearDown() {
   }
 }
 
-BOOL ExceptionHandlerTest::DoesPathExist(const TCHAR *path_name) {
+BOOL ExceptionHandlerTest::DoesPathExist(const TCHAR* path_name) {
   DWORD flags = GetFileAttributes(path_name);
   if (flags == INVALID_FILE_ATTRIBUTES) {
     return FALSE;
@@ -151,9 +151,9 @@ BOOL ExceptionHandlerTest::DoesPathExist(const TCHAR *path_name) {
 
 // static
 void ExceptionHandlerTest::ClientDumpCallback(
-    void *dump_context,
-    const google_breakpad::ClientInfo *client_info,
-    const wstring *dump_path) {
+    void* dump_context,
+    const google_breakpad::ClientInfo* client_info,
+    const wstring* dump_path) {
   dump_file = *dump_path;
   // Create the full dump file name from the dump path.
   full_dump_file = dump_file.substr(0, dump_file.length() - 4) + L"-full.dmp";
@@ -174,7 +174,7 @@ bool ExceptionHandlerTest::DumpCallback(const wchar_t* dump_path,
 }
 
 void ExceptionHandlerTest::DoCrashInvalidParameter() {
-  google_breakpad::ExceptionHandler *exc =
+  google_breakpad::ExceptionHandler* exc =
       new google_breakpad::ExceptionHandler(
           temp_path_, NULL, NULL, NULL,
           google_breakpad::ExceptionHandler::HANDLER_INVALID_PARAMETER,
@@ -206,7 +206,7 @@ struct PureVirtualCall : public PureVirtualCallBase {
 };
 
 void ExceptionHandlerTest::DoCrashPureVirtualCall() {
-  google_breakpad::ExceptionHandler *exc =
+  google_breakpad::ExceptionHandler* exc =
       new google_breakpad::ExceptionHandler(
           temp_path_, NULL, NULL, NULL,
           google_breakpad::ExceptionHandler::HANDLER_PURECALL,
@@ -247,6 +247,7 @@ TEST_F(ExceptionHandlerTest, InvalidParameterMiniDumpTest) {
   EXPECT_EXIT(DoCrashInvalidParameter(), ::testing::ExitedWithCode(0), "");
   ASSERT_TRUE(!dump_file.empty() && !full_dump_file.empty());
   ASSERT_TRUE(DoesPathExist(dump_file.c_str()));
+  ASSERT_TRUE(DoesPathExist(full_dump_file.c_str()));
 
   // Verify the dump for infos.
   DumpAnalysis mini(dump_file);
@@ -318,6 +319,7 @@ TEST_F(ExceptionHandlerTest, PureVirtualCallMiniDumpTest) {
   EXPECT_EXIT(DoCrashPureVirtualCall(), ::testing::ExitedWithCode(0), "");
   ASSERT_TRUE(!dump_file.empty() && !full_dump_file.empty());
   ASSERT_TRUE(DoesPathExist(dump_file.c_str()));
+  ASSERT_TRUE(DoesPathExist(full_dump_file.c_str()));
 
   // Verify the dump for infos.
   DumpAnalysis mini(dump_file);
diff --git a/src/MEGASync/google_breakpad/client/windows/unittests/minidump_test.cc b/src/MEGASync/google_breakpad/client/windows/unittests/minidump_test.cc
index e3097f28..82641125 100644
--- a/src/MEGASync/google_breakpad/client/windows/unittests/minidump_test.cc
+++ b/src/MEGASync/google_breakpad/client/windows/unittests/minidump_test.cc
@@ -31,11 +31,10 @@
 #include <objbase.h>
 #include <dbghelp.h>
 
+#include "breakpad_googletest_includes.h"
 #include "client/windows/crash_generation/minidump_generator.h"
 #include "client/windows/unittests/dump_analysis.h"  // NOLINT
 
-#include "gtest/gtest.h"
-
 namespace {
 
 // Minidump with stacks, PEB, TEB, and unloaded module list.
@@ -94,7 +93,7 @@ class MinidumpTest: public testing::Test {
         STATUS_ACCESS_VIOLATION,  // ExceptionCode
         0,  // ExceptionFlags
         NULL,  // ExceptionRecord;
-        reinterpret_cast<void*>(0xCAFEBABE),  // ExceptionAddress;
+        reinterpret_cast<void*>(static_cast<uintptr_t>(0xCAFEBABE)),  // ExceptionAddress;
         2,  // NumberParameters;
         { EXCEPTION_WRITE_FAULT, reinterpret_cast<ULONG_PTR>(this) }
     };
@@ -104,19 +103,19 @@ class MinidumpTest: public testing::Test {
       &ctx_record,
     };
 
-    MinidumpGenerator generator(dump_path_);
-
+    MinidumpGenerator generator(dump_path_,
+                                ::GetCurrentProcess(),
+                                ::GetCurrentProcessId(),
+                                ::GetCurrentThreadId(),
+                                ::GetCurrentThreadId(),
+                                &ex_ptrs,
+                                NULL,
+                                static_cast<MINIDUMP_TYPE>(flags),
+                                TRUE);
+    generator.GenerateDumpFile(&dump_file_);
+    generator.GenerateFullDumpFile(&full_dump_file_);
     // And write a dump
-    bool result = generator.WriteMinidump(::GetCurrentProcess(),
-                                          ::GetCurrentProcessId(),
-                                          ::GetCurrentThreadId(),
-                                          ::GetCurrentThreadId(),
-                                          &ex_ptrs,
-                                          NULL,
-                                          static_cast<MINIDUMP_TYPE>(flags),
-                                          TRUE,
-                                          &dump_file_,
-                                          &full_dump_file_);
+    bool result = generator.WriteMinidump();
     return result == TRUE;
   }
 
diff --git a/src/MEGASync/google_breakpad/client/windows/unittests/testing.gyp b/src/MEGASync/google_breakpad/client/windows/unittests/testing.gyp
index 3234f46c..0f9f944c 100644
--- a/src/MEGASync/google_breakpad/client/windows/unittests/testing.gyp
+++ b/src/MEGASync/google_breakpad/client/windows/unittests/testing.gyp
@@ -1,5 +1,4 @@
-# Copyright (c) 2010, Google Inc.
-# All rights reserved.
+# Copyright 2010 Google Inc. All rights reserved.
 #
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions are
@@ -29,7 +28,7 @@
 
 {
   'includes': [
-    '../build/common.gypi',
+    '../../../build/common.gypi',
   ],
   'target_defaults': {
   },
@@ -39,11 +38,12 @@
       'type': 'static_library',
       'include_dirs': [
         '<(DEPTH)/testing/include',
-        '<(DEPTH)/testing/gtest',
-        '<(DEPTH)/testing/gtest/include',
+        '<(DEPTH)/testing/googletest/include',
+        '<(DEPTH)/testing/googletest',
+        '<(DEPTH)/testing',
       ],
       'sources': [
-        '<(DEPTH)/testing/gtest/src/gtest-all.cc',
+        '<(DEPTH)/testing/googletest/src/gtest-all.cc',
       ],
       'direct_dependent_settings': {
         'include_dirs': [
@@ -53,31 +53,37 @@
         # Visual C++ implements variadic templates strangely, and
         # VC++2012 broke Google Test by lowering this value. See
         # http://stackoverflow.com/questions/12558327/google-test-in-visual-studio-2012
-        'defines': ['_VARIADIC_MAX=10'],
+        'defines': ['_VARIADIC_MAX=10', '_SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING'],
       },
-      'defines': ['_VARIADIC_MAX=10'],
+      'defines': ['_VARIADIC_MAX=10', '_SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING'],
     },
     {
       'target_name': 'gmock',
       'type': 'static_library',
       'include_dirs': [
         '<(DEPTH)/testing/include',
-        '<(DEPTH)/testing/',
-        '<(DEPTH)/testing/gtest',
-        '<(DEPTH)/testing/gtest/include',
+        '<(DEPTH)/testing/googletest/include',
+        '<(DEPTH)/testing/googletest',
+        '<(DEPTH)/testing/googlemock/include',
+        '<(DEPTH)/testing/googlemock',
+        '<(DEPTH)/testing',
       ],
       'sources': [
-        '<(DEPTH)/testing/src/gmock-all.cc',
-        '<(DEPTH)/testing/src/gmock_main.cc',
+        '<(DEPTH)/testing/googlemock/src/gmock-all.cc',
+        '<(DEPTH)/testing/googletest/src/gtest_main.cc',
       ],
       'direct_dependent_settings': {
         'include_dirs': [
           '<(DEPTH)/testing/include',
-          '<(DEPTH)/testing/gtest/include',
+          '<(DEPTH)/testing/googletest/include',
+          '<(DEPTH)/testing/googletest',
+          '<(DEPTH)/testing/googlemock/include',
+          '<(DEPTH)/testing/googlemock',
+          '<(DEPTH)/testing',
         ],
-        'defines': ['_VARIADIC_MAX=10'],
+        'defines': ['_VARIADIC_MAX=10', '_SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING'],
       },
-      'defines': ['_VARIADIC_MAX=10'],
+      'defines': ['_VARIADIC_MAX=10', '_SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING'],
     },
 
   ],
diff --git a/src/MEGASync/google_breakpad/common/android/breakpad_getcontext.S b/src/MEGASync/google_breakpad/common/android/breakpad_getcontext.S
deleted file mode 100644
index 13f242d8..00000000
--- a/src/MEGASync/google_breakpad/common/android/breakpad_getcontext.S
+++ /dev/null
@@ -1,224 +0,0 @@
-// Copyright (c) 2012, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// A minimalistic implementation of getcontext() to be used by
-// Google Breakpad on Android.
-
-#include "common/android/ucontext_constants.h"
-
-/* int getcontext (ucontext_t *ucp) */
-
-#ifdef __arm__
-
-  .text
-  .global breakpad_getcontext
-  .hidden breakpad_getcontext
-  .type breakpad_getcontext, #function
-  .align 0
-  .fnstart
-breakpad_getcontext:
-
-  /* First, save r4-r11 */
-  add   r1, r0, #(MCONTEXT_GREGS_OFFSET + 4*4)
-  stm   r1, {r4-r11}
-
-  /* r12 is a scratch register, don't save it */
-
-  /* Save sp and lr explicitely. */
-  /* - sp can't be stored with stmia in Thumb-2 */
-  /* - STM instructions that store sp and pc are deprecated in ARM */
-  str   sp, [r0, #(MCONTEXT_GREGS_OFFSET + 13*4)]
-  str   lr, [r0, #(MCONTEXT_GREGS_OFFSET + 14*4)]
-
-  /* Save the caller's address in 'pc' */
-  str   lr, [r0, #(MCONTEXT_GREGS_OFFSET + 15*4)]
-
-  /* Save ucontext_t* pointer accross next call */
-  mov   r4, r0
-
-  /* Call sigprocmask(SIG_BLOCK, NULL, &(ucontext->uc_sigmask)) */
-  mov   r0, #0  /* SIG_BLOCK */
-  mov   r1, #0  /* NULL */
-  add   r2, r4, #UCONTEXT_SIGMASK_OFFSET
-  bl    sigprocmask(PLT)
-
-  /* Intentionally do not save the FPU state here. This is because on
-   * Linux/ARM, one should instead use ptrace(PTRACE_GETFPREGS) or
-   * ptrace(PTRACE_GETVFPREGS) to get it.
-   *
-   * Note that a real implementation of getcontext() would need to save
-   * this here to allow setcontext()/swapcontext() to work correctly.
-   */
-
-  /* Restore the values of r4 and lr */
-  mov   r0, r4
-  ldr   lr, [r0, #(MCONTEXT_GREGS_OFFSET + 14*4)]
-  ldr   r4, [r0, #(MCONTEXT_GREGS_OFFSET +  4*4)]
-
-  /* Return 0 */
-  mov   r0, #0
-  bx    lr
-
-  .fnend
-  .size breakpad_getcontext, . - breakpad_getcontext
-
-#elif defined(__i386__)
-
-  .text
-  .global breakpad_getcontext
-  .hidden breakpad_getcontext
-  .align 4
-  .type breakpad_getcontext, @function
-
-breakpad_getcontext:
-
-  movl 4(%esp), %eax   /* eax = uc */
-
-  /* Save register values */
-  movl %ecx, MCONTEXT_ECX_OFFSET(%eax)
-  movl %edx, MCONTEXT_EDX_OFFSET(%eax)
-  movl %ebx, MCONTEXT_EBX_OFFSET(%eax)
-  movl %edi, MCONTEXT_EDI_OFFSET(%eax)
-  movl %esi, MCONTEXT_ESI_OFFSET(%eax)
-  movl %ebp, MCONTEXT_EBP_OFFSET(%eax)
-
-  movl (%esp), %edx   /* return address */
-  lea  4(%esp), %ecx  /* exclude return address from stack */
-  mov  %edx, MCONTEXT_EIP_OFFSET(%eax)
-  mov  %ecx, MCONTEXT_ESP_OFFSET(%eax)
-
-  xorl %ecx, %ecx
-  movw %fs, %cx
-  mov  %ecx, MCONTEXT_FS_OFFSET(%eax)
-
-  movl $0, MCONTEXT_EAX_OFFSET(%eax)
-
-  /* Save floating point state to fpregstate, then update
-   * the fpregs pointer to point to it */
-  leal UCONTEXT_FPREGS_MEM_OFFSET(%eax), %ecx
-  fnstenv (%ecx)
-  fldenv  (%ecx)
-  mov %ecx, UCONTEXT_FPREGS_OFFSET(%eax)
-
-  /* Save signal mask: sigprocmask(SIGBLOCK, NULL, &uc->uc_sigmask) */
-  leal UCONTEXT_SIGMASK_OFFSET(%eax), %edx
-  xorl %ecx, %ecx
-  push %edx   /* &uc->uc_sigmask */
-  push %ecx   /* NULL */
-  push %ecx   /* SIGBLOCK == 0 on i386 */
-  call sigprocmask@PLT
-  addl $12, %esp
-
-  movl $0, %eax
-  ret
-
-  .size breakpad_getcontext, . - breakpad_getcontext
-
-#elif defined(__mips__)
-
-#if _MIPS_SIM != _ABIO32
-#error "Unsupported mips ISA. Only mips o32 is supported."
-#endif
-
-// This implementation is inspired by implementation of getcontext in glibc.
-#include <asm/asm.h>
-#include <asm/regdef.h>
-#include <asm/fpregdef.h>
-#include <asm/unistd.h> // for __NR_rt_sigprocmask
-
-#define _NSIG8 128 / 8
-#define SIG_BLOCK 1
-
-
-  .text
-LOCALS_NUM = 2	// save gp and ra on stack
-FRAME_SIZE = ((LOCALS_NUM * SZREG) + ALSZ) & ALMASK
-RA_FRAME_OFFSET = FRAME_SIZE - (1 * SZREG)
-GP_FRAME_OFFSET = FRAME_SIZE - (2 * SZREG)
-MCONTEXT_REG_SIZE = 8
-
-NESTED (breakpad_getcontext, FRAME_SIZE, ra)
-  .mask	0x00000000, 0
-  .fmask 0x00000000, 0
-
-  .set noreorder
-  .cpload t9
-  .set reorder
-
-  move a2, sp
-#define _SP a2
-
-  addiu sp, -FRAME_SIZE
-  sw ra, RA_FRAME_OFFSET(sp)
-  sw gp, GP_FRAME_OFFSET(sp)
-
-  sw s0, (16 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
-  sw s1, (17 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
-  sw s2, (18 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
-  sw s3, (19 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
-  sw s4, (20 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
-  sw s5, (21 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
-  sw s6, (22 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
-  sw s7, (23 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
-  sw _SP, (29 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
-  sw fp, (30 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
-  sw ra, (31 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
-  sw ra, MCONTEXT_PC_OFFSET(a0)
-
-#ifdef __mips_hard_float
-  s.d fs0, (20 * MCONTEXT_REG_SIZE + MCONTEXT_FPREGS_OFFSET)(a0)
-  s.d fs1, (22 * MCONTEXT_REG_SIZE + MCONTEXT_FPREGS_OFFSET)(a0)
-  s.d fs2, (24 * MCONTEXT_REG_SIZE + MCONTEXT_FPREGS_OFFSET)(a0)
-  s.d fs3, (26 * MCONTEXT_REG_SIZE + MCONTEXT_FPREGS_OFFSET)(a0)
-  s.d fs4, (28 * MCONTEXT_REG_SIZE + MCONTEXT_FPREGS_OFFSET)(a0)
-  s.d fs5, (30 * MCONTEXT_REG_SIZE + MCONTEXT_FPREGS_OFFSET)(a0)
-
-  cfc1 v1, fcr31
-  sw v1, MCONTEXT_FPC_CSR(a0)
-#endif  // __mips_hard_float
-
-  /* rt_sigprocmask (SIG_BLOCK, NULL, &ucp->uc_sigmask, _NSIG8) */
-  li a3, _NSIG8
-  addu a2, a0, UCONTEXT_SIGMASK_OFFSET
-  move a1, zero
-  li a0, SIG_BLOCK
-  li v0, __NR_rt_sigprocmask
-  syscall
-
-  lw ra, RA_FRAME_OFFSET(sp)
-  lw gp, GP_FRAME_OFFSET(sp)
-  addiu sp, FRAME_SIZE
-  jr ra
-
-END (breakpad_getcontext)
-
-
-#else
-#error "This file has not been ported for your CPU!"
-#endif
diff --git a/src/MEGASync/google_breakpad/common/android/breakpad_getcontext_unittest.cc b/src/MEGASync/google_breakpad/common/android/breakpad_getcontext_unittest.cc
deleted file mode 100644
index c1b69c25..00000000
--- a/src/MEGASync/google_breakpad/common/android/breakpad_getcontext_unittest.cc
+++ /dev/null
@@ -1,94 +0,0 @@
-// Copyright (c) 2012, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#include <sys/ucontext.h>
-
-#include "breakpad_googletest_includes.h"
-#include "common/android/ucontext_constants.h"
-
-TEST(AndroidUContext, GRegsOffset) {
-#ifdef __arm__
-  // There is no gregs[] array on ARM, so compare to the offset of
-  // first register fields, since they're stored in order.
-  ASSERT_EQ(static_cast<size_t>(MCONTEXT_GREGS_OFFSET),
-            offsetof(ucontext_t,uc_mcontext.arm_r0));
-#elif defined(__i386__)
-  ASSERT_EQ(static_cast<size_t>(MCONTEXT_GREGS_OFFSET),
-            offsetof(ucontext_t,uc_mcontext.gregs));
-#define CHECK_REG(x) \
-  ASSERT_EQ(static_cast<size_t>(MCONTEXT_##x##_OFFSET),         \
-            offsetof(ucontext_t,uc_mcontext.gregs[REG_##x]))
-  CHECK_REG(GS);
-  CHECK_REG(FS);
-  CHECK_REG(ES);
-  CHECK_REG(DS);
-  CHECK_REG(EDI);
-  CHECK_REG(ESI);
-  CHECK_REG(EBP);
-  CHECK_REG(ESP);
-  CHECK_REG(EBX);
-  CHECK_REG(EDX);
-  CHECK_REG(ECX);
-  CHECK_REG(EAX);
-  CHECK_REG(TRAPNO);
-  CHECK_REG(ERR);
-  CHECK_REG(EIP);
-  CHECK_REG(CS);
-  CHECK_REG(EFL);
-  CHECK_REG(UESP);
-  CHECK_REG(SS);
-
-  ASSERT_EQ(static_cast<size_t>(UCONTEXT_FPREGS_OFFSET),
-            offsetof(ucontext_t,uc_mcontext.fpregs));
-
-  ASSERT_EQ(static_cast<size_t>(UCONTEXT_FPREGS_MEM_OFFSET),
-            offsetof(ucontext_t,__fpregs_mem));
-#elif defined(__mips__)
-  ASSERT_EQ(static_cast<size_t>(MCONTEXT_GREGS_OFFSET),
-            offsetof(ucontext_t,uc_mcontext.gregs));
-
-  // PC for mips is not part of gregs.
-  ASSERT_EQ(static_cast<size_t>(MCONTEXT_PC_OFFSET),
-            offsetof(ucontext_t,uc_mcontext.pc));
-
-  ASSERT_EQ(static_cast<size_t>(MCONTEXT_FPREGS_OFFSET),
-            offsetof(ucontext_t,uc_mcontext.fpregs));
-
-  ASSERT_EQ(static_cast<size_t>(MCONTEXT_FPC_CSR),
-            offsetof(ucontext_t,uc_mcontext.fpc_csr));
-#else
-  ASSERT_EQ(static_cast<size_t>(MCONTEXT_GREGS_OFFSET),
-            offsetof(ucontext_t,uc_mcontext.gregs));
-#endif
-}
-
-TEST(AndroidUContext, SigmakOffset) {
-  ASSERT_EQ(static_cast<size_t>(UCONTEXT_SIGMASK_OFFSET),
-            offsetof(ucontext_t,uc_sigmask));
-}
diff --git a/src/MEGASync/google_breakpad/common/android/include/asm-mips/README.md b/src/MEGASync/google_breakpad/common/android/include/asm-mips/README.md
new file mode 100644
index 00000000..b56ee60f
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/android/include/asm-mips/README.md
@@ -0,0 +1,9 @@
+# asm-mips
+
+The files in this directory are almost direct copies from Android NDK r12, with
+the exception of changing the include guards to Breakpad ones. They are copied
+from the MIPS asm/ directory, but are meant to be used as replacements for both
+asm/ and machine/ includes since the files in each are largely duplicates.
+
+Some MIPS asm/ and all machine/ headers were removed in the move to unified NDK
+headers, so Breakpad fails to compile on newer NDK versions without these files.
\ No newline at end of file
diff --git a/src/MEGASync/google_breakpad/common/android/include/asm-mips/asm.h b/src/MEGASync/google_breakpad/common/android/include/asm-mips/asm.h
new file mode 100644
index 00000000..8f086e75
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/android/include/asm-mips/asm.h
@@ -0,0 +1,270 @@
+#ifndef GOOGLE_BREAKPAD_COMMON_ANDROID_INCLUDE_ASM_MIPS_ASM_H
+#define GOOGLE_BREAKPAD_COMMON_ANDROID_INCLUDE_ASM_MIPS_ASM_H
+
+#if defined(__has_include_next) && __has_include_next(<asm/asm.h>)
+#include_next <asm/asm.h>
+#else
+
+/****************************************************************************
+ ****************************************************************************
+ ***
+ ***   This header was automatically generated from a Linux kernel header
+ ***   of the same name, to make information necessary for userspace to
+ ***   call into the kernel available to libc.  It contains only constants,
+ ***   structures, and macros generated from the original header, and thus,
+ ***   contains no copyrightable information.
+ ***
+ ***   To edit the content of this header, modify the corresponding
+ ***   source file (e.g. under external/kernel-headers/original/) then
+ ***   run bionic/libc/kernel/tools/update_all.py
+ ***
+ ***   Any manual change here will be lost the next time this script will
+ ***   be run. You've been warned!
+ ***
+ ****************************************************************************
+ ****************************************************************************/
+
+#include <asm/sgidefs.h>
+#ifndef CAT
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#ifdef __STDC__
+#define __CAT(str1, str2) str1##str2
+#else
+#define __CAT(str1, str2) str1 str2
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#endif
+#define CAT(str1, str2) __CAT(str1, str2)
+#endif
+#ifdef __PIC__
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define CPRESTORE(register)   .cprestore register
+#define CPADD(register)   .cpadd register
+#define CPLOAD(register)   .cpload register
+#else
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define CPRESTORE(register)
+#define CPADD(register)
+#define CPLOAD(register)
+#endif
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define LEAF(symbol)   .globl symbol;   .align 2;   .type symbol, @function;   .ent symbol, 0;  symbol: .frame sp, 0, ra
+#define NESTED(symbol, framesize, rpc)   .globl symbol;   .align 2;   .type symbol, @function;   .ent symbol, 0;  symbol: .frame sp, framesize, rpc
+#define END(function)   .end function;   .size function, .-function
+#define EXPORT(symbol)   .globl symbol;  symbol:
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define FEXPORT(symbol)   .globl symbol;   .type symbol, @function;  symbol:
+#define ABS(symbol,value)   .globl symbol;  symbol = value
+#define PANIC(msg)   .set push;   .set reorder;   PTR_LA a0, 8f;   jal panic;  9: b 9b;   .set pop;   TEXT(msg)
+#define PRINT(string)
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define TEXT(msg)   .pushsection .data;  8: .asciiz msg;   .popsection;
+#define TTABLE(string)   .pushsection .text;   .word 1f;   .popsection   .pushsection .data;  1: .asciiz string;   .popsection
+#define PREF(hint, addr)
+#define PREFX(hint, addr)
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#if _MIPS_ISA == _MIPS_ISA_MIPS1
+#define MOVN(rd, rs, rt)   .set push;   .set reorder;   beqz rt, 9f;   move rd, rs;   .set pop;  9:
+#define MOVZ(rd, rs, rt)   .set push;   .set reorder;   bnez rt, 9f;   move rd, rs;   .set pop;  9:
+#endif
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#if _MIPS_ISA == _MIPS_ISA_MIPS2 || _MIPS_ISA == _MIPS_ISA_MIPS3
+#define MOVN(rd, rs, rt)   .set push;   .set noreorder;   bnezl rt, 9f;   move rd, rs;   .set pop;  9:
+#define MOVZ(rd, rs, rt)   .set push;   .set noreorder;   beqzl rt, 9f;   move rd, rs;   .set pop;  9:
+#endif
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#if _MIPS_ISA == _MIPS_ISA_MIPS4 || _MIPS_ISA == _MIPS_ISA_MIPS5 || _MIPS_ISA == _MIPS_ISA_MIPS32 || _MIPS_ISA == _MIPS_ISA_MIPS64
+#define MOVN(rd, rs, rt)   movn rd, rs, rt
+#define MOVZ(rd, rs, rt)   movz rd, rs, rt
+#endif
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#if _MIPS_SIM == _MIPS_SIM_ABI32
+#define ALSZ 7
+#define ALMASK ~7
+#endif
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#if _MIPS_SIM == _MIPS_SIM_NABI32 || _MIPS_SIM == _MIPS_SIM_ABI64
+#define ALSZ 15
+#define ALMASK ~15
+#endif
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#ifdef __mips64
+#define SZREG 8
+#else
+#define SZREG 4
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#endif
+#if _MIPS_SIM == _MIPS_SIM_ABI32
+#define REG_S sw
+#define REG_L lw
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define REG_SUBU subu
+#define REG_ADDU addu
+#endif
+#if _MIPS_SIM == _MIPS_SIM_NABI32 || _MIPS_SIM == _MIPS_SIM_ABI64
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define REG_S sd
+#define REG_L ld
+#define REG_SUBU dsubu
+#define REG_ADDU daddu
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#endif
+#if _MIPS_SZINT == 32
+#define INT_ADD add
+#define INT_ADDU addu
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define INT_ADDI addi
+#define INT_ADDIU addiu
+#define INT_SUB sub
+#define INT_SUBU subu
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define INT_L lw
+#define INT_S sw
+#define INT_SLL sll
+#define INT_SLLV sllv
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define INT_SRL srl
+#define INT_SRLV srlv
+#define INT_SRA sra
+#define INT_SRAV srav
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#endif
+#if _MIPS_SZINT == 64
+#define INT_ADD dadd
+#define INT_ADDU daddu
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define INT_ADDI daddi
+#define INT_ADDIU daddiu
+#define INT_SUB dsub
+#define INT_SUBU dsubu
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define INT_L ld
+#define INT_S sd
+#define INT_SLL dsll
+#define INT_SLLV dsllv
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define INT_SRL dsrl
+#define INT_SRLV dsrlv
+#define INT_SRA dsra
+#define INT_SRAV dsrav
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#endif
+#if _MIPS_SZLONG == 32
+#define LONG_ADD add
+#define LONG_ADDU addu
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define LONG_ADDI addi
+#define LONG_ADDIU addiu
+#define LONG_SUB sub
+#define LONG_SUBU subu
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define LONG_L lw
+#define LONG_S sw
+#define LONG_SLL sll
+#define LONG_SLLV sllv
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define LONG_SRL srl
+#define LONG_SRLV srlv
+#define LONG_SRA sra
+#define LONG_SRAV srav
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define LONG .word
+#define LONGSIZE 4
+#define LONGMASK 3
+#define LONGLOG 2
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#endif
+#if _MIPS_SZLONG == 64
+#define LONG_ADD dadd
+#define LONG_ADDU daddu
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define LONG_ADDI daddi
+#define LONG_ADDIU daddiu
+#define LONG_SUB dsub
+#define LONG_SUBU dsubu
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define LONG_L ld
+#define LONG_S sd
+#define LONG_SLL dsll
+#define LONG_SLLV dsllv
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define LONG_SRL dsrl
+#define LONG_SRLV dsrlv
+#define LONG_SRA dsra
+#define LONG_SRAV dsrav
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define LONG .dword
+#define LONGSIZE 8
+#define LONGMASK 7
+#define LONGLOG 3
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#endif
+#if _MIPS_SZPTR == 32
+#define PTR_ADD add
+#define PTR_ADDU addu
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define PTR_ADDI addi
+#define PTR_ADDIU addiu
+#define PTR_SUB sub
+#define PTR_SUBU subu
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define PTR_L lw
+#define PTR_S sw
+#define PTR_LA la
+#define PTR_LI li
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define PTR_SLL sll
+#define PTR_SLLV sllv
+#define PTR_SRL srl
+#define PTR_SRLV srlv
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define PTR_SRA sra
+#define PTR_SRAV srav
+#define PTR_SCALESHIFT 2
+#define PTR .word
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define PTRSIZE 4
+#define PTRLOG 2
+#endif
+#if _MIPS_SZPTR == 64
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define PTR_ADD dadd
+#define PTR_ADDU daddu
+#define PTR_ADDI daddi
+#define PTR_ADDIU daddiu
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define PTR_SUB dsub
+#define PTR_SUBU dsubu
+#define PTR_L ld
+#define PTR_S sd
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define PTR_LA dla
+#define PTR_LI dli
+#define PTR_SLL dsll
+#define PTR_SLLV dsllv
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define PTR_SRL dsrl
+#define PTR_SRLV dsrlv
+#define PTR_SRA dsra
+#define PTR_SRAV dsrav
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define PTR_SCALESHIFT 3
+#define PTR .dword
+#define PTRSIZE 8
+#define PTRLOG 3
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#endif
+#if _MIPS_SIM == _MIPS_SIM_ABI32
+#define MFC0 mfc0
+#define MTC0 mtc0
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#endif
+#if _MIPS_SIM == _MIPS_SIM_NABI32 || _MIPS_SIM == _MIPS_SIM_ABI64
+#define MFC0 dmfc0
+#define MTC0 dmtc0
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#endif
+#define SSNOP sll zero, zero, 1
+#define R10KCBARRIER(addr)
+#endif  // defined(__has_include_next) && __has_include_next(<asm/asm.h>)
+#endif  // GOOGLE_BREAKPAD_COMMON_ANDROID_INCLUDE_ASM_MIPS_ASM_H
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
diff --git a/src/MEGASync/google_breakpad/common/android/include/asm-mips/fpregdef.h b/src/MEGASync/google_breakpad/common/android/include/asm-mips/fpregdef.h
new file mode 100644
index 00000000..a6eedc0e
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/android/include/asm-mips/fpregdef.h
@@ -0,0 +1,117 @@
+#ifndef GOOGLE_BREAKPAD_COMMON_ANDROID_INCLUDE_ASM_MIPS_FPREGDEF_H
+#define GOOGLE_BREAKPAD_COMMON_ANDROID_INCLUDE_ASM_MIPS_FPREGDEF_H
+
+#if defined(__has_include_next) && __has_include_next(<asm/fpregdef.h>)
+#include_next <asm/fpregdef.h>
+#else
+
+/****************************************************************************
+ ****************************************************************************
+ ***
+ ***   This header was automatically generated from a Linux kernel header
+ ***   of the same name, to make information necessary for userspace to
+ ***   call into the kernel available to libc.  It contains only constants,
+ ***   structures, and macros generated from the original header, and thus,
+ ***   contains no copyrightable information.
+ ***
+ ***   To edit the content of this header, modify the corresponding
+ ***   source file (e.g. under external/kernel-headers/original/) then
+ ***   run bionic/libc/kernel/tools/update_all.py
+ ***
+ ***   Any manual change here will be lost the next time this script will
+ ***   be run. You've been warned!
+ ***
+ ****************************************************************************
+ ****************************************************************************/
+
+#include <asm/sgidefs.h>
+#if _MIPS_SIM == _MIPS_SIM_ABI32
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define fv0 $f0  
+#define fv0f $f1
+#define fv1 $f2
+#define fv1f $f3
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define fa0 $f12  
+#define fa0f $f13
+#define fa1 $f14
+#define fa1f $f15
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define ft0 $f4  
+#define ft0f $f5
+#define ft1 $f6
+#define ft1f $f7
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define ft2 $f8
+#define ft2f $f9
+#define ft3 $f10
+#define ft3f $f11
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define ft4 $f16
+#define ft4f $f17
+#define ft5 $f18
+#define ft5f $f19
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define fs0 $f20  
+#define fs0f $f21
+#define fs1 $f22
+#define fs1f $f23
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define fs2 $f24
+#define fs2f $f25
+#define fs3 $f26
+#define fs3f $f27
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define fs4 $f28
+#define fs4f $f29
+#define fs5 $f30
+#define fs5f $f31
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define fcr31 $31  
+#endif
+#if _MIPS_SIM == _MIPS_SIM_ABI64 || _MIPS_SIM == _MIPS_SIM_NABI32
+#define fv0 $f0  
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define fv1 $f2
+#define fa0 $f12  
+#define fa1 $f13
+#define fa2 $f14
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define fa3 $f15
+#define fa4 $f16
+#define fa5 $f17
+#define fa6 $f18
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define fa7 $f19
+#define ft0 $f4  
+#define ft1 $f5
+#define ft2 $f6
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define ft3 $f7
+#define ft4 $f8
+#define ft5 $f9
+#define ft6 $f10
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define ft7 $f11
+#define ft8 $f20
+#define ft9 $f21
+#define ft10 $f22
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define ft11 $f23
+#define ft12 $f1
+#define ft13 $f3
+#define fs0 $f24  
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define fs1 $f25
+#define fs2 $f26
+#define fs3 $f27
+#define fs4 $f28
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define fs5 $f29
+#define fs6 $f30
+#define fs7 $f31
+#define fcr31 $31
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#endif
+#endif  // defined(__has_include_next) && __has_include_next(<asm/fpregdef.h>)
+#endif  // GOOGLE_BREAKPAD_COMMON_ANDROID_INCLUDE_ASM_MIPS_FPREGDEF_H
diff --git a/src/MEGASync/google_breakpad/common/android/include/asm-mips/regdef.h b/src/MEGASync/google_breakpad/common/android/include/asm-mips/regdef.h
new file mode 100644
index 00000000..a7fd7690
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/android/include/asm-mips/regdef.h
@@ -0,0 +1,125 @@
+#ifndef GOOGLE_BREAKPAD_COMMON_ANDROID_INCLUDE_ASM_MIPS_REGDEF_H
+#define GOOGLE_BREAKPAD_COMMON_ANDROID_INCLUDE_ASM_MIPS_REGDEF_H
+
+#if defined(__has_include_next) && __has_include_next(<asm/regdef.h>)
+#include_next <asm/regdef.h>
+#else
+
+/****************************************************************************
+ ****************************************************************************
+ ***
+ ***   This header was automatically generated from a Linux kernel header
+ ***   of the same name, to make information necessary for userspace to
+ ***   call into the kernel available to libc.  It contains only constants,
+ ***   structures, and macros generated from the original header, and thus,
+ ***   contains no copyrightable information.
+ ***
+ ***   To edit the content of this header, modify the corresponding
+ ***   source file (e.g. under external/kernel-headers/original/) then
+ ***   run bionic/libc/kernel/tools/update_all.py
+ ***
+ ***   Any manual change here will be lost the next time this script will
+ ***   be run. You've been warned!
+ ***
+ ****************************************************************************
+ ****************************************************************************/
+
+#include <asm/sgidefs.h>
+#if _MIPS_SIM == _MIPS_SIM_ABI32
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define zero $0  
+#define AT $1  
+#define v0 $2  
+#define v1 $3
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define a0 $4  
+#define a1 $5
+#define a2 $6
+#define a3 $7
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define t0 $8  
+#define t1 $9
+#define t2 $10
+#define t3 $11
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define t4 $12
+#define t5 $13
+#define t6 $14
+#define t7 $15
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define s0 $16  
+#define s1 $17
+#define s2 $18
+#define s3 $19
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define s4 $20
+#define s5 $21
+#define s6 $22
+#define s7 $23
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define t8 $24  
+#define t9 $25
+#define jp $25  
+#define k0 $26  
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define k1 $27
+#define gp $28  
+#define sp $29  
+#define fp $30  
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define s8 $30  
+#define ra $31  
+#endif
+#if _MIPS_SIM == _MIPS_SIM_ABI64 || _MIPS_SIM == _MIPS_SIM_NABI32
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define zero $0  
+#define AT $at  
+#define v0 $2  
+#define v1 $3
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define a0 $4  
+#define a1 $5
+#define a2 $6
+#define a3 $7
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define a4 $8  
+#define ta0 $8
+#define a5 $9
+#define ta1 $9
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define a6 $10
+#define ta2 $10
+#define a7 $11
+#define ta3 $11
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define t0 $12  
+#define t1 $13
+#define t2 $14
+#define t3 $15
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define s0 $16  
+#define s1 $17
+#define s2 $18
+#define s3 $19
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define s4 $20
+#define s5 $21
+#define s6 $22
+#define s7 $23
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define t8 $24  
+#define t9 $25  
+#define jp $25  
+#define k0 $26  
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define k1 $27
+#define gp $28  
+#define sp $29  
+#define fp $30  
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define s8 $30  
+#define ra $31  
+#endif
+#endif  // defined(__has_include_next) && __has_include_next(<asm/regdef.h>)
+#endif  // GOOGLE_BREAKPAD_COMMON_ANDROID_INCLUDE_ASM_MIPS_REGDEF_H
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
diff --git a/src/MEGASync/google_breakpad/common/android/include/elf.h b/src/MEGASync/google_breakpad/common/android/include/elf.h
index af50a799..e6f0c672 100644
--- a/src/MEGASync/google_breakpad/common/android/include/elf.h
+++ b/src/MEGASync/google_breakpad/common/android/include/elf.h
@@ -38,7 +38,7 @@ extern "C" {
 #endif  // __cplusplus
 
 // The Android <elf.h> provides BSD-based definitions for the ElfXX_Nhdr
-// types 
+// types
 // always source-compatible with the GLibc/kernel ones. To overcome this
 // issue without modifying a lot of code in Breakpad, use an ugly macro
 // renaming trick with #include_next
@@ -109,12 +109,6 @@ typedef struct {
 } Elf64_Dyn;
 
 
-// __WORDSIZE is GLibc-specific and used by Google Breakpad on Linux.
-// All Android platforms are 32-bit for now.
-#ifndef __WORDSIZE
-#define __WORDSIZE 32
-#endif
-
 // The Android headers don't always define this constant.
 #ifndef EM_X86_64
 #define EM_X86_64  62
diff --git a/src/MEGASync/google_breakpad/common/android/include/link.h b/src/MEGASync/google_breakpad/common/android/include/link.h
index 6f3c1828..4324629d 100644
--- a/src/MEGASync/google_breakpad/common/android/include/link.h
+++ b/src/MEGASync/google_breakpad/common/android/include/link.h
@@ -30,17 +30,25 @@
 #ifndef GOOGLE_BREAKPAD_ANDROID_INCLUDE_LINK_H
 #define GOOGLE_BREAKPAD_ANDROID_INCLUDE_LINK_H
 
-/* Android doesn't provide <link.h>. Provide custom version here */
-#include <elf.h>
+/* Android doesn't provide all the data-structures required in its <link.h>.
+   Provide custom version here. */
+#include_next <link.h>
+
+#include <android/api-level.h>
+
+// TODO(rmcilroy): Remove this file once the NDK API level is updated to at
+// least 21 for all architectures. https://crbug.com/358831
+
+// These structures are only present in traditional headers at API level 21 and
+// above. Unified headers define these structures regardless of the chosen API
+// level. __ANDROID_API_N__ is a proxy for determining whether unified headers
+// are in use. Its only defined by unified headers.
+#if __ANDROID_API__ < 21 && !defined(__ANDROID_API_N__)
 
 #ifdef __cplusplus
 extern "C" {
 #endif  // __cplusplus
 
-#define ElfW(type)      _ElfW (Elf, ELFSIZE, type)
-#define _ElfW(e,w,t)    _ElfW_1 (e, w, _##t)
-#define _ElfW_1(e,w,t)  e##w##t
-
 struct r_debug {
   int              r_version;
   struct link_map* r_map;
@@ -64,4 +72,6 @@ struct link_map {
 }  // extern "C"
 #endif  // __cplusplus
 
+#endif  // __ANDROID_API__ < 21 && !defined(__ANDROID_API_N__)
+
 #endif /* GOOGLE_BREAKPAD_ANDROID_INCLUDE_LINK_H */
diff --git a/src/MEGASync/google_breakpad/common/android/include/sys/procfs.h b/src/MEGASync/google_breakpad/common/android/include/sys/procfs.h
index 9cfdd01c..18512436 100644
--- a/src/MEGASync/google_breakpad/common/android/include/sys/procfs.h
+++ b/src/MEGASync/google_breakpad/common/android/include/sys/procfs.h
@@ -36,7 +36,11 @@
 
 #else
 
+#include <asm/ptrace.h>
 #include <sys/cdefs.h>
+#if defined (__mips__)
+#include <sys/types.h>
+#endif
 #include <sys/user.h>
 #include <unistd.h>
 
@@ -44,7 +48,7 @@
 extern "C" {
 #endif  // __cplusplus
 
-#ifdef __x86_64__
+#if defined(__x86_64__) || defined(__aarch64__)
 typedef unsigned long long elf_greg_t;
 #else
 typedef unsigned long  elf_greg_t;
@@ -52,6 +56,10 @@ typedef unsigned long  elf_greg_t;
 
 #ifdef __arm__
 #define ELF_NGREG (sizeof(struct user_regs) / sizeof(elf_greg_t))
+#elif defined(__aarch64__)
+#define ELF_NGREG (sizeof(struct user_pt_regs) / sizeof(elf_greg_t))
+#elif defined(__mips__)
+#define ELF_NGREG 45
 #else
 #define ELF_NGREG (sizeof(struct user_regs_struct) / sizeof(elf_greg_t))
 #endif
@@ -92,6 +100,9 @@ struct elf_prpsinfo {
 #ifdef __x86_64__
   unsigned int   pr_uid;
   unsigned int   pr_gid;
+#elif defined(__mips__)
+  __kernel_uid_t pr_uid;
+  __kernel_gid_t pr_gid;
 #else
   unsigned short pr_uid;
   unsigned short pr_gid;
diff --git a/src/MEGASync/google_breakpad/common/android/include/sys/ucontext.h b/src/MEGASync/google_breakpad/common/android/include/sys/ucontext.h
deleted file mode 100644
index 2b6f032d..00000000
--- a/src/MEGASync/google_breakpad/common/android/include/sys/ucontext.h
+++ /dev/null
@@ -1,174 +0,0 @@
-// Copyright (c) 2012, Google Inc.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef GOOGLE_BREAKPAD_COMMON_ANDROID_INCLUDE_SYS_UCONTEXT_H
-#define GOOGLE_BREAKPAD_COMMON_ANDROID_INCLUDE_SYS_UCONTEXT_H
-
-#include <sys/cdefs.h>
-#include <signal.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif  // __cplusplus
-
-#ifndef __BIONIC_HAVE_UCONTEXT_T
-
-// Ensure that 'stack_t' is defined.
-#include <asm/signal.h>
-
-// This version of the Android C library headers do not provide ucontext_t.
-// Provide custom definitions for Google Breakpad.
-#if defined(__arm__)
-
-// Ensure that 'struct sigcontext' is defined.
-#include <asm/sigcontext.h>
-typedef struct sigcontext mcontext_t;
-
-// The ARM kernel uses a 64-bit signal mask.
-typedef uint32_t  kernel_sigmask_t[2];
-
-typedef struct ucontext_t {
-  uint32_t uc_flags;
-  struct ucontext_t* uc_link;
-  stack_t uc_stack;
-  mcontext_t uc_mcontext;
-  kernel_sigmask_t uc_sigmask;
-  // Other fields are not used by Google Breakpad. Don't define them.
-} ucontext_t;
-
-#elif defined(__i386__)
-
-/* 80-bit floating-point register */
-struct _libc_fpreg {
-  unsigned short significand[4];
-  unsigned short exponent;
-};
-
-/* Simple floating-point state, see FNSTENV instruction */
-struct _libc_fpstate {
-  unsigned long cw;
-  unsigned long sw;
-  unsigned long tag;
-  unsigned long ipoff;
-  unsigned long cssel;
-  unsigned long dataoff;
-  unsigned long datasel;
-  struct _libc_fpreg _st[8];
-  unsigned long status;
-};
-
-typedef uint32_t  greg_t;
-
-typedef struct {
-  uint32_t gregs[19];
-  struct _libc_fpstate* fpregs;
-  uint32_t oldmask;
-  uint32_t cr2;
-} mcontext_t;
-
-enum {
-  REG_GS = 0,
-  REG_FS,
-  REG_ES,
-  REG_DS,
-  REG_EDI,
-  REG_ESI,
-  REG_EBP,
-  REG_ESP,
-  REG_EBX,
-  REG_EDX,
-  REG_ECX,
-  REG_EAX,
-  REG_TRAPNO,
-  REG_ERR,
-  REG_EIP,
-  REG_CS,
-  REG_EFL,
-  REG_UESP,
-  REG_SS,
-};
-
-// The i386 kernel uses a 64-bit signal mask.
-typedef uint32_t kernel_sigmask_t[2];
-
-typedef struct ucontext_t {
-  uint32_t uc_flags;
-  struct ucontext_t* uc_link;
-  stack_t uc_stack;
-  mcontext_t uc_mcontext;
-  kernel_sigmask_t uc_sigmask;
-  struct _libc_fpstate __fpregs_mem;
-} ucontext_t;
-
-#elif defined(__mips__)
-
-typedef struct {
-  uint32_t regmask;
-  uint32_t status;
-  uint64_t pc;
-  uint64_t gregs[32];
-  uint64_t fpregs[32];
-  uint32_t acx;
-  uint32_t fpc_csr;
-  uint32_t fpc_eir;
-  uint32_t used_math;
-  uint32_t dsp;
-  uint64_t mdhi;
-  uint64_t mdlo;
-  uint32_t hi1;
-  uint32_t lo1;
-  uint32_t hi2;
-  uint32_t lo2;
-  uint32_t hi3;
-  uint32_t lo3;
-} mcontext_t;
-
-// The MIPS kernel uses a 128-bit signal mask.
-typedef uint32_t kernel_sigmask_t[4];
-
-typedef struct ucontext_t {
-  uint32_t uc_flags;
-  struct ucontext_t* uc_link;
-  stack_t uc_stack;
-  mcontext_t uc_mcontext;
-  kernel_sigmask_t uc_sigmask;
-  // Other fields are not used by Google Breakpad. Don't define them.
-} ucontext_t;
-
-#else
-#  error "Unsupported Android CPU ABI!"
-#endif
-
-#endif  // __BIONIC_HAVE_UCONTEXT_T
-
-#ifdef __cplusplus
-}  // extern "C"
-#endif  // __cplusplus
-
-#endif  // GOOGLE_BREAKPAD_COMMON_ANDROID_INCLUDE_SYS_UCONTEXT_H
diff --git a/src/MEGASync/google_breakpad/common/android/include/sys/user.h b/src/MEGASync/google_breakpad/common/android/include/sys/user.h
index bc275bbe..9c27ef02 100644
--- a/src/MEGASync/google_breakpad/common/android/include/sys/user.h
+++ b/src/MEGASync/google_breakpad/common/android/include/sys/user.h
@@ -30,117 +30,37 @@
 #ifndef GOOGLE_BREAKPAD_COMMON_ANDROID_INCLUDE_SYS_USER_H
 #define GOOGLE_BREAKPAD_COMMON_ANDROID_INCLUDE_SYS_USER_H
 
-#ifdef __cplusplus
-extern "C" {
-#endif  // __cplusplus
-
-// These types are used with ptrace(), more specifically with
-// PTRACE_GETREGS, PTRACE_GETFPREGS and PTRACE_GETVFPREGS respectively.
-//
-// They are also defined, sometimes with different names, in <asm/user.h>
-//
-
-#if defined(__arm__)
-
-#define _ARM_USER_H  1  // Prevent <asm/user.h> conflicts
-
-// Note: on ARM, GLibc uses user_regs instead of user_regs_struct.
-struct user_regs {
-  // Note: Entries 0-15 match r0..r15
-  //       Entry 16 is used to store the CPSR register.
-  //       Entry 17 is used to store the "orig_r0" value.
-  unsigned long int uregs[18];
-};
+// The purpose of this file is to glue the mismatching headers (Android NDK vs
+// glibc) and therefore avoid doing otherwise awkward #ifdefs in the code.
+// The following quirks are currently handled by this file:
+// - i386: Use the Android NDK but alias user_fxsr_struct > user_fpxregs_struct.
 
-// Same here: user_fpregs instead of user_fpregs_struct.
-struct user_fpregs {
-  struct fp_reg {
-    unsigned int sign1:1;
-    unsigned int unused:15;
-    unsigned int sign2:1;
-    unsigned int exponent:14;
-    unsigned int j:1;
-    unsigned int mantissa1:31;
-    unsigned int mantissa0:32;
-  } fpregs[8];
-  unsigned int  fpsr:32;
-  unsigned int  fpcr:32;
-  unsigned char ftype[8];
-  unsigned int  init_flag;
-};
+// TODO(primiano): remove these changes after Chromium has stably rolled to
+// an NDK with the appropriate fixes. https://crbug.com/358831
 
-// GLibc doesn't define this one in <sys/user.h> though.
-struct user_vfpregs {
-  unsigned long long  fpregs[32];
-  unsigned long       fpscr;
-};
+// With traditional headers, <sys/user.h> forgot to do this. Unified headers get
+// it right.
+#include <sys/types.h>
 
-#elif defined(__i386__)
+#include_next <sys/user.h>
 
-#define _I386_USER_H 1  // Prevent <asm/user.h> conflicts
+#include <android/api-level.h>
 
-// GLibc-compatible definitions
-struct user_regs_struct {
-  long ebx, ecx, edx, esi, edi, ebp, eax;
-  long xds, xes, xfs, xgs, orig_eax;
-  long eip, xcs, eflags, esp, xss;
-};
-
-struct user_fpregs_struct {
-  long cwd, swd, twd, fip, fcs, foo, fos;
-  long st_space[20];
-};
-
-struct user_fpxregs_struct {
-  unsigned short cwd, swd, twd, fop;
-  long fip, fcs, foo, fos, mxcsr, reserved;
-  long st_space[32];
-  long xmm_space[32];
-  long padding[56];
-};
-
-struct user {
-  struct user_regs_struct    regs;
-  int                        u_fpvalid;
-  struct user_fpregs_struct  i387;
-  unsigned long              u_tsize;
-  unsigned long              u_dsize;
-  unsigned long              u_ssize;
-  unsigned long              start_code;
-  unsigned long              start_stack;
-  long                       signal;
-  int                        reserved;
-  struct user_regs_struct*   u_ar0;
-  struct user_fpregs_struct* u_fpstate;
-  unsigned long              magic;
-  char                       u_comm [32];
-  int                        u_debugreg [8];
-};
-
-
-#elif defined(__mips__)
-
-#define _ASM_USER_H 1  // Prevent <asm/user.h> conflicts
+#ifdef __cplusplus
+extern "C" {
+#endif  // __cplusplus
 
-struct user_regs_struct {
-  unsigned long long regs[32];
-  unsigned long long lo;
-  unsigned long long hi;
-  unsigned long long epc;
-  unsigned long long badvaddr;
-  unsigned long long status;
-  unsigned long long cause;
-};
+#if defined(__i386__)
+#if __ANDROID_API__ < 21 && !defined(__ANDROID_API_N__)
 
-struct user_fpregs_struct {
-  unsigned long long regs[32];
-  unsigned int fpcsr;
-  unsigned int fir;
-};
+// user_fpxregs_struct was called user_fxsr_struct in traditional headers before
+// API level 21. Unified headers call it user_fpxregs_struct regardless of the
+// chosen API level. __ANDROID_API_N__ is a proxy for determining whether
+// unified headers are in use. Its only defined by unified headers.
+typedef struct user_fxsr_struct user_fpxregs_struct;
 
-#else
-#  error "Unsupported Android CPU ABI"
-#endif
+#endif  // __ANDROID_API__ < 21 && !defined(__ANDROID_API_N__)
+#endif  // defined(__i386__)
 
 #ifdef __cplusplus
 }  // extern "C"
diff --git a/src/MEGASync/google_breakpad/common/android/testing/include/wchar.h b/src/MEGASync/google_breakpad/common/android/testing/include/wchar.h
index 9649cab6..85373fd2 100644
--- a/src/MEGASync/google_breakpad/common/android/testing/include/wchar.h
+++ b/src/MEGASync/google_breakpad/common/android/testing/include/wchar.h
@@ -38,6 +38,9 @@
 
 #include_next <wchar.h>
 
+#if !defined(__aarch64__) && !defined(__x86_64__) && \
+    !(defined(__mips__) && _MIPS_SIM == _ABI64)
+
 // This needs to be in an extern "C" namespace, or Googletest will not
 // compile against it.
 #ifdef __cplusplus
@@ -68,5 +71,6 @@ static int inline wcscasecmp(const wchar_t* s1, const wchar_t* s2) {
 #ifdef __cplusplus
 }  // extern "C"
 #endif  // __cplusplus
+#endif
 
 #endif  // GOOGLEBREAKPAD_COMMON_ANDROID_INCLUDE_WCHAR_H
diff --git a/src/MEGASync/google_breakpad/common/android/testing/pthread_fixes.h b/src/MEGASync/google_breakpad/common/android/testing/pthread_fixes.h
index 15c6309e..b0a3d82e 100644
--- a/src/MEGASync/google_breakpad/common/android/testing/pthread_fixes.h
+++ b/src/MEGASync/google_breakpad/common/android/testing/pthread_fixes.h
@@ -80,7 +80,7 @@ int pthread_barrier_wait(pthread_barrier_t* barrier) {
   return 0;
 }
 
-int pthread_barrier_destroy(pthread_barrier_t *barrier) {
+int pthread_barrier_destroy(pthread_barrier_t* barrier) {
   barrier->count = 0;
   pthread_cond_destroy(&barrier->cond);
   pthread_mutex_destroy(&barrier->mutex);
@@ -89,11 +89,6 @@ int pthread_barrier_destroy(pthread_barrier_t *barrier) {
 
 #endif  // defined(PTHREAD_BARRIER_SERIAL_THREAD)
 
-int pthread_yield(void) {
-  sched_yield();
-  return 0;
-}
-
 }  // namespace
 
 #endif  // GOOGLE_BREAKPAD_COMMON_ANDROID_TESTING_PTHREAD_FIXES_H
diff --git a/src/MEGASync/google_breakpad/common/byte_cursor.h b/src/MEGASync/google_breakpad/common/byte_cursor.h
index accd54e0..28bb8e76 100644
--- a/src/MEGASync/google_breakpad/common/byte_cursor.h
+++ b/src/MEGASync/google_breakpad/common/byte_cursor.h
@@ -52,16 +52,16 @@ namespace google_breakpad {
 // A buffer holding a series of bytes.
 struct ByteBuffer {
   ByteBuffer() : start(0), end(0) { }
-  ByteBuffer(const uint8_t *set_start, size_t set_size)
+  ByteBuffer(const uint8_t* set_start, size_t set_size)
       : start(set_start), end(set_start + set_size) { }
   ~ByteBuffer() { };
 
   // Equality operators. Useful in unit tests, and when we're using
   // ByteBuffers to refer to regions of a larger buffer.
-  bool operator==(const ByteBuffer &that) const {
+  bool operator==(const ByteBuffer& that) const {
     return start == that.start && end == that.end;
   }
-  bool operator!=(const ByteBuffer &that) const {
+  bool operator!=(const ByteBuffer& that) const {
     return start != that.start || end != that.end;
   }
 
@@ -71,7 +71,8 @@ struct ByteBuffer {
     return end - start;
   }
 
-  const uint8_t *start, *end;
+  const uint8_t* start;
+  const uint8_t* end;
 };
 
 // A cursor pointing into a ByteBuffer that can parse numbers of various
@@ -82,8 +83,8 @@ class ByteCursor {
  public:
   // Create a cursor reading bytes from the start of BUFFER. By default, the
   // cursor reads multi-byte values in little-endian form.
-  ByteCursor(const ByteBuffer *buffer, bool big_endian = false)
-      : buffer_(buffer), here_(buffer->start), 
+  ByteCursor(const ByteBuffer* buffer, bool big_endian = false)
+      : buffer_(buffer), here_(buffer->start),
         big_endian_(big_endian), complete_(true) { }
 
   // Accessor and setter for this cursor's endianness flag.
@@ -92,8 +93,8 @@ class ByteCursor {
 
   // Accessor and setter for this cursor's current position. The setter
   // returns a reference to this cursor.
-  const uint8_t *here() const { return here_; }
-  ByteCursor &set_here(const uint8_t *here) {
+  const uint8_t* here() const { return here_; }
+  ByteCursor& set_here(const uint8_t* here) {
     assert(buffer_->start <= here && here <= buffer_->end);
     here_ = here;
     return *this;
@@ -116,7 +117,7 @@ class ByteCursor {
   // this cursor's complete_ flag, and store a dummy value in *RESULT.
   // Return a reference to this cursor.
   template<typename T>
-  ByteCursor &Read(size_t size, bool is_signed, T *result) {
+  ByteCursor& Read(size_t size, bool is_signed, T* result) {
     if (CheckAvailable(size)) {
       T v = 0;
       if (big_endian_) {
@@ -145,7 +146,7 @@ class ByteCursor {
   // read off the end of our buffer, clear this cursor's complete_ flag.
   // Return a reference to this cursor.
   template<typename T>
-  ByteCursor &operator>>(T &result) {
+  ByteCursor& operator>>(T& result) {
     bool T_is_signed = (T)-1 < 0;
     return Read(sizeof(T), T_is_signed, &result); 
   }
@@ -154,7 +155,7 @@ class ByteCursor {
   // cursor to the end of them. If we read off the end of our buffer,
   // clear this cursor's complete_ flag, and set *POINTER to NULL.
   // Return a reference to this cursor.
-  ByteCursor &Read(uint8_t *buffer, size_t size) {
+  ByteCursor& Read(uint8_t* buffer, size_t size) {
     if (CheckAvailable(size)) {
       memcpy(buffer, here_, size);
       here_ += size;
@@ -166,11 +167,11 @@ class ByteCursor {
   // byte buffer does not contain a terminating zero, clear this cursor's
   // complete_ flag, and set STR to the empty string. Return a reference to
   // this cursor.
-  ByteCursor &CString(string *str) {
-    const uint8_t *end
-      = static_cast<const uint8_t *>(memchr(here_, '\0', Available()));
+  ByteCursor& CString(string* str) {
+    const uint8_t* end
+      = static_cast<const uint8_t*>(memchr(here_, '\0', Available()));
     if (end) {
-      str->assign(reinterpret_cast<const char *>(here_), end - here_);
+      str->assign(reinterpret_cast<const char*>(here_), end - here_);
       here_ = end + 1;
     } else {
       str->clear();
@@ -193,14 +194,14 @@ class ByteCursor {
   //   
   // - Otherwise, set *STR to a copy of those LIMIT bytes, and advance the
   //   cursor by LIMIT bytes.
-  ByteCursor &CString(string *str, size_t limit) {
+  ByteCursor& CString(string* str, size_t limit) {
     if (CheckAvailable(limit)) {
-      const uint8_t *end
-        = static_cast<const uint8_t *>(memchr(here_, '\0', limit));
+      const uint8_t* end
+        = static_cast<const uint8_t*>(memchr(here_, '\0', limit));
       if (end)
-        str->assign(reinterpret_cast<const char *>(here_), end - here_);
+        str->assign(reinterpret_cast<const char*>(here_), end - here_);
       else
-        str->assign(reinterpret_cast<const char *>(here_), limit);
+        str->assign(reinterpret_cast<const char*>(here_), limit);
       here_ += limit;
     } else {
       str->clear();
@@ -213,7 +214,7 @@ class ByteCursor {
   // cursor. If we read off the end of our buffer, clear this cursor's
   // complete_ flag, and set *POINTER to NULL. Return a reference to this
   // cursor.
-  ByteCursor &PointTo(const uint8_t **pointer, size_t size = 0) {
+  ByteCursor& PointTo(const uint8_t** pointer, size_t size = 0) {
     if (CheckAvailable(size)) {
       *pointer = here_;
       here_ += size;
@@ -226,7 +227,7 @@ class ByteCursor {
   // Skip SIZE bytes at the cursor. If doing so would advance us off
   // the end of our buffer, clear this cursor's complete_ flag, and
   // set *POINTER to NULL. Return a reference to this cursor.
-  ByteCursor &Skip(size_t size) {
+  ByteCursor& Skip(size_t size) {
     if (CheckAvailable(size))
       here_ += size;
     return *this;
@@ -247,10 +248,10 @@ class ByteCursor {
   }
 
   // The buffer we're reading bytes from.
-  const ByteBuffer *buffer_;
+  const ByteBuffer* buffer_;
 
   // The next byte within buffer_ that we'll read.
-  const uint8_t *here_;
+  const uint8_t* here_;
 
   // True if we should read numbers in big-endian form; false if we
   // should read in little-endian form.
diff --git a/src/MEGASync/google_breakpad/common/byte_cursor_unittest.cc b/src/MEGASync/google_breakpad/common/byte_cursor_unittest.cc
index 06bfd89d..45e6f2b4 100644
--- a/src/MEGASync/google_breakpad/common/byte_cursor_unittest.cc
+++ b/src/MEGASync/google_breakpad/common/byte_cursor_unittest.cc
@@ -593,7 +593,7 @@ TEST(Extractor, Signed4) {
   int32_t a;
   // For some reason, G++ 4.4.1 complains:
   //   warning: array subscript is above array bounds
-  // in ByteCursor::Read(size_t, bool, T *) as it inlines this call, but
+  // in ByteCursor::Read(size_t, bool, T*) as it inlines this call, but
   // I'm not able to see how such a reference would occur.
   EXPECT_TRUE(cursor >> a);
   EXPECT_EQ(-380377902, a);
@@ -627,7 +627,7 @@ TEST(Extractor, Unsigned4) {
   uint32_t a;
   // For some reason, G++ 4.4.1 complains:
   //   warning: array subscript is above array bounds
-  // in ByteCursor::Read(size_t, bool, T *) as it inlines this call, but
+  // in ByteCursor::Read(size_t, bool, T*) as it inlines this call, but
   // I'm not able to see how such a reference would occur.
   EXPECT_TRUE(cursor >> a);
   EXPECT_EQ(0xe953e4d2, a);
@@ -718,10 +718,10 @@ TEST(Strings, PointTo) {
   ByteBuffer buffer(data, sizeof(data));
   ByteCursor cursor(&buffer);
 
-  const uint8_t *received1;
-  const uint8_t *received2;
-  const uint8_t *received3;
-  const uint8_t *received4;
+  const uint8_t* received1;
+  const uint8_t* received2;
+  const uint8_t* received3;
+  const uint8_t* received4;
   EXPECT_FALSE(cursor
                .PointTo(&received1, 3)
                .PointTo(&received2, 3)
diff --git a/src/MEGASync/google_breakpad/common/common.gyp b/src/MEGASync/google_breakpad/common/common.gyp
new file mode 100644
index 00000000..c1dbb0fe
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/common.gyp
@@ -0,0 +1,260 @@
+# Copyright 2014 Google Inc. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are
+# met:
+#
+#     * Redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer.
+#     * Redistributions in binary form must reproduce the above
+# copyright notice, this list of conditions and the following disclaimer
+# in the documentation and/or other materials provided with the
+# distribution.
+#     * Neither the name of Google Inc. nor the names of its
+# contributors may be used to endorse or promote products derived from
+# this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+{
+  'target_defaults': {
+    'target_conditions': [
+      ['OS=="mac"', {
+        'defines': ['HAVE_MACH_O_NLIST_H'],
+      }],
+      ['OS=="linux"', {
+        # Assume glibc.
+        'defines': ['HAVE_A_OUT_H', 'HAVE_GETCONTEXT'],
+        'sources!': [
+          'linux/breakpad_getcontext.S',
+          'linux/breakpad_getcontext.h',
+          'linux/breakpad_getcontext_unittest.cc',
+        ],
+      }],
+      ['OS!="android"', {'sources/': [['exclude', '(^|/)android/']]}],
+      ['OS!="linux"', {'sources/': [['exclude', '(^|/)linux/']]}],
+      ['OS!="mac"', {'sources/': [['exclude', '(^|/)mac/']]}],
+      ['OS!="solaris"', {'sources/': [['exclude', '(^|/)solaris/']]}],
+      ['OS!="win"', {'sources/': [['exclude', '(^|/)windows/']]}],
+    ],
+  },
+  'targets': [
+    {
+      'target_name': 'common',
+      'type': 'static_library',
+      'sources': [
+        'android/include/elf.h',
+        'android/include/link.h',
+        'android/include/stab.h',
+        'android/include/sys/procfs.h',
+        'android/include/sys/user.h',
+        'android/testing/include/wchar.h',
+        'android/testing/mkdtemp.h',
+        'android/testing/pthread_fixes.h',
+        'android/ucontext_constants.h',
+        'basictypes.h',
+        'byte_cursor.h',
+        'convert_UTF.cc',
+        'convert_UTF.h',
+        'dwarf/bytereader-inl.h',
+        'dwarf/bytereader.cc',
+        'dwarf/bytereader.h',
+        'dwarf/cfi_assembler.cc',
+        'dwarf/cfi_assembler.h',
+        'dwarf/dwarf2diehandler.cc',
+        'dwarf/dwarf2diehandler.h',
+        'dwarf/dwarf2enums.h',
+        'dwarf/dwarf2reader.cc',
+        'dwarf/dwarf2reader.h',
+        'dwarf/dwarf2reader_test_common.h',
+        'dwarf/elf_reader.cc',
+        'dwarf/elf_reader.h',
+        'dwarf/functioninfo.cc',
+        'dwarf/functioninfo.h',
+        'dwarf/line_state_machine.h',
+        'dwarf/types.h',
+        'dwarf_cfi_to_module.cc',
+        'dwarf_cfi_to_module.h',
+        'dwarf_cu_to_module.cc',
+        'dwarf_cu_to_module.h',
+        'dwarf_line_to_module.cc',
+        'dwarf_line_to_module.h',
+        'language.cc',
+        'language.h',
+        'linux/breakpad_getcontext.S',
+        'linux/breakpad_getcontext.h',
+        'linux/crc32.cc',
+        'linux/crc32.h',
+        'linux/dump_symbols.cc',
+        'linux/dump_symbols.h',
+        'linux/eintr_wrapper.h',
+        'linux/elf_core_dump.cc',
+        'linux/elf_core_dump.h',
+        'linux/elf_gnu_compat.h',
+        'linux/elf_symbols_to_module.cc',
+        'linux/elf_symbols_to_module.h',
+        'linux/elfutils-inl.h',
+        'linux/elfutils.cc',
+        'linux/elfutils.h',
+        'linux/file_id.cc',
+        'linux/file_id.h',
+        'linux/google_crashdump_uploader.cc',
+        'linux/google_crashdump_uploader.h',
+        'linux/guid_creator.cc',
+        'linux/guid_creator.h',
+        'linux/http_upload.cc',
+        'linux/http_upload.h',
+        'linux/ignore_ret.h',
+        'linux/libcurl_wrapper.cc',
+        'linux/libcurl_wrapper.h',
+        'linux/linux_libc_support.cc',
+        'linux/linux_libc_support.h',
+        'linux/memory_mapped_file.cc',
+        'linux/memory_mapped_file.h',
+        'linux/safe_readlink.cc',
+        'linux/safe_readlink.h',
+        'linux/symbol_collector_client.cc',
+        'linux/symbol_collector_client.h',
+        'linux/synth_elf.cc',
+        'linux/synth_elf.h',
+        'long_string_dictionary.cc',
+        'long_string_dictionary.h',
+        'mac/arch_utilities.cc',
+        'mac/arch_utilities.h',
+        'mac/bootstrap_compat.cc',
+        'mac/bootstrap_compat.h',
+        'mac/byteswap.h',
+        'mac/dump_syms.h',
+        'mac/dump_syms.cc',
+        'mac/file_id.cc',
+        'mac/file_id.h',
+        'mac/GTMDefines.h',
+        'mac/GTMLogger.h',
+        'mac/GTMLogger.m',
+        'mac/HTTPMultipartUpload.h',
+        'mac/HTTPMultipartUpload.m',
+        'mac/MachIPC.h',
+        'mac/MachIPC.mm',
+        'mac/macho_id.cc',
+        'mac/macho_id.h',
+        'mac/macho_reader.cc',
+        'mac/macho_reader.h',
+        'mac/macho_utilities.cc',
+        'mac/macho_utilities.h',
+        'mac/macho_walker.cc',
+        'mac/macho_walker.h',
+        'mac/scoped_task_suspend-inl.h',
+        'mac/string_utilities.cc',
+        'mac/string_utilities.h',
+        'mac/super_fat_arch.h',
+        'md5.cc',
+        'md5.h',
+        'memory_allocator.h',
+        'memory_range.h',
+        'module.cc',
+        'module.h',
+        'scoped_ptr.h',
+        'simple_string_dictionary.cc',
+        'simple_string_dictionary.h',
+        'solaris/dump_symbols.cc',
+        'solaris/dump_symbols.h',
+        'solaris/file_id.cc',
+        'solaris/file_id.h',
+        'solaris/guid_creator.cc',
+        'solaris/guid_creator.h',
+        'solaris/message_output.h',
+        'stabs_reader.cc',
+        'stabs_reader.h',
+        'stabs_to_module.cc',
+        'stabs_to_module.h',
+        'string_conversion.cc',
+        'string_conversion.h',
+        'symbol_data.h',
+        'test_assembler.cc',
+        'test_assembler.h',
+        'unordered.h',
+        'using_std_string.h',
+        'windows/common_windows.gyp',
+        'windows/dia_util.cc',
+        'windows/dia_util.h',
+        'windows/guid_string.cc',
+        'windows/guid_string.h',
+        'windows/http_upload.cc',
+        'windows/http_upload.h',
+        'windows/omap.cc',
+        'windows/omap.h',
+        'windows/omap_internal.h',
+        'windows/pdb_source_line_writer.cc',
+        'windows/pdb_source_line_writer.h',
+        'windows/string_utils-inl.h',
+        'windows/string_utils.cc',
+      ],
+      'include_dirs': [
+        '..',
+      ],
+    },
+    {
+      'target_name': 'common_unittests',
+      'type': 'executable',
+      'sources': [
+        'byte_cursor_unittest.cc',
+        'dwarf/bytereader_unittest.cc',
+        'dwarf/dwarf2diehandler_unittest.cc',
+        'dwarf/dwarf2reader_cfi_unittest.cc',
+        'dwarf/dwarf2reader_die_unittest.cc',
+        'dwarf_cfi_to_module_unittest.cc',
+        'dwarf_cu_to_module_unittest.cc',
+        'dwarf_line_to_module_unittest.cc',
+        'linux/breakpad_getcontext_unittest.cc',
+        'linux/dump_symbols_unittest.cc',
+        'linux/elf_core_dump_unittest.cc',
+        'linux/elf_symbols_to_module_unittest.cc',
+        'linux/file_id_unittest.cc',
+        'linux/google_crashdump_uploader_test.cc',
+        'linux/linux_libc_support_unittest.cc',
+        'linux/memory_mapped_file_unittest.cc',
+        'linux/safe_readlink_unittest.cc',
+        'linux/synth_elf_unittest.cc',
+        'linux/tests/auto_testfile.h',
+        'linux/tests/crash_generator.cc',
+        'linux/tests/crash_generator.h',
+        'long_string_dictionary_unittest.cc',
+        'mac/macho_reader_unittest.cc',
+        'memory_allocator_unittest.cc',
+        'memory_range_unittest.cc',
+        'module_unittest.cc',
+        'simple_string_dictionary_unittest.cc',
+        'stabs_reader_unittest.cc',
+        'stabs_to_module_unittest.cc',
+        'string_conversion_unittest.cc',
+        'test_assembler_unittest.cc',
+        'tests/auto_tempdir.h',
+        'tests/file_utils.cc',
+        'tests/file_utils.h',
+        'windows/omap_unittest.cc',
+      ],
+      'include_dirs': [
+        '..',
+      ],
+      'dependencies': [
+        'common',
+        '../build/testing.gyp:gmock_main',
+        '../build/testing.gyp:gmock',
+        '../build/testing.gyp:gtest',
+      ],
+      'libraries': [
+        '-ldl',
+      ],
+    },
+  ],
+}
diff --git a/src/MEGASync/google_breakpad/common/convert_UTF.c b/src/MEGASync/google_breakpad/common/convert_UTF.cc
similarity index 65%
rename from src/MEGASync/google_breakpad/common/convert_UTF.c
rename to src/MEGASync/google_breakpad/common/convert_UTF.cc
index ee0305ff..4a5df1eb 100644
--- a/src/MEGASync/google_breakpad/common/convert_UTF.c
+++ b/src/MEGASync/google_breakpad/common/convert_UTF.cc
@@ -1,23 +1,39 @@
 /*
- * Copyright 2001-2004 Unicode, Inc.
+ * Copyright  1991-2015 Unicode, Inc. All rights reserved.
+ * Distributed under the Terms of Use in 
+ * http://www.unicode.org/copyright.html.
  *
- * Disclaimer
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of the Unicode data files and any associated documentation
+ * (the "Data Files") or Unicode software and any associated documentation
+ * (the "Software") to deal in the Data Files or Software
+ * without restriction, including without limitation the rights to use,
+ * copy, modify, merge, publish, distribute, and/or sell copies of
+ * the Data Files or Software, and to permit persons to whom the Data Files
+ * or Software are furnished to do so, provided that
+ * (a) this copyright and permission notice appear with all copies 
+ * of the Data Files or Software,
+ * (b) this copyright and permission notice appear in associated 
+ * documentation, and
+ * (c) there is clear notice in each modified Data File or in the Software
+ * as well as in the documentation associated with the Data File(s) or
+ * Software that the data or software has been modified.
  *
- * This source code is provided as is by Unicode, Inc. No claims are
- * made as to fitness for any particular purpose. No warranties of any
- * kind are expressed or implied. The recipient agrees to determine
- * applicability of information provided. If this file has been
- * purchased on magnetic or optical media from Unicode, Inc., the
- * sole remedy for any claim will be exchange of defective media
- * within 90 days of receipt.
+ * THE DATA FILES AND SOFTWARE ARE PROVIDED "AS IS", WITHOUT WARRANTY OF
+ * ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT OF THIRD PARTY RIGHTS.
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS
+ * NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL
+ * DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THE DATA FILES OR SOFTWARE.
  *
- * Limitations on Rights to Redistribute This Code
- *
- * Unicode, Inc. hereby grants the right to freely use the information
- * supplied in this file in the creation of products supporting the
- * Unicode Standard, and to make copies of this file in any form
- * for internal or external distribution as long as this notice
- * remains attached.
+ * Except as contained in this notice, the name of a copyright holder
+ * shall not be used in advertising or otherwise to promote the sale,
+ * use or other dealings in these Data Files or Software without prior
+ * written authorization of the copyright holder.
  */
 
 /* ---------------------------------------------------------------------
@@ -44,23 +60,24 @@ See the header file "ConvertUTF.h" for complete documentation.
 #include <stdio.h>
 #endif
 
-static const int halfShift  = 10; /* used for shifting by 10 bits */
+#include "common/macros.h"
+
+namespace google_breakpad {
+
+namespace {
 
-static const UTF32 halfBase = 0x0010000UL;
-static const UTF32 halfMask = 0x3FFUL;
+const int halfShift  = 10; /* used for shifting by 10 bits */
+
+const UTF32 halfBase = 0x0010000UL;
+const UTF32 halfMask = 0x3FFUL;
+
+}  // namespace
 
 #define UNI_SUR_HIGH_START  (UTF32)0xD800
 #define UNI_SUR_HIGH_END    (UTF32)0xDBFF
 #define UNI_SUR_LOW_START   (UTF32)0xDC00
 #define UNI_SUR_LOW_END     (UTF32)0xDFFF
 
-#ifndef false
-#define false       0
-#endif
-#ifndef true
-#define true        1
-#endif
-
 /* --------------------------------------------------------------------- */
 
 ConversionResult ConvertUTF32toUTF16 (const UTF32** sourceStart, const UTF32* sourceEnd,
@@ -71,12 +88,12 @@ ConversionResult ConvertUTF32toUTF16 (const UTF32** sourceStart, const UTF32* so
   while (source < sourceEnd) {
     UTF32 ch;
     if (target >= targetEnd) {
-        result = targetExhausted; break;
+	    result = targetExhausted; break;
     }
     ch = *source++;
     if (ch <= UNI_MAX_BMP) { /* Target is a character <= 0xFFFF */
-        /* UTF-16 surrogate values are illegal in UTF-32; 0xffff or 0xfffe are both reserved values */
-        if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {
+	    /* UTF-16 surrogate values are illegal in UTF-32; 0xffff or 0xfffe are both reserved values */
+	    if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {
         if (flags == strictConversion) {
           --source; /* return to the illegal value itself */
           result = sourceIllegal;
@@ -84,24 +101,24 @@ ConversionResult ConvertUTF32toUTF16 (const UTF32** sourceStart, const UTF32* so
         } else {
           *target++ = UNI_REPLACEMENT_CHAR;
         }
-        } else {
+	    } else {
         *target++ = (UTF16)ch; /* normal case */
-        }
+	    }
     } else if (ch > UNI_MAX_LEGAL_UTF32) {
-        if (flags == strictConversion) {
+	    if (flags == strictConversion) {
         result = sourceIllegal;
-        } else {
+	    } else {
         *target++ = UNI_REPLACEMENT_CHAR;
-        }
+	    }
     } else {
-        /* target is a character in range 0xFFFF - 0x10FFFF. */
-        if (target + 1 >= targetEnd) {
+	    /* target is a character in range 0xFFFF - 0x10FFFF. */
+	    if (target + 1 >= targetEnd) {
         --source; /* Back up source pointer! */
         result = targetExhausted; break;
-        }
-        ch -= halfBase;
-        *target++ = (UTF16)((ch >> halfShift) + UNI_SUR_HIGH_START);
-        *target++ = (UTF16)((ch & halfMask) + UNI_SUR_LOW_START);
+	    }
+	    ch -= halfBase;
+	    *target++ = (UTF16)((ch >> halfShift) + UNI_SUR_HIGH_START);
+	    *target++ = (UTF16)((ch & halfMask) + UNI_SUR_LOW_START);
     }
   }
 *sourceStart = source;
@@ -122,8 +139,8 @@ ConversionResult ConvertUTF16toUTF32 (const UTF16** sourceStart, const UTF16* so
     ch = *source++;
     /* If we have a surrogate pair, convert to UTF32 first. */
     if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) {
-        /* If the 16 bits following the high surrogate are in the source buffer... */
-        if (source < sourceEnd) {
+	    /* If the 16 bits following the high surrogate are in the source buffer... */
+	    if (source < sourceEnd) {
         ch2 = *source;
         /* If it's a low surrogate, convert to UTF32. */
         if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) {
@@ -135,22 +152,22 @@ ConversionResult ConvertUTF16toUTF32 (const UTF16** sourceStart, const UTF16* so
           result = sourceIllegal;
           break;
         }
-        } else { /* We don't have the 16 bits following the high surrogate. */
+	    } else { /* We don't have the 16 bits following the high surrogate. */
         --source; /* return to the high surrogate */
         result = sourceExhausted;
         break;
-        }
+	    }
     } else if (flags == strictConversion) {
-        /* UTF-16 surrogate values are illegal in UTF-32 */
-        if (ch >= UNI_SUR_LOW_START && ch <= UNI_SUR_LOW_END) {
+	    /* UTF-16 surrogate values are illegal in UTF-32 */
+	    if (ch >= UNI_SUR_LOW_START && ch <= UNI_SUR_LOW_END) {
         --source; /* return to the illegal value itself */
         result = sourceIllegal;
         break;
-        }
+	    }
     }
     if (target >= targetEnd) {
-        source = oldSource; /* Back up source pointer! */
-        result = targetExhausted; break;
+	    source = oldSource; /* Back up source pointer! */
+	    result = targetExhausted; break;
     }
     *target++ = ch;
   }
@@ -167,6 +184,8 @@ ConversionResult ConvertUTF16toUTF32 (const UTF16** sourceStart, const UTF16* so
 
 /* --------------------------------------------------------------------- */
 
+namespace {
+
 /*
  * Index into the table below with the first byte of a UTF-8 sequence to
  * get the number of trailing bytes that are supposed to follow it.
@@ -174,7 +193,7 @@ ConversionResult ConvertUTF16toUTF32 (const UTF16** sourceStart, const UTF16* so
  * left as-is for anyone who may want to do such conversion, which was
  * allowed in earlier algorithms.
  */
-static const char trailingBytesForUTF8[256] = {
+const char trailingBytesForUTF8[256] = {
   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
@@ -190,7 +209,7 @@ static const char trailingBytesForUTF8[256] = {
  * This table contains as many values as there might be trailing bytes
  * in a UTF-8 sequence.
  */
-static const UTF32 offsetsFromUTF8[6] = { 0x00000000UL, 0x00003080UL, 0x000E2080UL,
+const UTF32 offsetsFromUTF8[6] = { 0x00000000UL, 0x00003080UL, 0x000E2080UL,
   0x03C82080UL, 0xFA082080UL, 0x82082080UL };
 
 /*
@@ -200,7 +219,7 @@ static const UTF32 offsetsFromUTF8[6] = { 0x00000000UL, 0x00003080UL, 0x000E2080
  * (I.e., one byte sequence, two byte... etc.). Remember that sequencs
  * for *legal* UTF-8 will be 4 or fewer bytes total.
  */
-static const UTF8 firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
+const UTF8 firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
 
 /* --------------------------------------------------------------------- */
 
@@ -212,6 +231,8 @@ static const UTF8 firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC
 * into an inline function.
 */
 
+}  // namespace
+
 /* --------------------------------------------------------------------- */
 
 ConversionResult ConvertUTF16toUTF8 (const UTF16** sourceStart, const UTF16* sourceEnd,
@@ -228,8 +249,8 @@ ConversionResult ConvertUTF16toUTF8 (const UTF16** sourceStart, const UTF16* sou
     ch = *source++;
     /* If we have a surrogate pair, convert to UTF32 first. */
     if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) {
-        /* If the 16 bits following the high surrogate are in the source buffer... */
-        if (source < sourceEnd) {
+	    /* If the 16 bits following the high surrogate are in the source buffer... */
+	    if (source < sourceEnd) {
         UTF32 ch2 = *source;
         /* If it's a low surrogate, convert to UTF32. */
         if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) {
@@ -241,38 +262,48 @@ ConversionResult ConvertUTF16toUTF8 (const UTF16** sourceStart, const UTF16* sou
           result = sourceIllegal;
           break;
         }
-        } else { /* We don't have the 16 bits following the high surrogate. */
+	    } else { /* We don't have the 16 bits following the high surrogate. */
         --source; /* return to the high surrogate */
         result = sourceExhausted;
         break;
-        }
+	    }
     } else if (flags == strictConversion) {
-        /* UTF-16 surrogate values are illegal in UTF-32 */
-        if (ch >= UNI_SUR_LOW_START && ch <= UNI_SUR_LOW_END) {
+	    /* UTF-16 surrogate values are illegal in UTF-32 */
+	    if (ch >= UNI_SUR_LOW_START && ch <= UNI_SUR_LOW_END) {
         --source; /* return to the illegal value itself */
         result = sourceIllegal;
         break;
-        }
+	    }
     }
     /* Figure out how many bytes the result will require */
-    if (ch < (UTF32)0x80) {      bytesToWrite = 1;
+    if (ch < (UTF32)0x80) {	     bytesToWrite = 1;
     } else if (ch < (UTF32)0x800) {     bytesToWrite = 2;
     } else if (ch < (UTF32)0x10000) {   bytesToWrite = 3;
     } else if (ch < (UTF32)0x110000) {  bytesToWrite = 4;
-    } else {                bytesToWrite = 3;
+    } else {			    bytesToWrite = 3;
       ch = UNI_REPLACEMENT_CHAR;
     }
 
     target += bytesToWrite;
     if (target > targetEnd) {
-        source = oldSource; /* Back up source pointer! */
-        target -= bytesToWrite; result = targetExhausted; break;
+	    source = oldSource; /* Back up source pointer! */
+	    target -= bytesToWrite; result = targetExhausted; break;
     }
     switch (bytesToWrite) { /* note: everything falls through. */
-        case 4: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
-        case 3: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
-        case 2: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
-        case 1: *--target =  (UTF8)(ch | firstByteMark[bytesToWrite]);
+      case 4:
+        *--target = (UTF8)((ch | byteMark) & byteMask);
+        ch >>= 6;
+        BP_FALLTHROUGH;
+      case 3:
+        *--target = (UTF8)((ch | byteMark) & byteMask);
+        ch >>= 6;
+        BP_FALLTHROUGH;
+      case 2:
+        *--target = (UTF8)((ch | byteMark) & byteMask);
+        ch >>= 6;
+        BP_FALLTHROUGH;
+      case 1:
+        *--target =  (UTF8)(ch | firstByteMark[bytesToWrite]);
     }
     target += bytesToWrite;
   }
@@ -283,6 +314,8 @@ return result;
 
 /* --------------------------------------------------------------------- */
 
+namespace {
+
 /*
  * Utility routine to tell whether a sequence of bytes is legal UTF-8.
  * This must be called with the length pre-determined by the first byte.
@@ -293,16 +326,20 @@ return result;
  * If presented with a length > 4, this returns false.  The Unicode
  * definition of UTF-8 goes up to 4-byte sequences.
  */
-
-static Boolean isLegalUTF8(const UTF8 *source, int length) {
+Boolean isLegalUTF8(const UTF8 *source, int length) {
   UTF8 a;
   const UTF8 *srcptr = source+length;
   switch (length) {
     default: return false;
       /* Everything else falls through when "true"... */
-    case 4: if ((a = (*--srcptr)) < 0x80 || a > 0xBF) return false;
-    case 3: if ((a = (*--srcptr)) < 0x80 || a > 0xBF) return false;
-    case 2: if ((a = (*--srcptr)) > 0xBF) return false;
+    case 4:
+      if ((a = (*--srcptr)) < 0x80 || a > 0xBF) return false;
+      BP_FALLTHROUGH;
+    case 3:
+      if ((a = (*--srcptr)) < 0x80 || a > 0xBF) return false;
+      BP_FALLTHROUGH;
+    case 2:
+      if ((a = (*--srcptr)) > 0xBF) return false;
 
       switch (*source) {
         /* no fall-through in this inner switch */
@@ -312,13 +349,15 @@ static Boolean isLegalUTF8(const UTF8 *source, int length) {
         case 0xF4: if (a > 0x8F) return false; break;
         default:   if (a < 0x80) return false;
       }
-
-      case 1: if (*source >= 0x80 && *source < 0xC2) return false;
+      BP_FALLTHROUGH;
+    case 1: if (*source >= 0x80 && *source < 0xC2) return false;
   }
   if (*source > 0xF4) return false;
   return true;
 }
 
+}  // namespace
+
 /* --------------------------------------------------------------------- */
 
 /*
@@ -344,33 +383,35 @@ ConversionResult ConvertUTF8toUTF16 (const UTF8** sourceStart, const UTF8* sourc
     UTF32 ch = 0;
     unsigned short extraBytesToRead = trailingBytesForUTF8[*source];
     if (source + extraBytesToRead >= sourceEnd) {
-        result = sourceExhausted; break;
+	    result = sourceExhausted; break;
     }
     /* Do this check whether lenient or strict */
     if (! isLegalUTF8(source, extraBytesToRead+1)) {
-        result = sourceIllegal;
-        break;
+	    result = sourceIllegal;
+	    break;
     }
     /*
      * The cases all fall through. See "Note A" below.
      */
     switch (extraBytesToRead) {
-        case 5: ch += *source++; ch <<= 6; /* remember, illegal UTF-8 */
-        case 4: ch += *source++; ch <<= 6; /* remember, illegal UTF-8 */
-        case 3: ch += *source++; ch <<= 6;
-        case 2: ch += *source++; ch <<= 6;
-        case 1: ch += *source++; ch <<= 6;
-        case 0: ch += *source++;
+      /* remember, illegal UTF-8 */
+      case 5: ch += *source++; ch <<= 6; BP_FALLTHROUGH;
+      /* remember, illegal UTF-8 */
+      case 4: ch += *source++; ch <<= 6; BP_FALLTHROUGH;
+      case 3: ch += *source++; ch <<= 6; BP_FALLTHROUGH;
+      case 2: ch += *source++; ch <<= 6; BP_FALLTHROUGH;
+      case 1: ch += *source++; ch <<= 6; BP_FALLTHROUGH;
+      case 0: ch += *source++;
     }
     ch -= offsetsFromUTF8[extraBytesToRead];
 
     if (target >= targetEnd) {
-        source -= (extraBytesToRead+1); /* Back up source pointer! */
-        result = targetExhausted; break;
+	    source -= (extraBytesToRead+1); /* Back up source pointer! */
+	    result = targetExhausted; break;
     }
     if (ch <= UNI_MAX_BMP) { /* Target is a character <= 0xFFFF */
-        /* UTF-16 surrogate values are illegal in UTF-32 */
-        if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {
+	    /* UTF-16 surrogate values are illegal in UTF-32 */
+	    if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {
         if (flags == strictConversion) {
           source -= (extraBytesToRead+1); /* return to the illegal value itself */
           result = sourceIllegal;
@@ -378,26 +419,26 @@ ConversionResult ConvertUTF8toUTF16 (const UTF8** sourceStart, const UTF8* sourc
         } else {
           *target++ = UNI_REPLACEMENT_CHAR;
         }
-        } else {
+	    } else {
         *target++ = (UTF16)ch; /* normal case */
-        }
+	    }
     } else if (ch > UNI_MAX_UTF16) {
-        if (flags == strictConversion) {
+	    if (flags == strictConversion) {
         result = sourceIllegal;
         source -= (extraBytesToRead+1); /* return to the start */
         break; /* Bail out; shouldn't continue */
-        } else {
+	    } else {
         *target++ = UNI_REPLACEMENT_CHAR;
-        }
+	    }
     } else {
-        /* target is a character in range 0xFFFF - 0x10FFFF. */
-        if (target + 1 >= targetEnd) {
+	    /* target is a character in range 0xFFFF - 0x10FFFF. */
+	    if (target + 1 >= targetEnd) {
         source -= (extraBytesToRead+1); /* Back up source pointer! */
         result = targetExhausted; break;
-        }
-        ch -= halfBase;
-        *target++ = (UTF16)((ch >> halfShift) + UNI_SUR_HIGH_START);
-        *target++ = (UTF16)((ch & halfMask) + UNI_SUR_LOW_START);
+	    }
+	    ch -= halfBase;
+	    *target++ = (UTF16)((ch >> halfShift) + UNI_SUR_HIGH_START);
+	    *target++ = (UTF16)((ch & halfMask) + UNI_SUR_LOW_START);
     }
   }
 *sourceStart = source;
@@ -419,36 +460,46 @@ ConversionResult ConvertUTF32toUTF8 (const UTF32** sourceStart, const UTF32* sou
     const UTF32 byteMark = 0x80;
     ch = *source++;
     if (flags == strictConversion ) {
-        /* UTF-16 surrogate values are illegal in UTF-32 */
-        if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {
+	    /* UTF-16 surrogate values are illegal in UTF-32 */
+	    if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {
         --source; /* return to the illegal value itself */
         result = sourceIllegal;
         break;
-        }
+	    }
     }
     /*
      * Figure out how many bytes the result will require. Turn any
      * illegally large UTF32 things (> Plane 17) into replacement chars.
      */
-    if (ch < (UTF32)0x80) {      bytesToWrite = 1;
+    if (ch < (UTF32)0x80) {	     bytesToWrite = 1;
     } else if (ch < (UTF32)0x800) {     bytesToWrite = 2;
     } else if (ch < (UTF32)0x10000) {   bytesToWrite = 3;
     } else if (ch <= UNI_MAX_LEGAL_UTF32) {  bytesToWrite = 4;
-    } else {                bytesToWrite = 3;
+    } else {			    bytesToWrite = 3;
       ch = UNI_REPLACEMENT_CHAR;
       result = sourceIllegal;
     }
 
     target += bytesToWrite;
     if (target > targetEnd) {
-        --source; /* Back up source pointer! */
-        target -= bytesToWrite; result = targetExhausted; break;
+	    --source; /* Back up source pointer! */
+	    target -= bytesToWrite; result = targetExhausted; break;
     }
     switch (bytesToWrite) { /* note: everything falls through. */
-        case 4: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
-        case 3: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
-        case 2: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
-        case 1: *--target = (UTF8) (ch | firstByteMark[bytesToWrite]);
+      case 4:
+        *--target = (UTF8)((ch | byteMark) & byteMask);
+        ch >>= 6;
+        BP_FALLTHROUGH;
+      case 3:
+        *--target = (UTF8)((ch | byteMark) & byteMask);
+        ch >>= 6;
+        BP_FALLTHROUGH;
+      case 2:
+        *--target = (UTF8)((ch | byteMark) & byteMask);
+        ch >>= 6;
+        BP_FALLTHROUGH;
+      case 1:
+        *--target = (UTF8) (ch | firstByteMark[bytesToWrite]);
     }
     target += bytesToWrite;
   }
@@ -468,36 +519,36 @@ ConversionResult ConvertUTF8toUTF32 (const UTF8** sourceStart, const UTF8* sourc
     UTF32 ch = 0;
     unsigned short extraBytesToRead = trailingBytesForUTF8[*source];
     if (source + extraBytesToRead >= sourceEnd) {
-        result = sourceExhausted; break;
+	    result = sourceExhausted; break;
     }
     /* Do this check whether lenient or strict */
     if (! isLegalUTF8(source, extraBytesToRead+1)) {
-        result = sourceIllegal;
-        break;
+	    result = sourceIllegal;
+	    break;
     }
     /*
      * The cases all fall through. See "Note A" below.
      */
     switch (extraBytesToRead) {
-        case 5: ch += *source++; ch <<= 6;
-        case 4: ch += *source++; ch <<= 6;
-        case 3: ch += *source++; ch <<= 6;
-        case 2: ch += *source++; ch <<= 6;
-        case 1: ch += *source++; ch <<= 6;
-        case 0: ch += *source++;
+      case 5: ch += *source++; ch <<= 6; BP_FALLTHROUGH;
+      case 4: ch += *source++; ch <<= 6; BP_FALLTHROUGH;
+      case 3: ch += *source++; ch <<= 6; BP_FALLTHROUGH;
+      case 2: ch += *source++; ch <<= 6; BP_FALLTHROUGH;
+      case 1: ch += *source++; ch <<= 6; BP_FALLTHROUGH;
+      case 0: ch += *source++;
     }
     ch -= offsetsFromUTF8[extraBytesToRead];
 
     if (target >= targetEnd) {
-        source -= (extraBytesToRead+1); /* Back up the source pointer! */
-        result = targetExhausted; break;
+	    source -= (extraBytesToRead+1); /* Back up the source pointer! */
+	    result = targetExhausted; break;
     }
     if (ch <= UNI_MAX_LEGAL_UTF32) {
-        /*
-         * UTF-16 surrogate values are illegal in UTF-32, and anything
-         * over Plane 17 (> 0x10FFFF) is illegal.
-         */
-        if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {
+	    /*
+	     * UTF-16 surrogate values are illegal in UTF-32, and anything
+	     * over Plane 17 (> 0x10FFFF) is illegal.
+	     */
+	    if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {
         if (flags == strictConversion) {
           source -= (extraBytesToRead+1); /* return to the illegal value itself */
           result = sourceIllegal;
@@ -505,12 +556,12 @@ ConversionResult ConvertUTF8toUTF32 (const UTF8** sourceStart, const UTF8* sourc
         } else {
           *target++ = UNI_REPLACEMENT_CHAR;
         }
-        } else {
+	    } else {
         *target++ = ch;
-        }
+	    }
     } else { /* i.e., ch > UNI_MAX_LEGAL_UTF32 */
-        result = sourceIllegal;
-        *target++ = UNI_REPLACEMENT_CHAR;
+	    result = sourceIllegal;
+	    *target++ = UNI_REPLACEMENT_CHAR;
     }
   }
   *sourceStart = source;
@@ -527,12 +578,14 @@ are equivalent to the following loop:
 {
   int tmpBytesToRead = extraBytesToRead+1;
   do {
-        ch += *source++;
-        --tmpBytesToRead;
-        if (tmpBytesToRead) ch <<= 6;
+		ch += *source++;
+		--tmpBytesToRead;
+		if (tmpBytesToRead) ch <<= 6;
   } while (tmpBytesToRead > 0);
 }
 In UTF-8 writing code, the switches on "bytesToWrite" are
 similarly unrolled loops.
 
 --------------------------------------------------------------------- */
+
+}  // namespace google_breakpad
diff --git a/src/MEGASync/google_breakpad/common/convert_UTF.h b/src/MEGASync/google_breakpad/common/convert_UTF.h
index c481c9cb..2f69495d 100644
--- a/src/MEGASync/google_breakpad/common/convert_UTF.h
+++ b/src/MEGASync/google_breakpad/common/convert_UTF.h
@@ -1,23 +1,39 @@
 /*
- * Copyright 2001-2004 Unicode, Inc.
+ * Copyright  1991-2015 Unicode, Inc. All rights reserved.
+ * Distributed under the Terms of Use in 
+ * http://www.unicode.org/copyright.html.
  *
- * Disclaimer
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of the Unicode data files and any associated documentation
+ * (the "Data Files") or Unicode software and any associated documentation
+ * (the "Software") to deal in the Data Files or Software
+ * without restriction, including without limitation the rights to use,
+ * copy, modify, merge, publish, distribute, and/or sell copies of
+ * the Data Files or Software, and to permit persons to whom the Data Files
+ * or Software are furnished to do so, provided that
+ * (a) this copyright and permission notice appear with all copies 
+ * of the Data Files or Software,
+ * (b) this copyright and permission notice appear in associated 
+ * documentation, and
+ * (c) there is clear notice in each modified Data File or in the Software
+ * as well as in the documentation associated with the Data File(s) or
+ * Software that the data or software has been modified.
  *
- * This source code is provided as is by Unicode, Inc. No claims are
- * made as to fitness for any particular purpose. No warranties of any
- * kind are expressed or implied. The recipient agrees to determine
- * applicability of information provided. If this file has been
- * purchased on magnetic or optical media from Unicode, Inc., the
- * sole remedy for any claim will be exchange of defective media
- * within 90 days of receipt.
+ * THE DATA FILES AND SOFTWARE ARE PROVIDED "AS IS", WITHOUT WARRANTY OF
+ * ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT OF THIRD PARTY RIGHTS.
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS
+ * NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL
+ * DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THE DATA FILES OR SOFTWARE.
  *
- * Limitations on Rights to Redistribute This Code
- *
- * Unicode, Inc. hereby grants the right to freely use the information
- * supplied in this file in the creation of products supporting the
- * Unicode Standard, and to make copies of this file in any form
- * for internal or external distribution as long as this notice
- * remains attached.
+ * Except as contained in this notice, the name of a copyright holder
+ * shall not be used in advertising or otherwise to promote the sale,
+ * use or other dealings in these Data Files or Software without prior
+ * written authorization of the copyright holder.
  */
 
 #ifndef COMMON_CONVERT_UTF_H_
@@ -90,6 +106,8 @@ All should be unsigned values to avoid sign extension during
 bit mask & shift operations.
 ------------------------------------------------------------------------ */
 
+namespace google_breakpad {
+
 typedef unsigned long	UTF32;	/* at least 32 bits */
 typedef unsigned short	UTF16;	/* at least 16 bits */
 typedef unsigned char	UTF8;	/* typically 8 bits */
@@ -114,11 +132,6 @@ typedef enum {
 	lenientConversion
 } ConversionFlags;
 
-/* This is for C++ and does no harm in C */
-#ifdef __cplusplus
-extern "C" {
-#endif
-
 ConversionResult ConvertUTF8toUTF16 (const UTF8** sourceStart, const UTF8* sourceEnd,
                                      UTF16** targetStart, UTF16* targetEnd, ConversionFlags flags);
 
@@ -139,9 +152,7 @@ ConversionResult ConvertUTF32toUTF16 (const UTF32** sourceStart, const UTF32* so
 
 Boolean isLegalUTF8Sequence(const UTF8 *source, const UTF8 *sourceEnd);
 
-#ifdef __cplusplus
-}
-#endif
+}  // namespace google_breakpad
 
 /* --------------------------------------------------------------------- */
 
diff --git a/src/MEGASync/google_breakpad/common/dwarf/bytereader-inl.h b/src/MEGASync/google_breakpad/common/dwarf/bytereader-inl.h
index 3c167089..448be237 100644
--- a/src/MEGASync/google_breakpad/common/dwarf/bytereader-inl.h
+++ b/src/MEGASync/google_breakpad/common/dwarf/bytereader-inl.h
@@ -32,18 +32,17 @@
 #include "common/dwarf/bytereader.h"
 
 #include <assert.h>
+#include <stdint.h>
 
 namespace dwarf2reader {
 
-inline uint8 ByteReader::ReadOneByte(const char* buffer) const {
+inline uint8_t ByteReader::ReadOneByte(const uint8_t* buffer) const {
   return buffer[0];
 }
 
-inline uint16 ByteReader::ReadTwoBytes(const char* signed_buffer) const {
-  const unsigned char *buffer
-    = reinterpret_cast<const unsigned char *>(signed_buffer);
-  const uint16 buffer0 = buffer[0];
-  const uint16 buffer1 = buffer[1];
+inline uint16_t ByteReader::ReadTwoBytes(const uint8_t* buffer) const {
+  const uint16_t buffer0 = buffer[0];
+  const uint16_t buffer1 = buffer[1];
   if (endian_ == ENDIANNESS_LITTLE) {
     return buffer0 | buffer1 << 8;
   } else {
@@ -51,13 +50,22 @@ inline uint16 ByteReader::ReadTwoBytes(const char* signed_buffer) const {
   }
 }
 
-inline uint64 ByteReader::ReadFourBytes(const char* signed_buffer) const {
-  const unsigned char *buffer
-    = reinterpret_cast<const unsigned char *>(signed_buffer);
-  const uint32 buffer0 = buffer[0];
-  const uint32 buffer1 = buffer[1];
-  const uint32 buffer2 = buffer[2];
-  const uint32 buffer3 = buffer[3];
+inline uint64_t ByteReader::ReadThreeBytes(const uint8_t* buffer) const {
+  const uint32_t buffer0 = buffer[0];
+  const uint32_t buffer1 = buffer[1];
+  const uint32_t buffer2 = buffer[2];
+  if (endian_ == ENDIANNESS_LITTLE) {
+    return buffer0 | buffer1 << 8 | buffer2 << 16;
+  } else {
+    return buffer2 | buffer1 << 8 | buffer0 << 16;
+  }
+}
+
+inline uint64_t ByteReader::ReadFourBytes(const uint8_t* buffer) const {
+  const uint32_t buffer0 = buffer[0];
+  const uint32_t buffer1 = buffer[1];
+  const uint32_t buffer2 = buffer[2];
+  const uint32_t buffer3 = buffer[3];
   if (endian_ == ENDIANNESS_LITTLE) {
     return buffer0 | buffer1 << 8 | buffer2 << 16 | buffer3 << 24;
   } else {
@@ -65,17 +73,15 @@ inline uint64 ByteReader::ReadFourBytes(const char* signed_buffer) const {
   }
 }
 
-inline uint64 ByteReader::ReadEightBytes(const char* signed_buffer) const {
-  const unsigned char *buffer
-    = reinterpret_cast<const unsigned char *>(signed_buffer);
-  const uint64 buffer0 = buffer[0];
-  const uint64 buffer1 = buffer[1];
-  const uint64 buffer2 = buffer[2];
-  const uint64 buffer3 = buffer[3];
-  const uint64 buffer4 = buffer[4];
-  const uint64 buffer5 = buffer[5];
-  const uint64 buffer6 = buffer[6];
-  const uint64 buffer7 = buffer[7];
+inline uint64_t ByteReader::ReadEightBytes(const uint8_t* buffer) const {
+  const uint64_t buffer0 = buffer[0];
+  const uint64_t buffer1 = buffer[1];
+  const uint64_t buffer2 = buffer[2];
+  const uint64_t buffer3 = buffer[3];
+  const uint64_t buffer4 = buffer[4];
+  const uint64_t buffer5 = buffer[5];
+  const uint64_t buffer6 = buffer[6];
+  const uint64_t buffer7 = buffer[7];
   if (endian_ == ENDIANNESS_LITTLE) {
     return buffer0 | buffer1 << 8 | buffer2 << 16 | buffer3 << 24 |
       buffer4 << 32 | buffer5 << 40 | buffer6 << 48 | buffer7 << 56;
@@ -89,18 +95,18 @@ inline uint64 ByteReader::ReadEightBytes(const char* signed_buffer) const {
 // information, plus one bit saying whether the number continues or
 // not.
 
-inline uint64 ByteReader::ReadUnsignedLEB128(const char* buffer,
+inline uint64_t ByteReader::ReadUnsignedLEB128(const uint8_t* buffer,
                                              size_t* len) const {
-  uint64 result = 0;
+  uint64_t result = 0;
   size_t num_read = 0;
   unsigned int shift = 0;
-  unsigned char byte;
+  uint8_t byte;
 
   do {
     byte = *buffer++;
     num_read++;
 
-    result |= (static_cast<uint64>(byte & 0x7f)) << shift;
+    result |= (static_cast<uint64_t>(byte & 0x7f)) << shift;
 
     shift += 7;
 
@@ -114,54 +120,54 @@ inline uint64 ByteReader::ReadUnsignedLEB128(const char* buffer,
 // Read a signed LEB128 number.  These are like regular LEB128
 // numbers, except the last byte may have a sign bit set.
 
-inline int64 ByteReader::ReadSignedLEB128(const char* buffer,
+inline int64_t ByteReader::ReadSignedLEB128(const uint8_t* buffer,
                                           size_t* len) const {
-  int64 result = 0;
+  int64_t result = 0;
   unsigned int shift = 0;
   size_t num_read = 0;
-  unsigned char byte;
+  uint8_t byte;
 
   do {
       byte = *buffer++;
       num_read++;
-      result |= (static_cast<uint64>(byte & 0x7f) << shift);
+      result |= (static_cast<uint64_t>(byte & 0x7f) << shift);
       shift += 7;
   } while (byte & 0x80);
 
   if ((shift < 8 * sizeof (result)) && (byte & 0x40))
-    result |= -((static_cast<int64>(1)) << shift);
+    result |= -((static_cast<int64_t>(1)) << shift);
   *len = num_read;
   return result;
 }
 
-inline uint64 ByteReader::ReadOffset(const char* buffer) const {
+inline uint64_t ByteReader::ReadOffset(const uint8_t* buffer) const {
   assert(this->offset_reader_);
   return (this->*offset_reader_)(buffer);
 }
 
-inline uint64 ByteReader::ReadAddress(const char* buffer) const {
+inline uint64_t ByteReader::ReadAddress(const uint8_t* buffer) const {
   assert(this->address_reader_);
   return (this->*address_reader_)(buffer);
 }
 
-inline void ByteReader::SetCFIDataBase(uint64 section_base,
-                                       const char *buffer_base) {
+inline void ByteReader::SetCFIDataBase(uint64_t section_base,
+                                       const uint8_t* buffer_base) {
   section_base_ = section_base;
   buffer_base_ = buffer_base;
   have_section_base_ = true;
 }
 
-inline void ByteReader::SetTextBase(uint64 text_base) {
+inline void ByteReader::SetTextBase(uint64_t text_base) {
   text_base_ = text_base;
   have_text_base_ = true;
 }
 
-inline void ByteReader::SetDataBase(uint64 data_base) {
+inline void ByteReader::SetDataBase(uint64_t data_base) {
   data_base_ = data_base;
   have_data_base_ = true;
 }
 
-inline void ByteReader::SetFunctionBase(uint64 function_base) {
+inline void ByteReader::SetFunctionBase(uint64_t function_base) {
   function_base_ = function_base;
   have_function_base_ = true;
 }
diff --git a/src/MEGASync/google_breakpad/common/dwarf/bytereader.cc b/src/MEGASync/google_breakpad/common/dwarf/bytereader.cc
index 68020264..ac5064a7 100644
--- a/src/MEGASync/google_breakpad/common/dwarf/bytereader.cc
+++ b/src/MEGASync/google_breakpad/common/dwarf/bytereader.cc
@@ -27,6 +27,7 @@
 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #include <assert.h>
+#include <stdint.h>
 #include <stdlib.h>
 
 #include "common/dwarf/bytereader-inl.h"
@@ -42,7 +43,7 @@ ByteReader::ByteReader(enum Endianness endian)
 
 ByteReader::~ByteReader() { }
 
-void ByteReader::SetOffsetSize(uint8 size) {
+void ByteReader::SetOffsetSize(uint8_t size) {
   offset_size_ = size;
   assert(size == 4 || size == 8);
   if (size == 4) {
@@ -52,7 +53,7 @@ void ByteReader::SetOffsetSize(uint8 size) {
   }
 }
 
-void ByteReader::SetAddressSize(uint8 size) {
+void ByteReader::SetAddressSize(uint8_t size) {
   address_size_ = size;
   assert(size == 4 || size == 8);
   if (size == 4) {
@@ -62,8 +63,8 @@ void ByteReader::SetAddressSize(uint8 size) {
   }
 }
 
-uint64 ByteReader::ReadInitialLength(const char* start, size_t* len) {
-  const uint64 initial_length = ReadFourBytes(start);
+uint64_t ByteReader::ReadInitialLength(const uint8_t* start, size_t* len) {
+  const uint64_t initial_length = ReadFourBytes(start);
   start += 4;
 
   // In DWARF2/3, if the initial length is all 1 bits, then the offset
@@ -100,9 +101,9 @@ bool ByteReader::UsableEncoding(DwarfPointerEncoding encoding) const {
   }
 }
 
-uint64 ByteReader::ReadEncodedPointer(const char *buffer,
+uint64_t ByteReader::ReadEncodedPointer(const uint8_t* buffer,
                                       DwarfPointerEncoding encoding,
-                                      size_t *len) const {
+                                      size_t* len) const {
   // UsableEncoding doesn't approve of DW_EH_PE_omit, so we shouldn't
   // see it here.
   assert(encoding != DW_EH_PE_omit);
@@ -123,13 +124,13 @@ uint64 ByteReader::ReadEncodedPointer(const char *buffer,
 
     // First, find the offset to START from the closest prior aligned
     // address.
-    uint64 skew = section_base_ & (AddressSize() - 1);
+    uint64_t skew = section_base_ & (AddressSize() - 1);
     // Now find the offset from that aligned address to buffer.
-    uint64 offset = skew + (buffer - buffer_base_);
+    uint64_t offset = skew + (buffer - buffer_base_);
     // Round up to the next boundary.
-    uint64 aligned = (offset + AddressSize() - 1) & -AddressSize();
+    uint64_t aligned = (offset + AddressSize() - 1) & -AddressSize();
     // Convert back to a pointer.
-    const char *aligned_buffer = buffer_base_ + (aligned - skew);
+    const uint8_t* aligned_buffer = buffer_base_ + (aligned - skew);
     // Finally, store the length and actually fetch the pointer.
     *len = aligned_buffer - buffer + AddressSize();
     return ReadAddress(aligned_buffer);
@@ -137,7 +138,7 @@ uint64 ByteReader::ReadEncodedPointer(const char *buffer,
 
   // Extract the value first, ignoring whether it's a pointer or an
   // offset relative to some base.
-  uint64 offset;
+  uint64_t offset;
   switch (encoding & 0x0f) {
     case DW_EH_PE_absptr:
       // DW_EH_PE_absptr is weird, as it is used as a meaningful value for
@@ -201,7 +202,7 @@ uint64 ByteReader::ReadEncodedPointer(const char *buffer,
   }
 
   // Find the appropriate base address.
-  uint64 base;
+  uint64_t base;
   switch (encoding & 0x70) {
     case DW_EH_PE_absptr:
       base = 0;
@@ -231,15 +232,19 @@ uint64 ByteReader::ReadEncodedPointer(const char *buffer,
       abort();
   }
 
-  uint64 pointer = base + offset;
+  uint64_t pointer = base + offset;
 
   // Remove inappropriate upper bits.
   if (AddressSize() == 4)
     pointer = pointer & 0xffffffff;
   else
-    assert(AddressSize() == sizeof(uint64));
+    assert(AddressSize() == sizeof(uint64_t));
 
   return pointer;
 }
 
+Endianness ByteReader::GetEndianness() const {
+  return endian_;
+}
+
 }  // namespace dwarf2reader
diff --git a/src/MEGASync/google_breakpad/common/dwarf/bytereader.h b/src/MEGASync/google_breakpad/common/dwarf/bytereader.h
index e3894273..5d7a9a7f 100644
--- a/src/MEGASync/google_breakpad/common/dwarf/bytereader.h
+++ b/src/MEGASync/google_breakpad/common/dwarf/bytereader.h
@@ -31,7 +31,10 @@
 #ifndef COMMON_DWARF_BYTEREADER_H__
 #define COMMON_DWARF_BYTEREADER_H__
 
+#include <stdint.h>
+
 #include <string>
+
 #include "common/dwarf/types.h"
 #include "common/dwarf/dwarf2enums.h"
 
@@ -59,22 +62,27 @@ class ByteReader {
 
   // Read a single byte from BUFFER and return it as an unsigned 8 bit
   // number.
-  uint8 ReadOneByte(const char* buffer) const;
+  uint8_t ReadOneByte(const uint8_t* buffer) const;
 
   // Read two bytes from BUFFER and return them as an unsigned 16 bit
   // number, using this ByteReader's endianness.
-  uint16 ReadTwoBytes(const char* buffer) const;
+  uint16_t ReadTwoBytes(const uint8_t* buffer) const;
+
+  // Read three bytes from BUFFER and return them as an unsigned 64 bit
+  // number, using this ByteReader's endianness. DWARF 5 uses this encoding
+  // for various index-related DW_FORMs.
+  uint64_t ReadThreeBytes(const uint8_t* buffer) const;
 
   // Read four bytes from BUFFER and return them as an unsigned 32 bit
   // number, using this ByteReader's endianness. This function returns
-  // a uint64 so that it is compatible with ReadAddress and
+  // a uint64_t so that it is compatible with ReadAddress and
   // ReadOffset. The number it returns will never be outside the range
   // of an unsigned 32 bit integer.
-  uint64 ReadFourBytes(const char* buffer) const;
+  uint64_t ReadFourBytes(const uint8_t* buffer) const;
 
   // Read eight bytes from BUFFER and return them as an unsigned 64
   // bit number, using this ByteReader's endianness.
-  uint64 ReadEightBytes(const char* buffer) const;
+  uint64_t ReadEightBytes(const uint8_t* buffer) const;
 
   // Read an unsigned LEB128 (Little Endian Base 128) number from
   // BUFFER and return it as an unsigned 64 bit integer. Set LEN to
@@ -93,7 +101,7 @@ class ByteReader {
   // In other words, we break VALUE into groups of seven bits, put
   // them in little-endian order, and then write them as eight-bit
   // bytes with the high bit on all but the last.
-  uint64 ReadUnsignedLEB128(const char* buffer, size_t* len) const;
+  uint64_t ReadUnsignedLEB128(const uint8_t* buffer, size_t* len) const;
 
   // Read a signed LEB128 number from BUFFER and return it as an
   // signed 64 bit integer. Set LEN to the number of bytes read.
@@ -112,7 +120,7 @@ class ByteReader {
   // In other words, we break VALUE into groups of seven bits, put
   // them in little-endian order, and then write them as eight-bit
   // bytes with the high bit on all but the last.
-  int64 ReadSignedLEB128(const char* buffer, size_t* len) const;
+  int64_t ReadSignedLEB128(const uint8_t* buffer, size_t* len) const;
 
   // Indicate that addresses on this architecture are SIZE bytes long. SIZE
   // must be either 4 or 8. (DWARF allows addresses to be any number of
@@ -126,16 +134,16 @@ class ByteReader {
   // frame information doesn't indicate its address size (a shortcoming of
   // the spec); you must supply the appropriate size based on the
   // architecture of the target machine.
-  void SetAddressSize(uint8 size);
+  void SetAddressSize(uint8_t size);
 
   // Return the current address size, in bytes. This is either 4,
   // indicating 32-bit addresses, or 8, indicating 64-bit addresses.
-  uint8 AddressSize() const { return address_size_; }
+  uint8_t AddressSize() const { return address_size_; }
 
   // Read an address from BUFFER and return it as an unsigned 64 bit
   // integer, respecting this ByteReader's endianness and address size. You
   // must call SetAddressSize before calling this function.
-  uint64 ReadAddress(const char* buffer) const;
+  uint64_t ReadAddress(const uint8_t* buffer) const;
 
   // DWARF actually defines two slightly different formats: 32-bit DWARF
   // and 64-bit DWARF. This is *not* related to the size of registers or
@@ -172,26 +180,26 @@ class ByteReader {
   // - The 32-bit value 0xffffffff, followed by a 64-bit byte count,
   //   indicating that the data whose length is being measured uses
   //   the 64-bit DWARF format.
-  uint64 ReadInitialLength(const char* start, size_t* len);
+  uint64_t ReadInitialLength(const uint8_t* start, size_t* len);
 
   // Read an offset from BUFFER and return it as an unsigned 64 bit
   // integer, respecting the ByteReader's endianness. In 32-bit DWARF, the
   // offset is 4 bytes long; in 64-bit DWARF, the offset is eight bytes
   // long. You must call ReadInitialLength or SetOffsetSize before calling
   // this function; see the comments above for details.
-  uint64 ReadOffset(const char* buffer) const;
+  uint64_t ReadOffset(const uint8_t* buffer) const;
 
   // Return the current offset size, in bytes.
   // A return value of 4 indicates that we are reading 32-bit DWARF.
   // A return value of 8 indicates that we are reading 64-bit DWARF.
-  uint8 OffsetSize() const { return offset_size_; }
+  uint8_t OffsetSize() const { return offset_size_; }
 
   // Indicate that section offsets and lengths are SIZE bytes long. SIZE
   // must be either 4 (meaning 32-bit DWARF) or 8 (meaning 64-bit DWARF).
   // Usually, you should not call this function yourself; instead, let a
   // call to ReadInitialLength establish the data's offset size
   // automatically.
-  void SetOffsetSize(uint8 size);
+  void SetOffsetSize(uint8_t size);
 
   // The Linux C++ ABI uses a variant of DWARF call frame information
   // for exception handling. This data is included in the program's
@@ -234,24 +242,24 @@ class ByteReader {
   // is BUFFER_BASE. This allows us to find the address that a given
   // byte in our buffer would have when loaded into the program the
   // data describes. We need this to resolve DW_EH_PE_pcrel pointers.
-  void SetCFIDataBase(uint64 section_base, const char *buffer_base);
+  void SetCFIDataBase(uint64_t section_base, const uint8_t* buffer_base);
 
   // Indicate that the base address of the program's ".text" section
   // is TEXT_BASE. We need this to resolve DW_EH_PE_textrel pointers.
-  void SetTextBase(uint64 text_base);
+  void SetTextBase(uint64_t text_base);
 
   // Indicate that the base address for DW_EH_PE_datarel pointers is
   // DATA_BASE. The proper value depends on the ABI; it is usually the
   // address of the global offset table, held in a designated register in
   // position-independent code. You will need to look at the startup code
   // for the target system to be sure. I tried; my eyes bled.
-  void SetDataBase(uint64 data_base);
+  void SetDataBase(uint64_t data_base);
 
   // Indicate that the base address for the FDE we are processing is
   // FUNCTION_BASE. This is the start address of DW_EH_PE_funcrel
   // pointers. (This encoding does not seem to be used by the GNU
   // toolchain.)
-  void SetFunctionBase(uint64 function_base);
+  void SetFunctionBase(uint64_t function_base);
 
   // Indicate that we are no longer processing any FDE, so any use of
   // a DW_EH_PE_funcrel encoding is an error.
@@ -273,13 +281,15 @@ class ByteReader {
   // base address this reader hasn't been given, so you should check
   // with ValidEncoding and UsableEncoding first if you would rather
   // die in a more helpful way.
-  uint64 ReadEncodedPointer(const char *buffer, DwarfPointerEncoding encoding,
-                            size_t *len) const;
+  uint64_t ReadEncodedPointer(const uint8_t* buffer,
+                            DwarfPointerEncoding encoding,
+                            size_t* len) const;
 
+  Endianness GetEndianness() const;
  private:
 
   // Function pointer type for our address and offset readers.
-  typedef uint64 (ByteReader::*AddressReader)(const char*) const;
+  typedef uint64_t (ByteReader::*AddressReader)(const uint8_t*) const;
 
   // Read an offset from BUFFER and return it as an unsigned 64 bit
   // integer.  DWARF2/3 define offsets as either 4 or 8 bytes,
@@ -295,14 +305,14 @@ class ByteReader {
   AddressReader address_reader_;
 
   Endianness endian_;
-  uint8 address_size_;
-  uint8 offset_size_;
+  uint8_t address_size_;
+  uint8_t offset_size_;
 
   // Base addresses for Linux C++ exception handling data's encoded pointers.
   bool have_section_base_, have_text_base_, have_data_base_;
   bool have_function_base_;
-  uint64 section_base_, text_base_, data_base_, function_base_;
-  const char *buffer_base_;
+  uint64_t section_base_, text_base_, data_base_, function_base_;
+  const uint8_t* buffer_base_;
 };
 
 }  // namespace dwarf2reader
diff --git a/src/MEGASync/google_breakpad/common/dwarf/bytereader_unittest.cc b/src/MEGASync/google_breakpad/common/dwarf/bytereader_unittest.cc
index 4311ab6a..3d7924b9 100644
--- a/src/MEGASync/google_breakpad/common/dwarf/bytereader_unittest.cc
+++ b/src/MEGASync/google_breakpad/common/dwarf/bytereader_unittest.cc
@@ -31,6 +31,8 @@
 
 // bytereader_unittest.cc: Unit tests for dwarf2reader::ByteReader
 
+#include <stdint.h>
+
 #include <string>
 
 #include "breakpad_googletest_includes.h"
@@ -71,7 +73,7 @@ TEST_F(Reader, SimpleConstructor) {
     .LEB128(-0x4f337badf4483f83LL)
     .D32(0xfec319c9);
   ASSERT_TRUE(section.GetContents(&contents));
-  const char *data = contents.data();
+  const uint8_t* data = reinterpret_cast<const uint8_t*>(contents.data());
   EXPECT_EQ(0xc0U, reader.ReadOneByte(data));
   EXPECT_EQ(0xcf0dU, reader.ReadTwoBytes(data + 1));
   EXPECT_EQ(0x96fdd219U, reader.ReadFourBytes(data + 3));
@@ -375,7 +377,7 @@ TEST_F(Reader, ValidEncodings) {
 }
 
 TEST_F(ReaderDeathTest, DW_EH_PE_omit) {
-  static const char data[1] = { 42 };
+  static const uint8_t data[] = { 42 };
   ByteReader reader(ENDIANNESS_BIG);
   reader.SetAddressSize(4);
   EXPECT_DEATH(reader.ReadEncodedPointer(data, dwarf2reader::DW_EH_PE_omit,
@@ -384,7 +386,7 @@ TEST_F(ReaderDeathTest, DW_EH_PE_omit) {
 }
 
 TEST_F(Reader, DW_EH_PE_absptr4) {
-  static const char data[] = { 0x27, 0x57, 0xea, 0x40 };
+  static const uint8_t data[] = { 0x27, 0x57, 0xea, 0x40 };
   ByteReader reader(ENDIANNESS_LITTLE);
   reader.SetAddressSize(4);
   EXPECT_EQ(0x40ea5727U,
@@ -394,7 +396,7 @@ TEST_F(Reader, DW_EH_PE_absptr4) {
 }
 
 TEST_F(Reader, DW_EH_PE_absptr8) {
-  static const char data[] = {
+  static const uint8_t data[] = {
     0x60, 0x27, 0x57, 0xea, 0x40, 0xc2, 0x98, 0x05, 0x01, 0x50
   };
   ByteReader reader(ENDIANNESS_LITTLE);
@@ -406,7 +408,7 @@ TEST_F(Reader, DW_EH_PE_absptr8) {
 }
 
 TEST_F(Reader, DW_EH_PE_uleb128) {
-  static const char data[] = { 0x81, 0x84, 0x4c };
+  static const uint8_t data[] = { 0x81, 0x84, 0x4c };
   ByteReader reader(ENDIANNESS_LITTLE);
   reader.SetAddressSize(4);
   EXPECT_EQ(0x130201U,
@@ -416,7 +418,7 @@ TEST_F(Reader, DW_EH_PE_uleb128) {
 }
 
 TEST_F(Reader, DW_EH_PE_udata2) {
-  static const char data[] = { 0xf4, 0x8d };
+  static const uint8_t data[] = { 0xf4, 0x8d };
   ByteReader reader(ENDIANNESS_BIG);
   reader.SetAddressSize(4);
   EXPECT_EQ(0xf48dU,
@@ -426,7 +428,7 @@ TEST_F(Reader, DW_EH_PE_udata2) {
 }
 
 TEST_F(Reader, DW_EH_PE_udata4) {
-  static const char data[] = { 0xb2, 0x68, 0xa5, 0x62, 0x8f, 0x8b };
+  static const uint8_t data[] = { 0xb2, 0x68, 0xa5, 0x62, 0x8f, 0x8b };
   ByteReader reader(ENDIANNESS_BIG);
   reader.SetAddressSize(8);
   EXPECT_EQ(0xa5628f8b,
@@ -436,7 +438,7 @@ TEST_F(Reader, DW_EH_PE_udata4) {
 }
 
 TEST_F(Reader, DW_EH_PE_udata8Addr8) {
-  static const char data[] = {
+  static const uint8_t data[] = {
     0x27, 0x04, 0x73, 0x04, 0x69, 0x9f, 0x19, 0xed, 0x8f, 0xfe
   };
   ByteReader reader(ENDIANNESS_LITTLE);
@@ -448,7 +450,7 @@ TEST_F(Reader, DW_EH_PE_udata8Addr8) {
 }
 
 TEST_F(Reader, DW_EH_PE_udata8Addr4) {
-  static const char data[] = {
+  static const uint8_t data[] = {
     0x27, 0x04, 0x73, 0x04, 0x69, 0x9f, 0x19, 0xed, 0x8f, 0xfe
   };
   ByteReader reader(ENDIANNESS_LITTLE);
@@ -460,7 +462,7 @@ TEST_F(Reader, DW_EH_PE_udata8Addr4) {
 }
 
 TEST_F(Reader, DW_EH_PE_sleb128) {
-  static const char data[] = { 0x42, 0xff, 0xfb, 0x73 };
+  static const uint8_t data[] = { 0x42, 0xff, 0xfb, 0x73 };
   ByteReader reader(ENDIANNESS_BIG);
   reader.SetAddressSize(4);
   EXPECT_EQ(-0x030201U & 0xffffffff,
@@ -470,7 +472,7 @@ TEST_F(Reader, DW_EH_PE_sleb128) {
 }
 
 TEST_F(Reader, DW_EH_PE_sdata2) {
-  static const char data[] = { 0xb9, 0xbf };
+  static const uint8_t data[] = { 0xb9, 0xbf };
   ByteReader reader(ENDIANNESS_LITTLE);
   reader.SetAddressSize(8);
   EXPECT_EQ(0xffffffffffffbfb9ULL,
@@ -480,7 +482,7 @@ TEST_F(Reader, DW_EH_PE_sdata2) {
 }
 
 TEST_F(Reader, DW_EH_PE_sdata4) {
-  static const char data[] = { 0xa0, 0xca, 0xf2, 0xb8, 0xc2, 0xad };
+  static const uint8_t data[] = { 0xa0, 0xca, 0xf2, 0xb8, 0xc2, 0xad };
   ByteReader reader(ENDIANNESS_LITTLE);
   reader.SetAddressSize(8);
   EXPECT_EQ(0xffffffffadc2b8f2ULL,
@@ -490,7 +492,7 @@ TEST_F(Reader, DW_EH_PE_sdata4) {
 }
 
 TEST_F(Reader, DW_EH_PE_sdata8) {
-  static const char data[] = {
+  static const uint8_t data[] = {
     0xf6, 0x66, 0x57, 0x79, 0xe0, 0x0c, 0x9b, 0x26, 0x87
   };
   ByteReader reader(ENDIANNESS_LITTLE);
@@ -502,7 +504,9 @@ TEST_F(Reader, DW_EH_PE_sdata8) {
 }
 
 TEST_F(Reader, DW_EH_PE_pcrel) {
-  static const char data[] = { 0x4a, 0x8b, 0x1b, 0x14, 0xc8, 0xc4, 0x02, 0xce };
+  static const uint8_t data[] = {
+    0x4a, 0x8b, 0x1b, 0x14, 0xc8, 0xc4, 0x02, 0xce
+  };
   ByteReader reader(ENDIANNESS_BIG);
   reader.SetAddressSize(4);
   DwarfPointerEncoding encoding =
@@ -515,7 +519,9 @@ TEST_F(Reader, DW_EH_PE_pcrel) {
 }
 
 TEST_F(Reader, DW_EH_PE_textrel) {
-  static const char data[] = { 0xd9, 0x0d, 0x05, 0x17, 0xc9, 0x7a, 0x42, 0x1e };
+  static const uint8_t data[] = {
+    0xd9, 0x0d, 0x05, 0x17, 0xc9, 0x7a, 0x42, 0x1e
+  };
   ByteReader reader(ENDIANNESS_LITTLE);
   reader.SetAddressSize(4);
   reader.SetTextBase(0xb91beaf0);
@@ -528,7 +534,9 @@ TEST_F(Reader, DW_EH_PE_textrel) {
 }
 
 TEST_F(Reader, DW_EH_PE_datarel) {
-  static const char data[] = { 0x16, 0xf2, 0xbb, 0x82, 0x68, 0xa7, 0xbc, 0x39 };
+  static const uint8_t data[] = {
+    0x16, 0xf2, 0xbb, 0x82, 0x68, 0xa7, 0xbc, 0x39
+  };
   ByteReader reader(ENDIANNESS_BIG);
   reader.SetAddressSize(8);
   reader.SetDataBase(0xbef308bd25ce74f0ULL);
@@ -541,7 +549,9 @@ TEST_F(Reader, DW_EH_PE_datarel) {
 }
 
 TEST_F(Reader, DW_EH_PE_funcrel) {
-  static const char data[] = { 0x84, 0xf8, 0x14, 0x01, 0x61, 0xd1, 0x48, 0xc9 };
+  static const uint8_t data[] = {
+    0x84, 0xf8, 0x14, 0x01, 0x61, 0xd1, 0x48, 0xc9
+  };
   ByteReader reader(ENDIANNESS_BIG);
   reader.SetAddressSize(4);
   reader.SetFunctionBase(0x823c3520);
@@ -554,7 +564,7 @@ TEST_F(Reader, DW_EH_PE_funcrel) {
 }
 
 TEST(UsableBase, CFI) {
-  static const char data[1] = { 0x42 };
+  static const uint8_t data[] = { 0x42 };
   ByteReader reader(ENDIANNESS_BIG);
   reader.SetCFIDataBase(0xb31cbd20, data);
   EXPECT_TRUE(reader.UsableEncoding(dwarf2reader::DW_EH_PE_absptr));
@@ -617,12 +627,12 @@ TEST(UsableBase, ClearFunction) {
 
 struct AlignedFixture {
   AlignedFixture() : reader(ENDIANNESS_BIG) { reader.SetAddressSize(4); }
-  static const char data[10];
+  static const uint8_t data[10];
   ByteReader reader;
   size_t pointer_size;
 };
   
-const char AlignedFixture::data[10] = {
+const uint8_t AlignedFixture::data[10] = {
   0xfe, 0x6e, 0x93, 0xd8, 0x34, 0xd5, 0x1c, 0xd3, 0xac, 0x2b
 };
 
diff --git a/src/MEGASync/google_breakpad/common/dwarf/cfi_assembler.cc b/src/MEGASync/google_breakpad/common/dwarf/cfi_assembler.cc
index dbc2efae..858fd561 100644
--- a/src/MEGASync/google_breakpad/common/dwarf/cfi_assembler.cc
+++ b/src/MEGASync/google_breakpad/common/dwarf/cfi_assembler.cc
@@ -41,12 +41,14 @@ namespace google_breakpad {
 
 using dwarf2reader::DwarfPointerEncoding;
   
-CFISection &CFISection::CIEHeader(uint64_t code_alignment_factor,
+CFISection& CFISection::CIEHeader(uint64_t code_alignment_factor,
                                   int data_alignment_factor,
                                   unsigned return_address_register,
                                   uint8_t version,
-                                  const string &augmentation,
-                                  bool dwarf64) {
+                                  const string& augmentation,
+                                  bool dwarf64,
+                                  uint8_t address_size,
+                                  uint8_t segment_size) {
   assert(!entry_length_);
   entry_length_ = new PendingLength();
   in_fde_ = false;
@@ -63,6 +65,10 @@ CFISection &CFISection::CIEHeader(uint64_t code_alignment_factor,
   }
   D8(version);
   AppendCString(augmentation);
+  if (version >= 4) {
+    D8(address_size);
+    D8(segment_size);
+  }
   ULEB128(code_alignment_factor);
   LEB128(data_alignment_factor);
   if (version == 1)
@@ -72,7 +78,7 @@ CFISection &CFISection::CIEHeader(uint64_t code_alignment_factor,
   return *this;
 }
 
-CFISection &CFISection::FDEHeader(Label cie_pointer,
+CFISection& CFISection::FDEHeader(Label cie_pointer,
                                   uint64_t initial_location,
                                   uint64_t address_range,
                                   bool dwarf64) {
@@ -107,7 +113,7 @@ CFISection &CFISection::FDEHeader(Label cie_pointer,
   return *this;
 }
 
-CFISection &CFISection::FinishEntry() {
+CFISection& CFISection::FinishEntry() {
   assert(entry_length_);
   Align(address_size_, dwarf2reader::DW_CFA_nop);
   entry_length_->length = Here() - entry_length_->start;
@@ -117,9 +123,9 @@ CFISection &CFISection::FinishEntry() {
   return *this;
 }
 
-CFISection &CFISection::EncodedPointer(uint64_t address,
+CFISection& CFISection::EncodedPointer(uint64_t address,
                                        DwarfPointerEncoding encoding,
-                                       const EncodedPointerBases &bases) {
+                                       const EncodedPointerBases& bases) {
   // Omitted data is extremely easy to emit.
   if (encoding == dwarf2reader::DW_EH_PE_omit)
     return *this;
diff --git a/src/MEGASync/google_breakpad/common/dwarf/cfi_assembler.h b/src/MEGASync/google_breakpad/common/dwarf/cfi_assembler.h
index 227812b5..d60ecc9e 100644
--- a/src/MEGASync/google_breakpad/common/dwarf/cfi_assembler.h
+++ b/src/MEGASync/google_breakpad/common/dwarf/cfi_assembler.h
@@ -120,7 +120,7 @@ class CFISection: public Section {
   // Use the addresses in BASES as the base addresses for encoded
   // pointers in subsequent calls to FDEHeader or EncodedPointer.
   // This function makes a copy of BASES.
-  void SetEncodedPointerBases(const EncodedPointerBases &bases) {
+  void SetEncodedPointerBases(const EncodedPointerBases& bases) {
     encoded_pointer_bases_ = bases;
   }
 
@@ -133,12 +133,14 @@ class CFISection: public Section {
   // Before calling this function, you will typically want to use Mark
   // or Here to make a label to pass to FDEHeader that refers to this
   // CIE's position in the section.
-  CFISection &CIEHeader(uint64_t code_alignment_factor,
+  CFISection& CIEHeader(uint64_t code_alignment_factor,
                         int data_alignment_factor,
                         unsigned return_address_register,
                         uint8_t version = 3,
-                        const string &augmentation = "",
-                        bool dwarf64 = false);
+                        const string& augmentation = "",
+                        bool dwarf64 = false,
+                        uint8_t address_size = 8,
+                        uint8_t segment_size = 0);
 
   // Append a Frame Description Entry header to this section with the
   // given values. If dwarf64 is true, use the 64-bit DWARF initial
@@ -150,7 +152,7 @@ class CFISection: public Section {
   // 0xffffff00 bytes. (The "initial length" is always a 32-bit
   // value.) Nor does it support .debug_frame sections longer than
   // 0xffffff00 bytes.
-  CFISection &FDEHeader(Label cie_pointer,
+  CFISection& FDEHeader(Label cie_pointer,
                         uint64_t initial_location,
                         uint64_t address_range,
                         bool dwarf64 = false);
@@ -159,11 +161,11 @@ class CFISection: public Section {
   // started, after padding with DW_CFA_nops for alignment. This
   // defines the label representing the entry's length, cited in the
   // entry's header. Return a reference to this section.
-  CFISection &FinishEntry();
+  CFISection& FinishEntry();
 
   // Append the contents of BLOCK as a DW_FORM_block value: an
   // unsigned LEB128 length, followed by that many bytes of data.
-  CFISection &Block(const string &block) {
+  CFISection& Block(const string& block) {
     ULEB128(block.size());
     Append(block);
     return *this;
@@ -171,11 +173,11 @@ class CFISection: public Section {
 
   // Append ADDRESS to this section, in the appropriate size and
   // endianness. Return a reference to this section.
-  CFISection &Address(uint64_t address) {
+  CFISection& Address(uint64_t address) {
     Section::Append(endianness(), address_size_, address);
     return *this;
   }
-  CFISection &Address(Label address) {
+  CFISection& Address(Label address) {
     Section::Append(endianness(), address_size_, address);
     return *this;
   }
@@ -189,26 +191,26 @@ class CFISection: public Section {
   // 
   // (C++ doesn't let me use default arguments here, because I want to
   // refer to members of *this in the default argument expression.)
-  CFISection &EncodedPointer(uint64_t address) {
+  CFISection& EncodedPointer(uint64_t address) {
     return EncodedPointer(address, pointer_encoding_, encoded_pointer_bases_);
   }
-  CFISection &EncodedPointer(uint64_t address, DwarfPointerEncoding encoding) {
+  CFISection& EncodedPointer(uint64_t address, DwarfPointerEncoding encoding) {
     return EncodedPointer(address, encoding, encoded_pointer_bases_);
   }
-  CFISection &EncodedPointer(uint64_t address, DwarfPointerEncoding encoding,
-                             const EncodedPointerBases &bases);
+  CFISection& EncodedPointer(uint64_t address, DwarfPointerEncoding encoding,
+                             const EncodedPointerBases& bases);
 
   // Restate some member functions, to keep chaining working nicely.
-  CFISection &Mark(Label *label)   { Section::Mark(label); return *this; }
-  CFISection &D8(uint8_t v)       { Section::D8(v);       return *this; }
-  CFISection &D16(uint16_t v)     { Section::D16(v);      return *this; }
-  CFISection &D16(Label v)         { Section::D16(v);      return *this; }
-  CFISection &D32(uint32_t v)     { Section::D32(v);      return *this; }
-  CFISection &D32(const Label &v)  { Section::D32(v);      return *this; }
-  CFISection &D64(uint64_t v)     { Section::D64(v);      return *this; }
-  CFISection &D64(const Label &v)  { Section::D64(v);      return *this; }
-  CFISection &LEB128(long long v)  { Section::LEB128(v);   return *this; }
-  CFISection &ULEB128(uint64_t v) { Section::ULEB128(v);  return *this; }
+  CFISection& Mark(Label* label)  { Section::Mark(label); return *this; }
+  CFISection& D8(uint8_t v)       { Section::D8(v);       return *this; }
+  CFISection& D16(uint16_t v)     { Section::D16(v);      return *this; }
+  CFISection& D16(Label v)        { Section::D16(v);      return *this; }
+  CFISection& D32(uint32_t v)     { Section::D32(v);      return *this; }
+  CFISection& D32(const Label& v) { Section::D32(v);      return *this; }
+  CFISection& D64(uint64_t v)     { Section::D64(v);      return *this; }
+  CFISection& D64(const Label& v) { Section::D64(v);      return *this; }
+  CFISection& LEB128(long long v) { Section::LEB128(v);   return *this; }
+  CFISection& ULEB128(uint64_t v) { Section::ULEB128(v);  return *this; }
 
  private:
   // A length value that we've appended to the section, but is not yet
diff --git a/src/MEGASync/google_breakpad/common/dwarf/dwarf2diehandler.cc b/src/MEGASync/google_breakpad/common/dwarf/dwarf2diehandler.cc
index 20c15fa9..f5a0683e 100644
--- a/src/MEGASync/google_breakpad/common/dwarf/dwarf2diehandler.cc
+++ b/src/MEGASync/google_breakpad/common/dwarf/dwarf2diehandler.cc
@@ -32,6 +32,7 @@
 // See dwarf2diehandler.h for details.
 
 #include <assert.h>
+#include <stdint.h>
 
 #include <string>
 
@@ -42,24 +43,24 @@ namespace dwarf2reader {
 
 DIEDispatcher::~DIEDispatcher() {
   while (!die_handlers_.empty()) {
-    HandlerStack &entry = die_handlers_.top();
+    HandlerStack& entry = die_handlers_.top();
     if (entry.handler_ != root_handler_)
       delete entry.handler_;
     die_handlers_.pop();
   }
 }
 
-bool DIEDispatcher::StartCompilationUnit(uint64 offset, uint8 address_size,
-                                         uint8 offset_size, uint64 cu_length,
-                                         uint8 dwarf_version) {
+bool DIEDispatcher::StartCompilationUnit(uint64_t offset, uint8_t address_size,
+                                         uint8_t offset_size, uint64_t cu_length,
+                                         uint8_t dwarf_version) {
   return root_handler_->StartCompilationUnit(offset, address_size,
                                              offset_size, cu_length,
                                              dwarf_version);
 }
 
-bool DIEDispatcher::StartDIE(uint64 offset, enum DwarfTag tag) {
+bool DIEDispatcher::StartDIE(uint64_t offset, enum DwarfTag tag) {
   // The stack entry for the parent of this DIE, if there is one.
-  HandlerStack *parent = die_handlers_.empty() ? NULL : &die_handlers_.top();
+  HandlerStack* parent = die_handlers_.empty() ? NULL : &die_handlers_.top();
 
   // Does this call indicate that we're done receiving the parent's
   // attributes' values?  If so, call its EndAttributes member function.
@@ -77,7 +78,7 @@ bool DIEDispatcher::StartDIE(uint64 offset, enum DwarfTag tag) {
   }
 
   // Find a handler for this DIE.
-  DIEHandler *handler;
+  DIEHandler* handler;
   if (parent) {
     if (parent->handler_)
       // Ask the parent to find a handler.
@@ -112,9 +113,9 @@ bool DIEDispatcher::StartDIE(uint64 offset, enum DwarfTag tag) {
   return handler != NULL;
 }
 
-void DIEDispatcher::EndDIE(uint64 offset) {
+void DIEDispatcher::EndDIE(uint64_t offset) {
   assert(!die_handlers_.empty());
-  HandlerStack *entry = &die_handlers_.top();
+  HandlerStack* entry = &die_handlers_.top();
   if (entry->handler_) {
     // This entry had better be the handler for this DIE.
     assert(entry->offset_ == offset);
@@ -134,62 +135,62 @@ void DIEDispatcher::EndDIE(uint64 offset) {
   die_handlers_.pop();
 }
 
-void DIEDispatcher::ProcessAttributeUnsigned(uint64 offset,
+void DIEDispatcher::ProcessAttributeUnsigned(uint64_t offset,
                                              enum DwarfAttribute attr,
                                              enum DwarfForm form,
-                                             uint64 data) {
-  HandlerStack &current = die_handlers_.top();
+                                             uint64_t data) {
+  HandlerStack& current = die_handlers_.top();
   // This had better be an attribute of the DIE we were meant to handle.
   assert(offset == current.offset_);
   current.handler_->ProcessAttributeUnsigned(attr, form, data);
 }
 
-void DIEDispatcher::ProcessAttributeSigned(uint64 offset,
+void DIEDispatcher::ProcessAttributeSigned(uint64_t offset,
                                            enum DwarfAttribute attr,
                                            enum DwarfForm form,
-                                           int64 data) {
-  HandlerStack &current = die_handlers_.top();
+                                           int64_t data) {
+  HandlerStack& current = die_handlers_.top();
   // This had better be an attribute of the DIE we were meant to handle.
   assert(offset == current.offset_);
   current.handler_->ProcessAttributeSigned(attr, form, data);
 }
 
-void DIEDispatcher::ProcessAttributeReference(uint64 offset,
+void DIEDispatcher::ProcessAttributeReference(uint64_t offset,
                                               enum DwarfAttribute attr,
                                               enum DwarfForm form,
-                                              uint64 data) {
-  HandlerStack &current = die_handlers_.top();
+                                              uint64_t data) {
+  HandlerStack& current = die_handlers_.top();
   // This had better be an attribute of the DIE we were meant to handle.
   assert(offset == current.offset_);
   current.handler_->ProcessAttributeReference(attr, form, data);
 }
 
-void DIEDispatcher::ProcessAttributeBuffer(uint64 offset,
+void DIEDispatcher::ProcessAttributeBuffer(uint64_t offset,
                                            enum DwarfAttribute attr,
                                            enum DwarfForm form,
-                                           const char* data,
-                                           uint64 len) {
-  HandlerStack &current = die_handlers_.top();
+                                           const uint8_t* data,
+                                           uint64_t len) {
+  HandlerStack& current = die_handlers_.top();
   // This had better be an attribute of the DIE we were meant to handle.
   assert(offset == current.offset_);
   current.handler_->ProcessAttributeBuffer(attr, form, data, len);
 }
 
-void DIEDispatcher::ProcessAttributeString(uint64 offset,
+void DIEDispatcher::ProcessAttributeString(uint64_t offset,
                                            enum DwarfAttribute attr,
                                            enum DwarfForm form,
                                            const string& data) {
-  HandlerStack &current = die_handlers_.top();
+  HandlerStack& current = die_handlers_.top();
   // This had better be an attribute of the DIE we were meant to handle.
   assert(offset == current.offset_);
   current.handler_->ProcessAttributeString(attr, form, data);
 }
 
-void DIEDispatcher::ProcessAttributeSignature(uint64 offset,
+void DIEDispatcher::ProcessAttributeSignature(uint64_t offset,
                                               enum DwarfAttribute attr,
                                               enum DwarfForm form,
-                                              uint64 signature) {
-  HandlerStack &current = die_handlers_.top();
+                                              uint64_t signature) {
+  HandlerStack& current = die_handlers_.top();
   // This had better be an attribute of the DIE we were meant to handle.
   assert(offset == current.offset_);
   current.handler_->ProcessAttributeSignature(attr, form, signature);
diff --git a/src/MEGASync/google_breakpad/common/dwarf/dwarf2diehandler.h b/src/MEGASync/google_breakpad/common/dwarf/dwarf2diehandler.h
index 81f40f07..028a6d11 100644
--- a/src/MEGASync/google_breakpad/common/dwarf/dwarf2diehandler.h
+++ b/src/MEGASync/google_breakpad/common/dwarf/dwarf2diehandler.h
@@ -156,6 +156,8 @@
 #ifndef COMMON_DWARF_DWARF2DIEHANDLER_H__
 #define COMMON_DWARF_DWARF2DIEHANDLER_H__
 
+#include <stdint.h>
+
 #include <stack>
 #include <string>
 
@@ -197,23 +199,23 @@ class DIEHandler {
   // The default definitions ignore the values they are passed.
   virtual void ProcessAttributeUnsigned(enum DwarfAttribute attr,
                                         enum DwarfForm form,
-                                        uint64 data) { }
+                                        uint64_t data) { }
   virtual void ProcessAttributeSigned(enum DwarfAttribute attr,
                                       enum DwarfForm form,
-                                      int64 data) { }
+                                      int64_t data) { }
   virtual void ProcessAttributeReference(enum DwarfAttribute attr,
                                          enum DwarfForm form,
-                                         uint64 data) { }
+                                         uint64_t data) { }
   virtual void ProcessAttributeBuffer(enum DwarfAttribute attr,
                                       enum DwarfForm form,
-                                      const char* data,
-                                      uint64 len) { }
+                                      const uint8_t* data,
+                                      uint64_t len) { }
   virtual void ProcessAttributeString(enum DwarfAttribute attr,
                                       enum DwarfForm form,
                                       const string& data) { }
   virtual void ProcessAttributeSignature(enum DwarfAttribute attr,
                                          enum DwarfForm form,
-                                         uint64 signture) { }
+                                         uint64_t signture) { }
 
   // Once we have reported all the DIE's attributes' values, we call
   // this member function.  If it returns false, we skip all the DIE's
@@ -242,7 +244,7 @@ class DIEHandler {
   // it is.
   //
   // The default definition skips all children.
-  virtual DIEHandler *FindChildHandler(uint64 offset, enum DwarfTag tag) {
+  virtual DIEHandler* FindChildHandler(uint64_t offset, enum DwarfTag tag) {
     return NULL;
   }
 
@@ -266,9 +268,9 @@ class RootDIEHandler: public DIEHandler {
   // returns false.  So the root DIE handler is actually also
   // responsible for handling the compilation unit metadata.
   // The default definition always visits the compilation unit.
-  virtual bool StartCompilationUnit(uint64 offset, uint8 address_size,
-                                    uint8 offset_size, uint64 cu_length,
-                                    uint8 dwarf_version) { return true; }
+  virtual bool StartCompilationUnit(uint64_t offset, uint8_t address_size,
+                                    uint8_t offset_size, uint64_t cu_length,
+                                    uint8_t dwarf_version) { return true; }
 
   // For the root DIE handler only, we pass the offset, tag and
   // attributes of the compilation unit's root DIE.  This is the only
@@ -278,7 +280,7 @@ class RootDIEHandler: public DIEHandler {
   // unit.
   //
   // The default definition elects to visit the root DIE.
-  virtual bool StartRootDIE(uint64 offset, enum DwarfTag tag) { return true; }
+  virtual bool StartRootDIE(uint64_t offset, enum DwarfTag tag) { return true; }
 };
 
 class DIEDispatcher: public Dwarf2Handler {
@@ -286,40 +288,40 @@ class DIEDispatcher: public Dwarf2Handler {
   // Create a Dwarf2Handler which uses ROOT_HANDLER as the handler for
   // the compilation unit's root die, as described for the DIEHandler
   // class.
-  DIEDispatcher(RootDIEHandler *root_handler) : root_handler_(root_handler) { }
+  DIEDispatcher(RootDIEHandler* root_handler) : root_handler_(root_handler) { }
   // Destroying a DIEDispatcher destroys all active handler objects
   // except the root handler.
   ~DIEDispatcher();
-  bool StartCompilationUnit(uint64 offset, uint8 address_size,
-                            uint8 offset_size, uint64 cu_length,
-                            uint8 dwarf_version);
-  bool StartDIE(uint64 offset, enum DwarfTag tag);
-  void ProcessAttributeUnsigned(uint64 offset,
+  bool StartCompilationUnit(uint64_t offset, uint8_t address_size,
+                            uint8_t offset_size, uint64_t cu_length,
+                            uint8_t dwarf_version);
+  bool StartDIE(uint64_t offset, enum DwarfTag tag);
+  void ProcessAttributeUnsigned(uint64_t offset,
                                 enum DwarfAttribute attr,
                                 enum DwarfForm form,
-                                uint64 data);
-  void ProcessAttributeSigned(uint64 offset,
+                                uint64_t data);
+  void ProcessAttributeSigned(uint64_t offset,
                               enum DwarfAttribute attr,
                               enum DwarfForm form,
-                              int64 data);
-  void ProcessAttributeReference(uint64 offset,
+                              int64_t data);
+  void ProcessAttributeReference(uint64_t offset,
                                  enum DwarfAttribute attr,
                                  enum DwarfForm form,
-                                 uint64 data);
-  void ProcessAttributeBuffer(uint64 offset,
+                                 uint64_t data);
+  void ProcessAttributeBuffer(uint64_t offset,
                               enum DwarfAttribute attr,
                               enum DwarfForm form,
-                              const char* data,
-                              uint64 len);
-  void ProcessAttributeString(uint64 offset,
+                              const uint8_t* data,
+                              uint64_t len);
+  void ProcessAttributeString(uint64_t offset,
                               enum DwarfAttribute attr,
                               enum DwarfForm form,
-                              const string &data);
-  void ProcessAttributeSignature(uint64 offset,
+                              const string& data);
+  void ProcessAttributeSignature(uint64_t offset,
                                  enum DwarfAttribute attr,
                                  enum DwarfForm form,
-                                 uint64 signature);
-  void EndDIE(uint64 offset);
+                                 uint64_t signature);
+  void EndDIE(uint64_t offset);
 
  private:
 
@@ -329,11 +331,11 @@ class DIEDispatcher: public Dwarf2Handler {
   // makes it easier to see that the code is correct.
   struct HandlerStack {
     // The offset of the DIE for this handler stack entry.
-    uint64 offset_;
+    uint64_t offset_;
 
     // The handler object interested in this DIE's attributes and
     // children.  If NULL, we're not interested in either.
-    DIEHandler *handler_;
+    DIEHandler* handler_;
 
     // Have we reported the end of this DIE's attributes to the handler?
     bool reported_attributes_end_;
@@ -356,7 +358,7 @@ class DIEDispatcher: public Dwarf2Handler {
 
   // The root handler.  We don't push it on die_handlers_ until we
   // actually get the StartDIE call for the root.
-  RootDIEHandler *root_handler_;
+  RootDIEHandler* root_handler_;
 };
 
 } // namespace dwarf2reader
diff --git a/src/MEGASync/google_breakpad/common/dwarf/dwarf2diehandler_unittest.cc b/src/MEGASync/google_breakpad/common/dwarf/dwarf2diehandler_unittest.cc
index c0a532aa..552c3d11 100644
--- a/src/MEGASync/google_breakpad/common/dwarf/dwarf2diehandler_unittest.cc
+++ b/src/MEGASync/google_breakpad/common/dwarf/dwarf2diehandler_unittest.cc
@@ -32,6 +32,8 @@
 
 // dwarf2diehander_unittest.cc: Unit tests for google_breakpad::DIEDispatcher.
 
+#include <stdint.h>
+
 #include <string>
 #include <utility>
 
@@ -61,41 +63,42 @@ using dwarf2reader::RootDIEHandler;
 class MockDIEHandler: public DIEHandler {
  public:
   MOCK_METHOD3(ProcessAttributeUnsigned,
-               void(DwarfAttribute, DwarfForm, uint64));
+               void(DwarfAttribute, DwarfForm, uint64_t));
   MOCK_METHOD3(ProcessAttributeSigned,
-               void(DwarfAttribute, DwarfForm, int64));
+               void(DwarfAttribute, DwarfForm, int64_t));
   MOCK_METHOD3(ProcessAttributeReference,
-               void(DwarfAttribute, DwarfForm, uint64));
+               void(DwarfAttribute, DwarfForm, uint64_t));
   MOCK_METHOD4(ProcessAttributeBuffer,
-               void(DwarfAttribute, DwarfForm, const char *, uint64));
+               void(DwarfAttribute, DwarfForm, const uint8_t*, uint64_t));
   MOCK_METHOD3(ProcessAttributeString,
-               void(DwarfAttribute, DwarfForm, const string &));
+               void(DwarfAttribute, DwarfForm, const string&));
   MOCK_METHOD3(ProcessAttributeSignature,
-               void(DwarfAttribute, DwarfForm, uint64));
+               void(DwarfAttribute, DwarfForm, uint64_t));
   MOCK_METHOD0(EndAttributes, bool());
-  MOCK_METHOD2(FindChildHandler, DIEHandler *(uint64, DwarfTag));
+  MOCK_METHOD2(FindChildHandler, DIEHandler *(uint64_t, DwarfTag));
   MOCK_METHOD0(Finish, void());
 };
 
 class MockRootDIEHandler: public RootDIEHandler {
  public:
   MOCK_METHOD3(ProcessAttributeUnsigned,
-               void(DwarfAttribute, DwarfForm, uint64));
+               void(DwarfAttribute, DwarfForm, uint64_t));
   MOCK_METHOD3(ProcessAttributeSigned,
-               void(DwarfAttribute, DwarfForm, int64));
+               void(DwarfAttribute, DwarfForm, int64_t));
   MOCK_METHOD3(ProcessAttributeReference,
-               void(DwarfAttribute, DwarfForm, uint64));
+               void(DwarfAttribute, DwarfForm, uint64_t));
   MOCK_METHOD4(ProcessAttributeBuffer,
-               void(DwarfAttribute, DwarfForm, const char *, uint64));
+               void(DwarfAttribute, DwarfForm, const uint8_t*, uint64_t));
   MOCK_METHOD3(ProcessAttributeString,
-               void(DwarfAttribute, DwarfForm, const string &));
+               void(DwarfAttribute, DwarfForm, const string&));
   MOCK_METHOD3(ProcessAttributeSignature,
-               void(DwarfAttribute, DwarfForm, uint64));
+               void(DwarfAttribute, DwarfForm, uint64_t));
   MOCK_METHOD0(EndAttributes, bool());
-  MOCK_METHOD2(FindChildHandler, DIEHandler *(uint64, DwarfTag));
+  MOCK_METHOD2(FindChildHandler, DIEHandler *(uint64_t, DwarfTag));
   MOCK_METHOD0(Finish, void());
-  MOCK_METHOD5(StartCompilationUnit, bool(uint64, uint8, uint8, uint64, uint8));
-  MOCK_METHOD2(StartRootDIE, bool(uint64, DwarfTag));
+  MOCK_METHOD5(StartCompilationUnit, bool(uint64_t, uint8_t, uint8_t, uint64_t,
+                                          uint8_t));
+  MOCK_METHOD2(StartRootDIE, bool(uint64_t, DwarfTag));
 };
 
 // If the handler elects to skip the compilation unit, the dispatcher
@@ -185,8 +188,9 @@ TEST(Dwarf2DIEHandler, PassAttributeValues) {
   MockRootDIEHandler mock_root_handler;
   DIEDispatcher die_dispatcher(&mock_root_handler);
 
-  const char buffer[10] = { 0x24, 0x24, 0x35, 0x9a, 0xca,
-                            0xcf, 0xa8, 0x84, 0xa7, 0x18 };
+  const uint8_t buffer[10] = {
+    0x24, 0x24, 0x35, 0x9a, 0xca, 0xcf, 0xa8, 0x84, 0xa7, 0x18
+  };
   string str = "\xc8\x26\x2e\x0d\xa4\x9c\x37\xd6\xfb\x1d";
 
   // Set expectations.
@@ -335,7 +339,7 @@ TEST(Dwarf2DIEHandler, FindAndSkipChildren) {
       EXPECT_CALL(mock_root_handler,
                   FindChildHandler(0x97412be24875de9dLL,
                                    (DwarfTag) 0x505a068b))
-        .WillOnce(Return((DIEHandler *) NULL));
+        .WillOnce(Return((DIEHandler*) NULL));
 
       // Third child DIE.
       EXPECT_CALL(mock_root_handler,
diff --git a/src/MEGASync/google_breakpad/common/dwarf/dwarf2enums.h b/src/MEGASync/google_breakpad/common/dwarf/dwarf2enums.h
index 5565d66e..7bd39792 100644
--- a/src/MEGASync/google_breakpad/common/dwarf/dwarf2enums.h
+++ b/src/MEGASync/google_breakpad/common/dwarf/dwarf2enums.h
@@ -115,6 +115,16 @@ enum DwarfTag {
   DW_TAG_PGI_interface_block = 0xA020
 };
 
+enum DwarfUnitHeader {
+  DW_UT_compile = 0x01,
+  DW_UT_type = 0x02,
+  DW_UT_partial = 0x03,
+  DW_UT_skeleton = 0x04,
+  DW_UT_split_compile = 0x05,
+  DW_UT_split_type = 0x06,
+  DW_UT_lo_user = 0x80,
+  DW_UT_hi_user = 0xFF
+};
 
 enum DwarfHasChild {
   DW_children_no = 0,
@@ -149,7 +159,30 @@ enum DwarfForm {
   DW_FORM_sec_offset = 0x17,
   DW_FORM_exprloc = 0x18,
   DW_FORM_flag_present = 0x19,
-  DW_FORM_ref_sig8 = 0x20
+
+  // Added in DWARF 5:
+  DW_FORM_strx = 0x1a,
+  DW_FORM_strp_sup = 0x1d,
+  DW_FORM_line_strp = 0x1f,
+
+  // DWARF 4, but value out of order.
+  DW_FORM_ref_sig8 = 0x20,
+
+  // Added in DWARF 5:
+  DW_FORM_strx1 = 0x25,
+  DW_FORM_strx2 = 0x26,
+  DW_FORM_strx3 = 0x27,
+  DW_FORM_strx4 = 0x28,
+
+  DW_FORM_addrx = 0x1b,
+  DW_FORM_addrx1 = 0x29,
+  DW_FORM_addrx2 = 0x2a,
+  DW_FORM_addrx3 = 0x2b,
+  DW_FORM_addrx4 = 0x2c,
+
+  // Extensions for Fission.  See http://gcc.gnu.org/wiki/DebugFission.
+  DW_FORM_GNU_addr_index = 0x1f01,
+  DW_FORM_GNU_str_index = 0x1f02
 };
 
 // Attribute names and codes
@@ -229,6 +262,8 @@ enum DwarfAttribute {
   DW_AT_call_column   = 0x57,
   DW_AT_call_file     = 0x58,
   DW_AT_call_line     = 0x59,
+  // DWARF 4
+  DW_AT_linkage_name  = 0x6e,
   // SGI/MIPS extensions.
   DW_AT_MIPS_fde = 0x2001,
   DW_AT_MIPS_loop_begin = 0x2002,
@@ -264,6 +299,13 @@ enum DwarfAttribute {
   DW_AT_body_begin = 0x2105,
   DW_AT_body_end   = 0x2106,
   DW_AT_GNU_vector = 0x2107,
+  // Extensions for Fission.  See http://gcc.gnu.org/wiki/DebugFission.
+  DW_AT_GNU_dwo_name = 0x2130,
+  DW_AT_GNU_dwo_id = 0x2131,
+  DW_AT_GNU_ranges_base = 0x2132,
+  DW_AT_GNU_addr_base = 0x2133,
+  DW_AT_GNU_pubnames = 0x2134,
+  DW_AT_GNU_pubtypes = 0x2135,
   // VMS extensions.
   DW_AT_VMS_rtnbeg_pd_address = 0x2201,
   // UPC extension.
@@ -274,6 +316,14 @@ enum DwarfAttribute {
   DW_AT_PGI_lstride  = 0x3a02
 };
 
+// Line number content type codes (DWARF 5).
+enum DwarfLineNumberContentType {
+  DW_LNCT_path = 1,
+  DW_LNCT_directory_index = 2,
+  DW_LNCT_timestamp = 3,
+  DW_LNCT_size = 4,
+  DW_LNCT_MD5 = 5,
+};
 
 // Line number opcodes.
 enum DwarfLineNumberOps {
@@ -489,9 +539,24 @@ enum DwarfOpcode {
   DW_OP_call_frame_cfa               =0x9c,
   DW_OP_bit_piece                    =0x9d,
   DW_OP_lo_user                      =0xe0,
-  DW_OP_hi_user                      =0xff,  
+  DW_OP_hi_user                      =0xff,
   // GNU extensions
-  DW_OP_GNU_push_tls_address         =0xe0
+  DW_OP_GNU_push_tls_address         =0xe0,
+  // Extensions for Fission.  See http://gcc.gnu.org/wiki/DebugFission.
+  DW_OP_GNU_addr_index               =0xfb,
+  DW_OP_GNU_const_index              =0xfc
+};
+
+// Section identifiers for DWP files
+enum DwarfSectionId {
+  DW_SECT_INFO = 1,
+  DW_SECT_TYPES = 2,
+  DW_SECT_ABBREV = 3,
+  DW_SECT_LINE = 4,
+  DW_SECT_LOC = 5,
+  DW_SECT_STR_OFFSETS = 6,
+  DW_SECT_MACINFO = 7,
+  DW_SECT_MACRO = 8
 };
 
 // Source languages.  These are values for DW_AT_language.
@@ -517,6 +582,8 @@ enum DwarfLanguage
     DW_LANG_ObjC_plus_plus           =0x0011,
     DW_LANG_UPC                      =0x0012,
     DW_LANG_D                        =0x0013,
+    DW_LANG_Rust                     =0x001c,
+    DW_LANG_Swift                    =0x001e,
     // Implementation-defined language code range.
     DW_LANG_lo_user = 0x8000,
     DW_LANG_hi_user = 0xffff,
@@ -643,7 +710,7 @@ enum DwarfPointerEncoding
     // encoding (except DW_EH_PE_aligned), and indicates that the
     // encoded value represents the address at which the true address
     // is stored, not the true address itself.
-    DW_EH_PE_indirect	= 0x80  
+    DW_EH_PE_indirect	= 0x80
   };
 
 }  // namespace dwarf2reader
diff --git a/src/MEGASync/google_breakpad/common/dwarf/dwarf2reader.cc b/src/MEGASync/google_breakpad/common/dwarf/dwarf2reader.cc
index a26143c7..aca83677 100644
--- a/src/MEGASync/google_breakpad/common/dwarf/dwarf2reader.cc
+++ b/src/MEGASync/google_breakpad/common/dwarf/dwarf2reader.cc
@@ -33,7 +33,6 @@
 
 #include "common/dwarf/dwarf2reader.h"
 
-#include <assert.h>
 #include <stdint.h>
 #include <stdio.h>
 #include <string.h>
@@ -44,18 +43,61 @@
 #include <string>
 #include <utility>
 
+#include <sys/stat.h>
+
 #include "common/dwarf/bytereader-inl.h"
 #include "common/dwarf/bytereader.h"
 #include "common/dwarf/line_state_machine.h"
 #include "common/using_std_string.h"
+#include "google_breakpad/common/breakpad_types.h"
 
 namespace dwarf2reader {
 
-CompilationUnit::CompilationUnit(const SectionMap& sections, uint64 offset,
+const SectionMap::const_iterator GetSectionByName(const SectionMap&
+                                                  sections, const char *name) {
+  assert(name[0] == '.');
+  auto iter = sections.find(name);
+  if (iter != sections.end())
+    return iter;
+  std::string macho_name("__");
+  macho_name += name + 1;
+  iter = sections.find(macho_name);
+  return iter;
+}
+
+CompilationUnit::CompilationUnit(const string& path,
+                                 const SectionMap& sections, uint64_t offset,
                                  ByteReader* reader, Dwarf2Handler* handler)
-    : offset_from_section_start_(offset), reader_(reader),
-      sections_(sections), handler_(handler), abbrevs_(NULL),
-      string_buffer_(NULL), string_buffer_length_(0) {}
+    : path_(path), offset_from_section_start_(offset), reader_(reader),
+      sections_(sections), handler_(handler), abbrevs_(),
+      string_buffer_(NULL), string_buffer_length_(0),
+      line_string_buffer_(NULL), line_string_buffer_length_(0),
+      str_offsets_buffer_(NULL), str_offsets_buffer_length_(0),
+      addr_buffer_(NULL), addr_buffer_length_(0),
+      is_split_dwarf_(false), dwo_id_(0), dwo_name_(),
+      skeleton_dwo_id_(0), ranges_base_(0), addr_base_(0),
+      have_checked_for_dwp_(false), dwp_path_(),
+      dwp_byte_reader_(), dwp_reader_() {}
+
+// Initialize a compilation unit from a .dwo or .dwp file.
+// In this case, we need the .debug_addr section from the
+// executable file that contains the corresponding skeleton
+// compilation unit.  We also inherit the Dwarf2Handler from
+// the executable file, and call it as if we were still
+// processing the original compilation unit.
+
+void CompilationUnit::SetSplitDwarf(const uint8_t* addr_buffer,
+                                    uint64_t addr_buffer_length,
+                                    uint64_t addr_base,
+                                    uint64_t ranges_base,
+                                    uint64_t dwo_id) {
+  is_split_dwarf_ = true;
+  addr_buffer_ = addr_buffer;
+  addr_buffer_length_ = addr_buffer_length;
+  addr_base_ = addr_base;
+  ranges_base_ = ranges_base;
+  skeleton_dwo_id_ = dwo_id;
+}
 
 // Read a DWARF2/3 abbreviation section.
 // Each abbrev consists of a abbreviation number, a tag, a byte
@@ -69,12 +111,9 @@ void CompilationUnit::ReadAbbrevs() {
   if (abbrevs_)
     return;
 
-  // First get the debug_abbrev section.  ".debug_abbrev" is the name
-  // recommended in the DWARF spec, and used on Linux;
-  // "__debug_abbrev" is the name used in Mac OS X Mach-O files.
-  SectionMap::const_iterator iter = sections_.find(".debug_abbrev");
-  if (iter == sections_.end())
-    iter = sections_.find("__debug_abbrev");
+  // First get the debug_abbrev section.
+  SectionMap::const_iterator iter =
+      GetSectionByName(sections_, ".debug_abbrev");
   assert(iter != sections_.end());
 
   abbrevs_ = new std::vector<Abbrev>;
@@ -83,17 +122,17 @@ void CompilationUnit::ReadAbbrevs() {
   // The only way to check whether we are reading over the end of the
   // buffer would be to first compute the size of the leb128 data by
   // reading it, then go back and read it again.
-  const char* abbrev_start = iter->second.first +
+  const uint8_t* abbrev_start = iter->second.first +
                                       header_.abbrev_offset;
-  const char* abbrevptr = abbrev_start;
+  const uint8_t* abbrevptr = abbrev_start;
 #ifndef NDEBUG
-  const uint64 abbrev_length = iter->second.second - header_.abbrev_offset;
+  const uint64_t abbrev_length = iter->second.second - header_.abbrev_offset;
 #endif
 
   while (1) {
     CompilationUnit::Abbrev abbrev;
     size_t len;
-    const uint64 number = reader_->ReadUnsignedLEB128(abbrevptr, &len);
+    const uint64_t number = reader_->ReadUnsignedLEB128(abbrevptr, &len);
 
     if (number == 0)
       break;
@@ -101,7 +140,7 @@ void CompilationUnit::ReadAbbrevs() {
     abbrevptr += len;
 
     assert(abbrevptr < abbrev_start + abbrev_length);
-    const uint64 tag = reader_->ReadUnsignedLEB128(abbrevptr, &len);
+    const uint64_t tag = reader_->ReadUnsignedLEB128(abbrevptr, &len);
     abbrevptr += len;
     abbrev.tag = static_cast<enum DwarfTag>(tag);
 
@@ -112,11 +151,11 @@ void CompilationUnit::ReadAbbrevs() {
     assert(abbrevptr < abbrev_start + abbrev_length);
 
     while (1) {
-      const uint64 nametemp = reader_->ReadUnsignedLEB128(abbrevptr, &len);
+      const uint64_t nametemp = reader_->ReadUnsignedLEB128(abbrevptr, &len);
       abbrevptr += len;
 
       assert(abbrevptr < abbrev_start + abbrev_length);
-      const uint64 formtemp = reader_->ReadUnsignedLEB128(abbrevptr, &len);
+      const uint64_t formtemp = reader_->ReadUnsignedLEB128(abbrevptr, &len);
       abbrevptr += len;
       if (nametemp == 0 && formtemp == 0)
         break;
@@ -132,8 +171,8 @@ void CompilationUnit::ReadAbbrevs() {
 }
 
 // Skips a single DIE's attributes.
-const char* CompilationUnit::SkipDIE(const char* start,
-                                              const Abbrev& abbrev) {
+const uint8_t* CompilationUnit::SkipDIE(const uint8_t* start,
+                                        const Abbrev& abbrev) {
   for (AttributeList::const_iterator i = abbrev.attributes.begin();
        i != abbrev.attributes.end();
        i++)  {
@@ -143,8 +182,8 @@ const char* CompilationUnit::SkipDIE(const char* start,
 }
 
 // Skips a single attribute form's data.
-const char* CompilationUnit::SkipAttribute(const char* start,
-                                                    enum DwarfForm form) {
+const uint8_t* CompilationUnit::SkipAttribute(const uint8_t* start,
+                                              enum DwarfForm form) {
   size_t len;
 
   switch (form) {
@@ -156,24 +195,37 @@ const char* CompilationUnit::SkipAttribute(const char* start,
 
     case DW_FORM_flag_present:
       return start;
+    case DW_FORM_addrx1:
     case DW_FORM_data1:
     case DW_FORM_flag:
     case DW_FORM_ref1:
+    case DW_FORM_strx1:
       return start + 1;
+    case DW_FORM_addrx2:
     case DW_FORM_ref2:
     case DW_FORM_data2:
+    case DW_FORM_strx2:
       return start + 2;
+    case DW_FORM_addrx3:
+    case DW_FORM_strx3:
+      return start + 3;
+    case DW_FORM_addrx4:
     case DW_FORM_ref4:
     case DW_FORM_data4:
+    case DW_FORM_strx4:
       return start + 4;
     case DW_FORM_ref8:
     case DW_FORM_data8:
     case DW_FORM_ref_sig8:
       return start + 8;
     case DW_FORM_string:
-      return start + strlen(start) + 1;
+      return start + strlen(reinterpret_cast<const char*>(start)) + 1;
     case DW_FORM_udata:
     case DW_FORM_ref_udata:
+    case DW_FORM_strx:
+    case DW_FORM_GNU_str_index:
+    case DW_FORM_GNU_addr_index:
+    case DW_FORM_addrx:
       reader_->ReadUnsignedLEB128(start, &len);
       return start + len;
 
@@ -183,14 +235,15 @@ const char* CompilationUnit::SkipAttribute(const char* start,
     case DW_FORM_addr:
       return start + reader_->AddressSize();
     case DW_FORM_ref_addr:
-      // DWARF2 and 3 differ on whether ref_addr is address size or
+      // DWARF2 and 3/4 differ on whether ref_addr is address size or
       // offset size.
-      assert(header_.version == 2 || header_.version == 3);
+      assert(header_.version >= 2);
       if (header_.version == 2) {
         return start + reader_->AddressSize();
-      } else if (header_.version == 3) {
+      } else if (header_.version >= 3) {
         return start + reader_->OffsetSize();
       }
+      break;
 
     case DW_FORM_block1:
       return start + 1 + reader_->ReadOneByte(start);
@@ -200,10 +253,12 @@ const char* CompilationUnit::SkipAttribute(const char* start,
       return start + 4 + reader_->ReadFourBytes(start);
     case DW_FORM_block:
     case DW_FORM_exprloc: {
-      uint64 size = reader_->ReadUnsignedLEB128(start, &len);
+      uint64_t size = reader_->ReadUnsignedLEB128(start, &len);
       return start + size + len;
     }
     case DW_FORM_strp:
+    case DW_FORM_line_strp:
+    case DW_FORM_strp_sup:
     case DW_FORM_sec_offset:
       return start + reader_->OffsetSize();
   }
@@ -211,17 +266,56 @@ const char* CompilationUnit::SkipAttribute(const char* start,
   return NULL;
 }
 
-// Read a DWARF2/3 header.
-// The header is variable length in DWARF3 (and DWARF2 as extended by
-// most compilers), and consists of an length field, a version number,
-// the offset in the .debug_abbrev section for our abbrevs, and an
-// address size.
+// Read the abbreviation offset from a compilation unit header.
+size_t CompilationUnit::ReadAbbrevOffset(const uint8_t* headerptr) {
+  assert(headerptr + reader_->OffsetSize() < buffer_ + buffer_length_);
+  header_.abbrev_offset = reader_->ReadOffset(headerptr);
+  return reader_->OffsetSize();
+}
+
+// Read the address size from a compilation unit header.
+size_t CompilationUnit::ReadAddressSize(const uint8_t* headerptr) {
+  // Compare against less than or equal because this may be the last
+  // section in the file.
+  assert(headerptr + 1 <= buffer_ + buffer_length_);
+  header_.address_size = reader_->ReadOneByte(headerptr);
+  reader_->SetAddressSize(header_.address_size);
+  return 1;
+}
+
+// Read the DWO id from a split or skeleton compilation unit header.
+size_t CompilationUnit::ReadDwoId(const uint8_t* headerptr) {
+  assert(headerptr + 8 <= buffer_ + buffer_length_);
+  dwo_id_ = reader_->ReadEightBytes(headerptr);
+  return 8;
+}
+
+// Read the type signature from a type or split type compilation unit header.
+size_t CompilationUnit::ReadTypeSignature(const uint8_t* headerptr) {
+  assert(headerptr + 8 <= buffer_ + buffer_length_);
+  type_signature_ = reader_->ReadEightBytes(headerptr);
+  return 8;
+}
+
+// Read the DWO id from a split or skeleton compilation unit header.
+size_t CompilationUnit::ReadTypeOffset(const uint8_t* headerptr) {
+  assert(headerptr + reader_->OffsetSize() < buffer_ + buffer_length_);
+  type_offset_ = reader_->ReadOffset(headerptr);
+  return reader_->OffsetSize();
+}
+
+
+// Read a DWARF header.  The header is variable length in DWARF3 and DWARF4
+// (and DWARF2 as extended by most compilers), and consists of an length
+// field, a version number, the offset in the .debug_abbrev section for our
+// abbrevs, and an address size. DWARF5 adds a unit_type to distinguish
+// between partial-, full-, skeleton-, split-, and type- compilation units.
 void CompilationUnit::ReadHeader() {
-  const char* headerptr = buffer_;
+  const uint8_t* headerptr = buffer_;
   size_t initial_length_size;
 
   assert(headerptr + 4 < buffer_ + buffer_length_);
-  const uint64 initial_length
+  const uint64_t initial_length
     = reader_->ReadInitialLength(headerptr, &initial_length_size);
   headerptr += initial_length_size;
   header_.length = initial_length;
@@ -230,15 +324,36 @@ void CompilationUnit::ReadHeader() {
   header_.version = reader_->ReadTwoBytes(headerptr);
   headerptr += 2;
 
-  assert(headerptr + reader_->OffsetSize() < buffer_ + buffer_length_);
-  header_.abbrev_offset = reader_->ReadOffset(headerptr);
-  headerptr += reader_->OffsetSize();
-
-  assert(headerptr + 1 < buffer_ + buffer_length_);
-  header_.address_size = reader_->ReadOneByte(headerptr);
-  reader_->SetAddressSize(header_.address_size);
-  headerptr += 1;
-
+  if (header_.version <= 4) {
+    // Older versions of dwarf have a relatively simple structure.
+    headerptr += ReadAbbrevOffset(headerptr);
+    headerptr += ReadAddressSize(headerptr);
+  } else {
+    // DWARF5 adds a unit_type field, and various fields based on unit_type.
+    assert(headerptr + 1 < buffer_ + buffer_length_);
+    uint8_t unit_type = reader_->ReadOneByte(headerptr);
+    headerptr += 1;
+    headerptr += ReadAddressSize(headerptr);
+    headerptr += ReadAbbrevOffset(headerptr);
+    switch (unit_type) {
+      case DW_UT_compile:
+      case DW_UT_partial:
+        // nothing else to read
+        break;
+      case DW_UT_skeleton:
+      case DW_UT_split_compile:
+        headerptr += ReadDwoId(headerptr);
+        break;
+      case DW_UT_type:
+      case DW_UT_split_type:
+        headerptr += ReadTypeSignature(headerptr);
+        headerptr += ReadTypeOffset(headerptr);
+        break;
+      default:
+        fprintf(stderr, "Unhandled compilation unit type 0x%x", unit_type);
+        break;
+    }
+  }
   after_header_ = headerptr;
 
   // This check ensures that we don't have to do checking during the
@@ -248,13 +363,10 @@ void CompilationUnit::ReadHeader() {
         buffer_ + buffer_length_);
 }
 
-uint64 CompilationUnit::Start() {
-  // First get the debug_info section.  ".debug_info" is the name
-  // recommended in the DWARF spec, and used on Linux; "__debug_info"
-  // is the name used in Mac OS X Mach-O files.
-  SectionMap::const_iterator iter = sections_.find(".debug_info");
-  if (iter == sections_.end())
-    iter = sections_.find("__debug_info");
+uint64_t CompilationUnit::Start() {
+  // First get the debug_info section.
+  SectionMap::const_iterator iter =
+      GetSectionByName(sections_, ".debug_info");
   assert(iter != sections_.end());
 
   // Set up our buffer
@@ -267,7 +379,7 @@ uint64 CompilationUnit::Start() {
   // Figure out the real length from the end of the initial length to
   // the end of the compilation unit, since that is the value we
   // return.
-  uint64 ourlength = header_.length;
+  uint64_t ourlength = header_.length;
   if (reader_->OffsetSize() == 8)
     ourlength += 12;
   else
@@ -284,28 +396,67 @@ uint64 CompilationUnit::Start() {
   // Otherwise, continue by reading our abbreviation entries.
   ReadAbbrevs();
 
-  // Set the string section if we have one.  ".debug_str" is the name
-  // recommended in the DWARF spec, and used on Linux; "__debug_str"
-  // is the name used in Mac OS X Mach-O files.
-  iter = sections_.find(".debug_str");
-  if (iter == sections_.end())
-    iter = sections_.find("__debug_str");
+  // Set the string section if we have one.
+  iter = GetSectionByName(sections_, ".debug_str");
   if (iter != sections_.end()) {
     string_buffer_ = iter->second.first;
     string_buffer_length_ = iter->second.second;
   }
 
+  // Set the line string section if we have one.
+  iter = GetSectionByName(sections_, ".debug_line_str");
+  if (iter != sections_.end()) {
+    line_string_buffer_ = iter->second.first;
+    line_string_buffer_length_ = iter->second.second;
+  }
+
+  // Set the string offsets section if we have one.
+  iter = GetSectionByName(sections_, ".debug_str_offsets");
+  if (iter != sections_.end()) {
+    str_offsets_buffer_ = iter->second.first;
+    str_offsets_buffer_length_ = iter->second.second;
+  }
+
+  // Set the address section if we have one.
+  iter = GetSectionByName(sections_, ".debug_addr");
+  if (iter != sections_.end()) {
+    addr_buffer_ = iter->second.first;
+    addr_buffer_length_ = iter->second.second;
+  }
+
   // Now that we have our abbreviations, start processing DIE's.
   ProcessDIEs();
 
+  // If this is a skeleton compilation unit generated with split DWARF,
+  // and the client needs the full debug info, we need to find the full
+  // compilation unit in a .dwo or .dwp file.
+  if (!is_split_dwarf_
+      && dwo_name_ != NULL
+      && handler_->NeedSplitDebugInfo())
+    ProcessSplitDwarf();
+
   return ourlength;
 }
 
+void CompilationUnit::ProcessFormStringIndex(
+    uint64_t dieoffset, enum DwarfAttribute attr, enum DwarfForm form,
+    uint64_t str_index) {
+  const uint8_t* offset_ptr =
+      str_offsets_buffer_ + str_index * reader_->OffsetSize();
+  const uint64_t offset = reader_->ReadOffset(offset_ptr);
+  if (offset >= string_buffer_length_) {
+    return;
+  }
+
+  const char* str = reinterpret_cast<const char*>(string_buffer_) + offset;
+  ProcessAttributeString(dieoffset, attr, form, str);
+}
+
 // If one really wanted, you could merge SkipAttribute and
 // ProcessAttribute
 // This is all boring data manipulation and calling of the handler.
-const char* CompilationUnit::ProcessAttribute(
-    uint64 dieoffset, const char* start, enum DwarfAttribute attr,
+const uint8_t* CompilationUnit::ProcessAttribute(
+    uint64_t dieoffset, const uint8_t* start, enum DwarfAttribute attr,
     enum DwarfForm form) {
   size_t len;
 
@@ -319,48 +470,46 @@ const char* CompilationUnit::ProcessAttribute(
       return ProcessAttribute(dieoffset, start, attr, form);
 
     case DW_FORM_flag_present:
-      handler_->ProcessAttributeUnsigned(dieoffset, attr, form, 1);
+      ProcessAttributeUnsigned(dieoffset, attr, form, 1);
       return start;
     case DW_FORM_data1:
     case DW_FORM_flag:
-      handler_->ProcessAttributeUnsigned(dieoffset, attr, form,
-                                         reader_->ReadOneByte(start));
+      ProcessAttributeUnsigned(dieoffset, attr, form,
+                               reader_->ReadOneByte(start));
       return start + 1;
     case DW_FORM_data2:
-      handler_->ProcessAttributeUnsigned(dieoffset, attr, form,
-                                         reader_->ReadTwoBytes(start));
+      ProcessAttributeUnsigned(dieoffset, attr, form,
+                               reader_->ReadTwoBytes(start));
       return start + 2;
     case DW_FORM_data4:
-      handler_->ProcessAttributeUnsigned(dieoffset, attr, form,
-                                         reader_->ReadFourBytes(start));
+      ProcessAttributeUnsigned(dieoffset, attr, form,
+                               reader_->ReadFourBytes(start));
       return start + 4;
     case DW_FORM_data8:
-      handler_->ProcessAttributeUnsigned(dieoffset, attr, form,
-                                         reader_->ReadEightBytes(start));
+      ProcessAttributeUnsigned(dieoffset, attr, form,
+                               reader_->ReadEightBytes(start));
       return start + 8;
     case DW_FORM_string: {
-      const char* str = start;
-      handler_->ProcessAttributeString(dieoffset, attr, form,
-                                       str);
+      const char* str = reinterpret_cast<const char*>(start);
+      ProcessAttributeString(dieoffset, attr, form, str);
       return start + strlen(str) + 1;
     }
     case DW_FORM_udata:
-      handler_->ProcessAttributeUnsigned(dieoffset, attr, form,
-                                         reader_->ReadUnsignedLEB128(start,
-                                                                     &len));
+      ProcessAttributeUnsigned(dieoffset, attr, form,
+                               reader_->ReadUnsignedLEB128(start, &len));
       return start + len;
 
     case DW_FORM_sdata:
-      handler_->ProcessAttributeSigned(dieoffset, attr, form,
-                                      reader_->ReadSignedLEB128(start, &len));
+      ProcessAttributeSigned(dieoffset, attr, form,
+                             reader_->ReadSignedLEB128(start, &len));
       return start + len;
     case DW_FORM_addr:
-      handler_->ProcessAttributeUnsigned(dieoffset, attr, form,
-                                         reader_->ReadAddress(start));
+      ProcessAttributeUnsigned(dieoffset, attr, form,
+                               reader_->ReadAddress(start));
       return start + reader_->AddressSize();
     case DW_FORM_sec_offset:
-      handler_->ProcessAttributeUnsigned(dieoffset, attr, form,
-                                         reader_->ReadOffset(start));
+      ProcessAttributeUnsigned(dieoffset, attr, form,
+                               reader_->ReadOffset(start));
       return start + reader_->OffsetSize();
 
     case DW_FORM_ref1:
@@ -390,14 +539,14 @@ const char* CompilationUnit::ProcessAttribute(
                                           + offset_from_section_start_);
       return start + len;
     case DW_FORM_ref_addr:
-      // DWARF2 and 3 differ on whether ref_addr is address size or
+      // DWARF2 and 3/4 differ on whether ref_addr is address size or
       // offset size.
-      assert(header_.version == 2 || header_.version == 3);
+      assert(header_.version >= 2);
       if (header_.version == 2) {
         handler_->ProcessAttributeReference(dieoffset, attr, form,
                                             reader_->ReadAddress(start));
         return start + reader_->AddressSize();
-      } else if (header_.version == 3) {
+      } else if (header_.version >= 3) {
         handler_->ProcessAttributeReference(dieoffset, attr, form,
                                             reader_->ReadOffset(start));
         return start + reader_->OffsetSize();
@@ -409,26 +558,26 @@ const char* CompilationUnit::ProcessAttribute(
       return start + 8;
 
     case DW_FORM_block1: {
-      uint64 datalen = reader_->ReadOneByte(start);
+      uint64_t datalen = reader_->ReadOneByte(start);
       handler_->ProcessAttributeBuffer(dieoffset, attr, form, start + 1,
                                        datalen);
       return start + 1 + datalen;
     }
     case DW_FORM_block2: {
-      uint64 datalen = reader_->ReadTwoBytes(start);
+      uint64_t datalen = reader_->ReadTwoBytes(start);
       handler_->ProcessAttributeBuffer(dieoffset, attr, form, start + 2,
                                        datalen);
       return start + 2 + datalen;
     }
     case DW_FORM_block4: {
-      uint64 datalen = reader_->ReadFourBytes(start);
+      uint64_t datalen = reader_->ReadFourBytes(start);
       handler_->ProcessAttributeBuffer(dieoffset, attr, form, start + 4,
                                        datalen);
       return start + 4 + datalen;
     }
     case DW_FORM_block:
     case DW_FORM_exprloc: {
-      uint64 datalen = reader_->ReadUnsignedLEB128(start, &len);
+      uint64_t datalen = reader_->ReadUnsignedLEB128(start, &len);
       handler_->ProcessAttributeBuffer(dieoffset, attr, form, start + len,
                                        datalen);
       return start + datalen + len;
@@ -436,37 +585,111 @@ const char* CompilationUnit::ProcessAttribute(
     case DW_FORM_strp: {
       assert(string_buffer_ != NULL);
 
-      const uint64 offset = reader_->ReadOffset(start);
+      const uint64_t offset = reader_->ReadOffset(start);
       assert(string_buffer_ + offset < string_buffer_ + string_buffer_length_);
 
-      const char* str = string_buffer_ + offset;
-      handler_->ProcessAttributeString(dieoffset, attr, form,
-                                       str);
+      const char* str = reinterpret_cast<const char*>(string_buffer_ + offset);
+      ProcessAttributeString(dieoffset, attr, form, str);
       return start + reader_->OffsetSize();
     }
+    case DW_FORM_line_strp: {
+      assert(line_string_buffer_ != NULL);
+
+      const uint64_t offset = reader_->ReadOffset(start);
+      assert(line_string_buffer_ + offset <
+             line_string_buffer_ + line_string_buffer_length_);
+
+      const char* str =
+          reinterpret_cast<const char*>(line_string_buffer_ + offset);
+      ProcessAttributeString(dieoffset, attr, form, str);
+      return start + reader_->OffsetSize();
+    }
+    case DW_FORM_strp_sup:
+      // No support currently for suplementary object files.
+      fprintf(stderr, "Unhandled form type: DW_FORM_strp_sup\n");
+      return start + 4;
+
+    case DW_FORM_strx:
+    case DW_FORM_GNU_str_index: {
+      uint64_t str_index = reader_->ReadUnsignedLEB128(start, &len);
+      ProcessFormStringIndex(dieoffset, attr, form, str_index);
+      return start + len;
+    }
+    case DW_FORM_strx1: {
+      uint64_t str_index = reader_->ReadOneByte(start);
+      ProcessFormStringIndex(dieoffset, attr, form, str_index);
+      return start + 1;
+    }
+    case DW_FORM_strx2: {
+      uint64_t str_index = reader_->ReadTwoBytes(start);
+      ProcessFormStringIndex(dieoffset, attr, form, str_index);
+      return start + 2;
+    }
+    case DW_FORM_strx3: {
+      uint64_t str_index = reader_->ReadThreeBytes(start);
+      ProcessFormStringIndex(dieoffset, attr, form, str_index);
+      return start + 3;
+    }
+    case DW_FORM_strx4: {
+      uint64_t str_index = reader_->ReadFourBytes(start);
+      ProcessFormStringIndex(dieoffset, attr, form, str_index);
+      return start + 4;
+    }
+
+    case DW_FORM_addrx:
+    case DW_FORM_GNU_addr_index:
+      ProcessAttributeAddrIndex(
+          dieoffset, attr, form, reader_->ReadUnsignedLEB128(start, &len));
+      return start + len;
+    case DW_FORM_addrx1:
+      ProcessAttributeAddrIndex(
+          dieoffset, attr, form, reader_->ReadOneByte(start));
+      return start + 1;
+    case DW_FORM_addrx2:
+      ProcessAttributeAddrIndex(
+          dieoffset, attr, form, reader_->ReadTwoBytes(start));
+      return start + 2;
+    case DW_FORM_addrx3:
+      ProcessAttributeAddrIndex(
+          dieoffset, attr, form, reader_->ReadThreeBytes(start));
+      return start + 3;
+    case DW_FORM_addrx4:
+      ProcessAttributeAddrIndex(
+          dieoffset, attr, form, reader_->ReadFourBytes(start));
+      return start + 4;
   }
   fprintf(stderr, "Unhandled form type\n");
   return NULL;
 }
 
-const char* CompilationUnit::ProcessDIE(uint64 dieoffset,
-                                                 const char* start,
-                                                 const Abbrev& abbrev) {
+const uint8_t* CompilationUnit::ProcessDIE(uint64_t dieoffset,
+                                           const uint8_t* start,
+                                           const Abbrev& abbrev) {
   for (AttributeList::const_iterator i = abbrev.attributes.begin();
        i != abbrev.attributes.end();
        i++)  {
     start = ProcessAttribute(dieoffset, start, i->first, i->second);
   }
+
+  // If this is a compilation unit in a split DWARF object, verify that
+  // the dwo_id matches. If it does not match, we will ignore this
+  // compilation unit.
+  if (abbrev.tag == DW_TAG_compile_unit
+      && is_split_dwarf_
+      && dwo_id_ != skeleton_dwo_id_) {
+    return NULL;
+  }
+
   return start;
 }
 
 void CompilationUnit::ProcessDIEs() {
-  const char* dieptr = after_header_;
+  const uint8_t* dieptr = after_header_;
   size_t len;
 
   // lengthstart is the place the length field is based on.
   // It is the point in the header after the initial length field
-  const char* lengthstart = buffer_;
+  const uint8_t* lengthstart = buffer_;
 
   // In 64 bit dwarf, the initial length is 12 bytes, because of the
   // 0xffffffff at the start.
@@ -475,14 +698,14 @@ void CompilationUnit::ProcessDIEs() {
   else
     lengthstart += 4;
 
-  std::stack<uint64> die_stack;
+  std::stack<uint64_t> die_stack;
   
   while (dieptr < (lengthstart + header_.length)) {
     // We give the user the absolute offset from the beginning of
     // debug_info, since they need it to deal with ref_addr forms.
-    uint64 absolute_offset = (dieptr - buffer_) + offset_from_section_start_;
+    uint64_t absolute_offset = (dieptr - buffer_) + offset_from_section_start_;
 
-    uint64 abbrev_num = reader_->ReadUnsignedLEB128(dieptr, &len);
+    uint64_t abbrev_num = reader_->ReadUnsignedLEB128(dieptr, &len);
 
     dieptr += len;
 
@@ -492,7 +715,7 @@ void CompilationUnit::ProcessDIEs() {
       if (die_stack.size() == 0)
         // If it is padding, then we are done with the compilation unit's DIEs.
         return;
-      const uint64 offset = die_stack.top();
+      const uint64_t offset = die_stack.top();
       die_stack.pop();
       handler_->EndDIE(offset);
       continue;
@@ -514,26 +737,458 @@ void CompilationUnit::ProcessDIEs() {
   }
 }
 
-LineInfo::LineInfo(const char* buffer, uint64 buffer_length,
-                   ByteReader* reader, LineInfoHandler* handler):
+// Check for a valid ELF file and return the Address size.
+// Returns 0 if not a valid ELF file.
+inline int GetElfWidth(const ElfReader& elf) {
+  if (elf.IsElf32File())
+    return 4;
+  if (elf.IsElf64File())
+    return 8;
+  return 0;
+}
+
+void CompilationUnit::ProcessSplitDwarf() {
+  struct stat statbuf;
+  if (!have_checked_for_dwp_) {
+    // Look for a .dwp file in the same directory as the executable.
+    have_checked_for_dwp_ = true;
+    string dwp_suffix(".dwp");
+    dwp_path_ = path_ + dwp_suffix;
+    if (stat(dwp_path_.c_str(), &statbuf) != 0) {
+      // Fall back to a split .debug file in the same directory.
+      string debug_suffix(".debug");
+      dwp_path_ = path_;
+      size_t found = path_.rfind(debug_suffix);
+      if (found + debug_suffix.length() == path_.length())
+        dwp_path_ = dwp_path_.replace(found, debug_suffix.length(), dwp_suffix);
+    }
+    if (stat(dwp_path_.c_str(), &statbuf) == 0) {
+      ElfReader* elf = new ElfReader(dwp_path_);
+      int width = GetElfWidth(*elf);
+      if (width != 0) {
+        dwp_byte_reader_.reset(new ByteReader(reader_->GetEndianness()));
+        dwp_byte_reader_->SetAddressSize(width);
+        dwp_reader_.reset(new DwpReader(*dwp_byte_reader_, elf));
+        dwp_reader_->Initialize();
+      } else {
+        delete elf;
+      }
+    }
+  }
+  bool found_in_dwp = false;
+  if (dwp_reader_) {
+    // If we have a .dwp file, read the debug sections for the requested CU.
+    SectionMap sections;
+    dwp_reader_->ReadDebugSectionsForCU(dwo_id_, &sections);
+    if (!sections.empty()) {
+      found_in_dwp = true;
+      CompilationUnit dwp_comp_unit(dwp_path_, sections, 0,
+                                    dwp_byte_reader_.get(), handler_);
+      dwp_comp_unit.SetSplitDwarf(addr_buffer_, addr_buffer_length_, addr_base_,
+                                  ranges_base_, dwo_id_);
+      dwp_comp_unit.Start();
+    }
+  }
+  if (!found_in_dwp) {
+    // If no .dwp file, try to open the .dwo file.
+    if (stat(dwo_name_, &statbuf) == 0) {
+      ElfReader elf(dwo_name_);
+      int width = GetElfWidth(elf);
+      if (width != 0) {
+        ByteReader reader(ENDIANNESS_LITTLE);
+        reader.SetAddressSize(width);
+        SectionMap sections;
+        ReadDebugSectionsFromDwo(&elf, &sections);
+        CompilationUnit dwo_comp_unit(dwo_name_, sections, 0, &reader,
+                                      handler_);
+        dwo_comp_unit.SetSplitDwarf(addr_buffer_, addr_buffer_length_,
+                                    addr_base_, ranges_base_, dwo_id_);
+        dwo_comp_unit.Start();
+      }
+    }
+  }
+}
+
+void CompilationUnit::ReadDebugSectionsFromDwo(ElfReader* elf_reader,
+                                               SectionMap* sections) {
+  static const char* const section_names[] = {
+    ".debug_abbrev",
+    ".debug_info",
+    ".debug_str_offsets",
+    ".debug_str"
+  };
+  for (unsigned int i = 0u;
+       i < sizeof(section_names)/sizeof(*(section_names)); ++i) {
+    string base_name = section_names[i];
+    string dwo_name = base_name + ".dwo";
+    size_t section_size;
+    const char* section_data = elf_reader->GetSectionByName(dwo_name,
+                                                            &section_size);
+    if (section_data != NULL)
+      sections->insert(std::make_pair(
+          base_name, std::make_pair(
+             reinterpret_cast<const uint8_t*>(section_data),
+             section_size)));
+  }
+}
+
+DwpReader::DwpReader(const ByteReader& byte_reader, ElfReader* elf_reader)
+    : elf_reader_(elf_reader), byte_reader_(byte_reader),
+      cu_index_(NULL), cu_index_size_(0), string_buffer_(NULL),
+      string_buffer_size_(0), version_(0), ncolumns_(0), nunits_(0),
+      nslots_(0), phash_(NULL), pindex_(NULL), shndx_pool_(NULL),
+      offset_table_(NULL), size_table_(NULL), abbrev_data_(NULL),
+      abbrev_size_(0), info_data_(NULL), info_size_(0),
+      str_offsets_data_(NULL), str_offsets_size_(0) {}
+
+DwpReader::~DwpReader() {
+  if (elf_reader_) delete elf_reader_;
+}
+
+void DwpReader::Initialize() {
+  cu_index_ = elf_reader_->GetSectionByName(".debug_cu_index",
+                                            &cu_index_size_);
+  if (cu_index_ == NULL) {
+    return;
+  }
+  // The .debug_str.dwo section is shared by all CUs in the file.
+  string_buffer_ = elf_reader_->GetSectionByName(".debug_str.dwo",
+                                                 &string_buffer_size_);
+
+  version_ = byte_reader_.ReadFourBytes(
+      reinterpret_cast<const uint8_t*>(cu_index_));
+
+  if (version_ == 1) {
+    nslots_ = byte_reader_.ReadFourBytes(
+        reinterpret_cast<const uint8_t*>(cu_index_)
+        + 3 * sizeof(uint32_t));
+    phash_ = cu_index_ + 4 * sizeof(uint32_t);
+    pindex_ = phash_ + nslots_ * sizeof(uint64_t);
+    shndx_pool_ = pindex_ + nslots_ * sizeof(uint32_t);
+    if (shndx_pool_ >= cu_index_ + cu_index_size_) {
+      version_ = 0;
+    }
+  } else if (version_ == 2) {
+    ncolumns_ = byte_reader_.ReadFourBytes(
+        reinterpret_cast<const uint8_t*>(cu_index_) + sizeof(uint32_t));
+    nunits_ = byte_reader_.ReadFourBytes(
+        reinterpret_cast<const uint8_t*>(cu_index_) + 2 * sizeof(uint32_t));
+    nslots_ = byte_reader_.ReadFourBytes(
+        reinterpret_cast<const uint8_t*>(cu_index_) + 3 * sizeof(uint32_t));
+    phash_ = cu_index_ + 4 * sizeof(uint32_t);
+    pindex_ = phash_ + nslots_ * sizeof(uint64_t);
+    offset_table_ = pindex_ + nslots_ * sizeof(uint32_t);
+    size_table_ = offset_table_ + ncolumns_ * (nunits_ + 1) * sizeof(uint32_t);
+    abbrev_data_ = elf_reader_->GetSectionByName(".debug_abbrev.dwo",
+                                                 &abbrev_size_);
+    info_data_ = elf_reader_->GetSectionByName(".debug_info.dwo", &info_size_);
+    str_offsets_data_ = elf_reader_->GetSectionByName(".debug_str_offsets.dwo",
+                                                      &str_offsets_size_);
+    if (size_table_ >= cu_index_ + cu_index_size_) {
+      version_ = 0;
+    }
+  }
+}
+
+void DwpReader::ReadDebugSectionsForCU(uint64_t dwo_id,
+                                       SectionMap* sections) {
+  if (version_ == 1) {
+    int slot = LookupCU(dwo_id);
+    if (slot == -1) {
+      return;
+    }
+
+    // The index table points to the section index pool, where we
+    // can read a list of section indexes for the debug sections
+    // for the CU whose dwo_id we are looking for.
+    int index = byte_reader_.ReadFourBytes(
+        reinterpret_cast<const uint8_t*>(pindex_)
+        + slot * sizeof(uint32_t));
+    const char* shndx_list = shndx_pool_ + index * sizeof(uint32_t);
+    for (;;) {
+      if (shndx_list >= cu_index_ + cu_index_size_) {
+        version_ = 0;
+        return;
+      }
+      unsigned int shndx = byte_reader_.ReadFourBytes(
+          reinterpret_cast<const uint8_t*>(shndx_list));
+      shndx_list += sizeof(uint32_t);
+      if (shndx == 0)
+        break;
+      const char* section_name = elf_reader_->GetSectionName(shndx);
+      size_t section_size;
+      const char* section_data;
+      // We're only interested in these four debug sections.
+      // The section names in the .dwo file end with ".dwo", but we
+      // add them to the sections table with their normal names.
+      if (!strncmp(section_name, ".debug_abbrev", strlen(".debug_abbrev"))) {
+        section_data = elf_reader_->GetSectionByIndex(shndx, &section_size);
+        sections->insert(std::make_pair(
+            ".debug_abbrev",
+            std::make_pair(reinterpret_cast<const uint8_t*> (section_data),
+                                                              section_size)));
+      } else if (!strncmp(section_name, ".debug_info", strlen(".debug_info"))) {
+        section_data = elf_reader_->GetSectionByIndex(shndx, &section_size);
+        sections->insert(std::make_pair(
+            ".debug_info",
+            std::make_pair(reinterpret_cast<const uint8_t*> (section_data),
+                           section_size)));
+      } else if (!strncmp(section_name, ".debug_str_offsets",
+                          strlen(".debug_str_offsets"))) {
+        section_data = elf_reader_->GetSectionByIndex(shndx, &section_size);
+        sections->insert(std::make_pair(
+            ".debug_str_offsets",
+            std::make_pair(reinterpret_cast<const uint8_t*> (section_data),
+                           section_size)));
+      }
+    }
+    sections->insert(std::make_pair(
+        ".debug_str",
+        std::make_pair(reinterpret_cast<const uint8_t*> (string_buffer_),
+                       string_buffer_size_)));
+  } else if (version_ == 2) {
+    uint32_t index = LookupCUv2(dwo_id);
+    if (index == 0) {
+      return;
+    }
+
+    // The index points to a row in each of the section offsets table
+    // and the section size table, where we can read the offsets and sizes
+    // of the contributions to each debug section from the CU whose dwo_id
+    // we are looking for. Row 0 of the section offsets table has the
+    // section ids for each column of the table. The size table begins
+    // with row 1.
+    const char* id_row = offset_table_;
+    const char* offset_row = offset_table_
+                             + index * ncolumns_ * sizeof(uint32_t);
+    const char* size_row =
+        size_table_ + (index - 1) * ncolumns_ * sizeof(uint32_t);
+    if (size_row + ncolumns_ * sizeof(uint32_t) > cu_index_ + cu_index_size_) {
+      version_ = 0;
+      return;
+    }
+    for (unsigned int col = 0u; col < ncolumns_; ++col) {
+      uint32_t section_id =
+          byte_reader_.ReadFourBytes(reinterpret_cast<const uint8_t*>(id_row)
+                                     + col * sizeof(uint32_t));
+      uint32_t offset = byte_reader_.ReadFourBytes(
+          reinterpret_cast<const uint8_t*>(offset_row)
+          + col * sizeof(uint32_t));
+      uint32_t size = byte_reader_.ReadFourBytes(
+          reinterpret_cast<const uint8_t*>(size_row) + col * sizeof(uint32_t));
+      if (section_id == DW_SECT_ABBREV) {
+        sections->insert(std::make_pair(
+            ".debug_abbrev",
+            std::make_pair(reinterpret_cast<const uint8_t*> (abbrev_data_)
+                           + offset, size)));
+      } else if (section_id == DW_SECT_INFO) {
+        sections->insert(std::make_pair(
+            ".debug_info",
+            std::make_pair(reinterpret_cast<const uint8_t*> (info_data_)
+                           + offset, size)));
+      } else if (section_id == DW_SECT_STR_OFFSETS) {
+        sections->insert(std::make_pair(
+            ".debug_str_offsets",
+            std::make_pair(reinterpret_cast<const uint8_t*> (str_offsets_data_)
+                           + offset, size)));
+      }
+    }
+    sections->insert(std::make_pair(
+        ".debug_str",
+        std::make_pair(reinterpret_cast<const uint8_t*> (string_buffer_),
+                       string_buffer_size_)));
+  }
+}
+
+int DwpReader::LookupCU(uint64_t dwo_id) {
+  uint32_t slot = static_cast<uint32_t>(dwo_id) & (nslots_ - 1);
+  uint64_t probe = byte_reader_.ReadEightBytes(
+      reinterpret_cast<const uint8_t*>(phash_) + slot * sizeof(uint64_t));
+  if (probe != 0 && probe != dwo_id) {
+    uint32_t secondary_hash =
+        (static_cast<uint32_t>(dwo_id >> 32) & (nslots_ - 1)) | 1;
+    do {
+      slot = (slot + secondary_hash) & (nslots_ - 1);
+      probe = byte_reader_.ReadEightBytes(
+          reinterpret_cast<const uint8_t*>(phash_) + slot * sizeof(uint64_t));
+    } while (probe != 0 && probe != dwo_id);
+  }
+  if (probe == 0)
+    return -1;
+  return slot;
+}
+
+uint32_t DwpReader::LookupCUv2(uint64_t dwo_id) {
+  uint32_t slot = static_cast<uint32_t>(dwo_id) & (nslots_ - 1);
+  uint64_t probe = byte_reader_.ReadEightBytes(
+      reinterpret_cast<const uint8_t*>(phash_) + slot * sizeof(uint64_t));
+  uint32_t index = byte_reader_.ReadFourBytes(
+      reinterpret_cast<const uint8_t*>(pindex_) + slot * sizeof(uint32_t));
+  if (index != 0 && probe != dwo_id) {
+    uint32_t secondary_hash =
+        (static_cast<uint32_t>(dwo_id >> 32) & (nslots_ - 1)) | 1;
+    do {
+      slot = (slot + secondary_hash) & (nslots_ - 1);
+      probe = byte_reader_.ReadEightBytes(
+          reinterpret_cast<const uint8_t*>(phash_) + slot * sizeof(uint64_t));
+      index = byte_reader_.ReadFourBytes(
+          reinterpret_cast<const uint8_t*>(pindex_) + slot * sizeof(uint32_t));
+    } while (index != 0 && probe != dwo_id);
+  }
+  return index;
+}
+
+LineInfo::LineInfo(const uint8_t* buffer, uint64_t buffer_length,
+                   ByteReader* reader, const uint8_t* string_buffer,
+                   size_t string_buffer_length,
+                   const uint8_t* line_string_buffer,
+                   size_t line_string_buffer_length, LineInfoHandler* handler):
     handler_(handler), reader_(reader), buffer_(buffer),
-    buffer_length_(buffer_length) {
+    string_buffer_(string_buffer),
+    line_string_buffer_(line_string_buffer) {
+#ifndef NDEBUG
+  buffer_length_ = buffer_length;
+  string_buffer_length_ = string_buffer_length;
+  line_string_buffer_length_ = line_string_buffer_length;
+#endif
   header_.std_opcode_lengths = NULL;
 }
 
-uint64 LineInfo::Start() {
+uint64_t LineInfo::Start() {
   ReadHeader();
   ReadLines();
   return after_header_ - buffer_;
 }
 
+void LineInfo::ReadTypesAndForms(const uint8_t** lineptr,
+                                 uint32_t* content_types,
+                                 uint32_t* content_forms,
+                                 uint32_t max_types,
+                                 uint32_t* format_count) {
+  size_t len;
+
+  uint32_t count = reader_->ReadUnsignedLEB128(*lineptr, &len);
+  *lineptr += len;
+  if (count < 1 || count > max_types) {
+    return;
+  }
+  for (uint32_t col = 0; col < count; ++col) {
+    content_types[col] = reader_->ReadUnsignedLEB128(*lineptr, &len);
+    *lineptr += len;
+    content_forms[col] = reader_->ReadUnsignedLEB128(*lineptr, &len);
+    *lineptr += len;
+  }
+  *format_count = count;
+}
+
+const char* LineInfo::ReadStringForm(uint32_t form, const uint8_t** lineptr) {
+  const char* name = nullptr;
+  if (form == DW_FORM_string) {
+    name = reinterpret_cast<const char*>(*lineptr);
+    *lineptr += strlen(name) + 1;
+    return name;
+  } else if (form == DW_FORM_strp) {
+    uint64_t offset = reader_->ReadOffset(*lineptr);
+    assert(offset < string_buffer_length_);
+    *lineptr += reader_->OffsetSize();
+    if (string_buffer_ != nullptr) {
+      name = reinterpret_cast<const char*>(string_buffer_) + offset;
+      return name;
+    }
+  } else if (form == DW_FORM_line_strp) {
+    uint64_t offset = reader_->ReadOffset(*lineptr);
+    assert(offset < line_string_buffer_length_);
+    *lineptr += reader_->OffsetSize();
+    if (line_string_buffer_ != nullptr) {
+      name = reinterpret_cast<const char*>(line_string_buffer_) + offset;
+      return name;
+    }
+  }
+  // Shouldn't be called with a non-string-form, and
+  // if there is a string form but no string buffer,
+  // that is a problem too.
+  assert(0);
+  return nullptr;
+}
+
+uint64_t LineInfo::ReadUnsignedData(uint32_t form, const uint8_t** lineptr) {
+  size_t len;
+  uint64_t value;
+
+  switch (form) {
+    case DW_FORM_data1:
+      value = reader_->ReadOneByte(*lineptr);
+      *lineptr += 1;
+      return value;
+    case DW_FORM_data2:
+      value = reader_->ReadTwoBytes(*lineptr);
+      *lineptr += 2;
+      return value;
+    case DW_FORM_data4:
+      value = reader_->ReadFourBytes(*lineptr);
+      *lineptr += 4;
+      return value;
+    case DW_FORM_data8:
+      value = reader_->ReadEightBytes(*lineptr);
+      *lineptr += 8;
+      return value;
+    case DW_FORM_udata:
+      value = reader_->ReadUnsignedLEB128(*lineptr, &len);
+      *lineptr += len;
+      return value;
+    default:
+      fprintf(stderr, "Unrecognized data form.");
+      return 0;
+  }
+}
+
+void LineInfo::ReadFileRow(const uint8_t** lineptr,
+                           const uint32_t* content_types,
+                           const uint32_t* content_forms, uint32_t row,
+                           uint32_t format_count) {
+  const char* filename = nullptr;
+  uint64_t dirindex = 0;
+  uint64_t mod_time = 0;
+  uint64_t filelength = 0;
+
+  for (uint32_t col = 0; col < format_count; ++col) {
+    switch (content_types[col]) {
+      case DW_LNCT_path:
+        filename = ReadStringForm(content_forms[col], lineptr);
+        break;
+      case DW_LNCT_directory_index:
+        dirindex = ReadUnsignedData(content_forms[col], lineptr);
+        break;
+      case DW_LNCT_timestamp:
+        mod_time = ReadUnsignedData(content_forms[col], lineptr);
+        break;
+      case DW_LNCT_size:
+        filelength = ReadUnsignedData(content_forms[col], lineptr);
+        break;
+      case DW_LNCT_MD5:
+        // MD5 entries help a debugger sort different versions of files with
+        // the same name.  It is always paired with a DW_FORM_data16 and is
+        // unused in this case.
+        lineptr += 16;
+        break;
+      default:
+        fprintf(stderr, "Unrecognized form in line table header. %d\n",
+                content_types[col]);
+        assert(false);
+        break;
+    }
+  }
+  assert(filename != nullptr);
+  handler_->DefineFile(filename, row, dirindex, mod_time, filelength);
+}
+
 // The header for a debug_line section is mildly complicated, because
 // the line info is very tightly encoded.
 void LineInfo::ReadHeader() {
-  const char* lineptr = buffer_;
+  const uint8_t* lineptr = buffer_;
   size_t initial_length_size;
 
-  const uint64 initial_length
+  const uint64_t initial_length
     = reader_->ReadInitialLength(lineptr, &initial_length_size);
 
   lineptr += initial_length_size;
@@ -541,22 +1196,41 @@ void LineInfo::ReadHeader() {
   assert(buffer_ + initial_length_size + header_.total_length <=
         buffer_ + buffer_length_);
 
-  // Address size *must* be set by CU ahead of time.
-  assert(reader_->AddressSize() != 0);
 
   header_.version = reader_->ReadTwoBytes(lineptr);
   lineptr += 2;
 
+  if (header_.version >= 5) {
+    uint8_t address_size = reader_->ReadOneByte(lineptr);
+    reader_->SetAddressSize(address_size);
+    lineptr += 1;
+    uint8_t segment_selector_size = reader_->ReadOneByte(lineptr);
+    if (segment_selector_size != 0) {
+      fprintf(stderr,"No support for segmented memory.");
+    }
+    lineptr += 1;
+  } else {
+    // Address size *must* be set by CU ahead of time.
+    assert(reader_->AddressSize() != 0);
+  }
+
   header_.prologue_length = reader_->ReadOffset(lineptr);
   lineptr += reader_->OffsetSize();
 
   header_.min_insn_length = reader_->ReadOneByte(lineptr);
   lineptr += 1;
 
+  if (header_.version >= 4) {
+    __attribute__((unused)) uint8_t max_ops_per_insn =
+        reader_->ReadOneByte(lineptr);
+    ++lineptr;
+    assert(max_ops_per_insn == 1);
+  }
+
   header_.default_is_stmt = reader_->ReadOneByte(lineptr);
   lineptr += 1;
 
-  header_.line_base = *reinterpret_cast<const int8*>(lineptr);
+  header_.line_base = *reinterpret_cast<const int8_t*>(lineptr);
   lineptr += 1;
 
   header_.line_range = reader_->ReadOneByte(lineptr);
@@ -573,56 +1247,99 @@ void LineInfo::ReadHeader() {
     lineptr += 1;
   }
 
-  // It is legal for the directory entry table to be empty.
-  if (*lineptr) {
-    uint32 dirindex = 1;
-    while (*lineptr) {
-      const char* dirname = lineptr;
-      handler_->DefineDir(dirname, dirindex);
-      lineptr += strlen(dirname) + 1;
-      dirindex++;
+  if (header_.version <= 4) {
+    // Directory zero is assumed to be the compilation directory and special
+    // cased where used. It is not actually stored in the dwarf data. But an
+    // empty entry here avoids off-by-one errors elsewhere in the code.
+    handler_->DefineDir("", 0);
+    // It is legal for the directory entry table to be empty.
+    if (*lineptr) {
+      uint32_t dirindex = 1;
+      while (*lineptr) {
+        const char* dirname = reinterpret_cast<const char*>(lineptr);
+        handler_->DefineDir(dirname, dirindex);
+        lineptr += strlen(dirname) + 1;
+        dirindex++;
+      }
     }
-  }
-  lineptr++;
-
-  // It is also legal for the file entry table to be empty.
-  if (*lineptr) {
-    uint32 fileindex = 1;
+    lineptr++;
+    // It is also legal for the file entry table to be empty.
+
+    // Similarly for file zero.
+    handler_->DefineFile("", 0, 0, 0, 0);
+    if (*lineptr) {
+      uint32_t fileindex = 1;
+      size_t len;
+      while (*lineptr) {
+        const char* filename = ReadStringForm(DW_FORM_string, &lineptr);
+
+        uint64_t dirindex = reader_->ReadUnsignedLEB128(lineptr, &len);
+        lineptr += len;
+
+        uint64_t mod_time = reader_->ReadUnsignedLEB128(lineptr, &len);
+        lineptr += len;
+
+        uint64_t filelength = reader_->ReadUnsignedLEB128(lineptr, &len);
+        lineptr += len;
+        handler_->DefineFile(filename, fileindex,
+                             static_cast<uint32_t>(dirindex), mod_time,
+                             filelength);
+        fileindex++;
+      }
+    }
+    lineptr++;
+  } else {
+    // Read the DWARF-5 directory table.
+
+    // Dwarf5 supports five different types and forms per directory- and
+    // file-table entry. Theoretically, there could be duplicate entries
+    // in this table, but that would be quite unusual.
+    static const uint32_t kMaxTypesAndForms = 5;
+    uint32_t content_types[kMaxTypesAndForms];
+    uint32_t content_forms[kMaxTypesAndForms];
+    uint32_t format_count;
     size_t len;
-    while (*lineptr) {
-      const char* filename = lineptr;
-      lineptr += strlen(filename) + 1;
 
-      uint64 dirindex = reader_->ReadUnsignedLEB128(lineptr, &len);
-      lineptr += len;
+    ReadTypesAndForms(&lineptr, content_types, content_forms, kMaxTypesAndForms,
+                      &format_count);
+    uint32_t entry_count = reader_->ReadUnsignedLEB128(lineptr, &len);
+    lineptr += len;
+    for (uint32_t row = 0; row < entry_count; ++row) {
+      const char* dirname = nullptr;
+      for (uint32_t col = 0; col < format_count; ++col) {
+        // The path is the only relevant content type for this implementation.
+        if (content_types[col] == DW_LNCT_path) {
+          dirname = ReadStringForm(content_forms[col], &lineptr);
+        }
+      }
+      handler_->DefineDir(dirname, row);
+    }
 
-      uint64 mod_time = reader_->ReadUnsignedLEB128(lineptr, &len);
-      lineptr += len;
+    // Read the DWARF-5 filename table.
+    ReadTypesAndForms(&lineptr, content_types, content_forms, kMaxTypesAndForms,
+                      &format_count);
+    entry_count = reader_->ReadUnsignedLEB128(lineptr, &len);
+    lineptr += len;
 
-      uint64 filelength = reader_->ReadUnsignedLEB128(lineptr, &len);
-      lineptr += len;
-      handler_->DefineFile(filename, fileindex, static_cast<uint32>(dirindex), 
-                           mod_time, filelength);
-      fileindex++;
+    for (uint32_t row = 0; row < entry_count; ++row) {
+      ReadFileRow(&lineptr, content_types, content_forms, row, format_count);
     }
   }
-  lineptr++;
-
   after_header_ = lineptr;
 }
 
 /* static */
 bool LineInfo::ProcessOneOpcode(ByteReader* reader,
                                 LineInfoHandler* handler,
-                                const struct LineInfoHeader &header,
-                                const char* start,
+                                const struct LineInfoHeader& header,
+                                const uint8_t* start,
                                 struct LineStateMachine* lsm,
                                 size_t* len,
                                 uintptr pc,
-                                bool *lsm_passes_pc) {
+                                bool* lsm_passes_pc) {
   size_t oplen = 0;
   size_t templen;
-  uint8 opcode = reader->ReadOneByte(start);
+  uint8_t opcode = reader->ReadOneByte(start);
   oplen++;
   start++;
 
@@ -630,9 +1347,9 @@ bool LineInfo::ProcessOneOpcode(ByteReader* reader,
   // opcode. Most line programs consist mainly of special opcodes.
   if (opcode >= header.opcode_base) {
     opcode -= header.opcode_base;
-    const int64 advance_address = (opcode / header.line_range)
+    const int64_t advance_address = (opcode / header.line_range)
                                   * header.min_insn_length;
-    const int32 advance_line = (opcode % header.line_range)
+    const int32_t advance_line = (opcode % header.line_range)
                                + header.line_base;
 
     // Check if the lsm passes "pc". If so, mark it as passed.
@@ -657,7 +1374,7 @@ bool LineInfo::ProcessOneOpcode(ByteReader* reader,
     }
 
     case DW_LNS_advance_pc: {
-      uint64 advance_address = reader->ReadUnsignedLEB128(start, &templen);
+      uint64_t advance_address = reader->ReadUnsignedLEB128(start, &templen);
       oplen += templen;
 
       // Check if the lsm passes "pc". If so, mark it as passed.
@@ -670,9 +1387,9 @@ bool LineInfo::ProcessOneOpcode(ByteReader* reader,
     }
       break;
     case DW_LNS_advance_line: {
-      const int64 advance_line = reader->ReadSignedLEB128(start, &templen);
+      const int64_t advance_line = reader->ReadSignedLEB128(start, &templen);
       oplen += templen;
-      lsm->line_num += static_cast<int32>(advance_line);
+      lsm->line_num += static_cast<int32_t>(advance_line);
 
       // With gcc 4.2.1, we can get the line_no here for the first time
       // since DW_LNS_advance_line is called after DW_LNE_set_address is
@@ -684,15 +1401,15 @@ bool LineInfo::ProcessOneOpcode(ByteReader* reader,
     }
       break;
     case DW_LNS_set_file: {
-      const uint64 fileno = reader->ReadUnsignedLEB128(start, &templen);
+      const uint64_t fileno = reader->ReadUnsignedLEB128(start, &templen);
       oplen += templen;
-      lsm->file_num = static_cast<uint32>(fileno);
+      lsm->file_num = static_cast<uint32_t>(fileno);
     }
       break;
     case DW_LNS_set_column: {
-      const uint64 colno = reader->ReadUnsignedLEB128(start, &templen);
+      const uint64_t colno = reader->ReadUnsignedLEB128(start, &templen);
       oplen += templen;
-      lsm->column_num = static_cast<uint32>(colno);
+      lsm->column_num = static_cast<uint32_t>(colno);
     }
       break;
     case DW_LNS_negate_stmt: {
@@ -704,7 +1421,7 @@ bool LineInfo::ProcessOneOpcode(ByteReader* reader,
     }
       break;
     case DW_LNS_fixed_advance_pc: {
-      const uint16 advance_address = reader->ReadTwoBytes(start);
+      const uint16_t advance_address = reader->ReadTwoBytes(start);
       oplen += 2;
 
       // Check if the lsm passes "pc". If so, mark it as passed.
@@ -717,7 +1434,7 @@ bool LineInfo::ProcessOneOpcode(ByteReader* reader,
     }
       break;
     case DW_LNS_const_add_pc: {
-      const int64 advance_address = header.min_insn_length
+      const int64_t advance_address = header.min_insn_length
                                     * ((255 - header.opcode_base)
                                        / header.line_range);
 
@@ -731,12 +1448,12 @@ bool LineInfo::ProcessOneOpcode(ByteReader* reader,
     }
       break;
     case DW_LNS_extended_op: {
-      const uint64 extended_op_len = reader->ReadUnsignedLEB128(start,
+      const uint64_t extended_op_len = reader->ReadUnsignedLEB128(start,
                                                                 &templen);
       start += templen;
       oplen += templen + extended_op_len;
 
-      const uint64 extended_op = reader->ReadOneByte(start);
+      const uint64_t extended_op = reader->ReadOneByte(start);
       start++;
 
       switch (extended_op) {
@@ -751,29 +1468,29 @@ bool LineInfo::ProcessOneOpcode(ByteReader* reader,
           // DW_LNE_set_address is called before DW_LNS_advance_line is
           // called.  So we do not check if the lsm passes "pc" here.  See
           // also the comment in DW_LNS_advance_line.
-          uint64 address = reader->ReadAddress(start);
+          uint64_t address = reader->ReadAddress(start);
           lsm->address = address;
         }
           break;
         case DW_LNE_define_file: {
-          const char* filename  = start;
+          const char* filename = reinterpret_cast<const char*>(start);
 
           templen = strlen(filename) + 1;
           start += templen;
 
-          uint64 dirindex = reader->ReadUnsignedLEB128(start, &templen);
+          uint64_t dirindex = reader->ReadUnsignedLEB128(start, &templen);
           oplen += templen;
 
-          const uint64 mod_time = reader->ReadUnsignedLEB128(start,
+          const uint64_t mod_time = reader->ReadUnsignedLEB128(start,
                                                              &templen);
           oplen += templen;
 
-          const uint64 filelength = reader->ReadUnsignedLEB128(start,
+          const uint64_t filelength = reader->ReadUnsignedLEB128(start,
                                                                &templen);
           oplen += templen;
 
           if (handler) {
-            handler->DefineFile(filename, -1, static_cast<uint32>(dirindex), 
+            handler->DefineFile(filename, -1, static_cast<uint32_t>(dirindex), 
                                 mod_time, filelength);
           }
         }
@@ -803,7 +1520,7 @@ void LineInfo::ReadLines() {
 
   // lengthstart is the place the length field is based on.
   // It is the point in the header after the initial length field
-  const char* lengthstart = buffer_;
+  const uint8_t* lengthstart = buffer_;
 
   // In 64 bit dwarf, the initial length is 12 bytes, because of the
   // 0xffffffff at the start.
@@ -812,7 +1529,7 @@ void LineInfo::ReadLines() {
   else
     lengthstart += 4;
 
-  const char* lineptr = after_header_;
+  const uint8_t* lineptr = after_header_;
   lsm.Reset(header_.default_is_stmt);
 
   // The LineInfoHandler interface expects each line's length along
@@ -821,8 +1538,8 @@ void LineInfo::ReadLines() {
   // from the next address. So we report a line only when we get the
   // next line's address, or the end-of-sequence address.
   bool have_pending_line = false;
-  uint64 pending_address = 0;
-  uint32 pending_file_num = 0, pending_line_num = 0, pending_column_num = 0;
+  uint64_t pending_address = 0;
+  uint32_t pending_file_num = 0, pending_line_num = 0, pending_column_num = 0;
 
   while (lineptr < lengthstart + header_.total_length) {
     size_t oplength;
@@ -851,6 +1568,41 @@ void LineInfo::ReadLines() {
   after_header_ = lengthstart + header_.total_length;
 }
 
+RangeListReader::RangeListReader(const uint8_t* buffer, uint64_t size,
+                                 ByteReader* reader, RangeListHandler* handler)
+    : buffer_(buffer), size_(size), reader_(reader), handler_(handler) { }
+
+bool RangeListReader::ReadRangeList(uint64_t offset) {
+  const uint64_t max_address =
+    (reader_->AddressSize() == 4) ? 0xffffffffUL
+                                  : 0xffffffffffffffffULL;
+  const uint64_t entry_size = reader_->AddressSize() * 2;
+  bool list_end = false;
+
+  do {
+    if (offset > size_ - entry_size) {
+      return false; // Invalid range detected
+    }
+
+    uint64_t start_address = reader_->ReadAddress(buffer_ + offset);
+    uint64_t end_address =
+      reader_->ReadAddress(buffer_ + offset + reader_->AddressSize());
+
+    if (start_address == max_address) { // Base address selection
+      handler_->SetBaseAddress(end_address);
+    } else if (start_address == 0 && end_address == 0) { // End-of-list
+      handler_->Finish();
+      list_end = true;
+    } else { // Add a range entry
+      handler_->AddRange(start_address, end_address);
+    }
+
+    offset += entry_size;
+  } while (!list_end);
+
+  return true;
+}
+
 // A DWARF rule for recovering the address or value of a register, or
 // computing the canonical frame address. There is one subclass of this for
 // each '*Rule' member function in CallFrameInfo::Handler.
@@ -869,21 +1621,21 @@ class CallFrameInfo::Rule {
  public:
   virtual ~Rule() { }
 
-  // Tell HANDLER that, at ADDRESS in the program, REGISTER can be
-  // recovered using this rule. If REGISTER is kCFARegister, then this rule
-  // describes how to compute the canonical frame address. Return what the
-  // HANDLER member function returned.
-  virtual bool Handle(Handler *handler,
-                      uint64 address, int register) const = 0;
+  // Tell HANDLER that, at ADDRESS in the program, REG can be recovered using
+  // this rule. If REG is kCFARegister, then this rule describes how to compute
+  // the canonical frame address. Return what the HANDLER member function
+  // returned.
+  virtual bool Handle(Handler* handler,
+                      uint64_t address, int reg) const = 0;
 
   // Equality on rules. We use these to decide which rules we need
   // to report after a DW_CFA_restore_state instruction.
-  virtual bool operator==(const Rule &rhs) const = 0;
+  virtual bool operator==(const Rule& rhs) const = 0;
 
-  bool operator!=(const Rule &rhs) const { return ! (*this == rhs); }
+  bool operator!=(const Rule& rhs) const { return ! (*this == rhs); }
 
   // Return a pointer to a copy of this rule.
-  virtual Rule *Copy() const = 0;
+  virtual Rule* Copy() const = 0;
 
   // If this is a base+offset rule, change its base register to REG.
   // Otherwise, do nothing. (Ugly, but required for DW_CFA_def_cfa_register.)
@@ -899,16 +1651,16 @@ class CallFrameInfo::UndefinedRule: public CallFrameInfo::Rule {
  public:
   UndefinedRule() { }
   ~UndefinedRule() { }
-  bool Handle(Handler *handler, uint64 address, int reg) const {
+  bool Handle(Handler* handler, uint64_t address, int reg) const {
     return handler->UndefinedRule(address, reg);
   }
-  bool operator==(const Rule &rhs) const {
+  bool operator==(const Rule& rhs) const {
     // dynamic_cast is allowed by the Google C++ Style Guide, if the use has
     // been carefully considered; cheap RTTI-like workarounds are forbidden.
-    const UndefinedRule *our_rhs = dynamic_cast<const UndefinedRule *>(&rhs);
+    const UndefinedRule* our_rhs = dynamic_cast<const UndefinedRule*>(&rhs);
     return (our_rhs != NULL);
   }
-  Rule *Copy() const { return new UndefinedRule(*this); }
+  Rule* Copy() const { return new UndefinedRule(*this); }
 };
 
 // Rule: the register's value is the same as that it had in the caller.
@@ -916,16 +1668,16 @@ class CallFrameInfo::SameValueRule: public CallFrameInfo::Rule {
  public:
   SameValueRule() { }
   ~SameValueRule() { }
-  bool Handle(Handler *handler, uint64 address, int reg) const {
+  bool Handle(Handler* handler, uint64_t address, int reg) const {
     return handler->SameValueRule(address, reg);
   }
-  bool operator==(const Rule &rhs) const {
+  bool operator==(const Rule& rhs) const {
     // dynamic_cast is allowed by the Google C++ Style Guide, if the use has
     // been carefully considered; cheap RTTI-like workarounds are forbidden.
-    const SameValueRule *our_rhs = dynamic_cast<const SameValueRule *>(&rhs);
+    const SameValueRule* our_rhs = dynamic_cast<const SameValueRule*>(&rhs);
     return (our_rhs != NULL);
   }
-  Rule *Copy() const { return new SameValueRule(*this); }
+  Rule* Copy() const { return new SameValueRule(*this); }
 };
 
 // Rule: the register is saved at OFFSET from BASE_REGISTER.  BASE_REGISTER
@@ -935,18 +1687,18 @@ class CallFrameInfo::OffsetRule: public CallFrameInfo::Rule {
   OffsetRule(int base_register, long offset)
       : base_register_(base_register), offset_(offset) { }
   ~OffsetRule() { }
-  bool Handle(Handler *handler, uint64 address, int reg) const {
+  bool Handle(Handler* handler, uint64_t address, int reg) const {
     return handler->OffsetRule(address, reg, base_register_, offset_);
   }
-  bool operator==(const Rule &rhs) const {
+  bool operator==(const Rule& rhs) const {
     // dynamic_cast is allowed by the Google C++ Style Guide, if the use has
     // been carefully considered; cheap RTTI-like workarounds are forbidden.
-    const OffsetRule *our_rhs = dynamic_cast<const OffsetRule *>(&rhs);
+    const OffsetRule* our_rhs = dynamic_cast<const OffsetRule*>(&rhs);
     return (our_rhs &&
             base_register_ == our_rhs->base_register_ &&
             offset_ == our_rhs->offset_);
   }
-  Rule *Copy() const { return new OffsetRule(*this); }
+  Rule* Copy() const { return new OffsetRule(*this); }
   // We don't actually need SetBaseRegister or SetOffset here, since they
   // are only ever applied to CFA rules, for DW_CFA_def_cfa_offset, and it
   // doesn't make sense to use OffsetRule for computing the CFA: it
@@ -964,18 +1716,18 @@ class CallFrameInfo::ValOffsetRule: public CallFrameInfo::Rule {
   ValOffsetRule(int base_register, long offset)
       : base_register_(base_register), offset_(offset) { }
   ~ValOffsetRule() { }
-  bool Handle(Handler *handler, uint64 address, int reg) const {
+  bool Handle(Handler* handler, uint64_t address, int reg) const {
     return handler->ValOffsetRule(address, reg, base_register_, offset_);
   }
-  bool operator==(const Rule &rhs) const {
+  bool operator==(const Rule& rhs) const {
     // dynamic_cast is allowed by the Google C++ Style Guide, if the use has
     // been carefully considered; cheap RTTI-like workarounds are forbidden.
-    const ValOffsetRule *our_rhs = dynamic_cast<const ValOffsetRule *>(&rhs);
+    const ValOffsetRule* our_rhs = dynamic_cast<const ValOffsetRule*>(&rhs);
     return (our_rhs &&
             base_register_ == our_rhs->base_register_ &&
             offset_ == our_rhs->offset_);
   }
-  Rule *Copy() const { return new ValOffsetRule(*this); }
+  Rule* Copy() const { return new ValOffsetRule(*this); }
   void SetBaseRegister(unsigned reg) { base_register_ = reg; }
   void SetOffset(long long offset) { offset_ = offset; }
  private:
@@ -989,16 +1741,16 @@ class CallFrameInfo::RegisterRule: public CallFrameInfo::Rule {
   explicit RegisterRule(int register_number)
       : register_number_(register_number) { }
   ~RegisterRule() { }
-  bool Handle(Handler *handler, uint64 address, int reg) const {
+  bool Handle(Handler* handler, uint64_t address, int reg) const {
     return handler->RegisterRule(address, reg, register_number_);
   }
-  bool operator==(const Rule &rhs) const {
+  bool operator==(const Rule& rhs) const {
     // dynamic_cast is allowed by the Google C++ Style Guide, if the use has
     // been carefully considered; cheap RTTI-like workarounds are forbidden.
-    const RegisterRule *our_rhs = dynamic_cast<const RegisterRule *>(&rhs);
+    const RegisterRule* our_rhs = dynamic_cast<const RegisterRule*>(&rhs);
     return (our_rhs && register_number_ == our_rhs->register_number_);
   }
-  Rule *Copy() const { return new RegisterRule(*this); }
+  Rule* Copy() const { return new RegisterRule(*this); }
  private:
   int register_number_;
 };
@@ -1006,19 +1758,19 @@ class CallFrameInfo::RegisterRule: public CallFrameInfo::Rule {
 // Rule: EXPRESSION evaluates to the address at which the register is saved.
 class CallFrameInfo::ExpressionRule: public CallFrameInfo::Rule {
  public:
-  explicit ExpressionRule(const string &expression)
+  explicit ExpressionRule(const string& expression)
       : expression_(expression) { }
   ~ExpressionRule() { }
-  bool Handle(Handler *handler, uint64 address, int reg) const {
+  bool Handle(Handler* handler, uint64_t address, int reg) const {
     return handler->ExpressionRule(address, reg, expression_);
   }
-  bool operator==(const Rule &rhs) const {
+  bool operator==(const Rule& rhs) const {
     // dynamic_cast is allowed by the Google C++ Style Guide, if the use has
     // been carefully considered; cheap RTTI-like workarounds are forbidden.
-    const ExpressionRule *our_rhs = dynamic_cast<const ExpressionRule *>(&rhs);
+    const ExpressionRule* our_rhs = dynamic_cast<const ExpressionRule*>(&rhs);
     return (our_rhs && expression_ == our_rhs->expression_);
   }
-  Rule *Copy() const { return new ExpressionRule(*this); }
+  Rule* Copy() const { return new ExpressionRule(*this); }
  private:
   string expression_;
 };
@@ -1026,20 +1778,20 @@ class CallFrameInfo::ExpressionRule: public CallFrameInfo::Rule {
 // Rule: EXPRESSION evaluates to the address at which the register is saved.
 class CallFrameInfo::ValExpressionRule: public CallFrameInfo::Rule {
  public:
-  explicit ValExpressionRule(const string &expression)
+  explicit ValExpressionRule(const string& expression)
       : expression_(expression) { }
   ~ValExpressionRule() { }
-  bool Handle(Handler *handler, uint64 address, int reg) const {
+  bool Handle(Handler* handler, uint64_t address, int reg) const {
     return handler->ValExpressionRule(address, reg, expression_);
   }
-  bool operator==(const Rule &rhs) const {
+  bool operator==(const Rule& rhs) const {
     // dynamic_cast is allowed by the Google C++ Style Guide, if the use has
     // been carefully considered; cheap RTTI-like workarounds are forbidden.
-    const ValExpressionRule *our_rhs =
-        dynamic_cast<const ValExpressionRule *>(&rhs);
+    const ValExpressionRule* our_rhs =
+        dynamic_cast<const ValExpressionRule*>(&rhs);
     return (our_rhs && expression_ == our_rhs->expression_);
   }
-  Rule *Copy() const { return new ValExpressionRule(*this); }
+  Rule* Copy() const { return new ValExpressionRule(*this); }
  private:
   string expression_;
 };
@@ -1048,51 +1800,51 @@ class CallFrameInfo::ValExpressionRule: public CallFrameInfo::Rule {
 class CallFrameInfo::RuleMap {
  public:
   RuleMap() : cfa_rule_(NULL) { }
-  RuleMap(const RuleMap &rhs) : cfa_rule_(NULL) { *this = rhs; }
+  RuleMap(const RuleMap& rhs) : cfa_rule_(NULL) { *this = rhs; }
   ~RuleMap() { Clear(); }
 
-  RuleMap &operator=(const RuleMap &rhs);
+  RuleMap& operator=(const RuleMap& rhs);
 
   // Set the rule for computing the CFA to RULE. Take ownership of RULE.
-  void SetCFARule(Rule *rule) { delete cfa_rule_; cfa_rule_ = rule; }
+  void SetCFARule(Rule* rule) { delete cfa_rule_; cfa_rule_ = rule; }
 
   // Return the current CFA rule. Unlike RegisterRule, this RuleMap retains
   // ownership of the rule. We use this for DW_CFA_def_cfa_offset and
   // DW_CFA_def_cfa_register, and for detecting references to the CFA before
   // a rule for it has been established.
-  Rule *CFARule() const { return cfa_rule_; }
+  Rule* CFARule() const { return cfa_rule_; }
 
   // Return the rule for REG, or NULL if there is none. The caller takes
   // ownership of the result.
-  Rule *RegisterRule(int reg) const;
+  Rule* RegisterRule(int reg) const;
 
   // Set the rule for computing REG to RULE. Take ownership of RULE.
-  void SetRegisterRule(int reg, Rule *rule);
+  void SetRegisterRule(int reg, Rule* rule);
 
   // Make all the appropriate calls to HANDLER as if we were changing from
   // this RuleMap to NEW_RULES at ADDRESS. We use this to implement
   // DW_CFA_restore_state, where lots of rules can change simultaneously.
   // Return true if all handlers returned true; otherwise, return false.
-  bool HandleTransitionTo(Handler *handler, uint64 address,
-                          const RuleMap &new_rules) const;
+  bool HandleTransitionTo(Handler* handler, uint64_t address,
+                          const RuleMap& new_rules) const;
 
  private:
   // A map from register numbers to Rules.
-  typedef std::map<int, Rule *> RuleByNumber;
+  typedef std::map<int, Rule*> RuleByNumber;
 
   // Remove all register rules and clear cfa_rule_.
   void Clear();
 
   // The rule for computing the canonical frame address. This RuleMap owns
   // this rule.
-  Rule *cfa_rule_;
+  Rule* cfa_rule_;
 
   // A map from register numbers to postfix expressions to recover
   // their values. This RuleMap owns the Rules the map refers to.
   RuleByNumber registers_;
 };
 
-CallFrameInfo::RuleMap &CallFrameInfo::RuleMap::operator=(const RuleMap &rhs) {
+CallFrameInfo::RuleMap& CallFrameInfo::RuleMap::operator=(const RuleMap& rhs) {
   Clear();
   // Since each map owns the rules it refers to, assignment must copy them.
   if (rhs.cfa_rule_) cfa_rule_ = rhs.cfa_rule_->Copy();
@@ -1102,7 +1854,7 @@ CallFrameInfo::RuleMap &CallFrameInfo::RuleMap::operator=(const RuleMap &rhs) {
   return *this;
 }
 
-CallFrameInfo::Rule *CallFrameInfo::RuleMap::RegisterRule(int reg) const {
+CallFrameInfo::Rule* CallFrameInfo::RuleMap::RegisterRule(int reg) const {
   assert(reg != Handler::kCFARegister);
   RuleByNumber::const_iterator it = registers_.find(reg);
   if (it != registers_.end())
@@ -1111,18 +1863,18 @@ CallFrameInfo::Rule *CallFrameInfo::RuleMap::RegisterRule(int reg) const {
     return NULL;
 }
 
-void CallFrameInfo::RuleMap::SetRegisterRule(int reg, Rule *rule) {
+void CallFrameInfo::RuleMap::SetRegisterRule(int reg, Rule* rule) {
   assert(reg != Handler::kCFARegister);
   assert(rule);
-  Rule **slot = &registers_[reg];
+  Rule** slot = &registers_[reg];
   delete *slot;
   *slot = rule;
 }
 
 bool CallFrameInfo::RuleMap::HandleTransitionTo(
-    Handler *handler,
-    uint64 address,
-    const RuleMap &new_rules) const {
+    Handler* handler,
+    uint64_t address,
+    const RuleMap& new_rules) const {
   // Transition from cfa_rule_ to new_rules.cfa_rule_.
   if (cfa_rule_ && new_rules.cfa_rule_) {
     if (*cfa_rule_ != *new_rules.cfa_rule_ &&
@@ -1202,25 +1954,25 @@ class CallFrameInfo::State {
  public:
   // Create a call frame information interpreter state with the given
   // reporter, reader, handler, and initial call frame info address.
-  State(ByteReader *reader, Handler *handler, Reporter *reporter,
-        uint64 address)
+  State(ByteReader* reader, Handler* handler, Reporter* reporter,
+        uint64_t address)
       : reader_(reader), handler_(handler), reporter_(reporter),
         address_(address), entry_(NULL), cursor_(NULL) { }
 
   // Interpret instructions from CIE, save the resulting rule set for
   // DW_CFA_restore instructions, and return true. On error, report
   // the problem to reporter_ and return false.
-  bool InterpretCIE(const CIE &cie);
+  bool InterpretCIE(const CIE& cie);
 
   // Interpret instructions from FDE, and return true. On error,
   // report the problem to reporter_ and return false.
-  bool InterpretFDE(const FDE &fde);
+  bool InterpretFDE(const FDE& fde);
 
  private:  
   // The operands of a CFI instruction, for ParseOperands.
   struct Operands {
     unsigned register_number;  // A register number.
-    uint64 offset;             // An offset or address.
+    uint64_t offset;             // An offset or address.
     long signed_offset;        // A signed offset.
     string expression;         // A DWARF expression.
   };
@@ -1244,7 +1996,7 @@ class CallFrameInfo::State {
   //   '8'  an eight-byte offset            (OPERANDS->offset)
   //   'e'  a DW_FORM_block holding a       (OPERANDS->expression)
   //        DWARF expression
-  bool ParseOperands(const char *format, Operands *operands);
+  bool ParseOperands(const char* format, Operands* operands);
 
   // Interpret one CFI instruction from STATE's instruction stream, update
   // STATE, report any rule changes to handler_, and return true. On
@@ -1267,7 +2019,7 @@ class CallFrameInfo::State {
 
   // Specify that REG can be recovered using RULE, and return true. On
   // failure, report and return false.
-  bool DoRule(unsigned reg, Rule *rule);
+  bool DoRule(unsigned reg, Rule* rule);
 
   // Specify that REG can be found at OFFSET from the CFA, and return true.
   // On failure, report and return false. (Subroutine for DW_CFA_offset,
@@ -1286,7 +2038,7 @@ class CallFrameInfo::State {
 
   // Return the section offset of the instruction at cursor. For use
   // in error messages.
-  uint64 CursorOffset() { return entry_->offset + (cursor_ - entry_->start); }
+  uint64_t CursorOffset() { return entry_->offset + (cursor_ - entry_->start); }
 
   // Report that entry_ is incomplete, and return false. For brevity.
   bool ReportIncomplete() {
@@ -1295,23 +2047,23 @@ class CallFrameInfo::State {
   }
 
   // For reading multi-byte values with the appropriate endianness.
-  ByteReader *reader_;
+  ByteReader* reader_;
 
   // The handler to which we should report the data we find.
-  Handler *handler_;
+  Handler* handler_;
 
   // For reporting problems in the info we're parsing.
-  Reporter *reporter_;
+  Reporter* reporter_;
 
   // The code address to which the next instruction in the stream applies.
-  uint64 address_;
+  uint64_t address_;
 
   // The entry whose instructions we are currently processing. This is
   // first a CIE, and then an FDE.
-  const Entry *entry_;
+  const Entry* entry_;
 
   // The next instruction to process.
-  const char *cursor_;
+  const uint8_t* cursor_;
 
   // The current set of rules.
   RuleMap rules_;
@@ -1326,7 +2078,7 @@ class CallFrameInfo::State {
   std::stack<RuleMap> saved_rules_;
 };
 
-bool CallFrameInfo::State::InterpretCIE(const CIE &cie) {
+bool CallFrameInfo::State::InterpretCIE(const CIE& cie) {
   entry_ = &cie;
   cursor_ = entry_->instructions;
   while (cursor_ < entry_->end)
@@ -1338,7 +2090,7 @@ bool CallFrameInfo::State::InterpretCIE(const CIE &cie) {
   return true;
 }
 
-bool CallFrameInfo::State::InterpretFDE(const FDE &fde) {
+bool CallFrameInfo::State::InterpretFDE(const FDE& fde) {
   entry_ = &fde;
   cursor_ = entry_->instructions;
   while (cursor_ < entry_->end)
@@ -1347,10 +2099,10 @@ bool CallFrameInfo::State::InterpretFDE(const FDE &fde) {
   return true;
 }
 
-bool CallFrameInfo::State::ParseOperands(const char *format,
-                                         Operands *operands) {
+bool CallFrameInfo::State::ParseOperands(const char* format,
+                                         Operands* operands) {
   size_t len;
-  const char *operand;
+  const char* operand;
 
   for (operand = format; *operand; operand++) {
     size_t bytes_left = entry_->end - cursor_;
@@ -1409,7 +2161,8 @@ bool CallFrameInfo::State::ParseOperands(const char *format,
         if (len > bytes_left || expression_length > bytes_left - len)
           return ReportIncomplete();
         cursor_ += len;
-        operands->expression = string(cursor_, expression_length);
+        operands->expression = string(reinterpret_cast<const char*>(cursor_),
+                                      expression_length);
         cursor_ += expression_length;
         break;
       }
@@ -1423,7 +2176,7 @@ bool CallFrameInfo::State::ParseOperands(const char *format,
 }
 
 bool CallFrameInfo::State::DoInstruction() {
-  CIE *cie = entry_->cie;
+  CIE* cie = entry_->cie;
   Operands ops;
 
   // Our entry's kind should have been set by now.
@@ -1513,7 +2266,7 @@ bool CallFrameInfo::State::DoInstruction() {
     // Change the base register used to compute the CFA.
     case DW_CFA_def_cfa_register: {
       if (!ParseOperands("r", &ops)) return false;
-      Rule *cfa_rule = rules_.CFARule();
+      Rule* cfa_rule = rules_.CFARule();
       if (!cfa_rule) {
         if (!DoDefCFA(ops.register_number, ops.offset)) {
           reporter_->NoCFARule(entry_->offset, entry_->kind, CursorOffset());
@@ -1546,7 +2299,7 @@ bool CallFrameInfo::State::DoInstruction() {
     case DW_CFA_def_cfa_expression: {
       if (!ParseOperands("e", &ops))
         return false;
-      Rule *rule = new ValExpressionRule(ops.expression);
+      Rule* rule = new ValExpressionRule(ops.expression);
       rules_.SetCFARule(rule);
       if (!rule->Handle(handler_, address_,
                         Handler::kCFARegister))
@@ -1653,7 +2406,7 @@ bool CallFrameInfo::State::DoInstruction() {
                                    CursorOffset());
         return false;
       }
-      const RuleMap &new_rules = saved_rules_.top();
+      const RuleMap& new_rules = saved_rules_.top();
       if (rules_.CFARule() && !new_rules.CFARule()) {
         reporter_->ClearingCFARule(entry_->offset, entry_->kind,
                                    CursorOffset());
@@ -1705,14 +2458,14 @@ bool CallFrameInfo::State::DoInstruction() {
 }
 
 bool CallFrameInfo::State::DoDefCFA(unsigned base_register, long offset) {
-  Rule *rule = new ValOffsetRule(base_register, offset);
+  Rule* rule = new ValOffsetRule(base_register, offset);
   rules_.SetCFARule(rule);
   return rule->Handle(handler_, address_,
                       Handler::kCFARegister);
 }
 
 bool CallFrameInfo::State::DoDefCFAOffset(long offset) {
-  Rule *cfa_rule = rules_.CFARule();
+  Rule* cfa_rule = rules_.CFARule();
   if (!cfa_rule) {
     reporter_->NoCFARule(entry_->offset, entry_->kind, CursorOffset());
     return false;
@@ -1722,7 +2475,7 @@ bool CallFrameInfo::State::DoDefCFAOffset(long offset) {
                           Handler::kCFARegister);
 }
 
-bool CallFrameInfo::State::DoRule(unsigned reg, Rule *rule) {
+bool CallFrameInfo::State::DoRule(unsigned reg, Rule* rule) {
   rules_.SetRegisterRule(reg, rule);
   return rule->Handle(handler_, address_, reg);
 }
@@ -1751,7 +2504,7 @@ bool CallFrameInfo::State::DoRestore(unsigned reg) {
     reporter_->RestoreInCIE(entry_->offset, CursorOffset());
     return false;
   }
-  Rule *rule = cie_rules_.RegisterRule(reg);
+  Rule* rule = cie_rules_.RegisterRule(reg);
   if (!rule) {
     // This isn't really the right thing to do, but since CFI generally
     // only mentions callee-saves registers, and GCC's convention for
@@ -1762,8 +2515,8 @@ bool CallFrameInfo::State::DoRestore(unsigned reg) {
   return DoRule(reg, rule);
 }
 
-bool CallFrameInfo::ReadEntryPrologue(const char *cursor, Entry *entry) {
-  const char *buffer_end = buffer_ + buffer_length_;
+bool CallFrameInfo::ReadEntryPrologue(const uint8_t* cursor, Entry* entry) {
+  const uint8_t* buffer_end = buffer_ + buffer_length_;
 
   // Initialize enough of ENTRY for use in error reporting.
   entry->offset = cursor - buffer_;
@@ -1773,7 +2526,7 @@ bool CallFrameInfo::ReadEntryPrologue(const char *cursor, Entry *entry) {
 
   // Read the initial length. This sets reader_'s offset size.
   size_t length_size;
-  uint64 length = reader_->ReadInitialLength(cursor, &length_size);
+  uint64_t length = reader_->ReadInitialLength(cursor, &length_size);
   if (length_size > size_t(buffer_end - cursor))
     return ReportIncomplete(entry);
   cursor += length_size;
@@ -1840,8 +2593,8 @@ bool CallFrameInfo::ReadEntryPrologue(const char *cursor, Entry *entry) {
   return true;
 }
 
-bool CallFrameInfo::ReadCIEFields(CIE *cie) {
-  const char *cursor = cie->fields;
+bool CallFrameInfo::ReadCIEFields(CIE* cie) {
+  const uint8_t* cursor = cie->fields;
   size_t len;
 
   assert(cie->kind == kCIE);
@@ -1863,22 +2616,23 @@ bool CallFrameInfo::ReadCIEFields(CIE *cie) {
   cursor++;
 
   // If we don't recognize the version, we can't parse any more fields of the
-  // CIE. For DWARF CFI, we handle versions 1 through 3 (there was never a
-  // version 2 of CFI data). For .eh_frame, we handle versions 1 and 3 as well;
+  // CIE. For DWARF CFI, we handle versions 1 through 4 (there was never a
+  // version 2 of CFI data). For .eh_frame, we handle versions 1 and 4 as well;
   // the difference between those versions seems to be the same as for
   // .debug_frame.
-  if (cie->version < 1 || cie->version > 3) {
+  if (cie->version < 1 || cie->version > 4) {
     reporter_->UnrecognizedVersion(cie->offset, cie->version);
     return false;
   }
 
-  const char *augmentation_start = cursor;
-  const void *augmentation_end =
-      memchr(augmentation_start, '\0', cie->end - augmentation_start);
+  const uint8_t* augmentation_start = cursor;
+  const uint8_t* augmentation_end =
+      reinterpret_cast<const uint8_t*>(memchr(augmentation_start, '\0',
+                                               cie->end - augmentation_start));
   if (! augmentation_end) return ReportIncomplete(cie);
-  cursor = static_cast<const char *>(augmentation_end);
-  cie->augmentation = string(augmentation_start,
-                                  cursor - augmentation_start);
+  cursor = augmentation_end;
+  cie->augmentation = string(reinterpret_cast<const char*>(augmentation_start),
+                             cursor - augmentation_start);
   // Skip the terminating '\0'.
   cursor++;
 
@@ -1896,21 +2650,35 @@ bool CallFrameInfo::ReadCIEFields(CIE *cie) {
     }
   }
 
+  if (cie->version >= 4) {
+    cie->address_size = *cursor++;
+    if (cie->address_size != 8 && cie->address_size != 4) {
+      reporter_->UnexpectedAddressSize(cie->offset, cie->address_size);
+      return false;
+    }
+
+    cie->segment_size = *cursor++;
+    if (cie->segment_size != 0) {
+      reporter_->UnexpectedSegmentSize(cie->offset, cie->segment_size);
+      return false;
+    }
+  }
+
   // Parse the code alignment factor.
   cie->code_alignment_factor = reader_->ReadUnsignedLEB128(cursor, &len);
   if (size_t(cie->end - cursor) < len) return ReportIncomplete(cie);
   cursor += len;
-  
+
   // Parse the data alignment factor.
   cie->data_alignment_factor = reader_->ReadSignedLEB128(cursor, &len);
   if (size_t(cie->end - cursor) < len) return ReportIncomplete(cie);
   cursor += len;
-  
+
   // Parse the return address register. This is a ubyte in version 1, and
   // a ULEB128 in version 3.
   if (cie->version == 1) {
     if (cursor >= cie->end) return ReportIncomplete(cie);
-    cie->return_address_register = uint8(*cursor++);
+    cie->return_address_register = uint8_t(*cursor++);
   } else {
     cie->return_address_register = reader_->ReadUnsignedLEB128(cursor, &len);
     if (size_t(cie->end - cursor) < len) return ReportIncomplete(cie);
@@ -1924,9 +2692,9 @@ bool CallFrameInfo::ReadCIEFields(CIE *cie) {
     if (size_t(cie->end - cursor) < len + data_size)
       return ReportIncomplete(cie);
     cursor += len;
-    const char *data = cursor;
+    const uint8_t* data = cursor;
     cursor += data_size;
-    const char *data_end = cursor;
+    const uint8_t* data_end = cursor;
 
     cie->has_z_lsda = false;
     cie->has_z_personality = false;
@@ -2016,9 +2784,9 @@ bool CallFrameInfo::ReadCIEFields(CIE *cie) {
 
   return true;
 }
-  
-bool CallFrameInfo::ReadFDEFields(FDE *fde) {
-  const char *cursor = fde->fields;
+
+bool CallFrameInfo::ReadFDEFields(FDE* fde) {
+  const uint8_t* cursor = fde->fields;
   size_t size;
 
   fde->address = reader_->ReadEncodedPointer(cursor, fde->cie->pointer_encoding,
@@ -2084,10 +2852,10 @@ bool CallFrameInfo::ReadFDEFields(FDE *fde) {
 }
   
 bool CallFrameInfo::Start() {
-  const char *buffer_end = buffer_ + buffer_length_;
-  const char *cursor;
+  const uint8_t* buffer_end = buffer_ + buffer_length_;
+  const uint8_t* cursor;
   bool all_ok = true;
-  const char *entry_end;
+  const uint8_t* entry_end;
   bool ok;
 
   // Traverse all the entries in buffer_, skipping CIEs and offering
@@ -2153,6 +2921,15 @@ bool CallFrameInfo::Start() {
     if (!ReadCIEFields(&cie))
       continue;
 
+    // TODO(nbilling): This could lead to strange behavior if a single buffer
+    // contained a mixture of DWARF versions as well as address sizes. Not
+    // sure if it's worth handling such a case.
+
+    // DWARF4 CIE specifies address_size, so use it for this call frame.
+    if (cie.version >= 4) {
+      reader_->SetAddressSize(cie.address_size);
+    }
+
     // We now have the values that govern both the CIE and the FDE.
     cie.cie = &cie;
     fde.cie = &cie;
@@ -2209,7 +2986,7 @@ bool CallFrameInfo::Start() {
   return all_ok;
 }
 
-const char *CallFrameInfo::KindName(EntryKind kind) {
+const char* CallFrameInfo::KindName(EntryKind kind) {
   if (kind == CallFrameInfo::kUnknown)
     return "entry";
   else if (kind == CallFrameInfo::kCIE)
@@ -2222,119 +2999,135 @@ const char *CallFrameInfo::KindName(EntryKind kind) {
   }
 }
 
-bool CallFrameInfo::ReportIncomplete(Entry *entry) {
+bool CallFrameInfo::ReportIncomplete(Entry* entry) {
   reporter_->Incomplete(entry->offset, entry->kind);
   return false;
 }
 
-void CallFrameInfo::Reporter::Incomplete(uint64 offset,
+void CallFrameInfo::Reporter::Incomplete(uint64_t offset,
                                          CallFrameInfo::EntryKind kind) {
   fprintf(stderr,
-          "%s: CFI %s at offset 0x%llx in '%s': entry ends early\n",
+          "%s: CFI %s at offset 0x%" PRIx64 " in '%s': entry ends early\n",
           filename_.c_str(), CallFrameInfo::KindName(kind), offset,
           section_.c_str());
 }
 
-void CallFrameInfo::Reporter::EarlyEHTerminator(uint64 offset) {
+void CallFrameInfo::Reporter::EarlyEHTerminator(uint64_t offset) {
   fprintf(stderr,
-          "%s: CFI at offset 0x%llx in '%s': saw end-of-data marker"
+          "%s: CFI at offset 0x%" PRIx64 " in '%s': saw end-of-data marker"
           " before end of section contents\n",
           filename_.c_str(), offset, section_.c_str());
 }
 
-void CallFrameInfo::Reporter::CIEPointerOutOfRange(uint64 offset,
-                                                   uint64 cie_offset) {
+void CallFrameInfo::Reporter::CIEPointerOutOfRange(uint64_t offset,
+                                                   uint64_t cie_offset) {
   fprintf(stderr,
-          "%s: CFI frame description entry at offset 0x%llx in '%s':"
-          " CIE pointer is out of range: 0x%llx\n",
+          "%s: CFI frame description entry at offset 0x%" PRIx64 " in '%s':"
+          " CIE pointer is out of range: 0x%" PRIx64 "\n",
           filename_.c_str(), offset, section_.c_str(), cie_offset);
 }
 
-void CallFrameInfo::Reporter::BadCIEId(uint64 offset, uint64 cie_offset) {
+void CallFrameInfo::Reporter::BadCIEId(uint64_t offset, uint64_t cie_offset) {
   fprintf(stderr,
-          "%s: CFI frame description entry at offset 0x%llx in '%s':"
-          " CIE pointer does not point to a CIE: 0x%llx\n",
+          "%s: CFI frame description entry at offset 0x%" PRIx64 " in '%s':"
+          " CIE pointer does not point to a CIE: 0x%" PRIx64 "\n",
           filename_.c_str(), offset, section_.c_str(), cie_offset);
 }
 
-void CallFrameInfo::Reporter::UnrecognizedVersion(uint64 offset, int version) {
+void CallFrameInfo::Reporter::UnexpectedAddressSize(uint64_t offset,
+                                                    uint8_t address_size) {
+  fprintf(stderr,
+          "%s: CFI frame description entry at offset 0x%" PRIx64 " in '%s':"
+          " CIE specifies unexpected address size: %d\n",
+          filename_.c_str(), offset, section_.c_str(), address_size);
+}
+
+void CallFrameInfo::Reporter::UnexpectedSegmentSize(uint64_t offset,
+                                                    uint8_t segment_size) {
+  fprintf(stderr,
+          "%s: CFI frame description entry at offset 0x%" PRIx64 " in '%s':"
+          " CIE specifies unexpected segment size: %d\n",
+          filename_.c_str(), offset, section_.c_str(), segment_size);
+}
+
+void CallFrameInfo::Reporter::UnrecognizedVersion(uint64_t offset, int version) {
   fprintf(stderr,
-          "%s: CFI frame description entry at offset 0x%llx in '%s':"
+          "%s: CFI frame description entry at offset 0x%" PRIx64 " in '%s':"
           " CIE specifies unrecognized version: %d\n",
           filename_.c_str(), offset, section_.c_str(), version);
 }
 
-void CallFrameInfo::Reporter::UnrecognizedAugmentation(uint64 offset,
-                                                       const string &aug) {
+void CallFrameInfo::Reporter::UnrecognizedAugmentation(uint64_t offset,
+                                                       const string& aug) {
   fprintf(stderr,
-          "%s: CFI frame description entry at offset 0x%llx in '%s':"
+          "%s: CFI frame description entry at offset 0x%" PRIx64 " in '%s':"
           " CIE specifies unrecognized augmentation: '%s'\n",
           filename_.c_str(), offset, section_.c_str(), aug.c_str());
 }
 
-void CallFrameInfo::Reporter::InvalidPointerEncoding(uint64 offset,
-                                                     uint8 encoding) {
+void CallFrameInfo::Reporter::InvalidPointerEncoding(uint64_t offset,
+                                                     uint8_t encoding) {
   fprintf(stderr,
-          "%s: CFI common information entry at offset 0x%llx in '%s':"
+          "%s: CFI common information entry at offset 0x%" PRIx64 " in '%s':"
           " 'z' augmentation specifies invalid pointer encoding: 0x%02x\n",
           filename_.c_str(), offset, section_.c_str(), encoding);
 }
 
-void CallFrameInfo::Reporter::UnusablePointerEncoding(uint64 offset,
-                                                      uint8 encoding) {
+void CallFrameInfo::Reporter::UnusablePointerEncoding(uint64_t offset,
+                                                      uint8_t encoding) {
   fprintf(stderr,
-          "%s: CFI common information entry at offset 0x%llx in '%s':"
+          "%s: CFI common information entry at offset 0x%" PRIx64 " in '%s':"
           " 'z' augmentation specifies a pointer encoding for which"
           " we have no base address: 0x%02x\n",
           filename_.c_str(), offset, section_.c_str(), encoding);
 }
 
-void CallFrameInfo::Reporter::RestoreInCIE(uint64 offset, uint64 insn_offset) {
+void CallFrameInfo::Reporter::RestoreInCIE(uint64_t offset, uint64_t insn_offset) {
   fprintf(stderr,
-          "%s: CFI common information entry at offset 0x%llx in '%s':"
-          " the DW_CFA_restore instruction at offset 0x%llx"
+          "%s: CFI common information entry at offset 0x%" PRIx64 " in '%s':"
+          " the DW_CFA_restore instruction at offset 0x%" PRIx64
           " cannot be used in a common information entry\n",
           filename_.c_str(), offset, section_.c_str(), insn_offset);
 }
 
-void CallFrameInfo::Reporter::BadInstruction(uint64 offset,
+void CallFrameInfo::Reporter::BadInstruction(uint64_t offset,
                                              CallFrameInfo::EntryKind kind,
-                                             uint64 insn_offset) {
+                                             uint64_t insn_offset) {
   fprintf(stderr,
-          "%s: CFI %s at offset 0x%llx in section '%s':"
-          " the instruction at offset 0x%llx is unrecognized\n",
+          "%s: CFI %s at offset 0x%" PRIx64 " in section '%s':"
+          " the instruction at offset 0x%" PRIx64 " is unrecognized\n",
           filename_.c_str(), CallFrameInfo::KindName(kind),
           offset, section_.c_str(), insn_offset);
 }
 
-void CallFrameInfo::Reporter::NoCFARule(uint64 offset,
+void CallFrameInfo::Reporter::NoCFARule(uint64_t offset,
                                         CallFrameInfo::EntryKind kind,
-                                        uint64 insn_offset) {
+                                        uint64_t insn_offset) {
   fprintf(stderr,
-          "%s: CFI %s at offset 0x%llx in section '%s':"
-          " the instruction at offset 0x%llx assumes that a CFA rule has"
+          "%s: CFI %s at offset 0x%" PRIx64 " in section '%s':"
+          " the instruction at offset 0x%" PRIx64 " assumes that a CFA rule has"
           " been set, but none has been set\n",
           filename_.c_str(), CallFrameInfo::KindName(kind), offset,
           section_.c_str(), insn_offset);
 }
 
-void CallFrameInfo::Reporter::EmptyStateStack(uint64 offset,
+void CallFrameInfo::Reporter::EmptyStateStack(uint64_t offset,
                                               CallFrameInfo::EntryKind kind,
-                                              uint64 insn_offset) {
+                                              uint64_t insn_offset) {
   fprintf(stderr,
-          "%s: CFI %s at offset 0x%llx in section '%s':"
-          " the DW_CFA_restore_state instruction at offset 0x%llx"
+          "%s: CFI %s at offset 0x%" PRIx64 " in section '%s':"
+          " the DW_CFA_restore_state instruction at offset 0x%" PRIx64
           " should pop a saved state from the stack, but the stack is empty\n",
           filename_.c_str(), CallFrameInfo::KindName(kind), offset,
           section_.c_str(), insn_offset);
 }
 
-void CallFrameInfo::Reporter::ClearingCFARule(uint64 offset,
+void CallFrameInfo::Reporter::ClearingCFARule(uint64_t offset,
                                               CallFrameInfo::EntryKind kind,
-                                              uint64 insn_offset) {
+                                              uint64_t insn_offset) {
   fprintf(stderr,
-          "%s: CFI %s at offset 0x%llx in section '%s':"
-          " the DW_CFA_restore_state instruction at offset 0x%llx"
+          "%s: CFI %s at offset 0x%" PRIx64 " in section '%s':"
+          " the DW_CFA_restore_state instruction at offset 0x%" PRIx64
           " would clear the CFA rule in effect\n",
           filename_.c_str(), CallFrameInfo::KindName(kind), offset,
           section_.c_str(), insn_offset);
diff --git a/src/MEGASync/google_breakpad/common/dwarf/dwarf2reader.h b/src/MEGASync/google_breakpad/common/dwarf/dwarf2reader.h
index 8824bf90..e405e3a7 100644
--- a/src/MEGASync/google_breakpad/common/dwarf/dwarf2reader.h
+++ b/src/MEGASync/google_breakpad/common/dwarf/dwarf2reader.h
@@ -40,42 +40,55 @@
 #ifndef COMMON_DWARF_DWARF2READER_H__
 #define COMMON_DWARF_DWARF2READER_H__
 
+#include <assert.h>
+#include <stdint.h>
+
 #include <list>
 #include <map>
 #include <string>
 #include <utility>
 #include <vector>
+#include <memory>
 
 #include "common/dwarf/bytereader.h"
 #include "common/dwarf/dwarf2enums.h"
 #include "common/dwarf/types.h"
 #include "common/using_std_string.h"
+#include "common/dwarf/elf_reader.h"
 
 namespace dwarf2reader {
 struct LineStateMachine;
 class Dwarf2Handler;
 class LineInfoHandler;
+class DwpReader;
 
 // This maps from a string naming a section to a pair containing a
 // the data for the section, and the size of the section.
-typedef std::map<string, std::pair<const char*, uint64> > SectionMap;
+typedef std::map<string, std::pair<const uint8_t*, uint64_t> > SectionMap;
+
+// Abstract away the difference between elf and mach-o section names.
+// Elf-names use ".section_name, mach-o uses "__section_name".  Pass "name" in
+// the elf form, ".section_name".
+const SectionMap::const_iterator GetSectionByName(const SectionMap&
+                                                  sections, const char* name);
+
 typedef std::list<std::pair<enum DwarfAttribute, enum DwarfForm> >
     AttributeList;
 typedef AttributeList::iterator AttributeIterator;
 typedef AttributeList::const_iterator ConstAttributeIterator;
 
 struct LineInfoHeader {
-  uint64 total_length;
-  uint16 version;
-  uint64 prologue_length;
-  uint8 min_insn_length; // insn stands for instructin
+  uint64_t total_length;
+  uint16_t version;
+  uint64_t prologue_length;
+  uint8_t min_insn_length; // insn stands for instructin
   bool default_is_stmt; // stmt stands for statement
-  int8 line_base;
-  uint8 line_range;
-  uint8 opcode_base;
+  int8_t line_base;
+  uint8_t line_range;
+  uint8_t opcode_base;
   // Use a pointer so that signalsafe_addr2line is able to use this structure
   // without heap allocation problem.
-  std::vector<unsigned char> *std_opcode_lengths;
+  std::vector<unsigned char>* std_opcode_lengths;
 };
 
 class LineInfo {
@@ -85,8 +98,10 @@ class LineInfo {
   // to the beginning and length of the line information to read.
   // Reader is a ByteReader class that has the endianness set
   // properly.
-  LineInfo(const char* buffer_, uint64 buffer_length,
-           ByteReader* reader, LineInfoHandler* handler);
+  LineInfo(const uint8_t* buffer, uint64_t buffer_length,
+           ByteReader* reader, const uint8_t* string_buffer,
+           size_t string_buffer_length, const uint8_t* line_string_buffer,
+           size_t line_string_buffer_length, LineInfoHandler* handler);
 
   virtual ~LineInfo() {
     if (header_.std_opcode_lengths) {
@@ -97,7 +112,7 @@ class LineInfo {
   // Start processing line info, and calling callbacks in the handler.
   // Consumes the line number information for a single compilation unit.
   // Returns the number of bytes processed.
-  uint64 Start();
+  uint64_t Start();
 
   // Process a single line info opcode at START using the state
   // machine at LSM.  Return true if we should define a line using the
@@ -110,12 +125,12 @@ class LineInfo {
   // lsm's old address < PC <= lsm's new address
   static bool ProcessOneOpcode(ByteReader* reader,
                                LineInfoHandler* handler,
-                               const struct LineInfoHeader &header,
-                               const char* start,
+                               const struct LineInfoHeader& header,
+                               const uint8_t* start,
                                struct LineStateMachine* lsm,
                                size_t* len,
                                uintptr pc,
-                               bool *lsm_passes_pc);
+                               bool* lsm_passes_pc);
 
  private:
   // Reads the DWARF2/3 header for this line info.
@@ -124,24 +139,54 @@ class LineInfo {
   // Reads the DWARF2/3 line information
   void ReadLines();
 
+  // Read the DWARF5 types and forms for the file and directory tables.
+  void ReadTypesAndForms(const uint8_t** lineptr, uint32_t* content_types,
+                         uint32_t* content_forms, uint32_t max_types,
+                         uint32_t* format_count);
+
+  // Read a row from the dwarf5 LineInfo file table.
+  void ReadFileRow(const uint8_t** lineptr, const uint32_t* content_types,
+                   const uint32_t* content_forms, uint32_t row,
+                   uint32_t format_count);
+
+  // Read and return the data at *lineptr according to form. Advance
+  // *lineptr appropriately.
+  uint64_t ReadUnsignedData(uint32_t form, const uint8_t** lineptr);
+
+  // Read and return the data at *lineptr according to form. Advance
+  // *lineptr appropriately.
+  const char* ReadStringForm(uint32_t form, const uint8_t** lineptr);
+
   // The associated handler to call processing functions in
   LineInfoHandler* handler_;
 
   // The associated ByteReader that handles endianness issues for us
   ByteReader* reader_;
 
-  // A DWARF2/3 line info header.  This is not the same size as
-  // in the actual file, as the one in the file may have a 32 bit or
-  // 64 bit lengths
+  // A DWARF line info header.  This is not the same size as in the actual file,
+  // as the one in the file may have a 32 bit or 64 bit lengths
 
   struct LineInfoHeader header_;
 
   // buffer is the buffer for our line info, starting at exactly where
   // the line info to read is.  after_header is the place right after
   // the end of the line information header.
-  const char* buffer_;
-  uint64 buffer_length_;
-  const char* after_header_;
+  const uint8_t* buffer_;
+#ifndef NDEBUG
+  uint64_t buffer_length_;
+#endif
+  // Convenience pointers into .debug_str and .debug_line_str. These exactly
+  // correspond to those in the compilation unit.
+  const uint8_t* string_buffer_;
+#ifndef NDEBUG
+  uint64_t string_buffer_length_;
+#endif
+  const uint8_t* line_string_buffer_;
+#ifndef NDEBUG
+  uint64_t line_string_buffer_length_;
+#endif
+
+  const uint8_t* after_header_;
 };
 
 // This class is the main interface between the line info reader and
@@ -157,7 +202,7 @@ class LineInfoHandler {
 
   // Called when we define a directory.  NAME is the directory name,
   // DIR_NUM is the directory number
-  virtual void DefineDir(const string& name, uint32 dir_num) { }
+  virtual void DefineDir(const string& name, uint32_t dir_num) { }
 
   // Called when we define a filename. NAME is the filename, FILE_NUM
   // is the file number which is -1 if the file index is the next
@@ -166,9 +211,9 @@ class LineInfoHandler {
   // directory index for the directory name of this file, MOD_TIME is
   // the modification time of the file, and LENGTH is the length of
   // the file
-  virtual void DefineFile(const string& name, int32 file_num,
-                          uint32 dir_num, uint64 mod_time,
-                          uint64 length) { }
+  virtual void DefineFile(const string& name, int32_t file_num,
+                          uint32_t dir_num, uint64_t mod_time,
+                          uint64_t length) { }
 
   // Called when the line info reader has a new line, address pair
   // ready for us. ADDRESS is the address of the code, LENGTH is the
@@ -176,8 +221,138 @@ class LineInfoHandler {
   // containing the code, LINE_NUM is the line number in that file for
   // the code, and COLUMN_NUM is the column number the code starts at,
   // if we know it (0 otherwise).
-  virtual void AddLine(uint64 address, uint64 length,
-                       uint32 file_num, uint32 line_num, uint32 column_num) { }
+  virtual void AddLine(uint64_t address, uint64_t length,
+                       uint32_t file_num, uint32_t line_num, uint32_t column_num) { }
+};
+
+class RangeListHandler {
+ public:
+  RangeListHandler() { }
+
+  virtual ~RangeListHandler() { }
+
+  // Add a range.
+  virtual void AddRange(uint64_t begin, uint64_t end) { };
+
+  // A new base address must be set for computing the ranges' addresses.
+  virtual void SetBaseAddress(uint64_t base_address) { };
+
+  // Finish processing the range list.
+  virtual void Finish() { };
+};
+
+class RangeListReader {
+ public:
+  RangeListReader(const uint8_t* buffer, uint64_t size, ByteReader* reader,
+                  RangeListHandler* handler);
+
+  bool ReadRangeList(uint64_t offset);
+
+ private:
+  const uint8_t* buffer_;
+  uint64_t size_;
+  ByteReader* reader_;
+  RangeListHandler* handler_;
+};
+
+// This class is the main interface between the reader and the
+// client.  The virtual functions inside this get called for
+// interesting events that happen during DWARF2 reading.
+// The default implementation skips everything.
+class Dwarf2Handler {
+ public:
+  Dwarf2Handler() { }
+
+  virtual ~Dwarf2Handler() { }
+
+  // Start to process a compilation unit at OFFSET from the beginning of the
+  // .debug_info section. Return false if you would like to skip this
+  // compilation unit.
+  virtual bool StartCompilationUnit(uint64_t offset, uint8_t address_size,
+                                    uint8_t offset_size, uint64_t cu_length,
+                                    uint8_t dwarf_version) { return false; }
+
+  // When processing a skeleton compilation unit, resulting from a split
+  // DWARF compilation, once the skeleton debug info has been read,
+  // the reader will call this function to ask the client if it needs
+  // the full debug info from the .dwo or .dwp file.  Return true if
+  // you need it, or false to skip processing the split debug info.
+  virtual bool NeedSplitDebugInfo() { return true; }
+
+  // Start to process a split compilation unit at OFFSET from the beginning of
+  // the debug_info section in the .dwp/.dwo file.  Return false if you would
+  // like to skip this compilation unit.
+  virtual bool StartSplitCompilationUnit(uint64_t offset,
+                                         uint64_t cu_length) { return false; }
+
+  // Start to process a DIE at OFFSET from the beginning of the .debug_info
+  // section. Return false if you would like to skip this DIE.
+  virtual bool StartDIE(uint64_t offset, enum DwarfTag tag) { return false; }
+
+  // Called when we have an attribute with unsigned data to give to our
+  // handler. The attribute is for the DIE at OFFSET from the beginning of the
+  // .debug_info section. Its name is ATTR, its form is FORM, and its value is
+  // DATA.
+  virtual void ProcessAttributeUnsigned(uint64_t offset,
+                                        enum DwarfAttribute attr,
+                                        enum DwarfForm form,
+                                        uint64_t data) { }
+
+  // Called when we have an attribute with signed data to give to our handler.
+  // The attribute is for the DIE at OFFSET from the beginning of the
+  // .debug_info section. Its name is ATTR, its form is FORM, and its value is
+  // DATA.
+  virtual void ProcessAttributeSigned(uint64_t offset,
+                                      enum DwarfAttribute attr,
+                                      enum DwarfForm form,
+                                      int64_t data) { }
+
+  // Called when we have an attribute whose value is a reference to
+  // another DIE. The attribute belongs to the DIE at OFFSET from the
+  // beginning of the .debug_info section. Its name is ATTR, its form
+  // is FORM, and the offset of the DIE being referred to from the
+  // beginning of the .debug_info section is DATA.
+  virtual void ProcessAttributeReference(uint64_t offset,
+                                         enum DwarfAttribute attr,
+                                         enum DwarfForm form,
+                                         uint64_t data) { }
+
+  // Called when we have an attribute with a buffer of data to give to our
+  // handler. The attribute is for the DIE at OFFSET from the beginning of the
+  // .debug_info section. Its name is ATTR, its form is FORM, DATA points to
+  // the buffer's contents, and its length in bytes is LENGTH. The buffer is
+  // owned by the caller, not the callee, and may not persist for very long.
+  // If you want the data to be available later, it needs to be copied.
+  virtual void ProcessAttributeBuffer(uint64_t offset,
+                                      enum DwarfAttribute attr,
+                                      enum DwarfForm form,
+                                      const uint8_t* data,
+                                      uint64_t len) { }
+
+  // Called when we have an attribute with string data to give to our handler.
+  // The attribute is for the DIE at OFFSET from the beginning of the
+  // .debug_info section. Its name is ATTR, its form is FORM, and its value is
+  // DATA.
+  virtual void ProcessAttributeString(uint64_t offset,
+                                      enum DwarfAttribute attr,
+                                      enum DwarfForm form,
+                                      const string& data) { }
+
+  // Called when we have an attribute whose value is the 64-bit signature
+  // of a type unit in the .debug_types section. OFFSET is the offset of
+  // the DIE whose attribute we're reporting. ATTR and FORM are the
+  // attribute's name and form. SIGNATURE is the type unit's signature.
+  virtual void ProcessAttributeSignature(uint64_t offset,
+                                         enum DwarfAttribute attr,
+                                         enum DwarfForm form,
+                                         uint64_t signature) { }
+
+  // Called when finished processing the DIE at OFFSET.
+  // Because DWARF2/3 specifies a tree of DIEs, you may get starts
+  // before ends of the previous DIE, as we process children before
+  // ending the parent.
+  virtual void EndDIE(uint64_t offset) { }
+
 };
 
 // The base of DWARF2/3 debug info is a DIE (Debugging Information
@@ -221,12 +396,21 @@ class CompilationUnit {
   // Initialize a compilation unit.  This requires a map of sections,
   // the offset of this compilation unit in the .debug_info section, a
   // ByteReader, and a Dwarf2Handler class to call callbacks in.
-  CompilationUnit(const SectionMap& sections, uint64 offset,
-                  ByteReader* reader, Dwarf2Handler* handler);
+  CompilationUnit(const string& path, const SectionMap& sections,
+                  uint64_t offset, ByteReader* reader, Dwarf2Handler* handler);
   virtual ~CompilationUnit() {
     if (abbrevs_) delete abbrevs_;
   }
 
+  // Initialize a compilation unit from a .dwo or .dwp file.
+  // In this case, we need the .debug_addr section from the
+  // executable file that contains the corresponding skeleton
+  // compilation unit.  We also inherit the Dwarf2Handler from
+  // the executable file, and call it as if we were still
+  // processing the original compilation unit.
+  void SetSplitDwarf(const uint8_t* addr_buffer, uint64_t addr_buffer_length,
+                     uint64_t addr_base, uint64_t ranges_base, uint64_t dwo_id);
+
   // Begin reading a Dwarf2 compilation unit, and calling the
   // callbacks in the Dwarf2Handler
 
@@ -234,7 +418,7 @@ class CompilationUnit {
   // headers. This plus the starting offset passed to the constructor
   // is the offset of the end of the compilation unit --- and the
   // start of the next compilation unit, if there is one.
-  uint64 Start();
+  uint64_t Start();
 
  private:
 
@@ -242,7 +426,7 @@ class CompilationUnit {
   // The abbreviation tells how to read a DWARF2/3 DIE, and consist of a
   // tag and a list of attributes, as well as the data form of each attribute.
   struct Abbrev {
-    uint64 number;
+    uint64_t number;
     enum DwarfTag tag;
     bool has_children;
     AttributeList attributes;
@@ -252,10 +436,10 @@ class CompilationUnit {
   // in the actual file, as the one in the file may have a 32 bit or
   // 64 bit length.
   struct CompilationUnitHeader {
-    uint64 length;
-    uint16 version;
-    uint64 abbrev_offset;
-    uint8 address_size;
+    uint64_t length;
+    uint16_t version;
+    uint64_t abbrev_offset;
+    uint8_t address_size;
   } header_;
 
   // Reads the DWARF2/3 header for this compilation unit.
@@ -264,42 +448,152 @@ class CompilationUnit {
   // Reads the DWARF2/3 abbreviations for this compilation unit
   void ReadAbbrevs();
 
+  // Read the abbreviation offset for this compilation unit
+  size_t ReadAbbrevOffset(const uint8_t* headerptr);
+
+  // Read the address size for this compilation unit
+  size_t ReadAddressSize(const uint8_t* headerptr);
+
+  // Read the DWO id from a split or skeleton compilation unit header
+  size_t ReadDwoId(const uint8_t* headerptr);
+
+  // Read the type signature from a type or split type compilation unit header
+  size_t ReadTypeSignature(const uint8_t* headerptr);
+
+  // Read the DWO id from a split or skeleton compilation unit header
+  size_t ReadTypeOffset(const uint8_t* headerptr);
+
   // Processes a single DIE for this compilation unit and return a new
   // pointer just past the end of it
-  const char* ProcessDIE(uint64 dieoffset,
-                                  const char* start,
-                                  const Abbrev& abbrev);
+  const uint8_t* ProcessDIE(uint64_t dieoffset,
+                            const uint8_t* start,
+                            const Abbrev& abbrev);
 
   // Processes a single attribute and return a new pointer just past the
   // end of it
-  const char* ProcessAttribute(uint64 dieoffset,
-                                        const char* start,
-                                        enum DwarfAttribute attr,
-                                        enum DwarfForm form);
+  const uint8_t* ProcessAttribute(uint64_t dieoffset,
+                                  const uint8_t* start,
+                                  enum DwarfAttribute attr,
+                                  enum DwarfForm form);
+
+  // Called when we have an attribute with unsigned data to give to
+  // our handler.  The attribute is for the DIE at OFFSET from the
+  // beginning of compilation unit, has a name of ATTR, a form of
+  // FORM, and the actual data of the attribute is in DATA.
+  // If we see a DW_AT_GNU_dwo_id attribute, save the value so that
+  // we can find the debug info in a .dwo or .dwp file.
+  void ProcessAttributeUnsigned(uint64_t offset,
+                                enum DwarfAttribute attr,
+                                enum DwarfForm form,
+                                uint64_t data) {
+    if (attr == DW_AT_GNU_dwo_id) {
+      dwo_id_ = data;
+    }
+    else if (attr == DW_AT_GNU_addr_base) {
+      addr_base_ = data;
+    }
+    else if (attr == DW_AT_GNU_ranges_base) {
+      ranges_base_ = data;
+    }
+    // TODO(yunlian): When we add DW_AT_ranges_base from DWARF-5,
+    // that base will apply to DW_AT_ranges attributes in the
+    // skeleton CU as well as in the .dwo/.dwp files.
+    else if (attr == DW_AT_ranges && is_split_dwarf_) {
+      data += ranges_base_;
+    }
+    handler_->ProcessAttributeUnsigned(offset, attr, form, data);
+  }
+
+  // Called when we have an attribute with signed data to give to
+  // our handler.  The attribute is for the DIE at OFFSET from the
+  // beginning of compilation unit, has a name of ATTR, a form of
+  // FORM, and the actual data of the attribute is in DATA.
+  void ProcessAttributeSigned(uint64_t offset,
+                              enum DwarfAttribute attr,
+                              enum DwarfForm form,
+                              int64_t data) {
+    handler_->ProcessAttributeSigned(offset, attr, form, data);
+  }
+
+  // Called when we have an attribute with a buffer of data to give to
+  // our handler.  The attribute is for the DIE at OFFSET from the
+  // beginning of compilation unit, has a name of ATTR, a form of
+  // FORM, and the actual data of the attribute is in DATA, and the
+  // length of the buffer is LENGTH.
+  void ProcessAttributeBuffer(uint64_t offset,
+                              enum DwarfAttribute attr,
+                              enum DwarfForm form,
+                              const uint8_t* data,
+                              uint64_t len) {
+    handler_->ProcessAttributeBuffer(offset, attr, form, data, len);
+  }
+
+  // Handles the common parts of DW_FORM_GNU_str_index, DW_FORM_strx,
+  // DW_FORM_strx1, DW_FORM_strx2, DW_FORM_strx3, and DW_FORM_strx4.
+  // Retrieves the data and calls through to ProcessAttributeString.
+  void ProcessFormStringIndex(uint64_t offset,
+                              enum DwarfAttribute attr,
+                              enum DwarfForm form,
+                              uint64_t str_index);
+
+  // Called when we have an attribute with string data to give to
+  // our handler.  The attribute is for the DIE at OFFSET from the
+  // beginning of compilation unit, has a name of ATTR, a form of
+  // FORM, and the actual data of the attribute is in DATA.
+  // If we see a DW_AT_GNU_dwo_name attribute, save the value so
+  // that we can find the debug info in a .dwo or .dwp file.
+  void ProcessAttributeString(uint64_t offset,
+                              enum DwarfAttribute attr,
+                              enum DwarfForm form,
+                              const char* data) {
+    if (attr == DW_AT_GNU_dwo_name)
+      dwo_name_ = data;
+    handler_->ProcessAttributeString(offset, attr, form, data);
+  }
+
+  // Called to handle common portions of DW_FORM_addrx and variations, as well
+  // as DW_FORM_GNU_addr_index.
+  void ProcessAttributeAddrIndex(uint64_t offset,
+                                 enum DwarfAttribute attr,
+                                 enum DwarfForm form,
+                                 uint64_t addr_index) {
+    const uint8_t* addr_ptr =
+        addr_buffer_ + addr_base_ + addr_index * reader_->AddressSize();
+    ProcessAttributeUnsigned(
+        offset, attr, form, reader_->ReadAddress(addr_ptr));
+  }
 
   // Processes all DIEs for this compilation unit
   void ProcessDIEs();
 
   // Skips the die with attributes specified in ABBREV starting at
   // START, and return the new place to position the stream to.
-  const char* SkipDIE(const char* start,
-                               const Abbrev& abbrev);
+  const uint8_t* SkipDIE(const uint8_t* start, const Abbrev& abbrev);
 
   // Skips the attribute starting at START, with FORM, and return the
   // new place to position the stream to.
-  const char* SkipAttribute(const char* start,
-                                     enum DwarfForm form);
+  const uint8_t* SkipAttribute(const uint8_t* start, enum DwarfForm form);
+
+  // Process the actual debug information in a split DWARF file.
+  void ProcessSplitDwarf();
+
+  // Read the debug sections from a .dwo file.
+  void ReadDebugSectionsFromDwo(ElfReader* elf_reader,
+                                SectionMap* sections);
+
+  // Path of the file containing the debug information.
+  const string path_;
 
   // Offset from section start is the offset of this compilation unit
   // from the beginning of the .debug_info section.
-  uint64 offset_from_section_start_;
+  uint64_t offset_from_section_start_;
 
   // buffer is the buffer for our CU, starting at .debug_info + offset
   // passed in from constructor.
   // after_header points to right after the compilation unit header.
-  const char* buffer_;
-  uint64 buffer_length_;
-  const char* after_header_;
+  const uint8_t* buffer_;
+  uint64_t buffer_length_;
+  const uint8_t* after_header_;
 
   // The associated ByteReader that handles endianness issues for us
   ByteReader* reader_;
@@ -318,96 +612,153 @@ class CompilationUnit {
   // String section buffer and length, if we have a string section.
   // This is here to avoid doing a section lookup for strings in
   // ProcessAttribute, which is in the hot path for DWARF2 reading.
-  const char* string_buffer_;
-  uint64 string_buffer_length_;
-};
+  const uint8_t* string_buffer_;
+  uint64_t string_buffer_length_;
 
-// This class is the main interface between the reader and the
-// client.  The virtual functions inside this get called for
-// interesting events that happen during DWARF2 reading.
-// The default implementation skips everything.
+  // Similarly for .debug_line_string.
+  const uint8_t* line_string_buffer_;
+  uint64_t line_string_buffer_length_;
 
-class Dwarf2Handler {
+  // String offsets section buffer and length, if we have a string offsets
+  // section (.debug_str_offsets or .debug_str_offsets.dwo).
+  const uint8_t* str_offsets_buffer_;
+  uint64_t str_offsets_buffer_length_;
+
+  // Address section buffer and length, if we have an address section
+  // (.debug_addr).
+  const uint8_t* addr_buffer_;
+  uint64_t addr_buffer_length_;
+
+  // Flag indicating whether this compilation unit is part of a .dwo
+  // or .dwp file.  If true, we are reading this unit because a
+  // skeleton compilation unit in an executable file had a
+  // DW_AT_GNU_dwo_name or DW_AT_GNU_dwo_id attribute.
+  // In a .dwo file, we expect the string offsets section to
+  // have a ".dwo" suffix, and we will use the ".debug_addr" section
+  // associated with the skeleton compilation unit.
+  bool is_split_dwarf_;
+
+  // The value of the DW_AT_GNU_dwo_id attribute, if any.
+  uint64_t dwo_id_;
+
+  // The value of the DW_AT_GNU_type_signature attribute, if any.
+  uint64_t type_signature_;
+
+  // The value of the DW_AT_GNU_type_offset attribute, if any.
+  size_t type_offset_;
+
+  // The value of the DW_AT_GNU_dwo_name attribute, if any.
+  const char* dwo_name_;
+
+  // If this is a split DWARF CU, the value of the DW_AT_GNU_dwo_id attribute
+  // from the skeleton CU.
+  uint64_t skeleton_dwo_id_;
+
+  // The value of the DW_AT_GNU_ranges_base attribute, if any.
+  uint64_t ranges_base_;
+
+  // The value of the DW_AT_GNU_addr_base attribute, if any.
+  uint64_t addr_base_;
+
+  // True if we have already looked for a .dwp file.
+  bool have_checked_for_dwp_;
+
+  // Path to the .dwp file.
+  string dwp_path_;
+
+  // ByteReader for the DWP file.
+  std::unique_ptr<ByteReader> dwp_byte_reader_;
+
+  // DWP reader.
+   std::unique_ptr<DwpReader> dwp_reader_;
+};
+
+// A Reader for a .dwp file.  Supports the fetching of DWARF debug
+// info for a given dwo_id.
+//
+// There are two versions of .dwp files.  In both versions, the
+// .dwp file is an ELF file containing only debug sections.
+// In Version 1, the file contains many copies of each debug
+// section, one for each .dwo file that is packaged in the .dwp
+// file, and the .debug_cu_index section maps from the dwo_id
+// to a set of section indexes.  In Version 2, the file contains
+// one of each debug section, and the .debug_cu_index section
+// maps from the dwo_id to a set of offsets and lengths that
+// identify each .dwo file's contribution to the larger sections.
+
+class DwpReader {
  public:
-  Dwarf2Handler() { }
+  DwpReader(const ByteReader& byte_reader, ElfReader* elf_reader);
 
-  virtual ~Dwarf2Handler() { }
+  ~DwpReader();
 
-  // Start to process a compilation unit at OFFSET from the beginning of the
-  // .debug_info section. Return false if you would like to skip this
-  // compilation unit.
-  virtual bool StartCompilationUnit(uint64 offset, uint8 address_size,
-                                    uint8 offset_size, uint64 cu_length,
-                                    uint8 dwarf_version) { return false; }
+  // Read the CU index and initialize data members.
+  void Initialize();
 
-  // Start to process a DIE at OFFSET from the beginning of the .debug_info
-  // section. Return false if you would like to skip this DIE.
-  virtual bool StartDIE(uint64 offset, enum DwarfTag tag) { return false; }
+  // Read the debug sections for the given dwo_id.
+  void ReadDebugSectionsForCU(uint64_t dwo_id, SectionMap* sections);
 
-  // Called when we have an attribute with unsigned data to give to our
-  // handler. The attribute is for the DIE at OFFSET from the beginning of the
-  // .debug_info section. Its name is ATTR, its form is FORM, and its value is
-  // DATA.
-  virtual void ProcessAttributeUnsigned(uint64 offset,
-                                        enum DwarfAttribute attr,
-                                        enum DwarfForm form,
-                                        uint64 data) { }
+ private:
+  // Search a v1 hash table for "dwo_id".  Returns the slot index
+  // where the dwo_id was found, or -1 if it was not found.
+  int LookupCU(uint64_t dwo_id);
 
-  // Called when we have an attribute with signed data to give to our handler.
-  // The attribute is for the DIE at OFFSET from the beginning of the
-  // .debug_info section. Its name is ATTR, its form is FORM, and its value is
-  // DATA.
-  virtual void ProcessAttributeSigned(uint64 offset,
-                                      enum DwarfAttribute attr,
-                                      enum DwarfForm form,
-                                      int64 data) { }
+  // Search a v2 hash table for "dwo_id".  Returns the row index
+  // in the offsets and sizes tables, or 0 if it was not found.
+  uint32_t LookupCUv2(uint64_t dwo_id);
 
-  // Called when we have an attribute whose value is a reference to
-  // another DIE. The attribute belongs to the DIE at OFFSET from the
-  // beginning of the .debug_info section. Its name is ATTR, its form
-  // is FORM, and the offset of the DIE being referred to from the
-  // beginning of the .debug_info section is DATA.
-  virtual void ProcessAttributeReference(uint64 offset,
-                                         enum DwarfAttribute attr,
-                                         enum DwarfForm form,
-                                         uint64 data) { }
+  // The ELF reader for the .dwp file.
+  ElfReader* elf_reader_;
 
-  // Called when we have an attribute with a buffer of data to give to our
-  // handler. The attribute is for the DIE at OFFSET from the beginning of the
-  // .debug_info section. Its name is ATTR, its form is FORM, DATA points to
-  // the buffer's contents, and its length in bytes is LENGTH. The buffer is
-  // owned by the caller, not the callee, and may not persist for very long.
-  // If you want the data to be available later, it needs to be copied.
-  virtual void ProcessAttributeBuffer(uint64 offset,
-                                      enum DwarfAttribute attr,
-                                      enum DwarfForm form,
-                                      const char* data,
-                                      uint64 len) { }
+  // The ByteReader for the .dwp file.
+  const ByteReader& byte_reader_;
 
-  // Called when we have an attribute with string data to give to our handler.
-  // The attribute is for the DIE at OFFSET from the beginning of the
-  // .debug_info section. Its name is ATTR, its form is FORM, and its value is
-  // DATA.
-  virtual void ProcessAttributeString(uint64 offset,
-                                      enum DwarfAttribute attr,
-                                      enum DwarfForm form,
-                                      const string& data) { }
+  // Pointer to the .debug_cu_index section.
+  const char* cu_index_;
 
-  // Called when we have an attribute whose value is the 64-bit signature
-  // of a type unit in the .debug_types section. OFFSET is the offset of
-  // the DIE whose attribute we're reporting. ATTR and FORM are the
-  // attribute's name and form. SIGNATURE is the type unit's signature.
-  virtual void ProcessAttributeSignature(uint64 offset,
-                                         enum DwarfAttribute attr,
-                                         enum DwarfForm form,
-                                         uint64 signature) { }
+  // Size of the .debug_cu_index section.
+  size_t cu_index_size_;
 
-  // Called when finished processing the DIE at OFFSET.
-  // Because DWARF2/3 specifies a tree of DIEs, you may get starts
-  // before ends of the previous DIE, as we process children before
-  // ending the parent.
-  virtual void EndDIE(uint64 offset) { }
+  // Pointer to the .debug_str.dwo section.
+  const char* string_buffer_;
+
+  // Size of the .debug_str.dwo section.
+  size_t string_buffer_size_;
+
+  // Version of the .dwp file.  We support versions 1 and 2 currently.
+  int version_;
 
+  // Number of columns in the section tables (version 2).
+  unsigned int ncolumns_;
+
+  // Number of units in the section tables (version 2).
+  unsigned int nunits_;
+
+  // Number of slots in the hash table.
+  unsigned int nslots_;
+
+  // Pointer to the beginning of the hash table.
+  const char* phash_;
+
+  // Pointer to the beginning of the index table.
+  const char* pindex_;
+
+  // Pointer to the beginning of the section index pool (version 1).
+  const char* shndx_pool_;
+
+  // Pointer to the beginning of the section offset table (version 2).
+  const char* offset_table_;
+
+  // Pointer to the beginning of the section size table (version 2).
+  const char* size_table_;
+
+  // Contents of the sections of interest (version 2).
+  const char* abbrev_data_;
+  size_t abbrev_size_;
+  const char* info_data_;
+  size_t info_size_;
+  const char* str_offsets_data_;
+  size_t str_offsets_size_;
 };
 
 // This class is a reader for DWARF's Call Frame Information.  CFI
@@ -637,8 +988,8 @@ class CallFrameInfo {
   // The mechanics of C++ exception handling, personality routines,
   // and language-specific data areas are described here, rather nicely:
   // http://www.codesourcery.com/public/cxx-abi/abi-eh.html
-  CallFrameInfo(const char *buffer, size_t buffer_length,
-                ByteReader *reader, Handler *handler, Reporter *reporter,
+  CallFrameInfo(const uint8_t* buffer, size_t buffer_length,
+                ByteReader* reader, Handler* handler, Reporter* reporter,
                 bool eh_frame = false)
       : buffer_(buffer), buffer_length_(buffer_length),
         reader_(reader), handler_(handler), reporter_(reporter),
@@ -652,7 +1003,7 @@ class CallFrameInfo {
   bool Start();
 
   // Return the textual name of KIND. For error reporting.
-  static const char *KindName(EntryKind kind);
+  static const char* KindName(EntryKind kind);
 
  private:
 
@@ -665,7 +1016,7 @@ class CallFrameInfo {
     size_t offset;
 
     // The start of this entry in the buffer.
-    const char *start;
+    const uint8_t* start;
     
     // Which kind of entry this is.
     //
@@ -676,31 +1027,31 @@ class CallFrameInfo {
 
     // The end of this entry's common prologue (initial length and id), and
     // the start of this entry's kind-specific fields.
-    const char *fields;
+    const uint8_t* fields;
 
     // The start of this entry's instructions.
-    const char *instructions;
+    const uint8_t* instructions;
 
     // The address past the entry's last byte in the buffer. (Note that
     // since offset points to the entry's initial length field, and the
     // length field is the number of bytes after that field, this is not
     // simply buffer_ + offset + length.)
-    const char *end;
+    const uint8_t* end;
 
     // For both DWARF CFI and .eh_frame sections, this is the CIE id in a
     // CIE, and the offset of the associated CIE in an FDE.
-    uint64 id;
+    uint64_t id;
 
     // The CIE that applies to this entry, if we've parsed it. If this is a
     // CIE, then this field points to this structure.
-    CIE *cie;
+    CIE* cie;
   };
 
   // A common information entry (CIE).
   struct CIE: public Entry {
-    uint8 version;                      // CFI data version number
+    uint8_t version;                      // CFI data version number
     string augmentation;                // vendor format extension markers
-    uint64 code_alignment_factor;       // scale for code address adjustments 
+    uint64_t code_alignment_factor;       // scale for code address adjustments 
     int data_alignment_factor;          // scale for stack pointer adjustments
     unsigned return_address_register;   // which register holds the return addr
 
@@ -724,24 +1075,29 @@ class CallFrameInfo {
     // If has_z_personality is true, this is the address of the personality
     // routine --- or, if personality_encoding & DW_EH_PE_indirect, the
     // address where the personality routine's address is stored.
-    uint64 personality_address;
+    uint64_t personality_address;
 
     // This is the encoding used for addresses in the FDE header and
     // in DW_CFA_set_loc instructions. This is always valid, whether
     // or not we saw a 'z' augmentation string; its default value is
     // DW_EH_PE_absptr, which is what normal DWARF CFI uses.
     DwarfPointerEncoding pointer_encoding;
+
+    // These were only introduced in DWARF4, so will not be set in older
+    // versions.
+    uint8_t address_size;
+    uint8_t segment_size;
   };
 
   // A frame description entry (FDE).
   struct FDE: public Entry {
-    uint64 address;                     // start address of described code
-    uint64 size;                        // size of described code, in bytes
+    uint64_t address;                     // start address of described code
+    uint64_t size;                        // size of described code, in bytes
 
     // If cie->has_z_lsda is true, then this is the language-specific data
     // area's address --- or its address's address, if cie->lsda_encoding
     // has the DW_EH_PE_indirect bit set.
-    uint64 lsda_address;
+    uint64_t lsda_address;
   };
 
   // Internal use.
@@ -762,14 +1118,14 @@ class CallFrameInfo {
   // true. On failure, report the problem, and return false. Even if we
   // return false, set ENTRY->end to the first byte after the entry if we
   // were able to figure that out, or NULL if we weren't.
-  bool ReadEntryPrologue(const char *cursor, Entry *entry);
+  bool ReadEntryPrologue(const uint8_t* cursor, Entry* entry);
 
   // Parse the fields of a CIE after the entry prologue, including any 'z'
   // augmentation data. Assume that the 'Entry' fields of CIE are
   // populated; use CIE->fields and CIE->end as the start and limit for
   // parsing. On success, populate the rest of *CIE, and return true; on
   // failure, report the problem and return false.
-  bool ReadCIEFields(CIE *cie);
+  bool ReadCIEFields(CIE* cie);
 
   // Parse the fields of an FDE after the entry prologue, including any 'z'
   // augmentation data. Assume that the 'Entry' fields of *FDE are
@@ -777,12 +1133,12 @@ class CallFrameInfo {
   // parsing. Assume that FDE->cie is fully initialized. On success,
   // populate the rest of *FDE, and return true; on failure, report the
   // problem and return false.
-  bool ReadFDEFields(FDE *fde);
+  bool ReadFDEFields(FDE* fde);
 
   // Report that ENTRY is incomplete, and return false. This is just a
   // trivial wrapper for invoking reporter_->Incomplete; it provides a
   // little brevity.
-  bool ReportIncomplete(Entry *entry);
+  bool ReportIncomplete(Entry* entry);
 
   // Return true if ENCODING has the DW_EH_PE_indirect bit set.
   static bool IsIndirectEncoding(DwarfPointerEncoding encoding) {
@@ -790,17 +1146,17 @@ class CallFrameInfo {
   }
 
   // The contents of the DWARF .debug_info section we're parsing.
-  const char *buffer_;
+  const uint8_t* buffer_;
   size_t buffer_length_;
 
   // For reading multi-byte values with the appropriate endianness.
-  ByteReader *reader_;
+  ByteReader* reader_;
 
   // The handler to which we should report the data we find.
-  Handler *handler_;
+  Handler* handler_;
 
   // For reporting problems in the info we're parsing.
-  Reporter *reporter_;
+  Reporter* reporter_;
 
   // True if we are processing .eh_frame-format data.
   bool eh_frame_;
@@ -832,8 +1188,8 @@ class CallFrameInfo::Handler {
   // to the handler explicitly; instead, if the handler elects to
   // process a given FDE, the parser reiterates the appropriate CIE's
   // contents at the beginning of the FDE's rules.
-  virtual bool Entry(size_t offset, uint64 address, uint64 length,
-                     uint8 version, const string &augmentation,
+  virtual bool Entry(size_t offset, uint64_t address, uint64_t length,
+                     uint8_t version, const string& augmentation,
                      unsigned return_address) = 0;
 
   // When the Entry function returns true, the parser calls these
@@ -855,21 +1211,21 @@ class CallFrameInfo::Handler {
   // computation. All other REG values will be positive.
 
   // At ADDRESS, register REG's value is not recoverable.
-  virtual bool UndefinedRule(uint64 address, int reg) = 0;
+  virtual bool UndefinedRule(uint64_t address, int reg) = 0;
 
   // At ADDRESS, register REG's value is the same as that it had in
   // the caller.
-  virtual bool SameValueRule(uint64 address, int reg) = 0;
+  virtual bool SameValueRule(uint64_t address, int reg) = 0;
 
   // At ADDRESS, register REG has been saved at offset OFFSET from
   // BASE_REGISTER.
-  virtual bool OffsetRule(uint64 address, int reg,
+  virtual bool OffsetRule(uint64_t address, int reg,
                           int base_register, long offset) = 0;
 
   // At ADDRESS, the caller's value of register REG is the current
   // value of BASE_REGISTER plus OFFSET. (This rule doesn't provide an
   // address at which the register's value is saved.)
-  virtual bool ValOffsetRule(uint64 address, int reg,
+  virtual bool ValOffsetRule(uint64_t address, int reg,
                              int base_register, long offset) = 0;
 
   // At ADDRESS, register REG has been saved in BASE_REGISTER. This differs
@@ -877,18 +1233,18 @@ class CallFrameInfo::Handler {
   // BASE_REGISTER is the "home" for REG's saved value: if you want to
   // assign to a variable whose home is REG in the calling frame, you
   // should put the value in BASE_REGISTER.
-  virtual bool RegisterRule(uint64 address, int reg, int base_register) = 0;
+  virtual bool RegisterRule(uint64_t address, int reg, int base_register) = 0;
 
   // At ADDRESS, the DWARF expression EXPRESSION yields the address at
   // which REG was saved.
-  virtual bool ExpressionRule(uint64 address, int reg,
-                              const string &expression) = 0;
+  virtual bool ExpressionRule(uint64_t address, int reg,
+                              const string& expression) = 0;
 
   // At ADDRESS, the DWARF expression EXPRESSION yields the caller's
   // value for REG. (This rule doesn't provide an address at which the
   // register's value is saved.)
-  virtual bool ValExpressionRule(uint64 address, int reg,
-                                 const string &expression) = 0;
+  virtual bool ValExpressionRule(uint64_t address, int reg,
+                                 const string& expression) = 0;
 
   // Indicate that the rules for the address range reported by the
   // last call to Entry are complete.  End should return true if
@@ -928,7 +1284,7 @@ class CallFrameInfo::Handler {
   // which the routine's address is stored. The default definition for
   // this handler function simply returns true, allowing parsing of
   // the entry to continue.
-  virtual bool PersonalityRoutine(uint64 address, bool indirect) {
+  virtual bool PersonalityRoutine(uint64_t address, bool indirect) {
     return true;
   }
 
@@ -937,7 +1293,7 @@ class CallFrameInfo::Handler {
   // which the area's address is stored. The default definition for
   // this handler function simply returns true, allowing parsing of
   // the entry to continue.
-  virtual bool LanguageSpecificDataArea(uint64 address, bool indirect) {
+  virtual bool LanguageSpecificDataArea(uint64_t address, bool indirect) {
     return true;
   }
 
@@ -965,77 +1321,85 @@ class CallFrameInfo::Reporter {
   // in a Mach-O section named __debug_frame. If we support
   // Linux-style exception handling data, we could be reading an
   // .eh_frame section.
-  Reporter(const string &filename,
-           const string &section = ".debug_frame")
+  Reporter(const string& filename,
+           const string& section = ".debug_frame")
       : filename_(filename), section_(section) { }
   virtual ~Reporter() { }
 
   // The CFI entry at OFFSET ends too early to be well-formed. KIND
   // indicates what kind of entry it is; KIND can be kUnknown if we
   // haven't parsed enough of the entry to tell yet.
-  virtual void Incomplete(uint64 offset, CallFrameInfo::EntryKind kind);
+  virtual void Incomplete(uint64_t offset, CallFrameInfo::EntryKind kind);
 
   // The .eh_frame data has a four-byte zero at OFFSET where the next
   // entry's length would be; this is a terminator. However, the buffer
   // length as given to the CallFrameInfo constructor says there should be
   // more data.
-  virtual void EarlyEHTerminator(uint64 offset);
+  virtual void EarlyEHTerminator(uint64_t offset);
 
   // The FDE at OFFSET refers to the CIE at CIE_OFFSET, but the
   // section is not that large.
-  virtual void CIEPointerOutOfRange(uint64 offset, uint64 cie_offset);
+  virtual void CIEPointerOutOfRange(uint64_t offset, uint64_t cie_offset);
 
   // The FDE at OFFSET refers to the CIE at CIE_OFFSET, but the entry
   // there is not a CIE.
-  virtual void BadCIEId(uint64 offset, uint64 cie_offset);
+  virtual void BadCIEId(uint64_t offset, uint64_t cie_offset);
+
+  // The FDE at OFFSET refers to a CIE with an address size we don't know how
+  // to handle.
+  virtual void UnexpectedAddressSize(uint64_t offset, uint8_t address_size);
+
+  // The FDE at OFFSET refers to a CIE with an segment descriptor size we
+  // don't know how to handle.
+  virtual void UnexpectedSegmentSize(uint64_t offset, uint8_t segment_size);
 
   // The FDE at OFFSET refers to a CIE with version number VERSION,
   // which we don't recognize. We cannot parse DWARF CFI if it uses
   // a version number we don't recognize.
-  virtual void UnrecognizedVersion(uint64 offset, int version);
+  virtual void UnrecognizedVersion(uint64_t offset, int version);
 
   // The FDE at OFFSET refers to a CIE with augmentation AUGMENTATION,
   // which we don't recognize. We cannot parse DWARF CFI if it uses
   // augmentations we don't recognize.
-  virtual void UnrecognizedAugmentation(uint64 offset,
-                                        const string &augmentation);
+  virtual void UnrecognizedAugmentation(uint64_t offset,
+                                        const string& augmentation);
 
   // The pointer encoding ENCODING, specified by the CIE at OFFSET, is not
   // a valid encoding.
-  virtual void InvalidPointerEncoding(uint64 offset, uint8 encoding);
+  virtual void InvalidPointerEncoding(uint64_t offset, uint8_t encoding);
 
   // The pointer encoding ENCODING, specified by the CIE at OFFSET, depends
   // on a base address which has not been supplied.
-  virtual void UnusablePointerEncoding(uint64 offset, uint8 encoding);
+  virtual void UnusablePointerEncoding(uint64_t offset, uint8_t encoding);
 
   // The CIE at OFFSET contains a DW_CFA_restore instruction at
   // INSN_OFFSET, which may not appear in a CIE.
-  virtual void RestoreInCIE(uint64 offset, uint64 insn_offset);
+  virtual void RestoreInCIE(uint64_t offset, uint64_t insn_offset);
 
   // The entry at OFFSET, of kind KIND, has an unrecognized
   // instruction at INSN_OFFSET.
-  virtual void BadInstruction(uint64 offset, CallFrameInfo::EntryKind kind,
-                              uint64 insn_offset);
+  virtual void BadInstruction(uint64_t offset, CallFrameInfo::EntryKind kind,
+                              uint64_t insn_offset);
 
   // The instruction at INSN_OFFSET in the entry at OFFSET, of kind
   // KIND, establishes a rule that cites the CFA, but we have not
   // established a CFA rule yet.
-  virtual void NoCFARule(uint64 offset, CallFrameInfo::EntryKind kind, 
-                         uint64 insn_offset);
+  virtual void NoCFARule(uint64_t offset, CallFrameInfo::EntryKind kind, 
+                         uint64_t insn_offset);
 
   // The instruction at INSN_OFFSET in the entry at OFFSET, of kind
   // KIND, is a DW_CFA_restore_state instruction, but the stack of
   // saved states is empty.
-  virtual void EmptyStateStack(uint64 offset, CallFrameInfo::EntryKind kind, 
-                               uint64 insn_offset);
+  virtual void EmptyStateStack(uint64_t offset, CallFrameInfo::EntryKind kind, 
+                               uint64_t insn_offset);
 
   // The DW_CFA_remember_state instruction at INSN_OFFSET in the entry
   // at OFFSET, of kind KIND, would restore a state that has no CFA
   // rule, whereas the current state does have a CFA rule. This is
   // bogus input, which the CallFrameInfo::Handler interface doesn't
   // (and shouldn't) have any way to report.
-  virtual void ClearingCFARule(uint64 offset, CallFrameInfo::EntryKind kind, 
-                               uint64 insn_offset);
+  virtual void ClearingCFARule(uint64_t offset, CallFrameInfo::EntryKind kind, 
+                               uint64_t insn_offset);
 
  protected:
   // The name of the file whose CFI we're reading.
diff --git a/src/MEGASync/google_breakpad/common/dwarf/dwarf2reader_cfi_unittest.cc b/src/MEGASync/google_breakpad/common/dwarf/dwarf2reader_cfi_unittest.cc
index 66c6198b..8e5d68b4 100644
--- a/src/MEGASync/google_breakpad/common/dwarf/dwarf2reader_cfi_unittest.cc
+++ b/src/MEGASync/google_breakpad/common/dwarf/dwarf2reader_cfi_unittest.cc
@@ -31,6 +31,7 @@
 
 // dwarf2reader_cfi_unittest.cc: Unit tests for dwarf2reader::CallFrameInfo
 
+#include <stdint.h>
 #include <stdlib.h>
 
 #include <string>
@@ -86,7 +87,7 @@ using testing::_;
 
 #ifdef WRITE_ELF
 void WriteELFFrameSection(const char *filename, const char *section_name,
-                          const CFISection &section);
+                          const CFISection& section);
 #define PERHAPS_WRITE_DEBUG_FRAME_FILE(name, section)                   \
     WriteELFFrameSection("cfitest-" name, ".debug_frame", section);
 #define PERHAPS_WRITE_EH_FRAME_FILE(name, section)                      \
@@ -98,41 +99,45 @@ void WriteELFFrameSection(const char *filename, const char *section_name,
 
 class MockCallFrameInfoHandler: public CallFrameInfo::Handler {
  public:
-  MOCK_METHOD6(Entry, bool(size_t offset, uint64 address, uint64 length,
-                           uint8 version, const string &augmentation,
+  MOCK_METHOD6(Entry, bool(size_t offset, uint64_t address, uint64_t length,
+                           uint8_t version, const string& augmentation,
                            unsigned return_address));
-  MOCK_METHOD2(UndefinedRule, bool(uint64 address, int reg));
-  MOCK_METHOD2(SameValueRule, bool(uint64 address, int reg));
-  MOCK_METHOD4(OffsetRule, bool(uint64 address, int reg, int base_register,
+  MOCK_METHOD2(UndefinedRule, bool(uint64_t address, int reg));
+  MOCK_METHOD2(SameValueRule, bool(uint64_t address, int reg));
+  MOCK_METHOD4(OffsetRule, bool(uint64_t address, int reg, int base_register,
                                 long offset));
-  MOCK_METHOD4(ValOffsetRule, bool(uint64 address, int reg, int base_register,
+  MOCK_METHOD4(ValOffsetRule, bool(uint64_t address, int reg, int base_register,
                                    long offset));
-  MOCK_METHOD3(RegisterRule, bool(uint64 address, int reg, int base_register));
-  MOCK_METHOD3(ExpressionRule, bool(uint64 address, int reg,
-                                    const string &expression));
-  MOCK_METHOD3(ValExpressionRule, bool(uint64 address, int reg,
-                                       const string &expression));
+  MOCK_METHOD3(RegisterRule, bool(uint64_t address, int reg, int base_register));
+  MOCK_METHOD3(ExpressionRule, bool(uint64_t address, int reg,
+                                    const string& expression));
+  MOCK_METHOD3(ValExpressionRule, bool(uint64_t address, int reg,
+                                       const string& expression));
   MOCK_METHOD0(End, bool());
-  MOCK_METHOD2(PersonalityRoutine, bool(uint64 address, bool indirect));
-  MOCK_METHOD2(LanguageSpecificDataArea, bool(uint64 address, bool indirect));
+  MOCK_METHOD2(PersonalityRoutine, bool(uint64_t address, bool indirect));
+  MOCK_METHOD2(LanguageSpecificDataArea, bool(uint64_t address, bool indirect));
   MOCK_METHOD0(SignalHandler, bool());
 };
 
 class MockCallFrameErrorReporter: public CallFrameInfo::Reporter {
  public:
   MockCallFrameErrorReporter() : Reporter("mock filename", "mock section") { }
-  MOCK_METHOD2(Incomplete, void(uint64, CallFrameInfo::EntryKind));
-  MOCK_METHOD1(EarlyEHTerminator, void(uint64));
-  MOCK_METHOD2(CIEPointerOutOfRange, void(uint64, uint64));
-  MOCK_METHOD2(BadCIEId, void(uint64, uint64));
-  MOCK_METHOD2(UnrecognizedVersion, void(uint64, int version));
-  MOCK_METHOD2(UnrecognizedAugmentation, void(uint64, const string &));
-  MOCK_METHOD2(InvalidPointerEncoding, void(uint64, uint8));
-  MOCK_METHOD2(UnusablePointerEncoding, void(uint64, uint8));
-  MOCK_METHOD2(RestoreInCIE, void(uint64, uint64));
-  MOCK_METHOD3(BadInstruction, void(uint64, CallFrameInfo::EntryKind, uint64));
-  MOCK_METHOD3(NoCFARule, void(uint64, CallFrameInfo::EntryKind, uint64));
-  MOCK_METHOD3(EmptyStateStack, void(uint64, CallFrameInfo::EntryKind, uint64));
+  MOCK_METHOD2(Incomplete, void(uint64_t, CallFrameInfo::EntryKind));
+  MOCK_METHOD1(EarlyEHTerminator, void(uint64_t));
+  MOCK_METHOD2(CIEPointerOutOfRange, void(uint64_t, uint64_t));
+  MOCK_METHOD2(BadCIEId, void(uint64_t, uint64_t));
+  MOCK_METHOD2(UnexpectedAddressSize, void(uint64_t, uint8_t));
+  MOCK_METHOD2(UnexpectedSegmentSize, void(uint64_t, uint8_t));
+  MOCK_METHOD2(UnrecognizedVersion, void(uint64_t, int version));
+  MOCK_METHOD2(UnrecognizedAugmentation, void(uint64_t, const string&));
+  MOCK_METHOD2(InvalidPointerEncoding, void(uint64_t, uint8_t));
+  MOCK_METHOD2(UnusablePointerEncoding, void(uint64_t, uint8_t));
+  MOCK_METHOD2(RestoreInCIE, void(uint64_t, uint64_t));
+  MOCK_METHOD3(BadInstruction, void(uint64_t, CallFrameInfo::EntryKind,
+                                    uint64_t));
+  MOCK_METHOD3(NoCFARule, void(uint64_t, CallFrameInfo::EntryKind, uint64_t));
+  MOCK_METHOD3(EmptyStateStack, void(uint64_t, CallFrameInfo::EntryKind,
+                                     uint64_t));
 };
 
 struct CFIFixture {
@@ -186,7 +191,7 @@ class CFI: public CFIFixture, public Test { };
 TEST_F(CFI, EmptyRegion) {
   EXPECT_CALL(handler, Entry(_, _, _, _, _, _)).Times(0);
   EXPECT_CALL(handler, End()).Times(0);
-  static const char data[1] = { 42 };
+  static const uint8_t data[] = { 42 };
 
   ByteReader byte_reader(ENDIANNESS_BIG);
   CallFrameInfo parser(data, 0, &byte_reader, &handler, &reporter);
@@ -213,7 +218,8 @@ TEST_F(CFI, IncompleteLength32) {
 
   ByteReader byte_reader(ENDIANNESS_BIG);
   byte_reader.SetAddressSize(8);
-  CallFrameInfo parser(contents.data(), contents.size() - 2,
+  CallFrameInfo parser(reinterpret_cast<const uint8_t*>(contents.data()),
+                       contents.size() - 2,
                        &byte_reader, &handler, &reporter);
   EXPECT_FALSE(parser.Start());
 }
@@ -238,7 +244,8 @@ TEST_F(CFI, IncompleteLength64) {
 
   ByteReader byte_reader(ENDIANNESS_LITTLE);
   byte_reader.SetAddressSize(4);
-  CallFrameInfo parser(contents.data(), contents.size() - 4,
+  CallFrameInfo parser(reinterpret_cast<const uint8_t*>(contents.data()),
+                       contents.size() - 4,
                        &byte_reader, &handler, &reporter);
   EXPECT_FALSE(parser.Start());
 }
@@ -262,7 +269,8 @@ TEST_F(CFI, IncompleteId32) {
 
   ByteReader byte_reader(ENDIANNESS_BIG);
   byte_reader.SetAddressSize(8);
-  CallFrameInfo parser(contents.data(), contents.size(),
+  CallFrameInfo parser(reinterpret_cast<const uint8_t*>(contents.data()),
+                       contents.size(),
                        &byte_reader, &handler, &reporter);
   EXPECT_FALSE(parser.Start());
 }
@@ -288,7 +296,8 @@ TEST_F(CFI, BadId32) {
 
   ByteReader byte_reader(ENDIANNESS_BIG);
   byte_reader.SetAddressSize(8);
-  CallFrameInfo parser(contents.data(), contents.size(),
+  CallFrameInfo parser(reinterpret_cast<const uint8_t*>(contents.data()),
+                       contents.size(),
                        &byte_reader, &handler, &reporter);
   EXPECT_FALSE(parser.Start());
 }
@@ -309,7 +318,8 @@ TEST_F(CFI, SingleCIE) {
   EXPECT_TRUE(section.GetContents(&contents));
   ByteReader byte_reader(ENDIANNESS_LITTLE);
   byte_reader.SetAddressSize(4);
-  CallFrameInfo parser(contents.data(), contents.size(),
+  CallFrameInfo parser(reinterpret_cast<const uint8_t*>(contents.data()),
+                       contents.size(),
                        &byte_reader, &handler, &reporter);
   EXPECT_TRUE(parser.Start());
 }
@@ -339,7 +349,8 @@ TEST_F(CFI, OneFDE) {
   EXPECT_TRUE(section.GetContents(&contents));
   ByteReader byte_reader(ENDIANNESS_BIG);
   byte_reader.SetAddressSize(4);
-  CallFrameInfo parser(contents.data(), contents.size(),
+  CallFrameInfo parser(reinterpret_cast<const uint8_t*>(contents.data()),
+                       contents.size(),
                        &byte_reader, &handler, &reporter);
   EXPECT_TRUE(parser.Start());
 }
@@ -382,7 +393,8 @@ TEST_F(CFI, TwoFDEsOneCIE) {
   EXPECT_TRUE(section.GetContents(&contents));
   ByteReader byte_reader(ENDIANNESS_BIG);
   byte_reader.SetAddressSize(4);
-  CallFrameInfo parser(contents.data(), contents.size(),
+  CallFrameInfo parser(reinterpret_cast<const uint8_t*>(contents.data()),
+                       contents.size(),
                        &byte_reader, &handler, &reporter);
   EXPECT_TRUE(parser.Start());
 }
@@ -431,7 +443,8 @@ TEST_F(CFI, TwoFDEsTwoCIEs) {
   EXPECT_TRUE(section.GetContents(&contents));
   ByteReader byte_reader(ENDIANNESS_LITTLE);
   byte_reader.SetAddressSize(8);
-  CallFrameInfo parser(contents.data(), contents.size(),
+  CallFrameInfo parser(reinterpret_cast<const uint8_t*>(contents.data()),
+                       contents.size(),
                        &byte_reader, &handler, &reporter);
   EXPECT_TRUE(parser.Start());
 }
@@ -475,7 +488,8 @@ TEST_F(CFI, BadVersion) {
   EXPECT_TRUE(section.GetContents(&contents));
   ByteReader byte_reader(ENDIANNESS_BIG);
   byte_reader.SetAddressSize(4);
-  CallFrameInfo parser(contents.data(), contents.size(),
+  CallFrameInfo parser(reinterpret_cast<const uint8_t*>(contents.data()),
+                       contents.size(),
                        &byte_reader, &handler, &reporter);
   EXPECT_FALSE(parser.Start());
 }
@@ -519,7 +533,8 @@ TEST_F(CFI, BadAugmentation) {
   EXPECT_TRUE(section.GetContents(&contents));
   ByteReader byte_reader(ENDIANNESS_BIG);
   byte_reader.SetAddressSize(4);
-  CallFrameInfo parser(contents.data(), contents.size(),
+  CallFrameInfo parser(reinterpret_cast<const uint8_t*>(contents.data()),
+                       contents.size(),
                        &byte_reader, &handler, &reporter);
   EXPECT_FALSE(parser.Start());
 }
@@ -553,7 +568,8 @@ TEST_F(CFI, CIEVersion1ReturnColumn) {
   EXPECT_TRUE(section.GetContents(&contents));
   ByteReader byte_reader(ENDIANNESS_BIG);
   byte_reader.SetAddressSize(4);
-  CallFrameInfo parser(contents.data(), contents.size(),
+  CallFrameInfo parser(reinterpret_cast<const uint8_t*>(contents.data()),
+                       contents.size(),
                        &byte_reader, &handler, &reporter);
   EXPECT_TRUE(parser.Start());
 }
@@ -587,11 +603,124 @@ TEST_F(CFI, CIEVersion3ReturnColumn) {
   EXPECT_TRUE(section.GetContents(&contents));
   ByteReader byte_reader(ENDIANNESS_BIG);
   byte_reader.SetAddressSize(4);
-  CallFrameInfo parser(contents.data(), contents.size(),
+  CallFrameInfo parser(reinterpret_cast<const uint8_t*>(contents.data()),
+                       contents.size(),
                        &byte_reader, &handler, &reporter);
   EXPECT_TRUE(parser.Start());
 }
 
+TEST_F(CFI, CIEVersion4AdditionalFields) {
+  CFISection section(kBigEndian, 8);
+  Label cie;
+  section
+      .Mark(&cie)
+      // CIE version 4 with expected address (64bit) and segment size.
+      .CIEHeader(0x0ab4758d, 0xc010fdf7, 0x89, 4, "", true, 8, 0)
+      .FinishEntry()
+      // FDE, citing that CIE.
+      .FDEHeader(cie, 0x86763f2b, 0x2a66dc23)
+      .FinishEntry();
+
+  PERHAPS_WRITE_DEBUG_FRAME_FILE("CIEVersion3ReturnColumn", section);
+
+  {
+    InSequence s;
+    EXPECT_CALL(handler, Entry(_, 0x86763f2b, 0x2a66dc23, 4, "", 0x89))
+        .WillOnce(Return(true));
+    EXPECT_CALL(handler, End()).WillOnce(Return(true));
+  }
+
+  string contents;
+  EXPECT_TRUE(section.GetContents(&contents));
+  ByteReader byte_reader(ENDIANNESS_BIG);
+  CallFrameInfo parser(reinterpret_cast<const uint8_t*>(contents.data()),
+                       contents.size(),
+                       &byte_reader, &handler, &reporter);
+  EXPECT_TRUE(parser.Start());
+}
+
+TEST_F(CFI, CIEVersion4AdditionalFields32BitAddress) {
+  CFISection section(kBigEndian, 4);
+  Label cie;
+  section
+      .Mark(&cie)
+      // CIE version 4 with expected address (32bit) and segment size.
+      .CIEHeader(0x0ab4758d, 0xc010fdf7, 0x89, 4, "", true, 4, 0)
+      .FinishEntry()
+      // FDE, citing that CIE.
+      .FDEHeader(cie, 0x86763f2b, 0x2a66dc23)
+      .FinishEntry();
+
+  PERHAPS_WRITE_DEBUG_FRAME_FILE("CIEVersion3ReturnColumn", section);
+
+  {
+    InSequence s;
+    EXPECT_CALL(handler, Entry(_, 0x86763f2b, 0x2a66dc23, 4, "", 0x89))
+        .WillOnce(Return(true));
+    EXPECT_CALL(handler, End()).WillOnce(Return(true));
+  }
+
+  string contents;
+  EXPECT_TRUE(section.GetContents(&contents));
+  ByteReader byte_reader(ENDIANNESS_BIG);
+  CallFrameInfo parser(reinterpret_cast<const uint8_t*>(contents.data()),
+                       contents.size(),
+                       &byte_reader, &handler, &reporter);
+  EXPECT_TRUE(parser.Start());
+}
+
+TEST_F(CFI, CIEVersion4AdditionalFieldsUnexpectedAddressSize) {
+  CFISection section(kBigEndian, 4);
+  Label cie;
+
+  section
+      .Mark(&cie)
+      // Unexpected address size.
+      .CIEHeader(0x4be22f75, 0x2492236e, 0x6b6efb87, 4, "", true, 3, 0)
+      .FinishEntry()
+      // FDE, citing that CIE.
+      .FDEHeader(cie, 0x86763f2b, 0x2a66dc23)
+      .FinishEntry();
+
+  PERHAPS_WRITE_DEBUG_FRAME_FILE("AdditionalFieldsUnexpectedAddress", section);
+
+  EXPECT_CALL(reporter, UnexpectedAddressSize(_, 3))
+    .WillOnce(Return());
+
+  string contents;
+  EXPECT_TRUE(section.GetContents(&contents));
+  ByteReader byte_reader(ENDIANNESS_BIG);
+  CallFrameInfo parser(reinterpret_cast<const uint8_t*>(contents.data()),
+                       contents.size(),
+                       &byte_reader, &handler, &reporter);
+  EXPECT_FALSE(parser.Start());
+}
+
+TEST_F(CFI, CIEVersion4AdditionalFieldsUnexpectedSegmentSize) {
+  CFISection section(kBigEndian, 8);
+  Label cie;
+
+  section
+      .Mark(&cie)
+      .CIEHeader(0xf8bc4399, 0x8cf09931, 0xf2f519b2, 4, "", true, 8, 7)
+      .FinishEntry()
+      .FDEHeader(cie, 0x7bf0fda0, 0xcbcd28d8)
+      .FinishEntry();
+
+  PERHAPS_WRITE_DEBUG_FRAME_FILE("AdditionalFieldsUnexpectedSegment", section);
+
+  EXPECT_CALL(reporter, UnexpectedSegmentSize(_, 7))
+    .WillOnce(Return());
+
+  string contents;
+  EXPECT_TRUE(section.GetContents(&contents));
+  ByteReader byte_reader(ENDIANNESS_BIG);
+  CallFrameInfo parser(reinterpret_cast<const uint8_t*>(contents.data()),
+                       contents.size(),
+                       &byte_reader, &handler, &reporter);
+  EXPECT_FALSE(parser.Start());
+}
+
 struct CFIInsnFixture: public CFIFixture {
   CFIInsnFixture() : CFIFixture() {
     data_factor = 0xb6f;
@@ -668,7 +797,8 @@ struct CFIInsnFixture: public CFIFixture {
     }
     ByteReader byte_reader(endianness);
     byte_reader.SetAddressSize(section->AddressSize());
-    CallFrameInfo parser(contents.data(), contents.size(),
+    CallFrameInfo parser(reinterpret_cast<const uint8_t*>(contents.data()),
+                         contents.size(),
                          &byte_reader, &handler, &reporter);
     if (succeeds)
       EXPECT_TRUE(parser.Start());
@@ -678,13 +808,13 @@ struct CFIInsnFixture: public CFIFixture {
 
   Label cie_label;
   Sequence s;
-  uint64 code_factor;
+  uint64_t code_factor;
   int data_factor;
   unsigned return_register;
   unsigned version;
   unsigned cfa_base_register;
   int cfa_offset;
-  uint64 fde_start, fde_size;
+  uint64_t fde_start, fde_size;
 };
 
 class CFIInsn: public CFIInsnFixture, public Test { };
@@ -1320,7 +1450,7 @@ TEST_F(CFIInsn, DW_CFA_remember_and_restore_state) {
       .D8(dwarf2reader::DW_CFA_restore_state)
       .FinishEntry();
 
-  uint64 addr = fde_start;
+  uint64_t addr = fde_start;
 
   // Expect the incoming rules to be reported.
   EXPECT_CALL(handler, OffsetRule(addr, 2, kCFARegister, 0x9806 * data_factor))
@@ -1989,10 +2119,12 @@ struct EHFrameFixture: public CFIInsnFixture {
     }
     ByteReader byte_reader(endianness);
     byte_reader.SetAddressSize(section->AddressSize());
-    byte_reader.SetCFIDataBase(encoded_pointer_bases.cfi, contents.data());
+    byte_reader.SetCFIDataBase(encoded_pointer_bases.cfi,
+                               reinterpret_cast<const uint8_t*>(contents.data()));
     byte_reader.SetTextBase(encoded_pointer_bases.text);
     byte_reader.SetDataBase(encoded_pointer_bases.data);
-    CallFrameInfo parser(contents.data(), contents.size(),
+    CallFrameInfo parser(reinterpret_cast<const uint8_t*>(contents.data()),
+                         contents.size(),
                          &byte_reader, &handler, &reporter, true);
     if (succeeds)
       EXPECT_TRUE(parser.Start());
@@ -2336,7 +2468,7 @@ struct ELFSectionHeader {
   uint64_t entry_size;
 };
 
-void AppendSectionHeader(CFISection *table, const ELFSectionHeader &header) {
+void AppendSectionHeader(CFISection* table, const ELFSectionHeader& header) {
   (*table)
       .D32(header.name)                   // name, index in string tbl
       .D32(header.type)                   // type
@@ -2351,7 +2483,7 @@ void AppendSectionHeader(CFISection *table, const ELFSectionHeader &header) {
 }
 
 void WriteELFFrameSection(const char *filename, const char *cfi_name,
-                          const CFISection &cfi) {
+                          const CFISection& cfi) {
   int elf_class = cfi.AddressSize() == 4 ? ELFCLASS32 : ELFCLASS64;
   int elf_data = (cfi.endianness() == kBigEndian
                   ? ELFDATA2MSB : ELFDATA2LSB);
diff --git a/src/MEGASync/google_breakpad/common/dwarf/dwarf2reader_die_unittest.cc b/src/MEGASync/google_breakpad/common/dwarf/dwarf2reader_die_unittest.cc
index 4e344369..87819322 100644
--- a/src/MEGASync/google_breakpad/common/dwarf/dwarf2reader_die_unittest.cc
+++ b/src/MEGASync/google_breakpad/common/dwarf/dwarf2reader_die_unittest.cc
@@ -31,6 +31,7 @@
 
 // dwarf2reader_die_unittest.cc: Unit tests for dwarf2reader::CompilationUnit
 
+#include <stdint.h>
 #include <stdlib.h>
 
 #include <iostream>
@@ -72,36 +73,37 @@ using testing::_;
 
 class MockDwarf2Handler: public Dwarf2Handler {
  public:
-  MOCK_METHOD5(StartCompilationUnit, bool(uint64 offset, uint8 address_size,
-                                          uint8 offset_size, uint64 cu_length,
-                                          uint8 dwarf_version));
-  MOCK_METHOD2(StartDIE, bool(uint64 offset, enum DwarfTag tag));
-  MOCK_METHOD4(ProcessAttributeUnsigned, void(uint64 offset,
+  MOCK_METHOD5(StartCompilationUnit, bool(uint64_t offset, uint8_t address_size,
+                                          uint8_t offset_size,
+                                          uint64_t cu_length,
+                                          uint8_t dwarf_version));
+  MOCK_METHOD2(StartDIE, bool(uint64_t offset, enum DwarfTag tag));
+  MOCK_METHOD4(ProcessAttributeUnsigned, void(uint64_t offset,
                                               DwarfAttribute attr,
                                               enum DwarfForm form,
-                                              uint64 data));
-  MOCK_METHOD4(ProcessAttributeSigned, void(uint64 offset,
+                                              uint64_t data));
+  MOCK_METHOD4(ProcessAttributeSigned, void(uint64_t offset,
                                             enum DwarfAttribute attr,
                                             enum DwarfForm form,
-                                            int64 data));
-  MOCK_METHOD4(ProcessAttributeReference, void(uint64 offset,
+                                            int64_t data));
+  MOCK_METHOD4(ProcessAttributeReference, void(uint64_t offset,
                                                enum DwarfAttribute attr,
                                                enum DwarfForm form,
-                                               uint64 data));
-  MOCK_METHOD5(ProcessAttributeBuffer, void(uint64 offset,
+                                               uint64_t data));
+  MOCK_METHOD5(ProcessAttributeBuffer, void(uint64_t offset,
                                             enum DwarfAttribute attr,
                                             enum DwarfForm form,
-                                            const char* data,
-                                            uint64 len));
-  MOCK_METHOD4(ProcessAttributeString, void(uint64 offset,
+                                            const uint8_t* data,
+                                            uint64_t len));
+  MOCK_METHOD4(ProcessAttributeString, void(uint64_t offset,
                                             enum DwarfAttribute attr,
                                             enum DwarfForm form,
                                             const string& data));
-  MOCK_METHOD4(ProcessAttributeSignature, void(uint64 offset,
+  MOCK_METHOD4(ProcessAttributeSignature, void(uint64_t offset,
                                                DwarfAttribute attr,
                                                enum DwarfForm form,
-                                               uint64 signature));
-  MOCK_METHOD1(EndDIE, void(uint64 offset));
+                                               uint64_t signature));
+  MOCK_METHOD1(EndDIE, void(uint64_t offset));
 };
 
 struct DIEFixture {
@@ -126,15 +128,17 @@ struct DIEFixture {
   // to |info|, and whose .debug_abbrev section refers to |abbrevs|. This
   // function returns a reference to the same SectionMap each time; new
   // calls wipe out maps established by earlier calls.
-  const SectionMap &MakeSectionMap() {
+  const SectionMap& MakeSectionMap() {
     // Copy the sections' contents into strings that will live as long as
     // the map itself.
     assert(info.GetContents(&info_contents));
     assert(abbrevs.GetContents(&abbrevs_contents));
     section_map.clear();
-    section_map[".debug_info"].first  = info_contents.data();
+    section_map[".debug_info"].first
+      = reinterpret_cast<const uint8_t*>(info_contents.data());
     section_map[".debug_info"].second = info_contents.size();
-    section_map[".debug_abbrev"].first  = abbrevs_contents.data();
+    section_map[".debug_abbrev"].first
+      = reinterpret_cast<const uint8_t*>(abbrevs_contents.data());
     section_map[".debug_abbrev"].second = abbrevs_contents.size();
     return section_map;
   }
@@ -196,7 +200,7 @@ TEST_P(DwarfHeader, Header) {
 
   ByteReader byte_reader(GetParam().endianness == kLittleEndian ?
                          ENDIANNESS_LITTLE : ENDIANNESS_BIG);
-  CompilationUnit parser(MakeSectionMap(), 0, &byte_reader, &handler);
+  CompilationUnit parser("", MakeSectionMap(), 0, &byte_reader, &handler);
   EXPECT_EQ(parser.Start(), info_contents.size());
 }
 
@@ -214,6 +218,8 @@ INSTANTIATE_TEST_CASE_P(
                       DwarfHeaderParams(kLittleEndian, 8, 3, 8),
                       DwarfHeaderParams(kLittleEndian, 8, 4, 4),
                       DwarfHeaderParams(kLittleEndian, 8, 4, 8),
+                      DwarfHeaderParams(kLittleEndian, 8, 5, 4),
+                      DwarfHeaderParams(kLittleEndian, 8, 5, 8),
                       DwarfHeaderParams(kBigEndian,    4, 2, 4),
                       DwarfHeaderParams(kBigEndian,    4, 2, 8),
                       DwarfHeaderParams(kBigEndian,    4, 3, 4),
@@ -225,14 +231,16 @@ INSTANTIATE_TEST_CASE_P(
                       DwarfHeaderParams(kBigEndian,    8, 3, 4),
                       DwarfHeaderParams(kBigEndian,    8, 3, 8),
                       DwarfHeaderParams(kBigEndian,    8, 4, 4),
-                      DwarfHeaderParams(kBigEndian,    8, 4, 8)));
+                      DwarfHeaderParams(kBigEndian,    8, 4, 8),
+                      DwarfHeaderParams(kBigEndian,    8, 5, 4),
+                      DwarfHeaderParams(kBigEndian,    8, 5, 8)));
 
 struct DwarfFormsFixture: public DIEFixture {
   // Start a compilation unit, as directed by |params|, containing one
   // childless DIE of the given tag, with one attribute of the given name
   // and form. The 'info' fixture member is left just after the abbrev
   // code, waiting for the attribute value to be appended.
-  void StartSingleAttributeDIE(const DwarfHeaderParams &params,
+  void StartSingleAttributeDIE(const DwarfHeaderParams& params,
                                DwarfTag tag, DwarfAttribute name,
                                DwarfForm form) {
     // Create the abbreviation table.
@@ -252,8 +260,8 @@ struct DwarfFormsFixture: public DIEFixture {
   // Set up handler to expect a compilation unit matching |params|,
   // containing one childless DIE of the given tag, in the sequence s. Stop
   // just before the expectations.
-  void ExpectBeginCompilationUnit(const DwarfHeaderParams &params,
-                                  DwarfTag tag, uint64 offset=0) {
+  void ExpectBeginCompilationUnit(const DwarfHeaderParams& params,
+                                  DwarfTag tag, uint64_t offset=0) {
     EXPECT_CALL(handler,
                 StartCompilationUnit(offset, params.address_size,
                                      params.format_size, _,
@@ -271,10 +279,11 @@ struct DwarfFormsFixture: public DIEFixture {
         .WillOnce(Return());
   }
 
-  void ParseCompilationUnit(const DwarfHeaderParams &params, uint64 offset=0) {
+  void ParseCompilationUnit(const DwarfHeaderParams& params,
+                            uint64_t offset=0) {
     ByteReader byte_reader(params.endianness == kLittleEndian ?
                            ENDIANNESS_LITTLE : ENDIANNESS_BIG);
-    CompilationUnit parser(MakeSectionMap(), offset, &byte_reader, &handler);
+    CompilationUnit parser("", MakeSectionMap(), offset, &byte_reader, &handler);
     EXPECT_EQ(offset + parser.Start(), info_contents.size());
   }
 
diff --git a/src/MEGASync/google_breakpad/common/dwarf/dwarf2reader_lineinfo_unittest.cc b/src/MEGASync/google_breakpad/common/dwarf/dwarf2reader_lineinfo_unittest.cc
new file mode 100644
index 00000000..99fc1a07
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/dwarf/dwarf2reader_lineinfo_unittest.cc
@@ -0,0 +1,187 @@
+// Copyright (c) 2020, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// Original author: Sterling Augustine <saugustine@google.com>
+
+// dwarf2reader_lineinfo_unittest.cc: Unit tests for dwarf2reader::LineInfo
+
+#include <stdint.h>
+#include <stdlib.h>
+
+#include <string>
+#include <vector>
+
+#include "breakpad_googletest_includes.h"
+#include "common/dwarf/bytereader.h"
+#include "common/dwarf/dwarf2reader.h"
+#include "google_breakpad/common/breakpad_types.h"
+
+using std::vector;
+using testing::InSequence;
+using testing::Return;
+using testing::Sequence;
+using testing::Test;
+using testing::_;
+
+using namespace dwarf2reader;
+
+namespace {
+
+const uint8_t dwarf5_line_program[] = {
+  0x40, 0x0, 0x0, 0x0,  // unit_length (end - begin)
+  // begin
+  0x05, 0x0,  // version
+  0x8,  // address_size
+  0x0,  // segment_selector_size
+  0x26, 0x0, 0x0, 0x0, // header_length (end_header_end - begin_header)
+  // begin_header:
+  0x1,  // minimum_instruction_length
+  0x1,  // maximum_operations_per_instruction
+  0x1,  // default_is_stmt
+  0xfb, // line_base
+  0xe,  // line_range
+  0xd,  // opcode_base and lengths
+  0x0, 0x1, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x1,
+  0x1,  // directory entry format count
+  DW_LNCT_path, DW_FORM_strp,
+  0x1,  // directories count
+  0x1, 0x0, 0x0, 0x0, // offset into .debug_line_str
+  0x2,  // file_name_entry_format_count
+  DW_LNCT_directory_index, DW_FORM_data1,
+  DW_LNCT_path, DW_FORM_line_strp,
+  0x1,  // filename count
+  0x0,  // directory index
+  0x1, 0x0, 0x0, 0x0, // offset into .debug_str
+  // end_header
+  DW_LNS_set_file, 0x0,
+  //  set address to 0x0
+  0x0, 0x9, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+  // Advance Address by 0 and line by 3
+  0x15,
+  // Advance PC by 1
+  0x2, 0x1,
+  0x0,
+  DW_LNE_end_sequence,
+  DW_LNE_end_sequence,
+  // end
+};
+
+const uint8_t dwarf4_line_program[] = {
+  0x37, 0x0, 0x0, 0x0,  // unit_length (end - begin)
+  // begin
+  0x04, 0x0,  // version
+  0x1d, 0x0, 0x0, 0x0, // header_length (end_header - begin_header)
+  // begin_header:
+  0x1,  // minimum_instruction_length
+  0x1,  // maximum_operations_per_instruction
+  0x1,  // default_is_stmt
+  0xfb, // line_base
+  0xe,  // line_range
+  0xd,  // opcode_base and lengths
+  0x0, 0x1, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x1,
+  '/', 'a', '\0',  // directory entry 1 (zeroth entry implied)
+  '\0', // end of directory table
+  'b', '/', 'c', '\0',  // file entry 1 (zeroth entry implied)
+  0, // file 1 directory
+  0, // file 1 modification time
+  0, // file 1 length
+  '\0', // end of file table
+  // end_header
+  DW_LNS_set_file, 0x0,
+  //  set address to 0x0
+  0x0, 0x9, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+  // Advance Address by 0 and line by 3
+  0x15,
+  // Advance PC by 1
+  0x2, 0x1,
+  0x0,
+  DW_LNE_end_sequence,
+  DW_LNE_end_sequence,
+  // end
+};
+
+class MockLineInfoHandler: public LineInfoHandler {
+ public:
+  MOCK_METHOD(void, DefineDir, (const string&, uint32_t dir_num), (override));
+  MOCK_METHOD(void, DefineFile, (const string& name, int32_t file_num,
+                                 uint32_t dir_num, uint64_t mod_time,
+                                 uint64_t length), (override));
+  MOCK_METHOD(void, AddLine, (uint64_t address, uint64_t length,
+                              uint32_t file_num, uint32_t line_num,
+                              uint32_t column_num), (override));
+};
+
+const uint8_t string_section[] = {'x', '/', 'a', '\0'};
+const uint8_t line_string_section[] = {'x', 'b', '/', 'c', '\0' };
+
+struct LineProgram: public Test {
+  MockLineInfoHandler handler_;
+};
+
+TEST_F(LineProgram, ReadLinesDwarf5) {
+  ByteReader byte_reader(ENDIANNESS_LITTLE);
+  // LineTables don't specify the offset size like Compilation Units do.
+  byte_reader.SetOffsetSize(4);
+  LineInfo line_reader(dwarf5_line_program,
+                       sizeof(dwarf5_line_program),
+                       &byte_reader,
+                       string_section,
+                       sizeof(string_section),
+                       line_string_section,
+                       sizeof(line_string_section),
+                       &handler_);
+  EXPECT_CALL(handler_, DefineDir("/a", 0)).Times(1);
+  EXPECT_CALL(handler_, DefineFile("b/c", 0, 0, 0, 0)).Times(1);
+  EXPECT_CALL(handler_, AddLine(0, 1, 0, 4, 0)).Times(1);
+  EXPECT_EQ(line_reader.Start(), sizeof(dwarf5_line_program));
+}
+
+TEST_F(LineProgram, ReadLinesDwarf4) {
+  ByteReader byte_reader(ENDIANNESS_LITTLE);
+  // LineTables don't specify the offset size like Compilation Units do.
+  byte_reader.SetOffsetSize(4);
+  // dwarf4 line info headers don't encode the address size.
+  byte_reader.SetAddressSize(8);
+  LineInfo line_reader(dwarf4_line_program,
+                       sizeof(dwarf5_line_program),
+                       &byte_reader,
+                       // dwarf4 line tables can't access the string sections
+                       // so pass values likely to make assertions fail if
+                       // the code uses them improperly.
+                       nullptr, 0, nullptr, 0,
+                       &handler_);
+  EXPECT_CALL(handler_, DefineDir("", 0)).Times(1);
+  EXPECT_CALL(handler_, DefineDir("/a", 1)).Times(1);
+  EXPECT_CALL(handler_, DefineFile("", 0, 0, 0, 0)).Times(1);
+  EXPECT_CALL(handler_, DefineFile("b/c", 1, 0, 0, 0)).Times(1);
+  EXPECT_CALL(handler_, AddLine(0, 1, 0, 4, 0)).Times(1);
+  EXPECT_EQ(line_reader.Start(), sizeof(dwarf4_line_program));
+}
+
+}  // anonymous namespace
diff --git a/src/MEGASync/google_breakpad/common/dwarf/dwarf2reader_test_common.h b/src/MEGASync/google_breakpad/common/dwarf/dwarf2reader_test_common.h
index e91de906..1934094d 100644
--- a/src/MEGASync/google_breakpad/common/dwarf/dwarf2reader_test_common.h
+++ b/src/MEGASync/google_breakpad/common/dwarf/dwarf2reader_test_common.h
@@ -57,7 +57,7 @@ class TestCompilationUnit: public google_breakpad::test_assembler::Section {
     assert(format_size == 4 || format_size == 8);
     format_size_ = format_size;
   }
-    
+
   // Append a DWARF section offset value, of the appropriate size for this
   // compilation unit.
   template<typename T>
@@ -70,7 +70,7 @@ class TestCompilationUnit: public google_breakpad::test_assembler::Section {
 
   // Append a DWARF compilation unit header to the section, with the given
   // DWARF version, abbrev table offset, and address size.
-  TestCompilationUnit &Header(int version, const Label &abbrev_offset,
+  TestCompilationUnit& Header(int version, const Label& abbrev_offset,
                               size_t address_size) {
     if (format_size_ == 4) {
       D32(length_);
@@ -80,13 +80,19 @@ class TestCompilationUnit: public google_breakpad::test_assembler::Section {
     }
     post_length_offset_ = Size();
     D16(version);
-    SectionOffset(abbrev_offset);
-    D8(address_size);
+    if (version <= 4) {
+      SectionOffset(abbrev_offset);
+      D8(address_size);
+    } else {
+      D8(0x01);  // DW_UT_compile
+      D8(address_size);
+      SectionOffset(abbrev_offset);
+    }
     return *this;
   }
 
   // Mark the end of this header's DIEs.
-  TestCompilationUnit &Finish() {
+  TestCompilationUnit& Finish() {
     length_ = Size() - post_length_offset_;
     return *this;
   }
@@ -116,7 +122,7 @@ class TestAbbrevTable: public google_breakpad::test_assembler::Section {
   // Start a new abbreviation table entry for abbreviation code |code|,
   // encoding a DIE whose tag is |tag|, and which has children if and only
   // if |has_children| is true.
-  TestAbbrevTable &Abbrev(int code, DwarfTag tag, DwarfHasChild has_children) {
+  TestAbbrevTable& Abbrev(int code, DwarfTag tag, DwarfHasChild has_children) {
     assert(code != 0);
     ULEB128(code);
     ULEB128(static_cast<unsigned>(tag));
@@ -126,21 +132,21 @@ class TestAbbrevTable: public google_breakpad::test_assembler::Section {
 
   // Add an attribute to the current abbreviation code whose name is |name|
   // and whose form is |form|.
-  TestAbbrevTable &Attribute(DwarfAttribute name, DwarfForm form) {
+  TestAbbrevTable& Attribute(DwarfAttribute name, DwarfForm form) {
     ULEB128(static_cast<unsigned>(name));
     ULEB128(static_cast<unsigned>(form));
     return *this;
   }
 
   // Finish the current abbreviation code.
-  TestAbbrevTable &EndAbbrev() {
+  TestAbbrevTable& EndAbbrev() {
     ULEB128(0);
     ULEB128(0);
     return *this;
   }
 
   // Finish the current abbreviation table.
-  TestAbbrevTable &EndTable() {
+  TestAbbrevTable& EndTable() {
     ULEB128(0);
     return *this;
   }
diff --git a/src/MEGASync/google_breakpad/common/dwarf/elf_reader.cc b/src/MEGASync/google_breakpad/common/dwarf/elf_reader.cc
new file mode 100644
index 00000000..bbfdba68
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/dwarf/elf_reader.cc
@@ -0,0 +1,1274 @@
+// Copyright 2005 Google Inc. All Rights Reserved.
+// Author: chatham@google.com (Andrew Chatham)
+// Author: satorux@google.com (Satoru Takabayashi)
+//
+// Code for reading in ELF files.
+//
+// For information on the ELF format, see
+// http://www.x86.org/ftp/manuals/tools/elf.pdf
+//
+// I also liked:
+// http://www.caldera.com/developers/gabi/1998-04-29/contents.html
+//
+// A note about types: When dealing with the file format, we use types
+// like Elf32_Word, but in the public interfaces we treat all
+// addresses as uint64. As a result, we should be able to symbolize
+// 64-bit binaries from a 32-bit process (which we don't do,
+// anyway). size_t should therefore be avoided, except where required
+// by things like mmap().
+//
+// Although most of this code can deal with arbitrary ELF files of
+// either word size, the public ElfReader interface only examines
+// files loaded into the current address space, which must all match
+// the machine's native word size. This code cannot handle ELF files
+// with a non-native byte ordering.
+//
+// TODO(chatham): It would be nice if we could accomplish this task
+// without using malloc(), so we could use it as the process is dying.
+
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE  // needed for pread()
+#endif
+
+#include <fcntl.h>
+#include <limits.h>
+#include <string.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#include <algorithm>
+#include <map>
+#include <string>
+#include <vector>
+// TODO(saugustine): Add support for compressed debug.
+// Also need to add configure tests for zlib.
+//#include "zlib.h"
+
+#include "third_party/musl/include/elf.h"
+#include "elf_reader.h"
+#include "common/using_std_string.h"
+
+// EM_AARCH64 is not defined by elf.h of GRTE v3 on x86.
+// TODO(dougkwan): Remove this when v17 is retired.
+#if !defined(EM_AARCH64)
+#define EM_AARCH64      183             /* ARM AARCH64 */
+#endif
+
+// Map Linux macros to their Apple equivalents.
+#if __APPLE__
+#ifndef __LITTLE_ENDIAN
+#define __LITTLE_ENDIAN __ORDER_LITTLE_ENDIAN__
+#endif  // __LITTLE_ENDIAN
+#ifndef __BIG_ENDIAN
+#define __BIG_ENDIAN __ORDER_BIG_ENDIAN__
+#endif  // __BIG_ENDIAN
+#ifndef __BYTE_ORDER
+#define __BYTE_ORDER __BYTE_ORDER__
+#endif  // __BYTE_ORDER
+#endif  // __APPLE__
+
+// TODO(dthomson): Can be removed once all Java code is using the Google3
+// launcher. We need to avoid processing PLT functions as it causes memory
+// fragmentation in malloc, which is fixed in tcmalloc - and if the Google3
+// launcher is used the JVM will then use tcmalloc. b/13735638
+//DEFINE_bool(elfreader_process_dynsyms, true,
+//            "Activate PLT function processing");
+
+using std::vector;
+
+namespace {
+
+// The lowest bit of an ARM symbol value is used to indicate a Thumb address.
+const int kARMThumbBitOffset = 0;
+
+// Converts an ARM Thumb symbol value to a true aligned address value.
+template <typename T>
+T AdjustARMThumbSymbolValue(const T& symbol_table_value) {
+  return symbol_table_value & ~(1 << kARMThumbBitOffset);
+}
+
+// Names of PLT-related sections.
+const char kElfPLTRelSectionName[] = ".rel.plt";      // Use Rel struct.
+const char kElfPLTRelaSectionName[] = ".rela.plt";    // Use Rela struct.
+const char kElfPLTSectionName[] = ".plt";
+const char kElfDynSymSectionName[] = ".dynsym";
+
+const int kX86PLTCodeSize = 0x10;  // Size of one x86 PLT function in bytes.
+const int kARMPLTCodeSize = 0xc;
+const int kAARCH64PLTCodeSize = 0x10;
+
+const int kX86PLT0Size = 0x10;  // Size of the special PLT0 entry.
+const int kARMPLT0Size = 0x14;
+const int kAARCH64PLT0Size = 0x20;
+
+// Suffix for PLT functions when it needs to be explicitly identified as such.
+const char kPLTFunctionSuffix[] = "@plt";
+
+}  // namespace
+
+namespace dwarf2reader {
+
+template <class ElfArch> class ElfReaderImpl;
+
+// 32-bit and 64-bit ELF files are processed exactly the same, except
+// for various field sizes. Elf32 and Elf64 encompass all of the
+// differences between the two formats, and all format-specific code
+// in this file is templated on one of them.
+class Elf32 {
+ public:
+  typedef Elf32_Ehdr Ehdr;
+  typedef Elf32_Shdr Shdr;
+  typedef Elf32_Phdr Phdr;
+  typedef Elf32_Word Word;
+  typedef Elf32_Sym Sym;
+  typedef Elf32_Rel Rel;
+  typedef Elf32_Rela Rela;
+
+  // What should be in the EI_CLASS header.
+  static const int kElfClass = ELFCLASS32;
+
+  // Given a symbol pointer, return the binding type (eg STB_WEAK).
+  static char Bind(const Elf32_Sym* sym) {
+    return ELF32_ST_BIND(sym->st_info);
+  }
+  // Given a symbol pointer, return the symbol type (eg STT_FUNC).
+  static char Type(const Elf32_Sym* sym) {
+    return ELF32_ST_TYPE(sym->st_info);
+  }
+
+  // Extract the symbol index from the r_info field of a relocation.
+  static int r_sym(const Elf32_Word r_info) {
+    return ELF32_R_SYM(r_info);
+  }
+};
+
+
+class Elf64 {
+ public:
+  typedef Elf64_Ehdr Ehdr;
+  typedef Elf64_Shdr Shdr;
+  typedef Elf64_Phdr Phdr;
+  typedef Elf64_Word Word;
+  typedef Elf64_Sym Sym;
+  typedef Elf64_Rel Rel;
+  typedef Elf64_Rela Rela;
+
+  // What should be in the EI_CLASS header.
+  static const int kElfClass = ELFCLASS64;
+
+  static char Bind(const Elf64_Sym* sym) {
+    return ELF64_ST_BIND(sym->st_info);
+  }
+  static char Type(const Elf64_Sym* sym) {
+    return ELF64_ST_TYPE(sym->st_info);
+  }
+  static int r_sym(const Elf64_Xword r_info) {
+    return ELF64_R_SYM(r_info);
+  }
+};
+
+
+// ElfSectionReader mmaps a section of an ELF file ("section" is ELF
+// terminology). The ElfReaderImpl object providing the section header
+// must exist for the lifetime of this object.
+//
+// The motivation for mmaping individual sections of the file is that
+// many Google executables are large enough when unstripped that we
+// have to worry about running out of virtual address space.
+//
+// For compressed sections we have no choice but to allocate memory.
+template<class ElfArch>
+class ElfSectionReader {
+ public:
+  ElfSectionReader(const char* name, const string& path, int fd,
+                   const typename ElfArch::Shdr& section_header)
+      : contents_aligned_(NULL),
+        contents_(NULL),
+        header_(section_header) {
+    // Back up to the beginning of the page we're interested in.
+    const size_t additional = header_.sh_offset % getpagesize();
+    const size_t offset_aligned = header_.sh_offset - additional;
+    section_size_ = header_.sh_size;
+    size_aligned_ = section_size_ + additional;
+    // If the section has been stripped or is empty, do not attempt
+    // to process its contents.
+    if (header_.sh_type == SHT_NOBITS || header_.sh_size == 0)
+      return;
+    contents_aligned_ = mmap(NULL, size_aligned_, PROT_READ, MAP_SHARED,
+                             fd, offset_aligned);
+    // Set where the offset really should begin.
+    contents_ = reinterpret_cast<char*>(contents_aligned_) +
+                (header_.sh_offset - offset_aligned);
+
+    // Check for and handle any compressed contents.
+    //if (strncmp(name, ".zdebug_", strlen(".zdebug_")) == 0)
+    //  DecompressZlibContents();
+    // TODO(saugustine): Add support for proposed elf-section flag
+    // "SHF_COMPRESS".
+  }
+
+  ~ElfSectionReader() {
+    if (contents_aligned_ != NULL)
+      munmap(contents_aligned_, size_aligned_);
+    else
+      delete[] contents_;
+  }
+
+  // Return the section header for this section.
+  typename ElfArch::Shdr const& header() const { return header_; }
+
+  // Return memory at the given offset within this section.
+  const char* GetOffset(typename ElfArch::Word bytes) const {
+    return contents_ + bytes;
+  }
+
+  const char* contents() const { return contents_; }
+  size_t section_size() const { return section_size_; }
+
+ private:
+  // page-aligned file contents
+  void* contents_aligned_;
+  // contents as usable by the client. For non-compressed sections,
+  // pointer within contents_aligned_ to where the section data
+  // begins; for compressed sections, pointer to the decompressed
+  // data.
+  char* contents_;
+  // size of contents_aligned_
+  size_t size_aligned_;
+  // size of contents.
+  size_t section_size_;
+  const typename ElfArch::Shdr header_;
+};
+
+// An iterator over symbols in a given section. It handles walking
+// through the entries in the specified section and mapping symbol
+// entries to their names in the appropriate string table (in
+// another section).
+template<class ElfArch>
+class SymbolIterator {
+ public:
+  SymbolIterator(ElfReaderImpl<ElfArch>* reader,
+                 typename ElfArch::Word section_type)
+      : symbol_section_(reader->GetSectionByType(section_type)),
+        string_section_(NULL),
+        num_symbols_in_section_(0),
+        symbol_within_section_(0) {
+
+    // If this section type doesn't exist, leave
+    // num_symbols_in_section_ as zero, so this iterator is already
+    // done().
+    if (symbol_section_ != NULL) {
+      num_symbols_in_section_ = symbol_section_->header().sh_size /
+                                symbol_section_->header().sh_entsize;
+
+      // Symbol sections have sh_link set to the section number of
+      // the string section containing the symbol names.
+      string_section_ = reader->GetSection(symbol_section_->header().sh_link);
+    }
+  }
+
+  // Return true iff we have passed all symbols in this section.
+  bool done() const {
+    return symbol_within_section_ >= num_symbols_in_section_;
+  }
+
+  // Advance to the next symbol in this section.
+  // REQUIRES: !done()
+  void Next() { ++symbol_within_section_; }
+
+  // Return a pointer to the current symbol.
+  // REQUIRES: !done()
+  const typename ElfArch::Sym* GetSymbol() const {
+    return reinterpret_cast<const typename ElfArch::Sym*>(
+        symbol_section_->GetOffset(symbol_within_section_ *
+                                   symbol_section_->header().sh_entsize));
+  }
+
+  // Return the name of the current symbol, NULL if it has none.
+  // REQUIRES: !done()
+  const char* GetSymbolName() const {
+    int name_offset = GetSymbol()->st_name;
+    if (name_offset == 0)
+      return NULL;
+    return string_section_->GetOffset(name_offset);
+  }
+
+  int GetCurrentSymbolIndex() const {
+    return symbol_within_section_;
+  }
+
+ private:
+  const ElfSectionReader<ElfArch>* const symbol_section_;
+  const ElfSectionReader<ElfArch>* string_section_;
+  int num_symbols_in_section_;
+  int symbol_within_section_;
+};
+
+
+// Copied from strings/strutil.h.  Per chatham,
+// this library should not depend on strings.
+
+static inline bool MyHasSuffixString(const string& str, const string& suffix) {
+  int len = str.length();
+  int suflen = suffix.length();
+  return (suflen <= len) && (str.compare(len-suflen, suflen, suffix) == 0);
+}
+
+
+// ElfReader loads an ELF binary and can provide information about its
+// contents. It is most useful for matching addresses to function
+// names. It does not understand debugging formats (eg dwarf2), so it
+// can't print line numbers. It takes a path to an elf file and a
+// readable file descriptor for that file, which it does not assume
+// ownership of.
+template<class ElfArch>
+class ElfReaderImpl {
+ public:
+  explicit ElfReaderImpl(const string& path, int fd)
+      : path_(path),
+        fd_(fd),
+        section_headers_(NULL),
+        program_headers_(NULL),
+        opd_section_(NULL),
+        base_for_text_(0),
+        plts_supported_(false),
+        plt_code_size_(0),
+        plt0_size_(0),
+        visited_relocation_entries_(false) {
+    string error;
+    is_dwp_ = MyHasSuffixString(path, ".dwp");
+    ParseHeaders(fd, path);
+    // Currently we need some extra information for PowerPC64 binaries
+    // including a way to read the .opd section for function descriptors and a
+    // way to find the linked base for function symbols.
+    if (header_.e_machine == EM_PPC64) {
+      // "opd_section_" must always be checked for NULL before use.
+      opd_section_ = GetSectionInfoByName(".opd", &opd_info_);
+      for (unsigned int k = 0u; k < GetNumSections(); ++k) {
+        const char* name = GetSectionName(section_headers_[k].sh_name);
+        if (strncmp(name, ".text", strlen(".text")) == 0) {
+          base_for_text_ =
+              section_headers_[k].sh_addr - section_headers_[k].sh_offset;
+          break;
+        }
+      }
+    }
+    // Turn on PLTs.
+    if (header_.e_machine == EM_386 || header_.e_machine == EM_X86_64) {
+      plt_code_size_ = kX86PLTCodeSize;
+      plt0_size_ = kX86PLT0Size;
+      plts_supported_ = true;
+    } else if (header_.e_machine == EM_ARM) {
+      plt_code_size_ = kARMPLTCodeSize;
+      plt0_size_ = kARMPLT0Size;
+      plts_supported_ = true;
+    } else if (header_.e_machine == EM_AARCH64) {
+      plt_code_size_ = kAARCH64PLTCodeSize;
+      plt0_size_ = kAARCH64PLT0Size;
+      plts_supported_ = true;
+    }
+  }
+
+  ~ElfReaderImpl() {
+    for (unsigned int i = 0u; i < sections_.size(); ++i)
+      delete sections_[i];
+    delete [] section_headers_;
+    delete [] program_headers_;
+  }
+
+  // Examine the headers of the file and return whether the file looks
+  // like an ELF file for this architecture. Takes an already-open
+  // file descriptor for the candidate file, reading in the prologue
+  // to see if the ELF file appears to match the current
+  // architecture. If error is non-NULL, it will be set with a reason
+  // in case of failure.
+  static bool IsArchElfFile(int fd, string* error) {
+    unsigned char header[EI_NIDENT];
+    if (pread(fd, header, sizeof(header), 0) != sizeof(header)) {
+      if (error != NULL) *error = "Could not read header";
+      return false;
+    }
+
+    if (memcmp(header, ELFMAG, SELFMAG) != 0) {
+      if (error != NULL) *error = "Missing ELF magic";
+      return false;
+    }
+
+    if (header[EI_CLASS] != ElfArch::kElfClass) {
+      if (error != NULL) *error = "Different word size";
+      return false;
+    }
+
+    int endian = 0;
+    if (header[EI_DATA] == ELFDATA2LSB)
+      endian = __LITTLE_ENDIAN;
+    else if (header[EI_DATA] == ELFDATA2MSB)
+      endian = __BIG_ENDIAN;
+    if (endian != __BYTE_ORDER) {
+      if (error != NULL) *error = "Different byte order";
+      return false;
+    }
+
+    return true;
+  }
+
+  // Return true if we can use this symbol in Address-to-Symbol map.
+  bool CanUseSymbol(const char* name, const typename ElfArch::Sym* sym) {
+    // For now we only save FUNC and NOTYPE symbols. For now we just
+    // care about functions, but some functions written in assembler
+    // don't have a proper ELF type attached to them, so we store
+    // NOTYPE symbols as well. The remaining significant type is
+    // OBJECT (eg global variables), which represent about 25% of
+    // the symbols in a typical google3 binary.
+    if (ElfArch::Type(sym) != STT_FUNC &&
+        ElfArch::Type(sym) != STT_NOTYPE) {
+      return false;
+    }
+
+    // Target specific filtering.
+    switch (header_.e_machine) {
+    case EM_AARCH64:
+    case EM_ARM:
+      // Filter out '$x' special local symbols used by tools
+      return name[0] != '$' || ElfArch::Bind(sym) != STB_LOCAL;
+    case EM_X86_64:
+      // Filter out read-only constants like .LC123.
+      return name[0] != '.' || ElfArch::Bind(sym) != STB_LOCAL;
+    default:
+      return true;
+    }
+  }
+
+  // Iterate over the symbols in a section, either SHT_DYNSYM or
+  // SHT_SYMTAB. Add all symbols to the given SymbolMap.
+  /*
+  void GetSymbolPositions(SymbolMap* symbols,
+                          typename ElfArch::Word section_type,
+                          uint64_t mem_offset,
+                          uint64_t file_offset) {
+    // This map is used to filter out "nested" functions.
+    // See comment below.
+    AddrToSymMap addr_to_sym_map;
+    for (SymbolIterator<ElfArch> it(this, section_type);
+         !it.done(); it.Next()) {
+      const char* name = it.GetSymbolName();
+      if (name == NULL)
+        continue;
+      const typename ElfArch::Sym* sym = it.GetSymbol();
+      if (CanUseSymbol(name, sym)) {
+        const int sec = sym->st_shndx;
+
+        // We don't support special section indices. The most common
+        // is SHN_ABS, for absolute symbols used deep in the bowels of
+        // glibc. Also ignore any undefined symbols.
+        if (sec == SHN_UNDEF ||
+            (sec >= SHN_LORESERVE && sec <= SHN_HIRESERVE)) {
+          continue;
+        }
+
+        const typename ElfArch::Shdr& hdr = section_headers_[sec];
+
+        // Adjust for difference between where we expected to mmap
+        // this section, and where it was actually mmapped.
+        const int64_t expected_base = hdr.sh_addr - hdr.sh_offset;
+        const int64_t real_base = mem_offset - file_offset;
+        const int64_t adjust = real_base - expected_base;
+
+        uint64_t start = sym->st_value + adjust;
+
+        // Adjust function symbols for PowerPC64 by dereferencing and adjusting
+        // the function descriptor to get the function address.
+        if (header_.e_machine == EM_PPC64 && ElfArch::Type(sym) == STT_FUNC) {
+          const uint64_t opd_addr =
+              AdjustPPC64FunctionDescriptorSymbolValue(sym->st_value);
+          // Only adjust the returned value if the function address was found.
+          if (opd_addr != sym->st_value) {
+            const int64_t adjust_function_symbols =
+                real_base - base_for_text_;
+            start = opd_addr + adjust_function_symbols;
+          }
+        }
+
+        addr_to_sym_map.push_back(std::make_pair(start, sym));
+      }
+    }
+    std::sort(addr_to_sym_map.begin(), addr_to_sym_map.end(), &AddrToSymSorter);
+    addr_to_sym_map.erase(std::unique(addr_to_sym_map.begin(),
+                                      addr_to_sym_map.end(), &AddrToSymEquals),
+                          addr_to_sym_map.end());
+
+    // Squeeze out any "nested functions".
+    // Nested functions are not allowed in C, but libc plays tricks.
+    //
+    // For example, here is disassembly of /lib64/tls/libc-2.3.5.so:
+    //   0x00000000000aa380 <read+0>:             cmpl   $0x0,0x2781b9(%rip)
+    //   0x00000000000aa387 <read+7>:             jne    0xaa39b <read+27>
+    //   0x00000000000aa389 <__read_nocancel+0>:  mov    $0x0,%rax
+    //   0x00000000000aa390 <__read_nocancel+7>:  syscall
+    //   0x00000000000aa392 <__read_nocancel+9>:  cmp $0xfffffffffffff001,%rax
+    //   0x00000000000aa398 <__read_nocancel+15>: jae    0xaa3ef <read+111>
+    //   0x00000000000aa39a <__read_nocancel+17>: retq
+    //   0x00000000000aa39b <read+27>:            sub    $0x28,%rsp
+    //   0x00000000000aa39f <read+31>:            mov    %rdi,0x8(%rsp)
+    //   ...
+    // Without removing __read_nocancel, symbolizer will return NULL
+    // given e.g. 0xaa39f (because the lower bound is __read_nocancel,
+    // but 0xaa39f is beyond its end.
+    if (addr_to_sym_map.empty()) {
+      return;
+    }
+    const ElfSectionReader<ElfArch>* const symbol_section =
+        this->GetSectionByType(section_type);
+    const ElfSectionReader<ElfArch>* const string_section =
+        this->GetSection(symbol_section->header().sh_link);
+
+    typename AddrToSymMap::iterator curr = addr_to_sym_map.begin();
+    // Always insert the first symbol.
+    symbols->AddSymbol(string_section->GetOffset(curr->second->st_name),
+                       curr->first, curr->second->st_size);
+    typename AddrToSymMap::iterator prev = curr++;
+    for (; curr != addr_to_sym_map.end(); ++curr) {
+      const uint64_t prev_addr = prev->first;
+      const uint64_t curr_addr = curr->first;
+      const typename ElfArch::Sym* const prev_sym = prev->second;
+      const typename ElfArch::Sym* const curr_sym = curr->second;
+      if (prev_addr + prev_sym->st_size <= curr_addr ||
+          // The next condition is true if two symbols overlap like this:
+          //
+          //   Previous symbol  |----------------------------|
+          //   Current symbol     |-------------------------------|
+          //
+          // These symbols are not found in google3 codebase, but in
+          // jdk1.6.0_01_gg1/jre/lib/i386/server/libjvm.so.
+          //
+          // 0619e040 00000046 t CardTableModRefBS::write_region_work()
+          // 0619e070 00000046 t CardTableModRefBS::write_ref_array_work()
+          //
+          // We allow overlapped symbols rather than ignore these.
+          // Due to the way SymbolMap::GetSymbolAtPosition() works,
+          // lookup for any address in [curr_addr, curr_addr + its size)
+          // (e.g. 0619e071) will produce the current symbol,
+          // which is the desired outcome.
+          prev_addr + prev_sym->st_size < curr_addr + curr_sym->st_size) {
+        const char* name = string_section->GetOffset(curr_sym->st_name);
+        symbols->AddSymbol(name, curr_addr, curr_sym->st_size);
+        prev = curr;
+      } else {
+        // Current symbol is "nested" inside previous one like this:
+        //
+        //   Previous symbol  |----------------------------|
+        //   Current symbol     |---------------------|
+        //
+        // This happens within glibc, e.g. __read_nocancel is nested
+        // "inside" __read. Ignore "inner" symbol.
+        //DCHECK_LE(curr_addr + curr_sym->st_size,
+        //          prev_addr + prev_sym->st_size);
+        ;
+      }
+    }
+  }
+*/
+
+  void VisitSymbols(typename ElfArch::Word section_type,
+                    ElfReader::SymbolSink* sink) {
+    VisitSymbols(section_type, sink, -1, -1, false);
+  }
+
+  void VisitSymbols(typename ElfArch::Word section_type,
+                    ElfReader::SymbolSink* sink,
+                    int symbol_binding,
+                    int symbol_type,
+                    bool get_raw_symbol_values) {
+    for (SymbolIterator<ElfArch> it(this, section_type);
+         !it.done(); it.Next()) {
+      const char* name = it.GetSymbolName();
+      if (!name) continue;
+      const typename ElfArch::Sym* sym = it.GetSymbol();
+      if ((symbol_binding < 0 || ElfArch::Bind(sym) == symbol_binding) &&
+          (symbol_type < 0 || ElfArch::Type(sym) == symbol_type)) {
+        typename ElfArch::Sym symbol = *sym;
+        // Add a PLT symbol in addition to the main undefined symbol.
+        // Only do this for SHT_DYNSYM, because PLT symbols are dynamic.
+        int symbol_index = it.GetCurrentSymbolIndex();
+        // TODO(dthomson): Can be removed once all Java code is using the
+        // Google3 launcher.
+        if (section_type == SHT_DYNSYM &&
+            static_cast<unsigned int>(symbol_index) < symbols_plt_offsets_.size() &&
+            symbols_plt_offsets_[symbol_index] != 0) {
+          string plt_name = string(name) + kPLTFunctionSuffix;
+          if (plt_function_names_[symbol_index].empty()) {
+            plt_function_names_[symbol_index] = plt_name;
+          } else if (plt_function_names_[symbol_index] != plt_name) {
+		;
+          }
+          sink->AddSymbol(plt_function_names_[symbol_index].c_str(),
+                          symbols_plt_offsets_[it.GetCurrentSymbolIndex()],
+                          plt_code_size_);
+        }
+        if (!get_raw_symbol_values)
+          AdjustSymbolValue(&symbol);
+        sink->AddSymbol(name, symbol.st_value, symbol.st_size);
+      }
+    }
+  }
+
+  void VisitRelocationEntries() {
+    if (visited_relocation_entries_) {
+      return;
+    }
+    visited_relocation_entries_ = true;
+
+    if (!plts_supported_) {
+      return;
+    }
+    // First determine if PLTs exist. If not, then there is nothing to do.
+    ElfReader::SectionInfo plt_section_info;
+    const char* plt_section =
+        GetSectionInfoByName(kElfPLTSectionName, &plt_section_info);
+    if (!plt_section) {
+      return;
+    }
+    if (plt_section_info.size == 0) {
+      return;
+    }
+
+    // The PLTs could be referenced by either a Rel or Rela (Rel with Addend)
+    // section.
+    ElfReader::SectionInfo rel_section_info;
+    ElfReader::SectionInfo rela_section_info;
+    const char* rel_section =
+        GetSectionInfoByName(kElfPLTRelSectionName, &rel_section_info);
+    const char* rela_section =
+        GetSectionInfoByName(kElfPLTRelaSectionName, &rela_section_info);
+
+    const typename ElfArch::Rel* rel =
+        reinterpret_cast<const typename ElfArch::Rel*>(rel_section);
+    const typename ElfArch::Rela* rela =
+        reinterpret_cast<const typename ElfArch::Rela*>(rela_section);
+
+    if (!rel_section && !rela_section) {
+      return;
+    }
+
+    // Use either Rel or Rela section, depending on which one exists.
+    size_t section_size = rel_section ? rel_section_info.size
+                                      : rela_section_info.size;
+    size_t entry_size = rel_section ? sizeof(typename ElfArch::Rel)
+                                    : sizeof(typename ElfArch::Rela);
+
+    // Determine the number of entries in the dynamic symbol table.
+    ElfReader::SectionInfo dynsym_section_info;
+    const char* dynsym_section =
+        GetSectionInfoByName(kElfDynSymSectionName, &dynsym_section_info);
+    // The dynsym section might not exist, or it might be empty. In either case
+    // there is nothing to be done so return.
+    if (!dynsym_section || dynsym_section_info.size == 0) {
+      return;
+    }
+    size_t num_dynamic_symbols =
+        dynsym_section_info.size / dynsym_section_info.entsize;
+    symbols_plt_offsets_.resize(num_dynamic_symbols, 0);
+
+    // TODO(dthomson): Can be removed once all Java code is using the
+    // Google3 launcher.
+    // Make storage room for PLT function name strings.
+    plt_function_names_.resize(num_dynamic_symbols);
+
+    for (size_t i = 0; i < section_size / entry_size; ++i) {
+      // Determine symbol index from the |r_info| field.
+      int sym_index = ElfArch::r_sym(rel_section ? rel[i].r_info
+                                                 : rela[i].r_info);
+      if (static_cast<unsigned int>(sym_index) >= symbols_plt_offsets_.size()) {
+        continue;
+      }
+      symbols_plt_offsets_[sym_index] =
+          plt_section_info.addr + plt0_size_ + i * plt_code_size_;
+    }
+  }
+
+  // Return an ElfSectionReader for the first section of the given
+  // type by iterating through all section headers. Returns NULL if
+  // the section type is not found.
+  const ElfSectionReader<ElfArch>* GetSectionByType(
+      typename ElfArch::Word section_type) {
+    for (unsigned int k = 0u; k < GetNumSections(); ++k) {
+      if (section_headers_[k].sh_type == section_type) {
+        return GetSection(k);
+      }
+    }
+    return NULL;
+  }
+
+  // Return the name of section "shndx".  Returns NULL if the section
+  // is not found.
+  const char* GetSectionNameByIndex(int shndx) {
+    return GetSectionName(section_headers_[shndx].sh_name);
+  }
+
+  // Return a pointer to section "shndx", and store the size in
+  // "size".  Returns NULL if the section is not found.
+  const char* GetSectionContentsByIndex(int shndx, size_t* size) {
+    const ElfSectionReader<ElfArch>* section = GetSection(shndx);
+    if (section != NULL) {
+      *size = section->section_size();
+      return section->contents();
+    }
+    return NULL;
+  }
+
+  // Return a pointer to the first section of the given name by
+  // iterating through all section headers, and store the size in
+  // "size".  Returns NULL if the section name is not found.
+  const char* GetSectionContentsByName(const string& section_name,
+                                       size_t* size) {
+    for (unsigned int k = 0u; k < GetNumSections(); ++k) {
+      // When searching for sections in a .dwp file, the sections
+      // we're looking for will always be at the end of the section
+      // table, so reverse the direction of iteration.
+      int shndx = is_dwp_ ? GetNumSections() - k - 1 : k;
+      const char* name = GetSectionName(section_headers_[shndx].sh_name);
+      if (name != NULL && ElfReader::SectionNamesMatch(section_name, name)) {
+        const ElfSectionReader<ElfArch>* section = GetSection(shndx);
+        if (section == NULL) {
+          return NULL;
+        } else {
+          *size = section->section_size();
+          return section->contents();
+        }
+      }
+    }
+    return NULL;
+  }
+
+  // This is like GetSectionContentsByName() but it returns a lot of extra
+  // information about the section.
+  const char* GetSectionInfoByName(const string& section_name,
+                                   ElfReader::SectionInfo* info) {
+    for (unsigned int k = 0u; k < GetNumSections(); ++k) {
+      // When searching for sections in a .dwp file, the sections
+      // we're looking for will always be at the end of the section
+      // table, so reverse the direction of iteration.
+      int shndx = is_dwp_ ? GetNumSections() - k - 1 : k;
+      const char* name = GetSectionName(section_headers_[shndx].sh_name);
+      if (name != NULL && ElfReader::SectionNamesMatch(section_name, name)) {
+        const ElfSectionReader<ElfArch>* section = GetSection(shndx);
+        if (section == NULL) {
+          return NULL;
+        } else {
+          info->type = section->header().sh_type;
+          info->flags = section->header().sh_flags;
+          info->addr = section->header().sh_addr;
+          info->offset = section->header().sh_offset;
+          info->size = section->header().sh_size;
+          info->link = section->header().sh_link;
+          info->info = section->header().sh_info;
+          info->addralign = section->header().sh_addralign;
+          info->entsize = section->header().sh_entsize;
+          return section->contents();
+        }
+      }
+    }
+    return NULL;
+  }
+
+  // p_vaddr of the first PT_LOAD segment (if any), or 0 if no PT_LOAD
+  // segments are present. This is the address an ELF image was linked
+  // (by static linker) to be loaded at. Usually (but not always) 0 for
+  // shared libraries and position-independent executables.
+  uint64_t VaddrOfFirstLoadSegment() const {
+    // Relocatable objects (of type ET_REL) do not have LOAD segments.
+    if (header_.e_type == ET_REL) {
+      return 0;
+    }
+    for (int i = 0; i < GetNumProgramHeaders(); ++i) {
+      if (program_headers_[i].p_type == PT_LOAD) {
+        return program_headers_[i].p_vaddr;
+      }
+    }
+    return 0;
+  }
+
+  // According to the LSB ("ELF special sections"), sections with debug
+  // info are prefixed by ".debug".  The names are not specified, but they
+  // look like ".debug_line", ".debug_info", etc.
+  bool HasDebugSections() {
+    // Debug sections are likely to be near the end, so reverse the
+    // direction of iteration.
+    for (int k = GetNumSections() - 1; k >= 0; --k) {
+      const char* name = GetSectionName(section_headers_[k].sh_name);
+      if (strncmp(name, ".debug", strlen(".debug")) == 0) return true;
+      if (strncmp(name, ".zdebug", strlen(".zdebug")) == 0) return true;
+    }
+    return false;
+  }
+
+  bool IsDynamicSharedObject() const {
+    return header_.e_type == ET_DYN;
+  }
+
+  // Return the number of sections.
+  uint64_t GetNumSections() const {
+    if (HasManySections())
+      return first_section_header_.sh_size;
+    return header_.e_shnum;
+  }
+
+ private:
+  typedef vector<pair<uint64_t, const typename ElfArch::Sym*> > AddrToSymMap;
+
+  static bool AddrToSymSorter(const typename AddrToSymMap::value_type& lhs,
+                              const typename AddrToSymMap::value_type& rhs) {
+    return lhs.first < rhs.first;
+  }
+
+  static bool AddrToSymEquals(const typename AddrToSymMap::value_type& lhs,
+                              const typename AddrToSymMap::value_type& rhs) {
+    return lhs.first == rhs.first;
+  }
+
+  // Does this ELF file have too many sections to fit in the program header?
+  bool HasManySections() const {
+    return header_.e_shnum == SHN_UNDEF;
+  }
+
+  // Return the number of program headers.
+  int GetNumProgramHeaders() const {
+    if (HasManySections() && header_.e_phnum == 0xffff &&
+        first_section_header_.sh_info != 0)
+      return first_section_header_.sh_info;
+    return header_.e_phnum;
+  }
+
+  // Return the index of the string table.
+  int GetStringTableIndex() const {
+    if (HasManySections()) {
+      if (header_.e_shstrndx == 0xffff)
+        return first_section_header_.sh_link;
+      else if (header_.e_shstrndx >= GetNumSections())
+        return 0;
+    }
+    return header_.e_shstrndx;
+  }
+
+  // Given an offset into the section header string table, return the
+  // section name.
+  const char* GetSectionName(typename ElfArch::Word sh_name) {
+    const ElfSectionReader<ElfArch>* shstrtab =
+        GetSection(GetStringTableIndex());
+    if (shstrtab != NULL) {
+      return shstrtab->GetOffset(sh_name);
+    }
+    return NULL;
+  }
+
+  // Return an ElfSectionReader for the given section. The reader will
+  // be freed when this object is destroyed.
+  const ElfSectionReader<ElfArch>* GetSection(int num) {
+    const char* name;
+    // Hard-coding the name for the section-name string table prevents
+    // infinite recursion.
+    if (num == GetStringTableIndex())
+      name = ".shstrtab";
+    else
+      name = GetSectionNameByIndex(num);
+    ElfSectionReader<ElfArch>*& reader = sections_[num];
+    if (reader == NULL)
+      reader = new ElfSectionReader<ElfArch>(name, path_, fd_,
+                                             section_headers_[num]);
+    return reader;
+  }
+
+  // Parse out the overall header information from the file and assert
+  // that it looks sane. This contains information like the magic
+  // number and target architecture.
+  bool ParseHeaders(int fd, const string& path) {
+    // Read in the global ELF header.
+    if (pread(fd, &header_, sizeof(header_), 0) != sizeof(header_)) {
+      return false;
+    }
+
+    // Must be an executable, dynamic shared object or relocatable object
+    if (header_.e_type != ET_EXEC &&
+        header_.e_type != ET_DYN &&
+        header_.e_type != ET_REL) {
+      return false;
+    }
+    // Need a section header.
+    if (header_.e_shoff == 0) {
+      return false;
+    }
+
+    if (header_.e_shnum == SHN_UNDEF) {
+      // The number of sections in the program header is only a 16-bit value. In
+      // the event of overflow (greater than SHN_LORESERVE sections), e_shnum
+      // will read SHN_UNDEF and the true number of section header table entries
+      // is found in the sh_size field of the first section header.
+      // See: http://www.sco.com/developers/gabi/2003-12-17/ch4.sheader.html
+      if (pread(fd, &first_section_header_, sizeof(first_section_header_),
+                header_.e_shoff) != sizeof(first_section_header_)) {
+        return false;
+      }
+    }
+
+    // Dynamically allocate enough space to store the section headers
+    // and read them out of the file.
+    const int section_headers_size =
+        GetNumSections() * sizeof(*section_headers_);
+    section_headers_ = new typename ElfArch::Shdr[section_headers_size];
+    if (pread(fd, section_headers_, section_headers_size, header_.e_shoff) !=
+        section_headers_size) {
+      return false;
+    }
+
+    // Dynamically allocate enough space to store the program headers
+    // and read them out of the file.
+    //const int program_headers_size =
+    //    GetNumProgramHeaders() * sizeof(*program_headers_);
+    program_headers_ = new typename ElfArch::Phdr[GetNumProgramHeaders()];
+
+    // Presize the sections array for efficiency.
+    sections_.resize(GetNumSections(), NULL);
+    return true;
+  }
+
+  // Given the "value" of a function descriptor return the address of the
+  // function (i.e. the dereferenced value). Otherwise return "value".
+  uint64_t AdjustPPC64FunctionDescriptorSymbolValue(uint64_t value) {
+    if (opd_section_ != NULL &&
+        opd_info_.addr <= value &&
+        value < opd_info_.addr + opd_info_.size) {
+      uint64_t offset = value - opd_info_.addr;
+      return (*reinterpret_cast<const uint64_t*>(opd_section_ + offset));
+    }
+    return value;
+  }
+
+  void AdjustSymbolValue(typename ElfArch::Sym* sym) {
+    switch (header_.e_machine) {
+    case EM_ARM:
+      // For ARM architecture, if the LSB of the function symbol offset is set,
+      // it indicates a Thumb function.  This bit should not be taken literally.
+      // Clear it.
+      if (ElfArch::Type(sym) == STT_FUNC)
+        sym->st_value = AdjustARMThumbSymbolValue(sym->st_value);
+      break;
+    case EM_386:
+      // No adjustment needed for Intel x86 architecture.  However, explicitly
+      // define this case as we use it quite often.
+      break;
+    case EM_PPC64:
+      // PowerPC64 currently has function descriptors as part of the ABI.
+      // Function symbols need to be adjusted accordingly.
+      if (ElfArch::Type(sym) == STT_FUNC)
+        sym->st_value = AdjustPPC64FunctionDescriptorSymbolValue(sym->st_value);
+      break;
+    default:
+      break;
+    }
+  }
+
+  friend class SymbolIterator<ElfArch>;
+
+  // The file we're reading.
+  const string path_;
+  // Open file descriptor for path_. Not owned by this object.
+  const int fd_;
+
+  // The global header of the ELF file.
+  typename ElfArch::Ehdr header_;
+
+  // The header of the first section. This may be used to supplement the ELF
+  // file header.
+  typename ElfArch::Shdr first_section_header_;
+
+  // Array of GetNumSections() section headers, allocated when we read
+  // in the global header.
+  typename ElfArch::Shdr* section_headers_;
+
+  // Array of GetNumProgramHeaders() program headers, allocated when we read
+  // in the global header.
+  typename ElfArch::Phdr* program_headers_;
+
+  // An array of pointers to ElfSectionReaders. Sections are
+  // mmaped as they're needed and not released until this object is
+  // destroyed.
+  vector<ElfSectionReader<ElfArch>*> sections_;
+
+  // For PowerPC64 we need to keep track of function descriptors when looking up
+  // values for funtion symbols values. Function descriptors are kept in the
+  // .opd section and are dereferenced to find the function address.
+  ElfReader::SectionInfo opd_info_;
+  const char* opd_section_;  // Must be checked for NULL before use.
+  int64_t base_for_text_;
+
+  // Read PLT-related sections for the current architecture.
+  bool plts_supported_;
+  // Code size of each PLT function for the current architecture.
+  size_t plt_code_size_;
+  // Size of the special first entry in the .plt section that calls the runtime
+  // loader resolution routine, and that all other entries jump to when doing
+  // lazy symbol binding.
+  size_t plt0_size_;
+
+  // Maps a dynamic symbol index to a PLT offset.
+  // The vector entry index is the dynamic symbol index.
+  std::vector<uint64_t> symbols_plt_offsets_;
+
+  // Container for PLT function name strings. These strings are passed by
+  // reference to SymbolSink::AddSymbol() so they need to be stored somewhere.
+  std::vector<string> plt_function_names_;
+
+  bool visited_relocation_entries_;
+
+  // True if this is a .dwp file.
+  bool is_dwp_;
+};
+
+ElfReader::ElfReader(const string& path)
+    : path_(path), fd_(-1), impl32_(NULL), impl64_(NULL) {
+  // linux 2.6.XX kernel can show deleted files like this:
+  //   /var/run/nscd/dbYLJYaE (deleted)
+  // and the kernel-supplied vdso and vsyscall mappings like this:
+  //   [vdso]
+  //   [vsyscall]
+  if (MyHasSuffixString(path, " (deleted)"))
+    return;
+  if (path == "[vdso]")
+    return;
+  if (path == "[vsyscall]")
+    return;
+
+  fd_ = open(path.c_str(), O_RDONLY);
+}
+
+ElfReader::~ElfReader() {
+  if (fd_ != -1)
+    close(fd_);
+  if (impl32_ != NULL)
+    delete impl32_;
+  if (impl64_ != NULL)
+    delete impl64_;
+}
+
+
+// The only word-size specific part of this file is IsNativeElfFile().
+#if ULONG_MAX == 0xffffffff
+#define NATIVE_ELF_ARCH Elf32
+#elif ULONG_MAX == 0xffffffffffffffff
+#define NATIVE_ELF_ARCH Elf64
+#else
+#error "Invalid word size"
+#endif
+
+template <typename ElfArch>
+static bool IsElfFile(const int fd, const string& path) {
+  if (fd < 0)
+    return false;
+  if (!ElfReaderImpl<ElfArch>::IsArchElfFile(fd, NULL)) {
+    // No error message here.  IsElfFile gets called many times.
+    return false;
+  }
+  return true;
+}
+
+bool ElfReader::IsNativeElfFile() const {
+  return IsElfFile<NATIVE_ELF_ARCH>(fd_, path_);
+}
+
+bool ElfReader::IsElf32File() const {
+  return IsElfFile<Elf32>(fd_, path_);
+}
+
+bool ElfReader::IsElf64File() const {
+  return IsElfFile<Elf64>(fd_, path_);
+}
+
+/*
+void ElfReader::AddSymbols(SymbolMap* symbols,
+                           uint64_t mem_offset, uint64_t file_offset,
+                           uint64_t length) {
+  if (fd_ < 0)
+    return;
+  // TODO(chatham): Actually use the information about file offset and
+  // the length of the mapped section. On some machines the data
+  // section gets mapped as executable, and we'll end up reading the
+  // file twice and getting some of the offsets wrong.
+  if (IsElf32File()) {
+    GetImpl32()->GetSymbolPositions(symbols, SHT_SYMTAB,
+                                    mem_offset, file_offset);
+    GetImpl32()->GetSymbolPositions(symbols, SHT_DYNSYM,
+                                    mem_offset, file_offset);
+  } else if (IsElf64File()) {
+    GetImpl64()->GetSymbolPositions(symbols, SHT_SYMTAB,
+                                    mem_offset, file_offset);
+    GetImpl64()->GetSymbolPositions(symbols, SHT_DYNSYM,
+                                    mem_offset, file_offset);
+  }
+}
+*/
+
+void ElfReader::VisitSymbols(ElfReader::SymbolSink* sink) {
+  VisitSymbols(sink, -1, -1);
+}
+
+void ElfReader::VisitSymbols(ElfReader::SymbolSink* sink,
+                             int symbol_binding,
+                             int symbol_type) {
+  VisitSymbols(sink, symbol_binding, symbol_type, false);
+}
+
+void ElfReader::VisitSymbols(ElfReader::SymbolSink* sink,
+                             int symbol_binding,
+                             int symbol_type,
+                             bool get_raw_symbol_values) {
+  if (IsElf32File()) {
+    GetImpl32()->VisitRelocationEntries();
+    GetImpl32()->VisitSymbols(SHT_SYMTAB, sink, symbol_binding, symbol_type,
+                              get_raw_symbol_values);
+    GetImpl32()->VisitSymbols(SHT_DYNSYM, sink, symbol_binding, symbol_type,
+                              get_raw_symbol_values);
+  } else if (IsElf64File()) {
+    GetImpl64()->VisitRelocationEntries();
+    GetImpl64()->VisitSymbols(SHT_SYMTAB, sink, symbol_binding, symbol_type,
+                              get_raw_symbol_values);
+    GetImpl64()->VisitSymbols(SHT_DYNSYM, sink, symbol_binding, symbol_type,
+                              get_raw_symbol_values);
+  }
+}
+
+uint64_t ElfReader::VaddrOfFirstLoadSegment() {
+  if (IsElf32File()) {
+    return GetImpl32()->VaddrOfFirstLoadSegment();
+  } else if (IsElf64File()) {
+    return GetImpl64()->VaddrOfFirstLoadSegment();
+  } else {
+    return 0;
+  }
+}
+
+const char* ElfReader::GetSectionName(int shndx) {
+  if (shndx < 0 || static_cast<unsigned int>(shndx) >= GetNumSections()) return NULL;
+  if (IsElf32File()) {
+    return GetImpl32()->GetSectionNameByIndex(shndx);
+  } else if (IsElf64File()) {
+    return GetImpl64()->GetSectionNameByIndex(shndx);
+  } else {
+    return NULL;
+  }
+}
+
+uint64_t ElfReader::GetNumSections() {
+  if (IsElf32File()) {
+    return GetImpl32()->GetNumSections();
+  } else if (IsElf64File()) {
+    return GetImpl64()->GetNumSections();
+  } else {
+    return 0;
+  }
+}
+
+const char* ElfReader::GetSectionByIndex(int shndx, size_t* size) {
+  if (IsElf32File()) {
+    return GetImpl32()->GetSectionContentsByIndex(shndx, size);
+  } else if (IsElf64File()) {
+    return GetImpl64()->GetSectionContentsByIndex(shndx, size);
+  } else {
+    return NULL;
+  }
+}
+
+const char* ElfReader::GetSectionByName(const string& section_name,
+                                        size_t* size) {
+  if (IsElf32File()) {
+    return GetImpl32()->GetSectionContentsByName(section_name, size);
+  } else if (IsElf64File()) {
+    return GetImpl64()->GetSectionContentsByName(section_name, size);
+  } else {
+    return NULL;
+  }
+}
+
+const char* ElfReader::GetSectionInfoByName(const string& section_name,
+                                            SectionInfo* info) {
+  if (IsElf32File()) {
+    return GetImpl32()->GetSectionInfoByName(section_name, info);
+  } else if (IsElf64File()) {
+    return GetImpl64()->GetSectionInfoByName(section_name, info);
+  } else {
+    return NULL;
+  }
+}
+
+bool ElfReader::SectionNamesMatch(const string& name, const string& sh_name) {
+  if ((name.find(".debug_", 0) == 0) && (sh_name.find(".zdebug_", 0) == 0)) {
+    const string name_suffix(name, strlen(".debug_"));
+    const string sh_name_suffix(sh_name, strlen(".zdebug_"));
+    return name_suffix == sh_name_suffix;
+  }
+  return name == sh_name;
+}
+
+bool ElfReader::IsDynamicSharedObject() {
+  if (IsElf32File()) {
+    return GetImpl32()->IsDynamicSharedObject();
+  } else if (IsElf64File()) {
+    return GetImpl64()->IsDynamicSharedObject();
+  } else {
+    return false;
+  }
+}
+
+ElfReaderImpl<Elf32>* ElfReader::GetImpl32() {
+  if (impl32_ == NULL) {
+    impl32_ = new ElfReaderImpl<Elf32>(path_, fd_);
+  }
+  return impl32_;
+}
+
+ElfReaderImpl<Elf64>* ElfReader::GetImpl64() {
+  if (impl64_ == NULL) {
+    impl64_ = new ElfReaderImpl<Elf64>(path_, fd_);
+  }
+  return impl64_;
+}
+
+// Return true if file is an ELF binary of ElfArch, with unstripped
+// debug info (debug_only=true) or symbol table (debug_only=false).
+// Otherwise, return false.
+template <typename ElfArch>
+static bool IsNonStrippedELFBinaryImpl(const string& path, const int fd,
+                                       bool debug_only) {
+  if (!ElfReaderImpl<ElfArch>::IsArchElfFile(fd, NULL)) return false;
+  ElfReaderImpl<ElfArch> elf_reader(path, fd);
+  return debug_only ?
+      elf_reader.HasDebugSections()
+      : (elf_reader.GetSectionByType(SHT_SYMTAB) != NULL);
+}
+
+// Helper for the IsNon[Debug]StrippedELFBinary functions.
+static bool IsNonStrippedELFBinaryHelper(const string& path,
+                                         bool debug_only) {
+  const int fd = open(path.c_str(), O_RDONLY);
+  if (fd == -1) {
+    return false;
+  }
+
+  if (IsNonStrippedELFBinaryImpl<Elf32>(path, fd, debug_only) ||
+      IsNonStrippedELFBinaryImpl<Elf64>(path, fd, debug_only)) {
+    close(fd);
+    return true;
+  }
+  close(fd);
+  return false;
+}
+
+bool ElfReader::IsNonStrippedELFBinary(const string& path) {
+  return IsNonStrippedELFBinaryHelper(path, false);
+}
+
+bool ElfReader::IsNonDebugStrippedELFBinary(const string& path) {
+  return IsNonStrippedELFBinaryHelper(path, true);
+}
+}  // namespace dwarf2reader
diff --git a/src/MEGASync/google_breakpad/common/dwarf/elf_reader.h b/src/MEGASync/google_breakpad/common/dwarf/elf_reader.h
new file mode 100644
index 00000000..0aa92285
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/dwarf/elf_reader.h
@@ -0,0 +1,167 @@
+// Copyright 2005 Google Inc. All Rights Reserved.
+// Author: chatham@google.com (Andrew Chatham)
+// Author: satorux@google.com (Satoru Takabayashi)
+//
+// ElfReader handles reading in ELF. It can extract symbols from the
+// current process, which may be used to symbolize stack traces
+// without having to make a potentially dangerous call to fork().
+//
+// ElfReader dynamically allocates memory, so it is not appropriate to
+// use once the address space might be corrupted, such as during
+// process death.
+//
+// ElfReader supports both 32-bit and 64-bit ELF binaries.
+
+#ifndef COMMON_DWARF_ELF_READER_H__
+#define COMMON_DWARF_ELF_READER_H__
+
+#include <string>
+#include <vector>
+
+#include "common/dwarf/types.h"
+#include "common/using_std_string.h"
+
+using std::vector;
+using std::pair;
+
+namespace dwarf2reader {
+
+class SymbolMap;
+class Elf32;
+class Elf64;
+template<typename ElfArch>
+class ElfReaderImpl;
+
+class ElfReader {
+ public:
+  explicit ElfReader(const string& path);
+  ~ElfReader();
+
+  // Parse the ELF prologue of this file and return whether it was
+  // successfully parsed and matches the word size and byte order of
+  // the current process.
+  bool IsNativeElfFile() const;
+
+  // Similar to IsNativeElfFile but checks if it's a 32-bit ELF file.
+  bool IsElf32File() const;
+
+  // Similar to IsNativeElfFile but checks if it's a 64-bit ELF file.
+  bool IsElf64File() const;
+
+  // Checks if it's an ELF file of type ET_DYN (shared object file).
+  bool IsDynamicSharedObject();
+
+  // Add symbols in the given ELF file into the provided SymbolMap,
+  // assuming that the file has been loaded into the specified
+  // offset.
+  //
+  // The remaining arguments are typically taken from a
+  // ProcMapsIterator (base/sysinfo.h) and describe which portions of
+  // the ELF file are mapped into which parts of memory:
+  //
+  // mem_offset - position at which the segment is mapped into memory
+  // file_offset - offset in the file where the mapping begins
+  // length - length of the mapped segment
+  void AddSymbols(SymbolMap* symbols,
+                  uint64_t mem_offset, uint64_t file_offset,
+                  uint64_t length);
+
+  class SymbolSink {
+   public:
+    virtual ~SymbolSink() {}
+    virtual void AddSymbol(const char* name, uint64_t address,
+                           uint64_t size) = 0;
+  };
+
+  // Like AddSymbols above, but with no address correction.
+  // Processes any SHT_SYMTAB section, followed by any SHT_DYNSYM section.
+  void VisitSymbols(SymbolSink* sink);
+
+  // Like VisitSymbols above, but for a specific symbol binding/type.
+  // A negative value for the binding and type parameters means any
+  // binding or type.
+  void VisitSymbols(SymbolSink* sink, int symbol_binding, int symbol_type);
+
+  // Like VisitSymbols above but can optionally export raw symbol values instead
+  // of adjusted ones.
+  void VisitSymbols(SymbolSink* sink, int symbol_binding, int symbol_type,
+                    bool get_raw_symbol_values);
+
+  // p_vaddr of the first PT_LOAD segment (if any), or 0 if no PT_LOAD
+  // segments are present. This is the address an ELF image was linked
+  // (by static linker) to be loaded at. Usually (but not always) 0 for
+  // shared libraries and position-independent executables.
+  uint64_t VaddrOfFirstLoadSegment();
+
+  // Return the name of section "shndx".  Returns NULL if the section
+  // is not found.
+  const char* GetSectionName(int shndx);
+
+  // Return the number of sections in the given ELF file.
+  uint64_t GetNumSections();
+
+  // Get section "shndx" from the given ELF file.  On success, return
+  // the pointer to the section and store the size in "size".
+  // On error, return NULL.  The returned section data is only valid
+  // until the ElfReader gets destroyed.
+  const char* GetSectionByIndex(int shndx, size_t* size);
+
+  // Get section with "section_name" (ex. ".text", ".symtab") in the
+  // given ELF file.  On success, return the pointer to the section
+  // and store the size in "size".  On error, return NULL.  The
+  // returned section data is only valid until the ElfReader gets
+  // destroyed.
+  const char* GetSectionByName(const string& section_name, size_t* size);
+
+  // This is like GetSectionByName() but it returns a lot of extra information
+  // about the section. The SectionInfo structure is almost identical to
+  // the typedef struct Elf64_Shdr defined in <elf.h>, but is redefined
+  // here so that the many short macro names in <elf.h> don't have to be
+  // added to our already cluttered namespace.
+  struct SectionInfo {
+    uint32_t type;              // Section type (SHT_xxx constant from elf.h).
+    uint64_t flags;             // Section flags (SHF_xxx constants from elf.h).
+    uint64_t addr;              // Section virtual address at execution.
+    uint64_t offset;            // Section file offset.
+    uint64_t size;              // Section size in bytes.
+    uint32_t link;              // Link to another section.
+    uint32_t info;              // Additional section information.
+    uint64_t addralign;         // Section alignment.
+    uint64_t entsize;           // Entry size if section holds a table.
+  };
+  const char* GetSectionInfoByName(const string& section_name,
+                                   SectionInfo* info);
+
+  // Check if "path" is an ELF binary that has not been stripped of symbol
+  // tables.  This function supports both 32-bit and 64-bit ELF binaries.
+  static bool IsNonStrippedELFBinary(const string& path);
+
+  // Check if "path" is an ELF binary that has not been stripped of debug
+  // info. Unlike IsNonStrippedELFBinary, this function will return
+  // false for binaries passed through "strip -S".
+  static bool IsNonDebugStrippedELFBinary(const string& path);
+
+  // Match a requested section name with the section name as it
+  // appears in the elf-file, adjusting for compressed debug section
+  // names.  For example, returns true if name == ".debug_abbrev" and
+  // sh_name == ".zdebug_abbrev"
+  static bool SectionNamesMatch(const string& name, const string& sh_name);
+
+ private:
+  // Lazily initialize impl32_ and return it.
+  ElfReaderImpl<Elf32>* GetImpl32();
+  // Ditto for impl64_.
+  ElfReaderImpl<Elf64>* GetImpl64();
+
+  // Path of the file we're reading.
+  const string path_;
+  // Read-only file descriptor for the file. May be -1 if there was an
+  // error during open.
+  int fd_;
+  ElfReaderImpl<Elf32>* impl32_;
+  ElfReaderImpl<Elf64>* impl64_;
+};
+
+}  // namespace dwarf2reader
+
+#endif  // COMMON_DWARF_ELF_READER_H__
diff --git a/src/MEGASync/google_breakpad/common/dwarf/functioninfo.cc b/src/MEGASync/google_breakpad/common/dwarf/functioninfo.cc
index 55a255ed..6b9a92a3 100644
--- a/src/MEGASync/google_breakpad/common/dwarf/functioninfo.cc
+++ b/src/MEGASync/google_breakpad/common/dwarf/functioninfo.cc
@@ -51,26 +51,20 @@ CULineInfoHandler::CULineInfoHandler(std::vector<SourceFileInfo>* files,
                                      LineMap* linemap):linemap_(linemap),
                                                        files_(files),
                                                        dirs_(dirs) {
-  // The dirs and files are 1 indexed, so just make sure we put
-  // nothing in the 0 vector.
-  assert(dirs->size() == 0);
-  assert(files->size() == 0);
-  dirs->push_back("");
-  SourceFileInfo s;
-  s.name = "";
-  s.lowpc = ULLONG_MAX;
-  files->push_back(s);
+  // In dwarf4, the dirs and files are 1 indexed, and in dwarf5 they are zero
+  // indexed. This is handled in the LineInfo reader, so empty files are not
+  // needed here.
 }
 
-void CULineInfoHandler::DefineDir(const string& name, uint32 dir_num) {
+void CULineInfoHandler::DefineDir(const string& name, uint32_t dir_num) {
   // These should never come out of order, actually
   assert(dir_num == dirs_->size());
   dirs_->push_back(name);
 }
 
 void CULineInfoHandler::DefineFile(const string& name,
-                                   int32 file_num, uint32 dir_num,
-                                   uint64 mod_time, uint64 length) {
+                                   int32 file_num, uint32_t dir_num,
+                                   uint64_t mod_time, uint64_t length) {
   assert(dir_num >= 0);
   assert(dir_num < dirs_->size());
 
@@ -93,8 +87,9 @@ void CULineInfoHandler::DefineFile(const string& name,
   }
 }
 
-void CULineInfoHandler::AddLine(uint64 address, uint64 length, uint32 file_num,
-                                uint32 line_num, uint32 column_num) {
+void CULineInfoHandler::AddLine(uint64_t address, uint64_t length,
+                                uint32_t file_num, uint32_t line_num,
+                                uint32_t column_num) {
   if (file_num < files_->size()) {
     linemap_->insert(
         std::make_pair(address,
@@ -109,11 +104,11 @@ void CULineInfoHandler::AddLine(uint64 address, uint64 length, uint32 file_num,
   }
 }
 
-bool CUFunctionInfoHandler::StartCompilationUnit(uint64 offset,
-                                                 uint8 address_size,
-                                                 uint8 offset_size,
-                                                 uint64 cu_length,
-                                                 uint8 dwarf_version) {
+bool CUFunctionInfoHandler::StartCompilationUnit(uint64_t offset,
+                                                 uint8_t address_size,
+                                                 uint8_t offset_size,
+                                                 uint64_t cu_length,
+                                                 uint8_t dwarf_version) {
   current_compilation_unit_offset_ = offset;
   return true;
 }
@@ -123,7 +118,7 @@ bool CUFunctionInfoHandler::StartCompilationUnit(uint64 offset,
 // subroutines. For line info, the DW_AT_stmt_list lives in the
 // compile unit tag.
 
-bool CUFunctionInfoHandler::StartDIE(uint64 offset, enum DwarfTag tag) {
+bool CUFunctionInfoHandler::StartDIE(uint64_t offset, enum DwarfTag tag) {
   switch (tag) {
     case DW_TAG_subprogram:
     case DW_TAG_inlined_subroutine: {
@@ -146,10 +141,10 @@ bool CUFunctionInfoHandler::StartDIE(uint64 offset, enum DwarfTag tag) {
 
 // Only care about the name attribute for functions
 
-void CUFunctionInfoHandler::ProcessAttributeString(uint64 offset,
+void CUFunctionInfoHandler::ProcessAttributeString(uint64_t offset,
                                                    enum DwarfAttribute attr,
                                                    enum DwarfForm form,
-                                                   const string &data) {
+                                                   const string& data) {
   if (current_function_info_) {
     if (attr == DW_AT_name)
       current_function_info_->name = data;
@@ -158,12 +153,13 @@ void CUFunctionInfoHandler::ProcessAttributeString(uint64 offset,
   }
 }
 
-void CUFunctionInfoHandler::ProcessAttributeUnsigned(uint64 offset,
+void CUFunctionInfoHandler::ProcessAttributeUnsigned(uint64_t offset,
                                                      enum DwarfAttribute attr,
                                                      enum DwarfForm form,
-                                                     uint64 data) {
+                                                     uint64_t data) {
   if (attr == DW_AT_stmt_list) {
-    SectionMap::const_iterator iter = sections_.find("__debug_line");
+    SectionMap::const_iterator iter =
+        GetSectionByName(sections_, ".debug_line");
     assert(iter != sections_.end());
 
     scoped_ptr<LineInfo> lireader(new LineInfo(iter->second.first + data,
@@ -184,16 +180,19 @@ void CUFunctionInfoHandler::ProcessAttributeUnsigned(uint64 offset,
       case DW_AT_decl_file:
         current_function_info_->file = files_->at(data).name;
         break;
+      case DW_AT_ranges:
+        current_function_info_->ranges = data;
+        break;
       default:
         break;
     }
   }
 }
 
-void CUFunctionInfoHandler::ProcessAttributeReference(uint64 offset,
+void CUFunctionInfoHandler::ProcessAttributeReference(uint64_t offset,
                                                       enum DwarfAttribute attr,
                                                       enum DwarfForm form,
-                                                      uint64 data) {
+                                                      uint64_t data) {
   if (current_function_info_) {
     switch (attr) {
       case DW_AT_specification: {
@@ -222,7 +221,7 @@ void CUFunctionInfoHandler::ProcessAttributeReference(uint64 offset,
   }
 }
 
-void CUFunctionInfoHandler::EndDIE(uint64 offset) {
+void CUFunctionInfoHandler::EndDIE(uint64_t offset) {
   if (current_function_info_ && current_function_info_->lowpc)
     address_to_funcinfo_->insert(std::make_pair(current_function_info_->lowpc,
                                                 current_function_info_));
diff --git a/src/MEGASync/google_breakpad/common/dwarf/functioninfo.h b/src/MEGASync/google_breakpad/common/dwarf/functioninfo.h
index 0b08a5fc..5c733c6d 100644
--- a/src/MEGASync/google_breakpad/common/dwarf/functioninfo.h
+++ b/src/MEGASync/google_breakpad/common/dwarf/functioninfo.h
@@ -53,18 +53,20 @@ struct FunctionInfo {
   // File containing this function
   string file;
   // Line number for start of function.
-  uint32 line;
+  uint32_t line;
   // Beginning address for this function
-  uint64 lowpc;
+  uint64_t lowpc;
   // End address for this function.
-  uint64 highpc;
+  uint64_t highpc;
+  // Ranges offset
+  uint64_t ranges;
 };
 
 struct SourceFileInfo {
   // Name of the source file name
   string name;
   // Low address of source file name
-  uint64 lowpc;
+  uint64_t lowpc;
 };
 
 typedef std::map<uint64, FunctionInfo*> FunctionMap;
@@ -84,12 +86,12 @@ class CULineInfoHandler: public LineInfoHandler {
 
   // Called when we define a directory.  We just place NAME into dirs_
   // at position DIR_NUM.
-  virtual void DefineDir(const string& name, uint32 dir_num);
+  virtual void DefineDir(const string& name, uint32_t dir_num);
 
   // Called when we define a filename.  We just place
   // concat(dirs_[DIR_NUM], NAME) into files_ at position FILE_NUM.
   virtual void DefineFile(const string& name, int32 file_num,
-                          uint32 dir_num, uint64 mod_time, uint64 length);
+                          uint32_t dir_num, uint64_t mod_time, uint64_t length);
 
 
   // Called when the line info reader has a new line, address pair
@@ -98,8 +100,9 @@ class CULineInfoHandler: public LineInfoHandler {
   // containing the code, LINE_NUM is the line number in that file for
   // the code, and COLUMN_NUM is the column number the code starts at,
   // if we know it (0 otherwise).
-  virtual void AddLine(uint64 address, uint64 length,
-                       uint32 file_num, uint32 line_num, uint32 column_num);
+  virtual void AddLine(uint64_t address, uint64_t length,
+                       uint32_t file_num, uint32_t line_num,
+                       uint32_t column_num);
 
  private:
   LineMap* linemap_;
@@ -129,38 +132,38 @@ class CUFunctionInfoHandler: public Dwarf2Handler {
   // .debug_info section.  We want to see all compilation units, so we
   // always return true.
 
-  virtual bool StartCompilationUnit(uint64 offset, uint8 address_size,
-                                    uint8 offset_size, uint64 cu_length,
-                                    uint8 dwarf_version);
+  virtual bool StartCompilationUnit(uint64_t offset, uint8_t address_size,
+                                    uint8_t offset_size, uint64_t cu_length,
+                                    uint8_t dwarf_version);
 
   // Start to process a DIE at OFFSET from the beginning of the
   // .debug_info section.  We only care about function related DIE's.
-  virtual bool StartDIE(uint64 offset, enum DwarfTag tag);
+  virtual bool StartDIE(uint64_t offset, enum DwarfTag tag);
 
   // Called when we have an attribute with unsigned data to give to
   // our handler.  The attribute is for the DIE at OFFSET from the
   // beginning of the .debug_info section, has a name of ATTR, a form of
   // FORM, and the actual data of the attribute is in DATA.
-  virtual void ProcessAttributeUnsigned(uint64 offset,
+  virtual void ProcessAttributeUnsigned(uint64_t offset,
                                         enum DwarfAttribute attr,
                                         enum DwarfForm form,
-                                        uint64 data);
+                                        uint64_t data);
 
   // Called when we have an attribute with a DIE reference to give to
   // our handler.  The attribute is for the DIE at OFFSET from the
   // beginning of the .debug_info section, has a name of ATTR, a form of
   // FORM, and the offset of the referenced DIE from the start of the
   // .debug_info section is in DATA.
-  virtual void ProcessAttributeReference(uint64 offset,
+  virtual void ProcessAttributeReference(uint64_t offset,
                                          enum DwarfAttribute attr,
                                          enum DwarfForm form,
-                                         uint64 data);
+                                         uint64_t data);
 
   // Called when we have an attribute with string data to give to
   // our handler.  The attribute is for the DIE at OFFSET from the
   // beginning of the .debug_info section, has a name of ATTR, a form of
   // FORM, and the actual data of the attribute is in DATA.
-  virtual void ProcessAttributeString(uint64 offset,
+  virtual void ProcessAttributeString(uint64_t offset,
                                       enum DwarfAttribute attr,
                                       enum DwarfForm form,
                                       const string& data);
@@ -169,7 +172,7 @@ class CUFunctionInfoHandler: public Dwarf2Handler {
   // Because DWARF2/3 specifies a tree of DIEs, you may get starts
   // before ends of the previous DIE, as we process children before
   // ending the parent.
-  virtual void EndDIE(uint64 offset);
+  virtual void EndDIE(uint64_t offset);
 
  private:
   std::vector<SourceFileInfo>* files_;
@@ -181,7 +184,7 @@ class CUFunctionInfoHandler: public Dwarf2Handler {
   const SectionMap& sections_;
   ByteReader* reader_;
   FunctionInfo* current_function_info_;
-  uint64 current_compilation_unit_offset_;
+  uint64_t current_compilation_unit_offset_;
 };
 
 }  // namespace dwarf2reader
diff --git a/src/MEGASync/google_breakpad/common/dwarf/line_state_machine.h b/src/MEGASync/google_breakpad/common/dwarf/line_state_machine.h
index 0ff72abc..fc301c76 100644
--- a/src/MEGASync/google_breakpad/common/dwarf/line_state_machine.h
+++ b/src/MEGASync/google_breakpad/common/dwarf/line_state_machine.h
@@ -46,10 +46,10 @@ struct LineStateMachine {
     end_sequence = false;
   }
 
-  uint32 file_num;
-  uint64 address;
-  uint32 line_num;
-  uint32 column_num;
+  uint32_t file_num;
+  uint64_t address;
+  uint32_t line_num;
+  uint32_t column_num;
   bool is_stmt;  // stmt means statement.
   bool basic_block;
   bool end_sequence;
diff --git a/src/MEGASync/google_breakpad/common/dwarf/types.h b/src/MEGASync/google_breakpad/common/dwarf/types.h
index 61ca4579..23412d0e 100644
--- a/src/MEGASync/google_breakpad/common/dwarf/types.h
+++ b/src/MEGASync/google_breakpad/common/dwarf/types.h
@@ -35,21 +35,7 @@
 
 #include <stdint.h>
 
-typedef signed char         int8;
-typedef short               int16;
-typedef int                 int32;
-typedef long long           int64;
-
-typedef unsigned char      uint8;
-typedef unsigned short     uint16;
-typedef unsigned int       uint32;
-typedef unsigned long long uint64;
-
-#ifdef __PTRDIFF_TYPE__
-typedef          __PTRDIFF_TYPE__ intptr;
-typedef unsigned __PTRDIFF_TYPE__ uintptr;
-#else
-#error "Can't find pointer-sized integral types."
-#endif
+typedef intptr_t           intptr;
+typedef uintptr_t          uintptr;
 
 #endif // _COMMON_DWARF_TYPES_H__
diff --git a/src/MEGASync/google_breakpad/common/dwarf_cfi_to_module.cc b/src/MEGASync/google_breakpad/common/dwarf_cfi_to_module.cc
index d0056f32..eb19c132 100644
--- a/src/MEGASync/google_breakpad/common/dwarf_cfi_to_module.cc
+++ b/src/MEGASync/google_breakpad/common/dwarf_cfi_to_module.cc
@@ -105,6 +105,26 @@ vector<string> DwarfCFIToModule::RegisterNames::ARM() {
   return MakeVector(names, sizeof(names) / sizeof(names[0]));
 }
 
+// Per ARM IHI 0057A, section 3.1
+vector<string> DwarfCFIToModule::RegisterNames::ARM64() {
+  static const char *const names[] = {
+    "x0",  "x1",  "x2",  "x3",  "x4",  "x5",  "x6",  "x7",
+    "x8",  "x9",  "x10", "x11", "x12", "x13", "x14", "x15",
+    "x16", "x17", "x18", "x19", "x20", "x21", "x22", "x23",
+    "x24", "x25", "x26", "x27", "x28", "x29", "x30", "sp",
+    "",    "",    "",    "",    "",    "",    "",    "",
+    "",    "",    "",    "",    "",    "",    "",    "",
+    "",    "",    "",    "",    "",    "",    "",    "",
+    "",    "",    "",    "",    "",    "",    "",    "",
+    "v0",  "v1",  "v2",  "v3",  "v4",  "v5",  "v6",  "v7",
+    "v8",  "v9",  "v10", "v11", "v12", "v13", "v14", "v15",
+    "v16", "v17", "v18", "v19", "v20", "v21", "v22", "v23",
+    "v24", "v25", "v26", "v27", "v28", "v29", "v30", "v31"
+  };
+
+  return MakeVector(names, sizeof(names) / sizeof(names[0]));
+}
+
 vector<string> DwarfCFIToModule::RegisterNames::MIPS() {
   static const char* const kRegisterNames[] = {
     "$zero", "$at",  "$v0",  "$v1",  "$a0",   "$a1",  "$a2",  "$a3",
@@ -118,12 +138,12 @@ vector<string> DwarfCFIToModule::RegisterNames::MIPS() {
     "$f28",  "$f29", "$f30", "$f31", "$fcsr", "$fir"
   };
 
-  return MakeVector(kRegisterNames, 
+  return MakeVector(kRegisterNames,
                     sizeof(kRegisterNames) / sizeof(kRegisterNames[0]));
 }
 
-bool DwarfCFIToModule::Entry(size_t offset, uint64 address, uint64 length,
-                             uint8 version, const string &augmentation,
+bool DwarfCFIToModule::Entry(size_t offset, uint64_t address, uint64_t length,
+                             uint8_t version, const string& augmentation,
                              unsigned return_address) {
   assert(!entry_);
 
@@ -170,12 +190,12 @@ string DwarfCFIToModule::RegisterName(int i) {
 }
 
 void DwarfCFIToModule::Record(Module::Address address, int reg,
-                              const string &rule) {
+                              const string& rule) {
   assert(entry_);
 
   // Place the name in our global set of strings, and then use the string
   // from the set. Even though the assignment looks like a copy, all the
-  // major std::string implementations use reference counting internally,
+  // major string implementations use reference counting internally,
   // so the effect is to have all our data structures share copies of rules
   // whenever possible. Since register names are drawn from a
   // vector<string>, register names are already shared.
@@ -189,20 +209,20 @@ void DwarfCFIToModule::Record(Module::Address address, int reg,
     entry_->rule_changes[address][RegisterName(reg)] = shared_rule;
 }
 
-bool DwarfCFIToModule::UndefinedRule(uint64 address, int reg) {
+bool DwarfCFIToModule::UndefinedRule(uint64_t address, int reg) {
   reporter_->UndefinedNotSupported(entry_offset_, RegisterName(reg));
   // Treat this as a non-fatal error.
   return true;
 }
 
-bool DwarfCFIToModule::SameValueRule(uint64 address, int reg) {
+bool DwarfCFIToModule::SameValueRule(uint64_t address, int reg) {
   ostringstream s;
   s << RegisterName(reg);
   Record(address, reg, s.str());
   return true;
 }
 
-bool DwarfCFIToModule::OffsetRule(uint64 address, int reg,
+bool DwarfCFIToModule::OffsetRule(uint64_t address, int reg,
                                   int base_register, long offset) {
   ostringstream s;
   s << RegisterName(base_register) << " " << offset << " + ^";
@@ -210,7 +230,7 @@ bool DwarfCFIToModule::OffsetRule(uint64 address, int reg,
   return true;
 }
 
-bool DwarfCFIToModule::ValOffsetRule(uint64 address, int reg,
+bool DwarfCFIToModule::ValOffsetRule(uint64_t address, int reg,
                                      int base_register, long offset) {
   ostringstream s;
   s << RegisterName(base_register) << " " << offset << " +";
@@ -218,7 +238,7 @@ bool DwarfCFIToModule::ValOffsetRule(uint64 address, int reg,
   return true;
 }
 
-bool DwarfCFIToModule::RegisterRule(uint64 address, int reg,
+bool DwarfCFIToModule::RegisterRule(uint64_t address, int reg,
                                     int base_register) {
   ostringstream s;
   s << RegisterName(base_register);
@@ -226,15 +246,15 @@ bool DwarfCFIToModule::RegisterRule(uint64 address, int reg,
   return true;
 }
 
-bool DwarfCFIToModule::ExpressionRule(uint64 address, int reg,
-                                      const string &expression) {
+bool DwarfCFIToModule::ExpressionRule(uint64_t address, int reg,
+                                      const string& expression) {
   reporter_->ExpressionsNotSupported(entry_offset_, RegisterName(reg));
   // Treat this as a non-fatal error.
   return true;
 }
 
-bool DwarfCFIToModule::ValExpressionRule(uint64 address, int reg,
-                                         const string &expression) {
+bool DwarfCFIToModule::ValExpressionRule(uint64_t address, int reg,
+                                         const string& expression) {
   reporter_->ExpressionsNotSupported(entry_offset_, RegisterName(reg));
   // Treat this as a non-fatal error.
   return true;
@@ -254,7 +274,7 @@ void DwarfCFIToModule::Reporter::UnnamedRegister(size_t offset, int reg) {
 }
 
 void DwarfCFIToModule::Reporter::UndefinedNotSupported(size_t offset,
-                                                       const string &reg) {
+                                                       const string& reg) {
   fprintf(stderr, "%s, section '%s': "
           "the call frame entry at offset 0x%zx sets the rule for "
           "register '%s' to 'undefined', but the Breakpad symbol file format"
@@ -263,7 +283,7 @@ void DwarfCFIToModule::Reporter::UndefinedNotSupported(size_t offset,
 }
 
 void DwarfCFIToModule::Reporter::ExpressionsNotSupported(size_t offset,
-                                                         const string &reg) {
+                                                         const string& reg) {
   fprintf(stderr, "%s, section '%s': "
           "the call frame entry at offset 0x%zx uses a DWARF expression to"
           " describe how to recover register '%s', "
diff --git a/src/MEGASync/google_breakpad/common/dwarf_cfi_to_module.h b/src/MEGASync/google_breakpad/common/dwarf_cfi_to_module.h
index d5a8b1cc..35bdb5fd 100644
--- a/src/MEGASync/google_breakpad/common/dwarf_cfi_to_module.h
+++ b/src/MEGASync/google_breakpad/common/dwarf_cfi_to_module.h
@@ -71,7 +71,7 @@ class DwarfCFIToModule: public CallFrameInfo::Handler {
     // stream. FILE is the name of the file we're processing, and
     // SECTION is the name of the section within that file that we're
     // looking at (.debug_frame, .eh_frame, etc.).
-    Reporter(const string &file, const string &section)
+    Reporter(const string& file, const string& section)
       : file_(file), section_(section) { }
     virtual ~Reporter() { }
 
@@ -83,13 +83,13 @@ class DwarfCFIToModule: public CallFrameInfo::Handler {
 
     // The DWARF CFI entry at OFFSET says that REG is undefined, but the
     // Breakpad symbol file format cannot express this.
-    virtual void UndefinedNotSupported(size_t offset, const string &reg);
+    virtual void UndefinedNotSupported(size_t offset, const string& reg);
 
     // The DWARF CFI entry at OFFSET says that REG uses a DWARF
     // expression to find its value, but DwarfCFIToModule is not
     // capable of translating DWARF expressions to Breakpad postfix
     // expressions.
-    virtual void ExpressionsNotSupported(size_t offset, const string &reg);
+    virtual void ExpressionsNotSupported(size_t offset, const string& reg);
 
   protected:
     string file_, section_;
@@ -108,14 +108,17 @@ class DwarfCFIToModule: public CallFrameInfo::Handler {
 
     // ARM.
     static vector<string> ARM();
-    
+
+    // ARM64, aka AARCH64.
+    static vector<string> ARM64();
+
     // MIPS.
     static vector<string> MIPS();
 
    private:
     // Given STRINGS, an array of C strings with SIZE elements, return an
     // equivalent vector<string>.
-    static vector<string> MakeVector(const char * const *strings, size_t size);
+    static vector<string> MakeVector(const char* const* strings, size_t size);
   };
 
   // Create a handler for the dwarf2reader::CallFrameInfo parser that
@@ -127,27 +130,27 @@ class DwarfCFIToModule: public CallFrameInfo::Handler {
   //
   // Use REPORTER for reporting problems encountered in the conversion
   // process.
-  DwarfCFIToModule(Module *module, const vector<string> &register_names,
-                   Reporter *reporter)
+  DwarfCFIToModule(Module* module, const vector<string>& register_names,
+                   Reporter* reporter)
       : module_(module), register_names_(register_names), reporter_(reporter),
         entry_(NULL), return_address_(-1), cfa_name_(".cfa"), ra_name_(".ra") {
   }
   virtual ~DwarfCFIToModule() { delete entry_; }
 
-  virtual bool Entry(size_t offset, uint64 address, uint64 length,
-                     uint8 version, const string &augmentation,
+  virtual bool Entry(size_t offset, uint64_t address, uint64_t length,
+                     uint8_t version, const string& augmentation,
                      unsigned return_address);
-  virtual bool UndefinedRule(uint64 address, int reg);
-  virtual bool SameValueRule(uint64 address, int reg);
-  virtual bool OffsetRule(uint64 address, int reg,
+  virtual bool UndefinedRule(uint64_t address, int reg);
+  virtual bool SameValueRule(uint64_t address, int reg);
+  virtual bool OffsetRule(uint64_t address, int reg,
                           int base_register, long offset);
-  virtual bool ValOffsetRule(uint64 address, int reg,
+  virtual bool ValOffsetRule(uint64_t address, int reg,
                              int base_register, long offset);
-  virtual bool RegisterRule(uint64 address, int reg, int base_register);
-  virtual bool ExpressionRule(uint64 address, int reg,
-                              const string &expression);
-  virtual bool ValExpressionRule(uint64 address, int reg,
-                                 const string &expression);
+  virtual bool RegisterRule(uint64_t address, int reg, int base_register);
+  virtual bool ExpressionRule(uint64_t address, int reg,
+                              const string& expression);
+  virtual bool ValExpressionRule(uint64_t address, int reg,
+                                 const string& expression);
   virtual bool End();
 
  private:
@@ -155,19 +158,19 @@ class DwarfCFIToModule: public CallFrameInfo::Handler {
   string RegisterName(int i);
 
   // Record RULE for register REG at ADDRESS.
-  void Record(Module::Address address, int reg, const string &rule);
+  void Record(Module::Address address, int reg, const string& rule);
 
   // The module to which we should add entries.
-  Module *module_;
+  Module* module_;
 
   // Map from register numbers to register names.
-  const vector<string> &register_names_;
+  const vector<string>& register_names_;
 
   // The reporter to use to report problems.
-  Reporter *reporter_;
+  Reporter* reporter_;
 
   // The current entry we're constructing.
-  Module::StackFrameEntry *entry_;
+  Module::StackFrameEntry* entry_;
 
   // The section offset of the current frame description entry, for
   // use in error messages.
@@ -178,15 +181,15 @@ class DwarfCFIToModule: public CallFrameInfo::Handler {
 
   // The names of the return address and canonical frame address. Putting
   // these here instead of using string literals allows us to share their
-  // texts in reference-counted std::string implementations (all the
+  // texts in reference-counted string implementations (all the
   // popular ones). Many, many rules cite these strings.
   string cfa_name_, ra_name_;
 
   // A set of strings used by this CFI. Before storing a string in one of
   // our data structures, insert it into this set, and then use the string
   // from the set.
-  // 
-  // Because std::string uses reference counting internally, simply using
+  //
+  // Because string uses reference counting internally, simply using
   // strings from this set, even if passed by value, assigned, or held
   // directly in structures and containers (map<string, ...>, for example),
   // causes those strings to share a single instance of each distinct piece
diff --git a/src/MEGASync/google_breakpad/common/dwarf_cfi_to_module_unittest.cc b/src/MEGASync/google_breakpad/common/dwarf_cfi_to_module_unittest.cc
index 807d1b20..58c3cca3 100644
--- a/src/MEGASync/google_breakpad/common/dwarf_cfi_to_module_unittest.cc
+++ b/src/MEGASync/google_breakpad/common/dwarf_cfi_to_module_unittest.cc
@@ -47,11 +47,11 @@ using testing::Test;
 using testing::_;
 
 struct MockCFIReporter: public DwarfCFIToModule::Reporter {
-  MockCFIReporter(const string &file, const string &section)
+  MockCFIReporter(const string& file, const string& section)
       : Reporter(file, section) { }
   MOCK_METHOD2(UnnamedRegister, void(size_t offset, int reg));
-  MOCK_METHOD2(UndefinedNotSupported, void(size_t offset, const string &reg));
-  MOCK_METHOD2(ExpressionsNotSupported, void(size_t offset, const string &reg));
+  MOCK_METHOD2(UndefinedNotSupported, void(size_t offset, const string& reg));
+  MOCK_METHOD2(ExpressionsNotSupported, void(size_t offset, const string& reg));
 };
 
 struct DwarfCFIToModuleFixture {
@@ -80,7 +80,7 @@ struct DwarfCFIToModuleFixture {
   vector<string> register_names;
   MockCFIReporter reporter;
   DwarfCFIToModule handler;
-  vector<Module::StackFrameEntry *> entries;
+  vector<Module::StackFrameEntry*> entries;
 };
 
 class Entry: public DwarfCFIToModuleFixture, public Test { };
@@ -125,7 +125,7 @@ struct RuleFixture: public DwarfCFIToModuleFixture {
     EXPECT_EQ(entry_address, entries[0]->address);
     EXPECT_EQ(entry_size, entries[0]->size);
   }
-  uint64 entry_address, entry_size;
+  uint64_t entry_address, entry_size;
   unsigned return_reg;
 };
 
diff --git a/src/MEGASync/google_breakpad/common/dwarf_cu_to_module.cc b/src/MEGASync/google_breakpad/common/dwarf_cu_to_module.cc
index 8246daf9..a5bc7d6c 100644
--- a/src/MEGASync/google_breakpad/common/dwarf_cu_to_module.cc
+++ b/src/MEGASync/google_breakpad/common/dwarf_cu_to_module.cc
@@ -39,23 +39,23 @@
 #include "common/dwarf_cu_to_module.h"
 
 #include <assert.h>
-#if !defined(__ANDROID__)
-#include <cxxabi.h>
-#endif
 #include <inttypes.h>
+#include <stdint.h>
 #include <stdio.h>
 
 #include <algorithm>
-#include <set>
+#include <numeric>
 #include <utility>
 
 #include "common/dwarf_line_to_module.h"
+#include "common/unordered.h"
+#include "google_breakpad/common/breakpad_types.h"
 
 namespace google_breakpad {
 
+using std::accumulate;
 using std::map;
 using std::pair;
-using std::set;
 using std::sort;
 using std::vector;
 
@@ -96,7 +96,7 @@ struct AbstractOrigin {
   string name;
 };
 
-typedef map<uint64, AbstractOrigin> AbstractOriginByOffset;
+typedef map<uint64_t, AbstractOrigin> AbstractOriginByOffset;
 
 // Data global to the DWARF-bearing file that is private to the
 // DWARF-to-Module process.
@@ -118,7 +118,7 @@ struct DwarfCUToModule::FilePrivate {
   // so this set will actually hold yet another copy of the string (although
   // everything will still work). To improve memory consumption portably,
   // we will probably need to use pointers to strings held in this set.
-  set<string> common_strings;
+  unordered_set<string> common_strings;
 
   // A map from offsets of DIEs within the .debug_info section to
   // Specifications describing those DIEs. Specification references can
@@ -128,8 +128,8 @@ struct DwarfCUToModule::FilePrivate {
   AbstractOriginByOffset origins;
 };
 
-DwarfCUToModule::FileContext::FileContext(const string &filename,
-                                          Module *module,
+DwarfCUToModule::FileContext::FileContext(const string& filename,
+                                          Module* module,
                                           bool handle_inter_cu_refs)
     : filename_(filename),
       module_(module),
@@ -141,7 +141,7 @@ DwarfCUToModule::FileContext::~FileContext() {
 }
 
 void DwarfCUToModule::FileContext::AddSectionToSectionMap(
-    const string& name, const char* contents, uint64 length) {
+    const string& name, const uint8_t* contents, uint64_t length) {
   section_map_[name] = std::make_pair(contents, length);
 }
 
@@ -160,7 +160,7 @@ void DwarfCUToModule::FileContext::ClearSpecifications() {
 }
 
 bool DwarfCUToModule::FileContext::IsUnhandledInterCUReference(
-    uint64 offset, uint64 compilation_unit_start) const {
+    uint64_t offset, uint64_t compilation_unit_start) const {
   if (handle_inter_cu_refs_)
     return false;
   return offset < compilation_unit_start;
@@ -170,33 +170,52 @@ bool DwarfCUToModule::FileContext::IsUnhandledInterCUReference(
 // parsing. This is for data shared across the CU's entire DIE tree,
 // and parameters from the code invoking the CU parser.
 struct DwarfCUToModule::CUContext {
-  CUContext(FileContext *file_context_arg, WarningReporter *reporter_arg)
+  CUContext(FileContext* file_context_arg, WarningReporter* reporter_arg,
+            RangesHandler* ranges_handler_arg)
       : file_context(file_context_arg),
         reporter(reporter_arg),
-        language(Language::CPlusPlus) {}
+        ranges_handler(ranges_handler_arg),
+        language(Language::CPlusPlus),
+        low_pc(0),
+        high_pc(0),
+        ranges(0) {}
 
   ~CUContext() {
-    for (vector<Module::Function *>::iterator it = functions.begin();
+    for (vector<Module::Function*>::iterator it = functions.begin();
          it != functions.end(); ++it) {
       delete *it;
     }
   };
 
   // The DWARF-bearing file into which this CU was incorporated.
-  FileContext *file_context;
+  FileContext* file_context;
 
   // For printing error messages.
-  WarningReporter *reporter;
+  WarningReporter* reporter;
+
+  // For reading ranges from the .debug_ranges section
+  RangesHandler* ranges_handler;
 
   // The source language of this compilation unit.
-  const Language *language;
+  const Language* language;
+
+  // Addresses covered by this CU. If high_pc_ is non-zero then the CU covers
+  // low_pc to high_pc, otherwise ranges is non-zero and low_pc represents
+  // the base address of the ranges covered by the CU.
+  uint64_t low_pc;
+  uint64_t high_pc;
+  uint64_t ranges;
 
   // The functions defined in this compilation unit. We accumulate
   // them here during parsing. Then, in DwarfCUToModule::Finish, we
   // assign them lines and add them to file_context->module.
   //
   // Destroying this destroys all the functions this vector points to.
-  vector<Module::Function *> functions;
+  vector<Module::Function*> functions;
+
+  // Keep a list of forward references from DW_AT_abstract_origin and
+  // DW_AT_specification attributes so names can be fixed up.
+  std::map<uint64_t, Module::Function*> forward_ref_die_to_func;
 };
 
 // Information about the context of a particular DIE. This is for
@@ -222,31 +241,32 @@ class DwarfCUToModule::GenericDIEHandler: public dwarf2reader::DIEHandler {
   // Create a handler for the DIE at OFFSET whose compilation unit is
   // described by CU_CONTEXT, and whose immediate context is described
   // by PARENT_CONTEXT.
-  GenericDIEHandler(CUContext *cu_context, DIEContext *parent_context,
-                    uint64 offset)
+  GenericDIEHandler(CUContext* cu_context, DIEContext* parent_context,
+                    uint64_t offset)
       : cu_context_(cu_context),
         parent_context_(parent_context),
         offset_(offset),
         declaration_(false),
-        specification_(NULL) { }
+        specification_(NULL),
+        forward_ref_die_offset_(0) { }
 
   // Derived classes' ProcessAttributeUnsigned can defer to this to
   // handle DW_AT_declaration, or simply not override it.
   void ProcessAttributeUnsigned(enum DwarfAttribute attr,
                                 enum DwarfForm form,
-                                uint64 data);
+                                uint64_t data);
 
   // Derived classes' ProcessAttributeReference can defer to this to
   // handle DW_AT_specification, or simply not override it.
   void ProcessAttributeReference(enum DwarfAttribute attr,
                                  enum DwarfForm form,
-                                 uint64 data);
+                                 uint64_t data);
 
   // Derived classes' ProcessAttributeReference can defer to this to
   // handle DW_AT_specification, or simply not override it.
   void ProcessAttributeString(enum DwarfAttribute attr,
                               enum DwarfForm form,
-                              const string &data);
+                              const string& data);
 
  protected:
   // Compute and return the fully-qualified name of the DIE. If this
@@ -259,17 +279,17 @@ class DwarfCUToModule::GenericDIEHandler: public dwarf2reader::DIEHandler {
   // have been seen.
   string ComputeQualifiedName();
 
-  CUContext *cu_context_;
-  DIEContext *parent_context_;
-  uint64 offset_;
+  CUContext* cu_context_;
+  DIEContext* parent_context_;
+  uint64_t offset_;
 
   // Place the name in the global set of strings. Even though this looks
-  // like a copy, all the major std::string implementations use reference
+  // like a copy, all the major string implementations use reference
   // counting internally, so the effect is to have all the data structures
   // share copies of strings whenever possible.
   // FIXME: Should this return something like a string_ref to avoid the
   // assumption about how strings are implemented?
-  string AddStringToPool(const string &str);
+  string AddStringToPool(const string& str);
 
   // If this DIE has a DW_AT_declaration attribute, this is its value.
   // It is false on DIEs with no DW_AT_declaration attribute.
@@ -278,7 +298,12 @@ class DwarfCUToModule::GenericDIEHandler: public dwarf2reader::DIEHandler {
   // If this DIE has a DW_AT_specification attribute, this is the
   // Specification structure for the DIE the attribute refers to.
   // Otherwise, this is NULL.
-  Specification *specification_;
+  Specification* specification_;
+
+  // If this DIE has a DW_AT_specification or DW_AT_abstract_origin and it is a
+  // forward reference, no Specification will be available. Track the reference
+  // to be fixed up when the DIE is parsed.
+  uint64_t forward_ref_die_offset_;
 
   // The value of the DW_AT_name attribute, or the empty string if the
   // DIE has no such attribute.
@@ -288,12 +313,16 @@ class DwarfCUToModule::GenericDIEHandler: public dwarf2reader::DIEHandler {
   // string if the DIE has no such attribute or its content could not be
   // demangled.
   string demangled_name_;
+
+  // The non-demangled value of the DW_AT_MIPS_linkage_name attribute,
+  // it its content count not be demangled.
+  string raw_name_;
 };
 
 void DwarfCUToModule::GenericDIEHandler::ProcessAttributeUnsigned(
     enum DwarfAttribute attr,
     enum DwarfForm form,
-    uint64 data) {
+    uint64_t data) {
   switch (attr) {
     case dwarf2reader::DW_AT_declaration: declaration_ = (data != 0); break;
     default: break;
@@ -303,10 +332,10 @@ void DwarfCUToModule::GenericDIEHandler::ProcessAttributeUnsigned(
 void DwarfCUToModule::GenericDIEHandler::ProcessAttributeReference(
     enum DwarfAttribute attr,
     enum DwarfForm form,
-    uint64 data) {
+    uint64_t data) {
   switch (attr) {
     case dwarf2reader::DW_AT_specification: {
-      FileContext *file_context = cu_context_->file_context;
+      FileContext* file_context = cu_context_->file_context;
       if (file_context->IsUnhandledInterCUReference(
               data, cu_context_->reporter->cu_offset())) {
         cu_context_->reporter->UnhandledInterCUReference(offset_, data);
@@ -317,17 +346,14 @@ void DwarfCUToModule::GenericDIEHandler::ProcessAttributeReference(
       // here, but it's better to leave the real work to our
       // EndAttribute member function, at which point we know we have
       // seen all the DIE's attributes.
-      SpecificationByOffset *specifications =
+      SpecificationByOffset* specifications =
           &file_context->file_private_->specifications;
       SpecificationByOffset::iterator spec = specifications->find(data);
       if (spec != specifications->end()) {
         specification_ = &spec->second;
+      } else if (data > offset_) {
+        forward_ref_die_offset_ = data;
       } else {
-        // Technically, there's no reason a DW_AT_specification
-        // couldn't be a forward reference, but supporting that would
-        // be a lot of work (changing to a two-pass structure), and I
-        // don't think any producers we care about ever emit such
-        // things.
         cu_context_->reporter->UnknownSpecification(offset_, data);
       }
       break;
@@ -336,8 +362,8 @@ void DwarfCUToModule::GenericDIEHandler::ProcessAttributeReference(
   }
 }
 
-string DwarfCUToModule::GenericDIEHandler::AddStringToPool(const string &str) {
-  pair<set<string>::iterator, bool> result =
+string DwarfCUToModule::GenericDIEHandler::AddStringToPool(const string& str) {
+  pair<unordered_set<string>::iterator, bool> result =
     cu_context_->file_context->file_private_->common_strings.insert(str);
   return *result.first;
 }
@@ -345,19 +371,28 @@ string DwarfCUToModule::GenericDIEHandler::AddStringToPool(const string &str) {
 void DwarfCUToModule::GenericDIEHandler::ProcessAttributeString(
     enum DwarfAttribute attr,
     enum DwarfForm form,
-    const string &data) {
+    const string& data) {
   switch (attr) {
     case dwarf2reader::DW_AT_name:
       name_attribute_ = AddStringToPool(data);
       break;
-    case dwarf2reader::DW_AT_MIPS_linkage_name: {
-      char* demangled = NULL;
-#if !defined(__ANDROID__)
-      demangled = abi::__cxa_demangle(data.c_str(), NULL, NULL, NULL);
-#endif
-      if (demangled) {
-        demangled_name_ = AddStringToPool(demangled);
-        free(reinterpret_cast<void*>(demangled));
+    case dwarf2reader::DW_AT_MIPS_linkage_name:
+    case dwarf2reader::DW_AT_linkage_name: {
+      string demangled;
+      Language::DemangleResult result =
+          cu_context_->language->DemangleName(data, &demangled);
+      switch (result) {
+        case Language::kDemangleSuccess:
+          demangled_name_ = AddStringToPool(demangled);
+          break;
+
+        case Language::kDemangleFailure:
+          cu_context_->reporter->DemangleError(data);
+          // fallthrough
+        case Language::kDontDemangle:
+          demangled_name_.clear();
+          raw_name_ = AddStringToPool(data);
+          break;
       }
       break;
     }
@@ -369,7 +404,7 @@ string DwarfCUToModule::GenericDIEHandler::ComputeQualifiedName() {
   // Use the demangled name, if one is available. Demangled names are
   // preferable to those inferred from the DWARF structure because they
   // include argument types.
-  const string *qualified_name = NULL;
+  const string* qualified_name = NULL;
   if (!demangled_name_.empty()) {
     // Found it is this DIE.
     qualified_name = &demangled_name_;
@@ -378,17 +413,19 @@ string DwarfCUToModule::GenericDIEHandler::ComputeQualifiedName() {
     qualified_name = &specification_->qualified_name;
   }
 
-  const string *unqualified_name;
-  const string *enclosing_name;
+  const string* unqualified_name = NULL;
+  const string* enclosing_name;
   if (!qualified_name) {
-    // Find our unqualified name. If the DIE has its own DW_AT_name
-    // attribute, then use that; otherwise, check our specification.
-    if (name_attribute_.empty() && specification_)
-      unqualified_name = &specification_->unqualified_name;
-    else
+    // Find the unqualified name. If the DIE has its own DW_AT_name
+    // attribute, then use that; otherwise, check the specification.
+    if (!name_attribute_.empty())
       unqualified_name = &name_attribute_;
+    else if (specification_)
+      unqualified_name = &specification_->unqualified_name;
+    else if (!raw_name_.empty())
+      unqualified_name = &raw_name_;
 
-    // Find the name of our enclosing context. If we have a
+    // Find the name of the enclosing context. If this DIE has a
     // specification, it's the specification's enclosing context that
     // counts; otherwise, use this DIE's context.
     if (specification_)
@@ -397,9 +434,22 @@ string DwarfCUToModule::GenericDIEHandler::ComputeQualifiedName() {
       enclosing_name = &parent_context_->name;
   }
 
+  // Prepare the return value before upcoming mutations possibly invalidate the
+  // existing pointers.
+  string return_value;
+  if (qualified_name) {
+    return_value = *qualified_name;
+  } else if (unqualified_name && enclosing_name) {
+    // Combine the enclosing name and unqualified name to produce our
+    // own fully-qualified name.
+    return_value = cu_context_->language->MakeQualifiedName(*enclosing_name,
+                                                            *unqualified_name);
+  }
+
   // If this DIE was marked as a declaration, record its names in the
   // specification table.
-  if (declaration_) {
+  if ((declaration_ && qualified_name) ||
+      (unqualified_name && enclosing_name)) {
     Specification spec;
     if (qualified_name) {
       spec.qualified_name = *qualified_name;
@@ -410,32 +460,26 @@ string DwarfCUToModule::GenericDIEHandler::ComputeQualifiedName() {
     cu_context_->file_context->file_private_->specifications[offset_] = spec;
   }
 
-  if (qualified_name)
-    return *qualified_name;
-
-  // Combine the enclosing name and unqualified name to produce our
-  // own fully-qualified name.
-  return cu_context_->language->MakeQualifiedName(*enclosing_name,
-                                                  *unqualified_name);
+  return return_value;
 }
 
 // A handler class for DW_TAG_subprogram DIEs.
 class DwarfCUToModule::FuncHandler: public GenericDIEHandler {
  public:
-  FuncHandler(CUContext *cu_context, DIEContext *parent_context,
-              uint64 offset)
+  FuncHandler(CUContext* cu_context, DIEContext* parent_context,
+              uint64_t offset)
       : GenericDIEHandler(cu_context, parent_context, offset),
         low_pc_(0), high_pc_(0), high_pc_form_(dwarf2reader::DW_FORM_addr),
-        abstract_origin_(NULL), inline_(false) { }
+        ranges_(0), abstract_origin_(NULL), inline_(false) { }
   void ProcessAttributeUnsigned(enum DwarfAttribute attr,
                                 enum DwarfForm form,
-                                uint64 data);
+                                uint64_t data);
   void ProcessAttributeSigned(enum DwarfAttribute attr,
                               enum DwarfForm form,
-                              int64 data);
+                              int64_t data);
   void ProcessAttributeReference(enum DwarfAttribute attr,
                                  enum DwarfForm form,
-                                 uint64 data);
+                                 uint64_t data);
 
   bool EndAttributes();
   void Finish();
@@ -444,8 +488,9 @@ class DwarfCUToModule::FuncHandler: public GenericDIEHandler {
   // The fully-qualified name, as derived from name_attribute_,
   // specification_, parent_context_.  Computed in EndAttributes.
   string name_;
-  uint64 low_pc_, high_pc_; // DW_AT_low_pc, DW_AT_high_pc
+  uint64_t low_pc_, high_pc_; // DW_AT_low_pc, DW_AT_high_pc
   DwarfForm high_pc_form_; // DW_AT_high_pc can be length or address.
+  uint64_t ranges_; // DW_AT_ranges
   const AbstractOrigin* abstract_origin_;
   bool inline_;
 };
@@ -453,7 +498,7 @@ class DwarfCUToModule::FuncHandler: public GenericDIEHandler {
 void DwarfCUToModule::FuncHandler::ProcessAttributeUnsigned(
     enum DwarfAttribute attr,
     enum DwarfForm form,
-    uint64 data) {
+    uint64_t data) {
   switch (attr) {
     // If this attribute is present at all --- even if its value is
     // DW_INL_not_inlined --- then GCC may cite it as someone else's
@@ -465,6 +510,9 @@ void DwarfCUToModule::FuncHandler::ProcessAttributeUnsigned(
       high_pc_form_ = form;
       high_pc_ = data;
       break;
+    case dwarf2reader::DW_AT_ranges:
+      ranges_ = data;
+      break;
 
     default:
       GenericDIEHandler::ProcessAttributeUnsigned(attr, form, data);
@@ -475,7 +523,7 @@ void DwarfCUToModule::FuncHandler::ProcessAttributeUnsigned(
 void DwarfCUToModule::FuncHandler::ProcessAttributeSigned(
     enum DwarfAttribute attr,
     enum DwarfForm form,
-    int64 data) {
+    int64_t data) {
   switch (attr) {
     // If this attribute is present at all --- even if its value is
     // DW_INL_not_inlined --- then GCC may cite it as someone else's
@@ -490,7 +538,7 @@ void DwarfCUToModule::FuncHandler::ProcessAttributeSigned(
 void DwarfCUToModule::FuncHandler::ProcessAttributeReference(
     enum DwarfAttribute attr,
     enum DwarfForm form,
-    uint64 data) {
+    uint64_t data) {
   switch (attr) {
     case dwarf2reader::DW_AT_abstract_origin: {
       const AbstractOriginByOffset& origins =
@@ -498,6 +546,8 @@ void DwarfCUToModule::FuncHandler::ProcessAttributeReference(
       AbstractOriginByOffset::const_iterator origin = origins.find(data);
       if (origin != origins.end()) {
         abstract_origin_ = &(origin->second);
+      } else if (data > offset_) {
+        forward_ref_die_offset_ = data;
       } else {
         cu_context_->reporter->UnknownAbstractOrigin(offset_, data);
       }
@@ -518,36 +568,96 @@ bool DwarfCUToModule::FuncHandler::EndAttributes() {
   return true;
 }
 
+static bool IsEmptyRange(const vector<Module::Range>& ranges) {
+  uint64_t size = accumulate(ranges.cbegin(), ranges.cend(), 0,
+    [](uint64_t total, Module::Range entry) {
+      return total + entry.size;
+    }
+  );
+
+  return size == 0;
+}
+
 void DwarfCUToModule::FuncHandler::Finish() {
-  // Make high_pc_ an address, if it isn't already.
-  if (high_pc_form_ != dwarf2reader::DW_FORM_addr) {
-    high_pc_ += low_pc_;
+  vector<Module::Range> ranges;
+
+  // Check if this DIE was one of the forward references that was not able
+  // to be processed, and fix up the name of the appropriate Module::Function.
+  // "name_" will have already been fixed up in EndAttributes().
+  if (!name_.empty()) {
+    auto iter = cu_context_->forward_ref_die_to_func.find(offset_);
+    if (iter != cu_context_->forward_ref_die_to_func.end())
+      iter->second->name = name_;
+  }
+
+  if (!ranges_) {
+    // Make high_pc_ an address, if it isn't already.
+    if (high_pc_form_ != dwarf2reader::DW_FORM_addr &&
+        high_pc_form_ != dwarf2reader::DW_FORM_GNU_addr_index &&
+        high_pc_form_ != dwarf2reader::DW_FORM_addrx &&
+        high_pc_form_ != dwarf2reader::DW_FORM_addrx1 &&
+        high_pc_form_ != dwarf2reader::DW_FORM_addrx2 &&
+        high_pc_form_ != dwarf2reader::DW_FORM_addrx3 &&
+        high_pc_form_ != dwarf2reader::DW_FORM_addrx4) {
+      high_pc_ += low_pc_;
+    }
+
+    Module::Range range(low_pc_, high_pc_ - low_pc_);
+    ranges.push_back(range);
+  } else {
+    RangesHandler* ranges_handler = cu_context_->ranges_handler;
+
+    if (ranges_handler) {
+      if (!ranges_handler->ReadRanges(ranges_, cu_context_->low_pc, &ranges)) {
+        ranges.clear();
+        cu_context_->reporter->MalformedRangeList(ranges_);
+      }
+    } else {
+      cu_context_->reporter->MissingRanges();
+    }
   }
 
   // Did we collect the information we need?  Not all DWARF function
-  // entries have low and high addresses (for example, inlined
-  // functions that were never used), but all the ones we're
-  // interested in cover a non-empty range of bytes.
-  if (low_pc_ < high_pc_) {
-    // Create a Module::Function based on the data we've gathered, and
-    // add it to the functions_ list.
-    Module::Function *func = new Module::Function;
+  // entries are non-empty (for example, inlined functions that were never
+  // used), but all the ones we're interested in cover a non-empty range of
+  // bytes.
+  if (!IsEmptyRange(ranges)) {
+    low_pc_ = ranges.front().address;
+
     // Malformed DWARF may omit the name, but all Module::Functions must
     // have names.
+    string name;
     if (!name_.empty()) {
-      func->name = name_;
+      name = name_;
     } else {
-      cu_context_->reporter->UnnamedFunction(offset_);
-      func->name = "<name omitted>";
+      // If we have a forward reference to a DW_AT_specification or
+      // DW_AT_abstract_origin, then don't warn, the name will be fixed up
+      // later
+      if (forward_ref_die_offset_ == 0)
+        cu_context_->reporter->UnnamedFunction(offset_);
+      name = "<name omitted>";
     }
-    func->address = low_pc_;
-    func->size = high_pc_ - low_pc_;
+
+    // Create a Module::Function based on the data we've gathered, and
+    // add it to the functions_ list.
+    scoped_ptr<Module::Function> func(new Module::Function(name, low_pc_));
+    func->ranges = ranges;
     func->parameter_size = 0;
     if (func->address) {
-       // If the function address is zero this is a sign that this function
-       // description is just empty debug data and should just be discarded.
-       cu_context_->functions.push_back(func);
-     }
+      // If the function address is zero this is a sign that this function
+      // description is just empty debug data and should just be discarded.
+      cu_context_->functions.push_back(func.release());
+      if (forward_ref_die_offset_ != 0) {
+        auto iter =
+            cu_context_->forward_ref_die_to_func.find(forward_ref_die_offset_);
+        if (iter == cu_context_->forward_ref_die_to_func.end()) {
+          cu_context_->reporter->UnknownSpecification(offset_,
+                                                      forward_ref_die_offset_);
+        } else {
+          iter->second = cu_context_->functions.back();
+        }
+      }
+    }
   } else if (inline_) {
     AbstractOrigin origin(name_);
     cu_context_->file_context->file_private_->origins[offset_] = origin;
@@ -558,11 +668,11 @@ void DwarfCUToModule::FuncHandler::Finish() {
 // component to their names: namespaces, classes, etc.
 class DwarfCUToModule::NamedScopeHandler: public GenericDIEHandler {
  public:
-  NamedScopeHandler(CUContext *cu_context, DIEContext *parent_context,
-                    uint64 offset)
+  NamedScopeHandler(CUContext* cu_context, DIEContext* parent_context,
+                    uint64_t offset)
       : GenericDIEHandler(cu_context, parent_context, offset) { }
   bool EndAttributes();
-  DIEHandler *FindChildHandler(uint64 offset, enum DwarfTag tag);
+  DIEHandler* FindChildHandler(uint64_t offset, enum DwarfTag tag);
 
  private:
   DIEContext child_context_; // A context for our children.
@@ -573,8 +683,8 @@ bool DwarfCUToModule::NamedScopeHandler::EndAttributes() {
   return true;
 }
 
-dwarf2reader::DIEHandler *DwarfCUToModule::NamedScopeHandler::FindChildHandler(
-    uint64 offset,
+dwarf2reader::DIEHandler* DwarfCUToModule::NamedScopeHandler::FindChildHandler(
+    uint64_t offset,
     enum DwarfTag tag) {
   switch (tag) {
     case dwarf2reader::DW_TAG_subprogram:
@@ -592,36 +702,36 @@ dwarf2reader::DIEHandler *DwarfCUToModule::NamedScopeHandler::FindChildHandler(
 void DwarfCUToModule::WarningReporter::CUHeading() {
   if (printed_cu_header_)
     return;
-  fprintf(stderr, "%s: in compilation unit '%s' (offset 0x%llx):\n",
+  fprintf(stderr, "%s: in compilation unit '%s' (offset 0x%" PRIx64 "):\n",
           filename_.c_str(), cu_name_.c_str(), cu_offset_);
   printed_cu_header_ = true;
 }
 
-void DwarfCUToModule::WarningReporter::UnknownSpecification(uint64 offset,
-                                                            uint64 target) {
+void DwarfCUToModule::WarningReporter::UnknownSpecification(uint64_t offset,
+                                                            uint64_t target) {
   CUHeading();
-  fprintf(stderr, "%s: the DIE at offset 0x%llx has a DW_AT_specification"
-          " attribute referring to the die at offset 0x%llx, which either"
-          " was not marked as a declaration, or comes later in the file\n",
+  fprintf(stderr, "%s: the DIE at offset 0x%" PRIx64 " has a "
+          "DW_AT_specification attribute referring to the DIE at offset 0x%"
+          PRIx64 ", which was not marked as a declaration\n",
           filename_.c_str(), offset, target);
 }
 
-void DwarfCUToModule::WarningReporter::UnknownAbstractOrigin(uint64 offset,
-                                                             uint64 target) {
+void DwarfCUToModule::WarningReporter::UnknownAbstractOrigin(uint64_t offset,
+                                                             uint64_t target) {
   CUHeading();
-  fprintf(stderr, "%s: the DIE at offset 0x%llx has a DW_AT_abstract_origin"
-          " attribute referring to the die at offset 0x%llx, which either"
-          " was not marked as an inline, or comes later in the file\n",
+  fprintf(stderr, "%s: the DIE at offset 0x%" PRIx64 " has a "
+          "DW_AT_abstract_origin attribute referring to the DIE at offset 0x%"
+          PRIx64 ", which was not marked as an inline\n",
           filename_.c_str(), offset, target);
 }
 
-void DwarfCUToModule::WarningReporter::MissingSection(const string &name) {
+void DwarfCUToModule::WarningReporter::MissingSection(const string& name) {
   CUHeading();
   fprintf(stderr, "%s: warning: couldn't find DWARF '%s' section\n",
           filename_.c_str(), name.c_str());
 }
 
-void DwarfCUToModule::WarningReporter::BadLineInfoOffset(uint64 offset) {
+void DwarfCUToModule::WarningReporter::BadLineInfoOffset(uint64_t offset) {
   CUHeading();
   fprintf(stderr, "%s: warning: line number data offset beyond end"
           " of '.debug_line' section\n",
@@ -638,16 +748,16 @@ void DwarfCUToModule::WarningReporter::UncoveredHeading() {
 }
 
 void DwarfCUToModule::WarningReporter::UncoveredFunction(
-    const Module::Function &function) {
+    const Module::Function& function) {
   if (!uncovered_warnings_enabled_)
     return;
   UncoveredHeading();
   fprintf(stderr, "    function%s: %s\n",
-          function.size == 0 ? " (zero-length)" : "",
+          IsEmptyRange(function.ranges) ? " (zero-length)" : "",
           function.name.c_str());
 }
 
-void DwarfCUToModule::WarningReporter::UncoveredLine(const Module::Line &line) {
+void DwarfCUToModule::WarningReporter::UncoveredLine(const Module::Line& line) {
   if (!uncovered_warnings_enabled_)
     return;
   UncoveredHeading();
@@ -656,26 +766,46 @@ void DwarfCUToModule::WarningReporter::UncoveredLine(const Module::Line &line) {
           line.file->name.c_str(), line.number, line.address);
 }
 
-void DwarfCUToModule::WarningReporter::UnnamedFunction(uint64 offset) {
+void DwarfCUToModule::WarningReporter::UnnamedFunction(uint64_t offset) {
   CUHeading();
-  fprintf(stderr, "%s: warning: function at offset 0x%llx has no name\n",
+  fprintf(stderr, "%s: warning: function at offset 0x%" PRIx64 " has no name\n",
           filename_.c_str(), offset);
 }
 
+void DwarfCUToModule::WarningReporter::DemangleError(const string& input) {
+  CUHeading();
+  fprintf(stderr, "%s: warning: failed to demangle %s\n",
+          filename_.c_str(), input.c_str());
+}
+
 void DwarfCUToModule::WarningReporter::UnhandledInterCUReference(
-    uint64 offset, uint64 target) {
+    uint64_t offset, uint64_t target) {
   CUHeading();
-  fprintf(stderr, "%s: warning: the DIE at offset 0x%llx has a "
+  fprintf(stderr, "%s: warning: the DIE at offset 0x%" PRIx64 " has a "
                   "DW_FORM_ref_addr attribute with an inter-CU reference to "
-                  "0x%llx, but inter-CU reference handling is turned off.\n",
-                  filename_.c_str(), offset, target);
+                  "0x%" PRIx64 ", but inter-CU reference handling is turned "
+                  " off.\n", filename_.c_str(), offset, target);
 }
 
-DwarfCUToModule::DwarfCUToModule(FileContext *file_context,
-                                 LineToModuleHandler *line_reader,
-                                 WarningReporter *reporter)
+void DwarfCUToModule::WarningReporter::MalformedRangeList(uint64_t offset) {
+  CUHeading();
+  fprintf(stderr, "%s: warning: the range list at offset 0x%" PRIx64 " falls "
+                  " out of the .debug_ranges section.\n",
+                  filename_.c_str(), offset);
+}
+
+void DwarfCUToModule::WarningReporter::MissingRanges() {
+  CUHeading();
+  fprintf(stderr, "%s: warning: A DW_AT_ranges attribute was encountered but "
+                  "the .debug_ranges section is missing.\n", filename_.c_str());
+}
+
+DwarfCUToModule::DwarfCUToModule(FileContext* file_context,
+                                 LineToModuleHandler* line_reader,
+                                 RangesHandler* ranges_handler,
+                                 WarningReporter* reporter)
     : line_reader_(line_reader),
-      cu_context_(new CUContext(file_context, reporter)),
+      cu_context_(new CUContext(file_context, reporter, ranges_handler)),
       child_context_(new DIEContext()),
       has_source_line_info_(false) {
 }
@@ -685,7 +815,7 @@ DwarfCUToModule::~DwarfCUToModule() {
 
 void DwarfCUToModule::ProcessAttributeSigned(enum DwarfAttribute attr,
                                              enum DwarfForm form,
-                                             int64 data) {
+                                             int64_t data) {
   switch (attr) {
     case dwarf2reader::DW_AT_language: // source language of this CU
       SetLanguage(static_cast<DwarfLanguage>(data));
@@ -697,7 +827,7 @@ void DwarfCUToModule::ProcessAttributeSigned(enum DwarfAttribute attr,
 
 void DwarfCUToModule::ProcessAttributeUnsigned(enum DwarfAttribute attr,
                                                enum DwarfForm form,
-                                               uint64 data) {
+                                               uint64_t data) {
   switch (attr) {
     case dwarf2reader::DW_AT_stmt_list: // Line number information.
       has_source_line_info_ = true;
@@ -706,6 +836,16 @@ void DwarfCUToModule::ProcessAttributeUnsigned(enum DwarfAttribute attr,
     case dwarf2reader::DW_AT_language: // source language of this CU
       SetLanguage(static_cast<DwarfLanguage>(data));
       break;
+    case dwarf2reader::DW_AT_low_pc:
+      cu_context_->low_pc  = data;
+      break;
+    case dwarf2reader::DW_AT_high_pc:
+      cu_context_->high_pc  = data;
+      break;
+    case dwarf2reader::DW_AT_ranges:
+      cu_context_->ranges = data;
+      break;
+
     default:
       break;
   }
@@ -713,7 +853,7 @@ void DwarfCUToModule::ProcessAttributeUnsigned(enum DwarfAttribute attr,
 
 void DwarfCUToModule::ProcessAttributeString(enum DwarfAttribute attr,
                                              enum DwarfForm form,
-                                             const string &data) {
+                                             const string& data) {
   switch (attr) {
     case dwarf2reader::DW_AT_name:
       cu_context_->reporter->SetCUName(data);
@@ -730,8 +870,8 @@ bool DwarfCUToModule::EndAttributes() {
   return true;
 }
 
-dwarf2reader::DIEHandler *DwarfCUToModule::FindChildHandler(
-    uint64 offset,
+dwarf2reader::DIEHandler* DwarfCUToModule::FindChildHandler(
+    uint64_t offset,
     enum DwarfTag tag) {
   switch (tag) {
     case dwarf2reader::DW_TAG_subprogram:
@@ -740,6 +880,7 @@ dwarf2reader::DIEHandler *DwarfCUToModule::FindChildHandler(
     case dwarf2reader::DW_TAG_class_type:
     case dwarf2reader::DW_TAG_structure_type:
     case dwarf2reader::DW_TAG_union_type:
+    case dwarf2reader::DW_TAG_module:
       return new NamedScopeHandler(cu_context_.get(), child_context_.get(),
                                    offset);
     default:
@@ -753,6 +894,14 @@ void DwarfCUToModule::SetLanguage(DwarfLanguage language) {
       cu_context_->language = Language::Java;
       break;
 
+    case dwarf2reader::DW_LANG_Swift:
+      cu_context_->language = Language::Swift;
+      break;
+
+    case dwarf2reader::DW_LANG_Rust:
+      cu_context_->language = Language::Rust;
+      break;
+
     // DWARF has no generic language code for assembly language; this is
     // what the GNU toolchain uses.
     case dwarf2reader::DW_LANG_Mips_Assembler:
@@ -782,33 +931,93 @@ void DwarfCUToModule::SetLanguage(DwarfLanguage language) {
   }
 }
 
-void DwarfCUToModule::ReadSourceLines(uint64 offset) {
-  const dwarf2reader::SectionMap &section_map
+void DwarfCUToModule::ReadSourceLines(uint64_t offset) {
+  const dwarf2reader::SectionMap& section_map
       = cu_context_->file_context->section_map();
   dwarf2reader::SectionMap::const_iterator map_entry
-      = section_map.find(".debug_line");
-  // Mac OS X puts DWARF data in sections whose names begin with "__"
-  // instead of ".".
-  if (map_entry == section_map.end())
-    map_entry = section_map.find("__debug_line");
+      = dwarf2reader::GetSectionByName(section_map, ".debug_line");
   if (map_entry == section_map.end()) {
     cu_context_->reporter->MissingSection(".debug_line");
     return;
   }
-  const char *section_start = map_entry->second.first;
-  uint64 section_length = map_entry->second.second;
-  if (offset >= section_length) {
+  const uint8_t* line_section_start = map_entry->second.first + offset;
+  uint64_t line_section_length = map_entry->second.second;
+  if (offset >= line_section_length) {
     cu_context_->reporter->BadLineInfoOffset(offset);
     return;
   }
-  line_reader_->ReadProgram(section_start + offset, section_length - offset,
-                            cu_context_->file_context->module_, &lines_);
+  line_section_length -= offset;
+  // When reading line tables, string sections are never needed for dwarf4, and
+  // may or may not be needed by dwarf5, so no error if they are missing.
+  const uint8_t* string_section_start = nullptr;
+  uint64_t string_section_length = 0;
+  map_entry = dwarf2reader::GetSectionByName(section_map, ".debug_str");
+  if (map_entry != section_map.end()) {
+    string_section_start = map_entry->second.first + offset;
+    string_section_length = map_entry->second.second - offset;
+  }
+  const uint8_t* line_string_section_start = nullptr;
+  uint64_t line_string_section_length = 0;
+  map_entry = dwarf2reader::GetSectionByName(section_map, ".debug_line_str");
+  if (map_entry != section_map.end()) {
+    line_string_section_start = map_entry->second.first + offset;
+    line_string_section_length = map_entry->second.second - offset;
+    return;
+  }
+  line_reader_->ReadProgram(
+      line_section_start, line_section_length,
+      string_section_start, string_section_length,
+      line_string_section_start, line_string_section_length,
+      cu_context_->file_context->module_, &lines_);
 }
 
 namespace {
+class FunctionRange {
+ public:
+  FunctionRange(const Module::Range& range, Module::Function* function) :
+      address(range.address), size(range.size), function(function) { }
+
+  void AddLine(Module::Line& line) {
+    function->lines.push_back(line);
+  }
+
+  Module::Address address;
+  Module::Address size;
+  Module::Function* function;
+};
+
+// Fills an array of ranges with pointers to the functions which owns
+// them. The array is sorted in ascending order and the ranges are non
+// empty and non-overlapping.
+
+static void FillSortedFunctionRanges(vector<FunctionRange>& dest_ranges,
+                                     vector<Module::Function*>* functions) {
+  for (vector<Module::Function*>::const_iterator func_it = functions->cbegin();
+       func_it != functions->cend();
+       func_it++)
+  {
+    Module::Function* func = *func_it;
+    vector<Module::Range>& ranges = func->ranges;
+    for (vector<Module::Range>::const_iterator ranges_it = ranges.cbegin();
+         ranges_it != ranges.cend();
+         ++ranges_it) {
+      FunctionRange range(*ranges_it, func);
+      if (range.size != 0) {
+          dest_ranges.push_back(range);
+      }
+    }
+  }
+
+  sort(dest_ranges.begin(), dest_ranges.end(),
+    [](const FunctionRange& fr1, const FunctionRange& fr2) {
+      return fr1.address < fr2.address;
+    }
+  );
+}
+
 // Return true if ADDRESS falls within the range of ITEM.
 template <class T>
-inline bool within(const T &item, Module::Address address) {
+inline bool within(const T& item, Module::Address address) {
   // Because Module::Address is unsigned, and unsigned arithmetic
   // wraps around, this will be false if ADDRESS falls before the
   // start of ITEM, or if it falls after ITEM's end.
@@ -817,8 +1026,8 @@ inline bool within(const T &item, Module::Address address) {
 }
 
 void DwarfCUToModule::AssignLinesToFunctions() {
-  vector<Module::Function *> *functions = &cu_context_->functions;
-  WarningReporter *reporter = cu_context_->reporter;
+  vector<Module::Function*>* functions = &cu_context_->functions;
+  WarningReporter* reporter = cu_context_->reporter;
 
   // This would be simpler if we assumed that source line entries
   // don't cross function boundaries.  However, there's no real reason
@@ -838,54 +1047,62 @@ void DwarfCUToModule::AssignLinesToFunctions() {
 
   // The last line that we used any piece of.  We use this only for
   // generating warnings.
-  const Module::Line *last_line_used = NULL;
+  const Module::Line* last_line_used = NULL;
 
   // The last function and line we warned about --- so we can avoid
   // doing so more than once.
-  const Module::Function *last_function_cited = NULL;
-  const Module::Line *last_line_cited = NULL;
-
-  // Make a single pass through both vectors from lower to higher
-  // addresses, populating each Function's lines vector with lines
-  // from our lines_ vector that fall within the function's address
-  // range.
-  vector<Module::Function *>::iterator func_it = functions->begin();
+  const Module::Function* last_function_cited = NULL;
+  const Module::Line* last_line_cited = NULL;
+
+  // Prepare a sorted list of ranges with range-to-function mapping
+  vector<FunctionRange> sorted_ranges;
+  FillSortedFunctionRanges(sorted_ranges, functions);
+
+  // Make a single pass through both the range and line vectors from lower to
+  // higher addresses, populating each range's function lines vector with lines
+  // from our lines_ vector that fall within the range.
+  vector<FunctionRange>::iterator range_it = sorted_ranges.begin();
   vector<Module::Line>::const_iterator line_it = lines_.begin();
 
   Module::Address current;
 
   // Pointers to the referents of func_it and line_it, or NULL if the
   // iterator is at the end of the sequence.
-  Module::Function *func;
-  const Module::Line *line;
+  FunctionRange* range;
+  const Module::Line* line;
 
   // Start current at the beginning of the first line or function,
   // whichever is earlier.
-  if (func_it != functions->end() && line_it != lines_.end()) {
-    func = *func_it;
+  if (range_it != sorted_ranges.end() && line_it != lines_.end()) {
+    range = &*range_it;
     line = &*line_it;
-    current = std::min(func->address, line->address);
+    current = std::min(range->address, line->address);
   } else if (line_it != lines_.end()) {
-    func = NULL;
+    range = NULL;
     line = &*line_it;
     current = line->address;
-  } else if (func_it != functions->end()) {
-    func = *func_it;
+  } else if (range_it != sorted_ranges.end()) {
+    range = &*range_it;
     line = NULL;
-    current = (*func_it)->address;
+    current = range->address;
   } else {
     return;
   }
 
-  while (func || line) {
+  // Some dwarf producers handle linker-removed functions by using -1 as a
+  // tombstone in the line table. So the end marker can be -1.
+  if (current == Module::kMaxAddress)
+    return;
+
+  while (range || line) {
     // This loop has two invariants that hold at the top.
     //
     // First, at least one of the iterators is not at the end of its
     // sequence, and those that are not refer to the earliest
-    // function or line that contains or starts after CURRENT.
+    // range or line that contains or starts after CURRENT.
     //
     // Note that every byte is in one of four states: it is covered
-    // or not covered by a function, and, independently, it is
+    // or not covered by a range, and, independently, it is
     // covered or not covered by a line.
     //
     // The second invariant is that CURRENT refers to a byte whose
@@ -895,7 +1112,7 @@ void DwarfCUToModule::AssignLinesToFunctions() {
     //
     // Note that, although each iteration advances CURRENT from one
     // transition address to the next in each iteration, it might
-    // not advance the iterators. Suppose we have a function that
+    // not advance the iterators. Suppose we have a range that
     // starts with a line, has a gap, and then a second line, and
     // suppose that we enter an iteration with CURRENT at the end of
     // the first line. The next transition address is the start of
@@ -903,11 +1120,11 @@ void DwarfCUToModule::AssignLinesToFunctions() {
     // advance CURRENT to that point. At the head of that iteration,
     // the invariants require that the line iterator be pointing at
     // the second line. But this is also true at the head of the
-    // next. And clearly, the iteration must not change the function
+    // next. And clearly, the iteration must not change the range
     // iterator. So neither iterator moves.
 
     // Assert the first invariant (see above).
-    assert(!func || current < func->address || within(*func, current));
+    assert(!range || current < range->address || within(*range, current));
     assert(!line || current < line->address || within(*line, current));
 
     // The next transition after CURRENT.
@@ -915,33 +1132,33 @@ void DwarfCUToModule::AssignLinesToFunctions() {
 
     // Figure out which state we're in, add lines or warn, and compute
     // the next transition address.
-    if (func && current >= func->address) {
+    if (range && current >= range->address) {
       if (line && current >= line->address) {
-        // Covered by both a line and a function.
-        Module::Address func_left = func->size - (current - func->address);
+        // Covered by both a line and a range.
+        Module::Address range_left = range->size - (current - range->address);
         Module::Address line_left = line->size - (current - line->address);
         // This may overflow, but things work out.
-        next_transition = current + std::min(func_left, line_left);
+        next_transition = current + std::min(range_left, line_left);
         Module::Line l = *line;
         l.address = current;
         l.size = next_transition - current;
-        func->lines.push_back(l);
+        range->AddLine(l);
         last_line_used = line;
       } else {
-        // Covered by a function, but no line.
-        if (func != last_function_cited) {
-          reporter->UncoveredFunction(*func);
-          last_function_cited = func;
+        // Covered by a range, but no line.
+        if (range->function != last_function_cited) {
+          reporter->UncoveredFunction(*(range->function));
+          last_function_cited = range->function;
         }
-        if (line && within(*func, line->address))
+        if (line && within(*range, line->address))
           next_transition = line->address;
         else
           // If this overflows, we'll catch it below.
-          next_transition = func->address + func->size;
+          next_transition = range->address + range->size;
       }
     } else {
       if (line && current >= line->address) {
-        // Covered by a line, but no function.
+        // Covered by a line, but no range.
         //
         // If GCC emits padding after one function to align the start
         // of the next, then it will attribute the padding
@@ -953,27 +1170,27 @@ void DwarfCUToModule::AssignLinesToFunctions() {
         // start of the next function, then assume this is what
         // happened, and don't warn.
         if (line != last_line_cited
-            && !(func
+            && !(range
                  && line == last_line_used
-                 && func->address - line->address == line->size)) {
+                 && range->address - line->address == line->size)) {
           reporter->UncoveredLine(*line);
           last_line_cited = line;
         }
-        if (func && within(*line, func->address))
-          next_transition = func->address;
+        if (range && within(*line, range->address))
+          next_transition = range->address;
         else
           // If this overflows, we'll catch it below.
           next_transition = line->address + line->size;
       } else {
-        // Covered by neither a function nor a line. By the invariant,
-        // both func and line begin after CURRENT. The next transition
-        // is the start of the next function or next line, whichever
+        // Covered by neither a range nor a line. By the invariant,
+        // both range and line begin after CURRENT. The next transition
+        // is the start of the next range or next line, whichever
         // is earliest.
-        assert(func || line);
-        if (func && line)
-          next_transition = std::min(func->address, line->address);
-        else if (func)
-          next_transition = func->address;
+        assert(range || line);
+        if (range && line)
+          next_transition = std::min(range->address, line->address);
+        else if (range)
+          next_transition = range->address;
         else
           next_transition = line->address;
       }
@@ -983,18 +1200,21 @@ void DwarfCUToModule::AssignLinesToFunctions() {
     // next_transition may end up being zero, in which case we've completed
     // our pass. Handle that here, instead of trying to deal with it in
     // each place we compute next_transition.
-    if (!next_transition)
+
+    // Some dwarf producers handle linker-removed functions by using -1 as a
+    // tombstone in the line table. So the end marker can be -1.
+    if (!next_transition || next_transition == Module::kMaxAddress)
       break;
 
     // Advance iterators as needed. If lines overlap or functions overlap,
     // then we could go around more than once. We don't worry too much
     // about what result we produce in that case, just as long as we don't
     // hang or crash.
-    while (func_it != functions->end()
-           && next_transition >= (*func_it)->address
-           && !within(**func_it, next_transition))
-      func_it++;
-    func = (func_it != functions->end()) ? *func_it : NULL;
+    while (range_it != sorted_ranges.end()
+           && next_transition >= range_it->address
+           && !within(*range_it, next_transition))
+      range_it++;
+    range = (range_it != sorted_ranges.end()) ? &(*range_it) : NULL;
     while (line_it != lines_.end()
            && next_transition >= line_it->address
            && !within(*line_it, next_transition))
@@ -1020,7 +1240,7 @@ void DwarfCUToModule::Finish() {
   if (has_source_line_info_)
     ReadSourceLines(source_line_offset_);
 
-  vector<Module::Function *> *functions = &cu_context_->functions;
+  vector<Module::Function*>* functions = &cu_context_->functions;
 
   // Dole out lines to the appropriate functions.
   AssignLinesToFunctions();
@@ -1037,15 +1257,15 @@ void DwarfCUToModule::Finish() {
   cu_context_->file_context->ClearSpecifications();
 }
 
-bool DwarfCUToModule::StartCompilationUnit(uint64 offset,
-                                           uint8 address_size,
-                                           uint8 offset_size,
-                                           uint64 cu_length,
-                                           uint8 dwarf_version) {
+bool DwarfCUToModule::StartCompilationUnit(uint64_t offset,
+                                           uint8_t address_size,
+                                           uint8_t offset_size,
+                                           uint64_t cu_length,
+                                           uint8_t dwarf_version) {
   return dwarf_version >= 2;
 }
 
-bool DwarfCUToModule::StartRootDIE(uint64 offset, enum DwarfTag tag) {
+bool DwarfCUToModule::StartRootDIE(uint64_t offset, enum DwarfTag tag) {
   // We don't deal with partial compilation units (the only other tag
   // likely to be used for root DIE).
   return tag == dwarf2reader::DW_TAG_compile_unit;
diff --git a/src/MEGASync/google_breakpad/common/dwarf_cu_to_module.h b/src/MEGASync/google_breakpad/common/dwarf_cu_to_module.h
index ab95485f..3e15b667 100644
--- a/src/MEGASync/google_breakpad/common/dwarf_cu_to_module.h
+++ b/src/MEGASync/google_breakpad/common/dwarf_cu_to_module.h
@@ -39,6 +39,8 @@
 #ifndef COMMON_LINUX_DWARF_CU_TO_MODULE_H__
 #define COMMON_LINUX_DWARF_CU_TO_MODULE_H__
 
+#include <stdint.h>
+
 #include <string>
 
 #include "common/language.h"
@@ -77,15 +79,15 @@ class DwarfCUToModule: public dwarf2reader::RootDIEHandler {
   // to true to handle debugging symbols with DW_FORM_ref_addr entries.
   class FileContext {
    public:
-    FileContext(const string &filename,
-                Module *module,
+    FileContext(const string& filename,
+                Module* module,
                 bool handle_inter_cu_refs);
     ~FileContext();
 
     // Add CONTENTS of size LENGTH to the section map as NAME.
     void AddSectionToSectionMap(const string& name,
-                                const char* contents,
-                                uint64 length);
+                                const uint8_t* contents,
+                                uint64_t length);
 
     // Clear the section map for testing.
     void ClearSectionMapForTest();
@@ -101,8 +103,8 @@ class DwarfCUToModule: public dwarf2reader::RootDIEHandler {
     // Given an OFFSET and a CU that starts at COMPILATION_UNIT_START, returns
     // true if this is an inter-compilation unit reference that is not being
     // handled.
-    bool IsUnhandledInterCUReference(uint64 offset,
-                                     uint64 compilation_unit_start) const;
+    bool IsUnhandledInterCUReference(uint64_t offset,
+                                     uint64_t compilation_unit_start) const;
 
     // The name of this file, for use in error messages.
     const string filename_;
@@ -112,7 +114,7 @@ class DwarfCUToModule: public dwarf2reader::RootDIEHandler {
     dwarf2reader::SectionMap section_map_;
 
     // The Module to which we're contributing definitions.
-    Module *module_;
+    Module* module_;
 
     // True if we are handling references between compilation units.
     const bool handle_inter_cu_refs_;
@@ -121,6 +123,22 @@ class DwarfCUToModule: public dwarf2reader::RootDIEHandler {
     scoped_ptr<FilePrivate> file_private_;
   };
 
+  // An abstract base class for handlers that handle DWARF range lists for
+  // DwarfCUToModule.
+  class RangesHandler {
+   public:
+    RangesHandler() { }
+    virtual ~RangesHandler() { }
+
+    // Called when finishing a function to populate the function's ranges.
+    // The ranges' entries are read starting from offset in the .debug_ranges
+    // section, base_address holds the base PC the range list values are
+    // offsets off. Return false if the rangelist falls out of the
+    // .debug_ranges section.
+    virtual bool ReadRanges(uint64_t offset, Module::Address base_address,
+                            vector<Module::Range>* ranges) = 0;
+  };
+
   // An abstract base class for handlers that handle DWARF line data
   // for DwarfCUToModule. DwarfCUToModule could certainly just use
   // dwarf2reader::LineInfo itself directly, but decoupling things
@@ -140,8 +158,12 @@ class DwarfCUToModule: public dwarf2reader::RootDIEHandler {
     // mappings, given a pointer to some DWARF line number data
     // PROGRAM, and an overestimate of its size. Add no zero-length
     // lines to LINES.
-    virtual void ReadProgram(const char *program, uint64 length,
-                             Module *module, vector<Module::Line> *lines) = 0;
+    virtual void ReadProgram(const uint8_t* program, uint64_t length,
+                             const uint8_t* string_section,
+                             uint64_t string_section_length,
+                             const uint8_t* line_string_section,
+                             uint64_t line_string_length,
+                             Module* module, vector<Module::Line>* lines) = 0;
   };
 
   // The interface DwarfCUToModule uses to report warnings. The member
@@ -152,14 +174,14 @@ class DwarfCUToModule: public dwarf2reader::RootDIEHandler {
    public:
     // Warn about problems in the DWARF file FILENAME, in the
     // compilation unit at OFFSET.
-    WarningReporter(const string &filename, uint64 cu_offset)
+    WarningReporter(const string& filename, uint64_t cu_offset)
         : filename_(filename), cu_offset_(cu_offset), printed_cu_header_(false),
           printed_unpaired_header_(false),
           uncovered_warnings_enabled_(false) { }
     virtual ~WarningReporter() { }
 
     // Set the name of the compilation unit we're processing to NAME.
-    virtual void SetCUName(const string &name) { cu_name_ = name; }
+    virtual void SetCUName(const string& name) { cu_name_ = name; }
 
     // Accessor and setter for uncovered_warnings_enabled_.
     // UncoveredFunction and UncoveredLine only report a problem if that is
@@ -175,41 +197,52 @@ class DwarfCUToModule: public dwarf2reader::RootDIEHandler {
     // A DW_AT_specification in the DIE at OFFSET refers to a DIE we
     // haven't processed yet, or that wasn't marked as a declaration,
     // at TARGET.
-    virtual void UnknownSpecification(uint64 offset, uint64 target);
+    virtual void UnknownSpecification(uint64_t offset, uint64_t target);
 
     // A DW_AT_abstract_origin in the DIE at OFFSET refers to a DIE we
     // haven't processed yet, or that wasn't marked as inline, at TARGET.
-    virtual void UnknownAbstractOrigin(uint64 offset, uint64 target);
+    virtual void UnknownAbstractOrigin(uint64_t offset, uint64_t target);
 
     // We were unable to find the DWARF section named SECTION_NAME.
-    virtual void MissingSection(const string &section_name);
+    virtual void MissingSection(const string& section_name);
 
     // The CU's DW_AT_stmt_list offset OFFSET is bogus.
-    virtual void BadLineInfoOffset(uint64 offset);
+    virtual void BadLineInfoOffset(uint64_t offset);
 
     // FUNCTION includes code covered by no line number data.
-    virtual void UncoveredFunction(const Module::Function &function);
+    virtual void UncoveredFunction(const Module::Function& function);
 
     // Line number NUMBER in LINE_FILE, of length LENGTH, includes code
     // covered by no function.
-    virtual void UncoveredLine(const Module::Line &line);
+    virtual void UncoveredLine(const Module::Line& line);
 
     // The DW_TAG_subprogram DIE at OFFSET has no name specified directly
     // in the DIE, nor via a DW_AT_specification or DW_AT_abstract_origin
     // link.
-    virtual void UnnamedFunction(uint64 offset);
+    virtual void UnnamedFunction(uint64_t offset);
+
+    // __cxa_demangle() failed to demangle INPUT.
+    virtual void DemangleError(const string& input);
 
     // The DW_FORM_ref_addr at OFFSET to TARGET was not handled because
     // FilePrivate did not retain the inter-CU specification data.
-    virtual void UnhandledInterCUReference(uint64 offset, uint64 target);
+    virtual void UnhandledInterCUReference(uint64_t offset, uint64_t target);
+
+    // The DW_AT_ranges at offset is malformed (truncated or outside of the
+    // .debug_ranges section's bound).
+    virtual void MalformedRangeList(uint64_t offset);
+
+    // A DW_AT_ranges attribute was encountered but the no .debug_ranges
+    // section was found.
+    virtual void MissingRanges();
 
-    uint64 cu_offset() const {
+    uint64_t cu_offset() const {
       return cu_offset_;
     }
 
    protected:
     const string filename_;
-    const uint64 cu_offset_;
+    const uint64_t cu_offset_;
     string cu_name_;
     bool printed_cu_header_;
     bool printed_unpaired_header_;
@@ -228,31 +261,32 @@ class DwarfCUToModule: public dwarf2reader::RootDIEHandler {
   // FILE_CONTEXT->module. Use LINE_READER to handle the compilation
   // unit's line number data. Use REPORTER to report problems with the
   // data we find.
-  DwarfCUToModule(FileContext *file_context,
-                  LineToModuleHandler *line_reader,
-                  WarningReporter *reporter);
+  DwarfCUToModule(FileContext* file_context,
+                  LineToModuleHandler* line_reader,
+                  RangesHandler* ranges_handler,
+                  WarningReporter* reporter);
   ~DwarfCUToModule();
 
   void ProcessAttributeSigned(enum DwarfAttribute attr,
                               enum DwarfForm form,
-                              int64 data);
+                              int64_t data);
   void ProcessAttributeUnsigned(enum DwarfAttribute attr,
                                 enum DwarfForm form,
-                                uint64 data);
+                                uint64_t data);
   void ProcessAttributeString(enum DwarfAttribute attr,
                               enum DwarfForm form,
-                              const string &data);
+                              const string& data);
   bool EndAttributes();
-  DIEHandler *FindChildHandler(uint64 offset, enum DwarfTag tag);
+  DIEHandler* FindChildHandler(uint64_t offset, enum DwarfTag tag);
 
   // Assign all our source Lines to the Functions that cover their
   // addresses, and then add them to module_.
   void Finish();
 
-  bool StartCompilationUnit(uint64 offset, uint8 address_size,
-                            uint8 offset_size, uint64 cu_length,
-                            uint8 dwarf_version);
-  bool StartRootDIE(uint64 offset, enum DwarfTag tag);
+  bool StartCompilationUnit(uint64_t offset, uint8_t address_size,
+                            uint8_t offset_size, uint64_t cu_length,
+                            uint8_t dwarf_version);
+  bool StartRootDIE(uint64_t offset, enum DwarfTag tag);
 
  private:
   // Used internally by the handler. Full definitions are in
@@ -265,7 +299,7 @@ class DwarfCUToModule: public dwarf2reader::RootDIEHandler {
   class NamedScopeHandler;
 
   // A map from section offsets to specifications.
-  typedef map<uint64, Specification> SpecificationByOffset;
+  typedef map<uint64_t, Specification> SpecificationByOffset;
 
   // Set this compilation unit's source language to LANGUAGE.
   void SetLanguage(DwarfLanguage language);
@@ -274,7 +308,7 @@ class DwarfCUToModule: public dwarf2reader::RootDIEHandler {
   // section.  Record source files in module_, but record source lines
   // in lines_; we apportion them to functions in
   // AssignLinesToFunctions.
-  void ReadSourceLines(uint64 offset);
+  void ReadSourceLines(uint64_t offset);
 
   // Assign the lines in lines_ to the individual line lists of the
   // functions in functions_.  (DWARF line information maps an entire
@@ -289,7 +323,7 @@ class DwarfCUToModule: public dwarf2reader::RootDIEHandler {
   // destructor deletes them.
 
   // The handler to use to handle line number data.
-  LineToModuleHandler *line_reader_;
+  LineToModuleHandler* line_reader_;
 
   // This compilation unit's context.
   scoped_ptr<CUContext> cu_context_;
@@ -302,7 +336,7 @@ class DwarfCUToModule: public dwarf2reader::RootDIEHandler {
 
   // The offset of this compilation unit's line number information in
   // the .debug_line section.
-  uint64 source_line_offset_;
+  uint64_t source_line_offset_;
 
   // The line numbers we have seen thus far.  We accumulate these here
   // during parsing.  Then, in Finish, we call AssignLinesToFunctions
diff --git a/src/MEGASync/google_breakpad/common/dwarf_cu_to_module_unittest.cc b/src/MEGASync/google_breakpad/common/dwarf_cu_to_module_unittest.cc
index 5f61a58e..8545c67d 100644
--- a/src/MEGASync/google_breakpad/common/dwarf_cu_to_module_unittest.cc
+++ b/src/MEGASync/google_breakpad/common/dwarf_cu_to_module_unittest.cc
@@ -31,6 +31,8 @@
 
 // dwarf_cu_to_module.cc: Unit tests for google_breakpad::DwarfCUToModule.
 
+#include <stdint.h>
+
 #include <string>
 #include <utility>
 #include <vector>
@@ -65,23 +67,28 @@ using ::testing::ValuesIn;
 class MockLineToModuleHandler: public DwarfCUToModule::LineToModuleHandler {
  public:
   MOCK_METHOD1(StartCompilationUnit, void(const string& compilation_dir));
-  MOCK_METHOD4(ReadProgram, void(const char* program, uint64 length,
-                                 Module *module, vector<Module::Line> *lines));
+  MOCK_METHOD8(ReadProgram, void(const uint8_t* program, uint64_t length,
+                                 const uint8_t* string_section,
+                                 uint64_t string_section_length,
+                                 const uint8_t* line_string_section,
+                                 uint64_t line_string_section_length,
+                                 Module* module, vector<Module::Line>* lines));
 };
 
 class MockWarningReporter: public DwarfCUToModule::WarningReporter {
  public:
-  MockWarningReporter(const string &filename, uint64 cu_offset)
+  MockWarningReporter(const string& filename, uint64_t cu_offset)
       : DwarfCUToModule::WarningReporter(filename, cu_offset) { }
-  MOCK_METHOD1(SetCUName, void(const string &name));
-  MOCK_METHOD2(UnknownSpecification, void(uint64 offset, uint64 target));
-  MOCK_METHOD2(UnknownAbstractOrigin, void(uint64 offset, uint64 target));
-  MOCK_METHOD1(MissingSection, void(const string &section_name));
-  MOCK_METHOD1(BadLineInfoOffset, void(uint64 offset));
-  MOCK_METHOD1(UncoveredFunction, void(const Module::Function &function));
-  MOCK_METHOD1(UncoveredLine, void(const Module::Line &line));
-  MOCK_METHOD1(UnnamedFunction, void(uint64 offset));
-  MOCK_METHOD2(UnhandledInterCUReference, void(uint64 offset, uint64 target));
+  MOCK_METHOD1(SetCUName, void(const string& name));
+  MOCK_METHOD2(UnknownSpecification, void(uint64_t offset, uint64_t target));
+  MOCK_METHOD2(UnknownAbstractOrigin, void(uint64_t offset, uint64_t target));
+  MOCK_METHOD1(MissingSection, void(const string& section_name));
+  MOCK_METHOD1(BadLineInfoOffset, void(uint64_t offset));
+  MOCK_METHOD1(UncoveredFunction, void(const Module::Function& function));
+  MOCK_METHOD1(UncoveredLine, void(const Module::Line& line));
+  MOCK_METHOD1(UnnamedFunction, void(uint64_t offset));
+  MOCK_METHOD1(DemangleError, void(const string& input));
+  MOCK_METHOD2(UnhandledInterCUReference, void(uint64_t offset, uint64_t target));
 };
 
 // A fixture class including all the objects needed to handle a
@@ -109,13 +116,17 @@ class CUFixtureBase {
   class AppendLinesFunctor {
    public:
     explicit AppendLinesFunctor(
-        const vector<Module::Line> *lines) : lines_(lines) { }
-    void operator()(const char *program, uint64 length,
-                    Module *module, vector<Module::Line> *lines) {
+        const vector<Module::Line>* lines) : lines_(lines) { }
+    void operator()(const uint8_t* program, uint64_t length,
+                    const uint8_t* string_section,
+                    uint64_t string_section_length,
+                    const uint8_t* line_string_section,
+                    uint64_t line_string_section_length,
+                    Module *module, vector<Module::Line>* lines) {
       lines->insert(lines->end(), lines_->begin(), lines_->end());
     }
    private:
-    const vector<Module::Line> *lines_;
+    const vector<Module::Line>* lines_;
   };
 
   CUFixtureBase()
@@ -125,7 +136,8 @@ class CUFixtureBase {
         language_signed_(false),
         appender_(&lines_),
         reporter_("dwarf-filename", 0xcf8f9bb6443d29b5LL),
-        root_handler_(&file_context_, &line_reader_, &reporter_),
+        root_handler_(&file_context_, &line_reader_,
+                      /* ranges_reader */ nullptr, &reporter_),
         functions_filled_(false) {
     // By default, expect no warnings to be reported, and expect the
     // compilation unit's name to be provided. The test can override
@@ -143,7 +155,7 @@ class CUFixtureBase {
     // By default, expect the line program reader not to be invoked. We
     // may override this in StartCU.
     EXPECT_CALL(line_reader_, StartCompilationUnit(_)).Times(0);
-    EXPECT_CALL(line_reader_, ReadProgram(_,_,_,_)).Times(0);
+    EXPECT_CALL(line_reader_, ReadProgram(_,_,_,_,_,_,_,_)).Times(0);
 
     // The handler will consult this section map to decide what to
     // pass to our line reader.
@@ -157,7 +169,7 @@ class CUFixtureBase {
   // when it invokes its LineToModuleHandler. Call this before calling
   // StartCU.
   void PushLine(Module::Address address, Module::Address size,
-                const string &filename, int line_number);
+                const string& filename, int line_number);
 
   // Use LANGUAGE for the compilation unit. More precisely, arrange
   // for StartCU to pass the compilation unit's root DIE a
@@ -178,28 +190,28 @@ class CUFixtureBase {
   void StartCU();
 
   // Have HANDLER process some strange attribute/form/value triples.
-  void ProcessStrangeAttributes(dwarf2reader::DIEHandler *handler);
+  void ProcessStrangeAttributes(dwarf2reader::DIEHandler* handler);
 
   // Start a child DIE of PARENT with the given tag and name. Leave
   // the handler ready to hear about children: call EndAttributes, but
   // not Finish.
-  DIEHandler *StartNamedDIE(DIEHandler *parent, DwarfTag tag,
-                            const string &name);
+  DIEHandler* StartNamedDIE(DIEHandler* parent, DwarfTag tag,
+                            const string& name);
 
   // Start a child DIE of PARENT with the given tag and a
   // DW_AT_specification attribute whose value is SPECIFICATION. Leave
   // the handler ready to hear about children: call EndAttributes, but
   // not Finish. If NAME is non-zero, use it as the DW_AT_name
   // attribute.
-  DIEHandler *StartSpecifiedDIE(DIEHandler *parent, DwarfTag tag,
-                                uint64 specification, const char *name = NULL);
+  DIEHandler* StartSpecifiedDIE(DIEHandler* parent, DwarfTag tag,
+                                uint64_t specification, const char* name = NULL);
 
   // Define a function as a child of PARENT with the given name, address, and
   // size. If high_pc_form is DW_FORM_addr then the DW_AT_high_pc attribute
   // will be written as an address; otherwise it will be written as the
   // function's size. Call EndAttributes and Finish; one cannot define
   // children of the defined function's DIE.
-  void DefineFunction(DIEHandler *parent, const string &name,
+  void DefineFunction(DIEHandler* parent, const string& name,
                       Module::Address address, Module::Address size,
                       const char* mangled_name,
                       DwarfForm high_pc_form = dwarf2reader::DW_FORM_addr);
@@ -207,33 +219,33 @@ class CUFixtureBase {
   // Create a declaration DIE as a child of PARENT with the given
   // offset, tag and name. If NAME is the empty string, don't provide
   // a DW_AT_name attribute. Call EndAttributes and Finish.
-  void DeclarationDIE(DIEHandler *parent, uint64 offset,
-                      DwarfTag tag, const string &name,
-                      const string &mangled_name);
+  void DeclarationDIE(DIEHandler* parent, uint64_t offset,
+                      DwarfTag tag, const string& name,
+                      const string& mangled_name);
 
   // Create a definition DIE as a child of PARENT with the given tag
   // that refers to the declaration DIE at offset SPECIFICATION as its
   // specification. If NAME is non-empty, pass it as the DW_AT_name
   // attribute. If SIZE is non-zero, record ADDRESS and SIZE as
   // low_pc/high_pc attributes.
-  void DefinitionDIE(DIEHandler *parent, DwarfTag tag,
-                     uint64 specification, const string &name,
+  void DefinitionDIE(DIEHandler* parent, DwarfTag tag,
+                     uint64_t specification, const string& name,
                      Module::Address address = 0, Module::Address size = 0);
 
   // Create an inline DW_TAG_subprogram DIE as a child of PARENT.  If
   // SPECIFICATION is non-zero, then the DIE refers to the declaration DIE at
   // offset SPECIFICATION as its specification.  If Name is non-empty, pass it
   // as the DW_AT_name attribute.
-  void AbstractInstanceDIE(DIEHandler *parent, uint64 offset,
-                           DwarfInline type, uint64 specification,
-                           const string &name,
+  void AbstractInstanceDIE(DIEHandler* parent, uint64_t offset,
+                           DwarfInline type, uint64_t specification,
+                           const string& name,
                            DwarfForm form = dwarf2reader::DW_FORM_data1);
 
   // Create a DW_TAG_subprogram DIE as a child of PARENT that refers to
   // ORIGIN in its DW_AT_abstract_origin attribute.  If NAME is the empty
   // string, don't provide a DW_AT_name attribute.
-  void DefineInlineInstanceDIE(DIEHandler *parent, const string &name,
-                               uint64 origin, Module::Address address,
+  void DefineInlineInstanceDIE(DIEHandler* parent, const string& name,
+                               uint64_t origin, Module::Address address,
                                Module::Address size);
 
   // The following Test* functions should be called after calling
@@ -247,7 +259,7 @@ class CUFixtureBase {
   // Test that the I'th function (ordered by address) in the module
   // this.module_ has the given name, address, and size, and that its
   // parameter size is zero.
-  void TestFunction(int i, const string &name,
+  void TestFunction(int i, const string& name,
                     Module::Address address, Module::Address size);
 
   // Test that the number of source lines owned by the I'th function
@@ -258,7 +270,7 @@ class CUFixtureBase {
   // (again, by address) has the given address, size, filename, and
   // line number.
   void TestLine(int i, int j, Module::Address address, Module::Address size,
-                const string &filename, int number);
+                const string& filename, int number);
 
   // Actual objects under test.
   Module module_;
@@ -284,7 +296,7 @@ class CUFixtureBase {
   // Mock line program reader.
   MockLineToModuleHandler line_reader_;
   AppendLinesFunctor appender_;
-  static const char dummy_line_program_[];
+  static const uint8_t dummy_line_program_[];
   static const size_t dummy_line_size_;
 
   MockWarningReporter reporter_;
@@ -296,17 +308,17 @@ class CUFixtureBase {
 
   // If functions_filled_ is true, this is a table of functions we've
   // extracted from module_, sorted by address.
-  vector<Module::Function *> functions_;
+  vector<Module::Function*> functions_;
   // True if we have filled the above vector with this.module_'s function list.
   bool functions_filled_;
 };
 
-const char CUFixtureBase::dummy_line_program_[] = "lots of fun data";
+const uint8_t CUFixtureBase::dummy_line_program_[] = "lots of fun data";
 const size_t CUFixtureBase::dummy_line_size_ =
     sizeof(CUFixtureBase::dummy_line_program_);
 
 void CUFixtureBase::PushLine(Module::Address address, Module::Address size,
-                             const string &filename, int line_number) {
+                             const string& filename, int line_number) {
   Module::Line l;
   l.address = address;
   l.size = size;
@@ -328,10 +340,10 @@ void CUFixtureBase::StartCU() {
   if (!lines_.empty())
     EXPECT_CALL(line_reader_,
                 ReadProgram(&dummy_line_program_[0], dummy_line_size_,
+                            _,_,_,_,
                             &module_, _))
         .Times(AtMost(1))
         .WillOnce(DoAll(Invoke(appender_), Return()));
-
   ASSERT_TRUE(root_handler_
               .StartCompilationUnit(0x51182ec307610b51ULL, 0x81, 0x44,
                                     0x4241b4f33720dd5cULL, 3));
@@ -364,7 +376,7 @@ void CUFixtureBase::StartCU() {
 }
 
 void CUFixtureBase::ProcessStrangeAttributes(
-    dwarf2reader::DIEHandler *handler) {
+    dwarf2reader::DIEHandler* handler) {
   handler->ProcessAttributeUnsigned((DwarfAttribute) 0xf560dead,
                                     (DwarfForm) 0x4106e4db,
                                     0xa592571997facda1ULL);
@@ -374,7 +386,7 @@ void CUFixtureBase::ProcessStrangeAttributes(
   handler->ProcessAttributeReference((DwarfAttribute) 0xf7f7480f,
                                      (DwarfForm) 0x829e038a,
                                      0x50fddef44734fdecULL);
-  static const char buffer[10] = "frobynode";
+  static const uint8_t buffer[10] = "frobynode";
   handler->ProcessAttributeBuffer((DwarfAttribute) 0xa55ffb51,
                                   (DwarfForm) 0x2f43b041,
                                   buffer, sizeof(buffer));
@@ -383,10 +395,10 @@ void CUFixtureBase::ProcessStrangeAttributes(
                                   "strange string");
 }
 
-DIEHandler *CUFixtureBase::StartNamedDIE(DIEHandler *parent,
+DIEHandler* CUFixtureBase::StartNamedDIE(DIEHandler* parent,
                                          DwarfTag tag,
-                                         const string &name) {
-  dwarf2reader::DIEHandler *handler
+                                         const string& name) {
+  dwarf2reader::DIEHandler* handler
     = parent->FindChildHandler(0x8f4c783c0467c989ULL, tag);
   if (!handler)
     return NULL;
@@ -403,11 +415,11 @@ DIEHandler *CUFixtureBase::StartNamedDIE(DIEHandler *parent,
   return handler;
 }
 
-DIEHandler *CUFixtureBase::StartSpecifiedDIE(DIEHandler *parent,
+DIEHandler* CUFixtureBase::StartSpecifiedDIE(DIEHandler* parent,
                                              DwarfTag tag,
-                                             uint64 specification,
-                                             const char *name) {
-  dwarf2reader::DIEHandler *handler
+                                             uint64_t specification,
+                                             const char* name) {
+  dwarf2reader::DIEHandler* handler
     = parent->FindChildHandler(0x8f4c783c0467c989ULL, tag);
   if (!handler)
     return NULL;
@@ -427,12 +439,12 @@ DIEHandler *CUFixtureBase::StartSpecifiedDIE(DIEHandler *parent,
   return handler;
 }
 
-void CUFixtureBase::DefineFunction(dwarf2reader::DIEHandler *parent,
-                                   const string &name, Module::Address address,
+void CUFixtureBase::DefineFunction(dwarf2reader::DIEHandler* parent,
+                                   const string& name, Module::Address address,
                                    Module::Address size,
                                    const char* mangled_name,
                                    DwarfForm high_pc_form) {
-  dwarf2reader::DIEHandler *func
+  dwarf2reader::DIEHandler* func
       = parent->FindChildHandler(0xe34797c7e68590a8LL,
                                  dwarf2reader::DW_TAG_subprogram);
   ASSERT_TRUE(func != NULL);
@@ -462,11 +474,11 @@ void CUFixtureBase::DefineFunction(dwarf2reader::DIEHandler *parent,
   delete func;
 }
 
-void CUFixtureBase::DeclarationDIE(DIEHandler *parent, uint64 offset,
+void CUFixtureBase::DeclarationDIE(DIEHandler* parent, uint64_t offset,
                                    DwarfTag tag,
-                                   const string &name,
-                                   const string &mangled_name) {
-  dwarf2reader::DIEHandler *die = parent->FindChildHandler(offset, tag);
+                                   const string& name,
+                                   const string& mangled_name) {
+  dwarf2reader::DIEHandler* die = parent->FindChildHandler(offset, tag);
   ASSERT_TRUE(die != NULL);
   if (!name.empty())
     die->ProcessAttributeString(dwarf2reader::DW_AT_name,
@@ -485,13 +497,13 @@ void CUFixtureBase::DeclarationDIE(DIEHandler *parent, uint64 offset,
   delete die;
 }
 
-void CUFixtureBase::DefinitionDIE(DIEHandler *parent,
+void CUFixtureBase::DefinitionDIE(DIEHandler* parent,
                                   DwarfTag tag,
-                                  uint64 specification,
-                                  const string &name,
+                                  uint64_t specification,
+                                  const string& name,
                                   Module::Address address,
                                   Module::Address size) {
-  dwarf2reader::DIEHandler *die
+  dwarf2reader::DIEHandler* die
     = parent->FindChildHandler(0x6ccfea031a9e6cc9ULL, tag);
   ASSERT_TRUE(die != NULL);
   die->ProcessAttributeReference(dwarf2reader::DW_AT_specification,
@@ -514,13 +526,13 @@ void CUFixtureBase::DefinitionDIE(DIEHandler *parent,
   delete die;
 }
 
-void CUFixtureBase::AbstractInstanceDIE(DIEHandler *parent,
-                                        uint64 offset,
+void CUFixtureBase::AbstractInstanceDIE(DIEHandler* parent,
+                                        uint64_t offset,
                                         DwarfInline type,
-                                        uint64 specification,
-                                        const string &name,
+                                        uint64_t specification,
+                                        const string& name,
                                         DwarfForm form) {
-  dwarf2reader::DIEHandler *die
+  dwarf2reader::DIEHandler* die
     = parent->FindChildHandler(offset, dwarf2reader::DW_TAG_subprogram);
   ASSERT_TRUE(die != NULL);
   if (specification != 0ULL)
@@ -542,12 +554,12 @@ void CUFixtureBase::AbstractInstanceDIE(DIEHandler *parent,
   delete die;
 }
 
-void CUFixtureBase::DefineInlineInstanceDIE(DIEHandler *parent,
-                                            const string &name,
-                                            uint64 origin,
+void CUFixtureBase::DefineInlineInstanceDIE(DIEHandler* parent,
+                                            const string& name,
+                                            uint64_t origin,
                                             Module::Address address,
                                             Module::Address size) {
-  dwarf2reader::DIEHandler *func
+  dwarf2reader::DIEHandler* func
       = parent->FindChildHandler(0x11c70f94c6e87ccdLL,
                                  dwarf2reader::DW_TAG_subprogram);
   ASSERT_TRUE(func != NULL);
@@ -585,16 +597,16 @@ void CUFixtureBase::TestFunctionCount(size_t expected) {
   ASSERT_EQ(expected, functions_.size());
 }
 
-void CUFixtureBase::TestFunction(int i, const string &name,
+void CUFixtureBase::TestFunction(int i, const string& name,
                                  Module::Address address,
                                  Module::Address size) {
   FillFunctions();
   ASSERT_LT((size_t) i, functions_.size());
 
-  Module::Function *function = functions_[i];
+  Module::Function* function = functions_[i];
   EXPECT_EQ(name,    function->name);
   EXPECT_EQ(address, function->address);
-  EXPECT_EQ(size,    function->size);
+  EXPECT_EQ(size,    function->ranges[0].size);
   EXPECT_EQ(0U,      function->parameter_size);
 }
 
@@ -607,12 +619,12 @@ void CUFixtureBase::TestLineCount(int i, size_t expected) {
 
 void CUFixtureBase::TestLine(int i, int j,
                              Module::Address address, Module::Address size,
-                             const string &filename, int number) {
+                             const string& filename, int number) {
   FillFunctions();
   ASSERT_LT((size_t) i, functions_.size());
   ASSERT_LT((size_t) j, functions_[i]->lines.size());
 
-  Module::Line *line = &functions_[i]->lines[j];
+  Module::Line* line = &functions_[i]->lines[j];
   EXPECT_EQ(address,  line->address);
   EXPECT_EQ(size,     line->size);
   EXPECT_EQ(filename, line->file->name.c_str());
@@ -699,7 +711,7 @@ TEST_F(SimpleCU, IrrelevantRootChildren) {
 
 TEST_F(SimpleCU, IrrelevantNamedScopeChildren) {
   StartCU();
-  DIEHandler *class_A_handler
+  DIEHandler* class_A_handler
     = StartNamedDIE(&root_handler_, dwarf2reader::DW_TAG_class_type, "class_A");
   EXPECT_TRUE(class_A_handler != NULL);
   EXPECT_FALSE(class_A_handler
@@ -849,7 +861,7 @@ INSTANTIATE_TEST_CASE_P(AllSituations, FuncLinePairing,
                         ValuesIn(situations));
 
 TEST_P(FuncLinePairing, Pairing) {
-  const Situation &s = GetParam();
+  const Situation& s = GetParam();
   PushLine(s.lines[0].start,
            s.lines[0].end - s.lines[0].start,
            "line-file", 67636963);
@@ -1045,7 +1057,7 @@ TEST_P(CXXQualifiedNames, TwoFunctions) {
   PushLine(20, 1, "filename2", 95115701);
 
   StartCU();
-  DIEHandler *enclosure_handler = StartNamedDIE(&root_handler_, tag,
+  DIEHandler* enclosure_handler = StartNamedDIE(&root_handler_, tag,
                                                 "Enclosure");
   EXPECT_TRUE(enclosure_handler != NULL);
   DefineFunction(enclosure_handler, "func_B", 10, 1, NULL);
@@ -1066,11 +1078,11 @@ TEST_P(CXXQualifiedNames, FuncInEnclosureInNamespace) {
   PushLine(10, 1, "line-file", 69819327);
 
   StartCU();
-  DIEHandler *namespace_handler
+  DIEHandler* namespace_handler
       = StartNamedDIE(&root_handler_, dwarf2reader::DW_TAG_namespace,
                       "Namespace");
   EXPECT_TRUE(namespace_handler != NULL);
-  DIEHandler *enclosure_handler = StartNamedDIE(namespace_handler, tag,
+  DIEHandler* enclosure_handler = StartNamedDIE(namespace_handler, tag,
                                                 "Enclosure");
   EXPECT_TRUE(enclosure_handler != NULL);
   DefineFunction(enclosure_handler, "function", 10, 1, NULL);
@@ -1089,15 +1101,15 @@ TEST_F(CXXQualifiedNames, FunctionInClassInStructInNamespace) {
   PushLine(10, 1, "filename1", 69819327);
 
   StartCU();
-  DIEHandler *namespace_handler
+  DIEHandler* namespace_handler
       = StartNamedDIE(&root_handler_, dwarf2reader::DW_TAG_namespace,
                       "namespace_A");
   EXPECT_TRUE(namespace_handler != NULL);
-  DIEHandler *struct_handler
+  DIEHandler* struct_handler
       = StartNamedDIE(namespace_handler, dwarf2reader::DW_TAG_structure_type,
                       "struct_B");
   EXPECT_TRUE(struct_handler != NULL);
-  DIEHandler *class_handler
+  DIEHandler* class_handler
       = StartNamedDIE(struct_handler, dwarf2reader::DW_TAG_class_type,
                       "class_C");
   DefineFunction(class_handler, "function_D", 10, 1, NULL);
@@ -1115,7 +1127,7 @@ TEST_F(CXXQualifiedNames, FunctionInClassInStructInNamespace) {
 
 struct LanguageAndQualifiedName {
   dwarf2reader::DwarfLanguage language;
-  const char *name;
+  const char* name;
 };
 
 const LanguageAndQualifiedName LanguageAndQualifiedNameCases[] = {
@@ -1137,13 +1149,13 @@ INSTANTIATE_TEST_CASE_P(LanguageAndQualifiedName, QualifiedForLanguage,
                         ValuesIn(LanguageAndQualifiedNameCases));
 
 TEST_P(QualifiedForLanguage, MemberFunction) {
-  const LanguageAndQualifiedName &param = GetParam();
+  const LanguageAndQualifiedName& param = GetParam();
 
   PushLine(10, 1, "line-file", 212966758);
   SetLanguage(param.language);
 
   StartCU();
-  DIEHandler *class_handler
+  DIEHandler* class_handler
       = StartNamedDIE(&root_handler_, dwarf2reader::DW_TAG_class_type,
                       "class_A");
   DefineFunction(class_handler, "function_B", 10, 1, NULL);
@@ -1160,14 +1172,14 @@ TEST_P(QualifiedForLanguage, MemberFunction) {
 }
 
 TEST_P(QualifiedForLanguage, MemberFunctionSignedLanguage) {
-  const LanguageAndQualifiedName &param = GetParam();
+  const LanguageAndQualifiedName& param = GetParam();
 
   PushLine(10, 1, "line-file", 212966758);
   SetLanguage(param.language);
   SetLanguageSigned(true);
 
   StartCU();
-  DIEHandler *class_handler
+  DIEHandler* class_handler
       = StartNamedDIE(&root_handler_, dwarf2reader::DW_TAG_class_type,
                       "class_A");
   DefineFunction(class_handler, "function_B", 10, 1, NULL);
@@ -1202,6 +1214,7 @@ TEST_F(Specifications, Function) {
 }
 
 TEST_F(Specifications, MangledName) {
+  // Language defaults to C++, so no need to set it here.
   PushLine(0x93cd3dfc1aa10097ULL, 0x0397d47a0b4ca0d4ULL, "line-file", 54883661);
 
   StartCU();
@@ -1218,11 +1231,58 @@ TEST_F(Specifications, MangledName) {
                0x93cd3dfc1aa10097ULL, 0x0397d47a0b4ca0d4ULL);
 }
 
+TEST_F(Specifications, MangledNameSwift) {
+  // Swift mangled names should pass through untouched.
+  SetLanguage(dwarf2reader::DW_LANG_Swift);
+  PushLine(0x93cd3dfc1aa10097ULL, 0x0397d47a0b4ca0d4ULL, "line-file", 54883661);
+  StartCU();
+  const string kName = "_TFC9swifttest5Shape17simpleDescriptionfS0_FT_Si";
+  DeclarationDIE(&root_handler_, 0xcd3c51b946fb1eeeLL,
+                 dwarf2reader::DW_TAG_subprogram, "declaration-name",
+                 kName);
+  DefinitionDIE(&root_handler_, dwarf2reader::DW_TAG_subprogram,
+                0xcd3c51b946fb1eeeLL, "",
+                0x93cd3dfc1aa10097ULL, 0x0397d47a0b4ca0d4ULL);
+  root_handler_.Finish();
+
+  TestFunctionCount(1);
+  TestFunction(0, kName,
+               0x93cd3dfc1aa10097ULL, 0x0397d47a0b4ca0d4ULL);
+}
+
+TEST_F(Specifications, MangledNameRust) {
+  SetLanguage(dwarf2reader::DW_LANG_Rust);
+  PushLine(0x93cd3dfc1aa10097ULL, 0x0397d47a0b4ca0d4ULL, "line-file", 54883661);
+
+  StartCU();
+  const string kName = "_ZN14rustc_demangle8demangle17h373defa94bffacdeE";
+  DeclarationDIE(&root_handler_, 0xcd3c51b946fb1eeeLL,
+                 dwarf2reader::DW_TAG_subprogram, "declaration-name",
+                 kName);
+  DefinitionDIE(&root_handler_, dwarf2reader::DW_TAG_subprogram,
+                0xcd3c51b946fb1eeeLL, "",
+                0x93cd3dfc1aa10097ULL, 0x0397d47a0b4ca0d4ULL);
+  root_handler_.Finish();
+
+  TestFunctionCount(1);
+  TestFunction(0,
+#ifndef HAVE_RUST_DEMANGLE
+               // Rust mangled names should pass through untouched if not
+               // using rust-demangle.
+               kName,
+#else
+               // If rust-demangle is available this should be properly
+               // demangled.
+               "rustc_demangle::demangle",
+#endif
+               0x93cd3dfc1aa10097ULL, 0x0397d47a0b4ca0d4ULL);
+}
+
 TEST_F(Specifications, MemberFunction) {
   PushLine(0x3341a248634e7170ULL, 0x5f6938ee5553b953ULL, "line-file", 18116691);
 
   StartCU();
-  DIEHandler *class_handler
+  DIEHandler* class_handler
     = StartNamedDIE(&root_handler_, dwarf2reader::DW_TAG_class_type, "class_A");
   DeclarationDIE(class_handler, 0x7d83028c431406e8ULL,
                  dwarf2reader::DW_TAG_subprogram, "declaration-name", "");
@@ -1245,7 +1305,7 @@ TEST_F(Specifications, FunctionDeclarationParent) {
 
   StartCU();
   {
-    DIEHandler *class_handler
+    DIEHandler* class_handler
       = StartNamedDIE(&root_handler_, dwarf2reader::DW_TAG_class_type,
                       "class_A");
     ASSERT_TRUE(class_handler != NULL);
@@ -1273,7 +1333,7 @@ TEST_F(Specifications, NamedScopeDeclarationParent) {
 
   StartCU();
   {
-    DIEHandler *space_handler
+    DIEHandler* space_handler
       = StartNamedDIE(&root_handler_, dwarf2reader::DW_TAG_namespace,
                       "space_A");
     ASSERT_TRUE(space_handler != NULL);
@@ -1285,7 +1345,7 @@ TEST_F(Specifications, NamedScopeDeclarationParent) {
   }
 
   {
-    DIEHandler *class_handler
+    DIEHandler* class_handler
       = StartSpecifiedDIE(&root_handler_, dwarf2reader::DW_TAG_class_type,
                           0x419bb1d12f9a73a2ULL, "class-definition-name");
     ASSERT_TRUE(class_handler != NULL);
@@ -1320,6 +1380,29 @@ TEST_F(Specifications, InlineFunction) {
                0x1758a0f941b71efbULL, 0x1cf154f1f545e146ULL);
 }
 
+// An inline function in a namespace should correctly derive its
+// name from its abstract origin, and not just the namespace name.
+TEST_F(Specifications, InlineFunctionInNamespace) {
+  PushLine(0x1758a0f941b71efbULL, 0x1cf154f1f545e146ULL, "line-file", 75173118);
+
+  StartCU();
+  DIEHandler* space_handler
+      = StartNamedDIE(&root_handler_, dwarf2reader::DW_TAG_namespace,
+                      "Namespace");
+  ASSERT_TRUE(space_handler != NULL);
+  AbstractInstanceDIE(space_handler, 0x1e8dac5d507ed7abULL,
+                      dwarf2reader::DW_INL_inlined, 0LL, "func-name");
+  DefineInlineInstanceDIE(space_handler, "", 0x1e8dac5d507ed7abULL,
+                       0x1758a0f941b71efbULL, 0x1cf154f1f545e146ULL);
+  space_handler->Finish();
+  delete space_handler;
+  root_handler_.Finish();
+
+  TestFunctionCount(1);
+  TestFunction(0, "Namespace::func-name",
+               0x1758a0f941b71efbULL, 0x1cf154f1f545e146ULL);
+}
+
 // Check name construction for a long chain containing each combination of:
 // - struct, union, class, namespace
 // - direct and definition
@@ -1354,7 +1437,7 @@ TEST_F(Specifications, LongChain) {
   // space_A::space_B::struct_C::struct_D::union_E::union_F::
   //   class_G::class_H::func_I
   {
-    DIEHandler *space_A_handler
+    DIEHandler* space_A_handler
       = StartNamedDIE(&root_handler_, dwarf2reader::DW_TAG_namespace,
                       "space_A");
     DeclarationDIE(space_A_handler, 0x2e111126496596e2ULL,
@@ -1364,10 +1447,10 @@ TEST_F(Specifications, LongChain) {
   }
 
   {
-    DIEHandler *space_B_handler
+    DIEHandler* space_B_handler
       = StartSpecifiedDIE(&root_handler_, dwarf2reader::DW_TAG_namespace,
                           0x2e111126496596e2ULL);
-    DIEHandler *struct_C_handler
+    DIEHandler* struct_C_handler
       = StartNamedDIE(space_B_handler, dwarf2reader::DW_TAG_structure_type,
                       "struct_C");
     DeclarationDIE(struct_C_handler, 0x20cd423bf2a25a4cULL,
@@ -1379,10 +1462,10 @@ TEST_F(Specifications, LongChain) {
   }
 
   {
-    DIEHandler *struct_D_handler
+    DIEHandler* struct_D_handler
       = StartSpecifiedDIE(&root_handler_, dwarf2reader::DW_TAG_structure_type,
                           0x20cd423bf2a25a4cULL);
-    DIEHandler *union_E_handler
+    DIEHandler* union_E_handler
       = StartNamedDIE(struct_D_handler, dwarf2reader::DW_TAG_union_type,
                       "union_E");
     DeclarationDIE(union_E_handler, 0xe25c84805aa58c32ULL,
@@ -1394,10 +1477,10 @@ TEST_F(Specifications, LongChain) {
   }
 
   {
-    DIEHandler *union_F_handler
+    DIEHandler* union_F_handler
       = StartSpecifiedDIE(&root_handler_, dwarf2reader::DW_TAG_union_type,
                           0xe25c84805aa58c32ULL);
-    DIEHandler *class_G_handler
+    DIEHandler* class_G_handler
       = StartNamedDIE(union_F_handler, dwarf2reader::DW_TAG_class_type,
                       "class_G");
     DeclarationDIE(class_G_handler, 0xb70d960dcc173b6eULL,
@@ -1409,7 +1492,7 @@ TEST_F(Specifications, LongChain) {
   }
 
   {
-    DIEHandler *class_H_handler
+    DIEHandler* class_H_handler
       = StartSpecifiedDIE(&root_handler_, dwarf2reader::DW_TAG_class_type,
                           0xb70d960dcc173b6eULL);
     DeclarationDIE(class_H_handler, 0x27ff829e3bf69f37ULL,
@@ -1434,14 +1517,14 @@ TEST_F(Specifications, InterCU) {
   DwarfCUToModule::FileContext fc("dwarf-filename", &m, true);
   EXPECT_CALL(reporter_, UncoveredFunction(_)).WillOnce(Return());
   MockLineToModuleHandler lr;
-  EXPECT_CALL(lr, ReadProgram(_,_,_,_)).Times(0);
+  EXPECT_CALL(lr, ReadProgram(_,_,_,_,_,_,_,_)).Times(0);
 
   // Kludge: satisfy reporter_'s expectation.
   reporter_.SetCUName("compilation-unit-name");
 
   // First CU.  Declares class_A.
   {
-    DwarfCUToModule root1_handler(&fc, &lr, &reporter_);
+    DwarfCUToModule root1_handler(&fc, &lr, nullptr, &reporter_);
     ASSERT_TRUE(root1_handler.StartCompilationUnit(0, 1, 2, 3, 3));
     ASSERT_TRUE(root1_handler.StartRootDIE(1,
                                            dwarf2reader::DW_TAG_compile_unit));
@@ -1454,12 +1537,12 @@ TEST_F(Specifications, InterCU) {
 
   // Second CU.  Defines class_A, declares member_func_B.
   {
-    DwarfCUToModule root2_handler(&fc, &lr, &reporter_);
+    DwarfCUToModule root2_handler(&fc, &lr, nullptr, &reporter_);
     ASSERT_TRUE(root2_handler.StartCompilationUnit(0, 1, 2, 3, 3));
     ASSERT_TRUE(root2_handler.StartRootDIE(1,
                                            dwarf2reader::DW_TAG_compile_unit));
     ASSERT_TRUE(root2_handler.EndAttributes());
-    DIEHandler *class_A_handler
+    DIEHandler* class_A_handler
       = StartSpecifiedDIE(&root2_handler, dwarf2reader::DW_TAG_class_type,
                           0xb8fbfdd5f0b26fceULL);
     DeclarationDIE(class_A_handler, 0xb01fef8b380bd1a2ULL,
@@ -1471,7 +1554,7 @@ TEST_F(Specifications, InterCU) {
 
   // Third CU.  Defines member_func_B.
   {
-    DwarfCUToModule root3_handler(&fc, &lr, &reporter_);
+    DwarfCUToModule root3_handler(&fc, &lr, nullptr, &reporter_);
     ASSERT_TRUE(root3_handler.StartCompilationUnit(0, 1, 2, 3, 3));
     ASSERT_TRUE(root3_handler.StartRootDIE(1,
                                            dwarf2reader::DW_TAG_compile_unit));
@@ -1482,7 +1565,7 @@ TEST_F(Specifications, InterCU) {
     root3_handler.Finish();
   }
 
-  vector<Module::Function *> functions;
+  vector<Module::Function*> functions;
   m.GetFunctions(&functions, functions.end());
   EXPECT_EQ(1U, functions.size());
   EXPECT_STREQ("class_A::member_func_B", functions[0]->name.c_str());
@@ -1493,14 +1576,14 @@ TEST_F(Specifications, UnhandledInterCU) {
   DwarfCUToModule::FileContext fc("dwarf-filename", &m, false);
   EXPECT_CALL(reporter_, UncoveredFunction(_)).WillOnce(Return());
   MockLineToModuleHandler lr;
-  EXPECT_CALL(lr, ReadProgram(_,_,_,_)).Times(0);
+  EXPECT_CALL(lr, ReadProgram(_,_,_,_,_,_,_,_)).Times(0);
 
   // Kludge: satisfy reporter_'s expectation.
   reporter_.SetCUName("compilation-unit-name");
 
   // First CU.  Declares class_A.
   {
-    DwarfCUToModule root1_handler(&fc, &lr, &reporter_);
+    DwarfCUToModule root1_handler(&fc, &lr, nullptr, &reporter_);
     ASSERT_TRUE(root1_handler.StartCompilationUnit(0, 1, 2, 3, 3));
     ASSERT_TRUE(root1_handler.StartRootDIE(1,
                                            dwarf2reader::DW_TAG_compile_unit));
@@ -1513,13 +1596,13 @@ TEST_F(Specifications, UnhandledInterCU) {
 
   // Second CU.  Defines class_A, declares member_func_B.
   {
-    DwarfCUToModule root2_handler(&fc, &lr, &reporter_);
+    DwarfCUToModule root2_handler(&fc, &lr, nullptr, &reporter_);
     ASSERT_TRUE(root2_handler.StartCompilationUnit(0, 1, 2, 3, 3));
     ASSERT_TRUE(root2_handler.StartRootDIE(1,
                                            dwarf2reader::DW_TAG_compile_unit));
     ASSERT_TRUE(root2_handler.EndAttributes());
     EXPECT_CALL(reporter_, UnhandledInterCUReference(_, _)).Times(1);
-    DIEHandler *class_A_handler
+    DIEHandler* class_A_handler
       = StartSpecifiedDIE(&root2_handler, dwarf2reader::DW_TAG_class_type,
                           0xb8fbfdd5f0b26fceULL);
     DeclarationDIE(class_A_handler, 0xb01fef8b380bd1a2ULL,
@@ -1531,7 +1614,7 @@ TEST_F(Specifications, UnhandledInterCU) {
 
   // Third CU.  Defines member_func_B.
   {
-    DwarfCUToModule root3_handler(&fc, &lr, &reporter_);
+    DwarfCUToModule root3_handler(&fc, &lr, nullptr, &reporter_);
     ASSERT_TRUE(root3_handler.StartCompilationUnit(0, 1, 2, 3, 3));
     ASSERT_TRUE(root3_handler.StartRootDIE(1,
                                            dwarf2reader::DW_TAG_compile_unit));
@@ -1582,7 +1665,7 @@ TEST_F(Specifications, ClassDefinitionHasOwnName) {
   DeclarationDIE(&root_handler_, 0xd0fe467ec2f1a58cULL,
                  dwarf2reader::DW_TAG_class_type, "class-declaration-name", "");
 
-  dwarf2reader::DIEHandler *class_definition
+  dwarf2reader::DIEHandler* class_definition
     = StartSpecifiedDIE(&root_handler_, dwarf2reader::DW_TAG_class_type,
                         0xd0fe467ec2f1a58cULL, "class-definition-name");
   ASSERT_TRUE(class_definition);
@@ -1613,7 +1696,7 @@ TEST_F(Specifications, PreferSpecificationParents) {
 
   StartCU();
   {
-    dwarf2reader::DIEHandler *declaration_class_handler =
+    dwarf2reader::DIEHandler* declaration_class_handler =
       StartNamedDIE(&root_handler_, dwarf2reader::DW_TAG_class_type,
                     "declaration-class");
     DeclarationDIE(declaration_class_handler, 0x9ddb35517455ef7aULL,
@@ -1623,7 +1706,7 @@ TEST_F(Specifications, PreferSpecificationParents) {
     delete declaration_class_handler;
   }
   {
-    dwarf2reader::DIEHandler *definition_class_handler
+    dwarf2reader::DIEHandler* definition_class_handler
       = StartNamedDIE(&root_handler_, dwarf2reader::DW_TAG_class_type,
                       "definition-class");
     DefinitionDIE(definition_class_handler, dwarf2reader::DW_TAG_subprogram,
@@ -1712,16 +1795,15 @@ TEST_F(CUErrors, BadCURootDIETag) {
 // produce) output, so their results need to be checked by hand.
 struct Reporter: public Test {
   Reporter()
-      : reporter("filename", 0x123456789abcdef0ULL) {
+      : reporter("filename", 0x123456789abcdef0ULL),
+        function("function name", 0x19c45c30770c1eb0ULL),
+        file("source file name") {
     reporter.SetCUName("compilation-unit-name");
 
-    function.name = "function name";
-    function.address = 0x19c45c30770c1eb0ULL;
-    function.size = 0x89808a5bdfa0a6a3ULL;
+    Module::Range range(0x19c45c30770c1eb0ULL, 0x89808a5bdfa0a6a3ULL);
+    function.ranges.push_back(range);
     function.parameter_size = 0x6a329f18683dcd51ULL;
 
-    file.name = "source file name";
-
     line.address = 0x3606ac6267aebeccULL;
     line.size = 0x5de482229f32556aULL;
     line.file = &file;
diff --git a/src/MEGASync/google_breakpad/common/dwarf_line_to_module.cc b/src/MEGASync/google_breakpad/common/dwarf_line_to_module.cc
index 258b0b60..fe808c08 100644
--- a/src/MEGASync/google_breakpad/common/dwarf_line_to_module.cc
+++ b/src/MEGASync/google_breakpad/common/dwarf_line_to_module.cc
@@ -44,18 +44,18 @@
 // it until we actually have to deal with DWARF on Windows.
 
 // Return true if PATH is an absolute path, false if it is relative.
-static bool PathIsAbsolute(const string &path) {
+static bool PathIsAbsolute(const string& path) {
   return (path.size() >= 1 && path[0] == '/');
 }
 
-static bool HasTrailingSlash(const string &path) {
+static bool HasTrailingSlash(const string& path) {
   return (path.size() >= 1 && path[path.size() - 1] == '/');
 }
 
 // If PATH is an absolute path, return PATH.  If PATH is a relative path,
 // treat it as relative to BASE and return the combined path.
-static string ExpandPath(const string &path,
-                         const string &base) {
+static string ExpandPath(const string& path,
+                         const string& base) {
   if (PathIsAbsolute(path) || base.empty())
     return path;
   return base + (HasTrailingSlash(base) ? "" : "/") + path;
@@ -63,16 +63,16 @@ static string ExpandPath(const string &path,
 
 namespace google_breakpad {
 
-void DwarfLineToModule::DefineDir(const string &name, uint32 dir_num) {
+void DwarfLineToModule::DefineDir(const string& name, uint32_t dir_num) {
   // Directory number zero is reserved to mean the compilation
   // directory. Silently ignore attempts to redefine it.
   if (dir_num != 0)
     directories_[dir_num] = ExpandPath(name, compilation_dir_);
 }
 
-void DwarfLineToModule::DefineFile(const string &name, int32 file_num,
-                                   uint32 dir_num, uint64 mod_time,
-                                   uint64 length) {
+void DwarfLineToModule::DefineFile(const string& name, int32_t file_num,
+                                   uint32_t dir_num, uint64_t mod_time,
+                                   uint64_t length) {
   if (file_num == -1)
     file_num = ++highest_file_number_;
   else if (file_num > highest_file_number_)
@@ -103,9 +103,9 @@ void DwarfLineToModule::DefineFile(const string &name, int32 file_num,
   files_[file_num] = module_->FindFile(full_name);
 }
 
-void DwarfLineToModule::AddLine(uint64 address, uint64 length,
-                                uint32 file_num, uint32 line_num,
-                                uint32 column_num) {
+void DwarfLineToModule::AddLine(uint64_t address, uint64_t length,
+                                uint32_t file_num, uint32_t line_num,
+                                uint32_t column_num) {
   if (length == 0)
     return;
 
diff --git a/src/MEGASync/google_breakpad/common/dwarf_line_to_module.h b/src/MEGASync/google_breakpad/common/dwarf_line_to_module.h
index 1fdd4cb7..f80f1b07 100644
--- a/src/MEGASync/google_breakpad/common/dwarf_line_to_module.h
+++ b/src/MEGASync/google_breakpad/common/dwarf_line_to_module.h
@@ -121,7 +121,7 @@ class DwarfLineToModule: public dwarf2reader::LineInfoHandler {
   // sort out which lines belong to which functions; we don't add them
   // to any particular function in MODULE ourselves.
   DwarfLineToModule(Module *module, const string& compilation_dir,
-                    vector<Module::Line> *lines)
+                    vector<Module::Line>* lines)
       : module_(module),
         compilation_dir_(compilation_dir),
         lines_(lines),
@@ -132,17 +132,17 @@ class DwarfLineToModule: public dwarf2reader::LineInfoHandler {
   
   ~DwarfLineToModule() { }
 
-  void DefineDir(const string &name, uint32 dir_num);
-  void DefineFile(const string &name, int32 file_num,
-                  uint32 dir_num, uint64 mod_time,
-                  uint64 length);
-  void AddLine(uint64 address, uint64 length,
-               uint32 file_num, uint32 line_num, uint32 column_num);
+  void DefineDir(const string& name, uint32_t dir_num);
+  void DefineFile(const string& name, int32_t file_num,
+                  uint32_t dir_num, uint64_t mod_time,
+                  uint64_t length);
+  void AddLine(uint64_t address, uint64_t length,
+               uint32_t file_num, uint32_t line_num, uint32_t column_num);
 
  private:
 
-  typedef std::map<uint32, string> DirectoryTable;
-  typedef std::map<uint32, Module::File *> FileTable;
+  typedef std::map<uint32_t, string> DirectoryTable;
+  typedef std::map<uint32_t, Module::File*> FileTable;
 
   // The module we're contributing debugging info to. Owned by our
   // client.
@@ -161,7 +161,7 @@ class DwarfLineToModule: public dwarf2reader::LineInfoHandler {
   // to the appropriate function from module_ until we've read the
   // function info as well. Instead, we accumulate lines here, and let
   // whoever constructed this sort it all out.
-  vector<Module::Line> *lines_;
+  vector<Module::Line>* lines_;
 
   // A table mapping directory numbers to paths.
   DirectoryTable directories_;
@@ -171,12 +171,12 @@ class DwarfLineToModule: public dwarf2reader::LineInfoHandler {
 
   // The highest file number we've seen so far, or -1 if we've seen
   // none.  Used for dynamically defined file numbers.
-  int32 highest_file_number_;
+  int32_t highest_file_number_;
   
   // This is the ending address of the last line we omitted, or zero if we
   // didn't omit the previous line. It is zero before we have received any
   // AddLine calls.
-  uint64 omitted_line_end_;
+  uint64_t omitted_line_end_;
 
   // True if we've warned about:
   bool warned_bad_file_number_; // bad file numbers
diff --git a/src/MEGASync/google_breakpad/common/dwarf_line_to_module_unittest.cc b/src/MEGASync/google_breakpad/common/dwarf_line_to_module_unittest.cc
index 7c0fcfd3..90b6570d 100644
--- a/src/MEGASync/google_breakpad/common/dwarf_line_to_module_unittest.cc
+++ b/src/MEGASync/google_breakpad/common/dwarf_line_to_module_unittest.cc
@@ -51,7 +51,7 @@ TEST(SimpleModule, One) {
   h.AddLine(0x6fd126fbf74f2680LL, 0x63c9a14cf556712bLL, 0x30bf0f27,
             0x4c090cbf, 0x1cf9fe0d);
 
-  vector<Module::File *> files;
+  vector<Module::File*> files;
   m.GetFiles(&files);
   EXPECT_EQ(1U, files.size());
   EXPECT_STREQ("/file1", files[0]->name.c_str());
@@ -86,7 +86,7 @@ TEST(SimpleModule, Many) {
   h.AddLine(0xe2d72a37f8d9403aULL, 0x034dfab5b0d4d236ULL, 0x63beb4a5,
             0x75047044U, 0xb6a0016cU);
 
-  vector<Module::File *> files;
+  vector<Module::File*> files;
   m.GetFiles(&files);
   ASSERT_EQ(5U, files.size());
   EXPECT_STREQ("/directory1/file1", files[0]->name.c_str());
@@ -133,7 +133,7 @@ TEST(Filenames, Absolute) {
 
   h.AddLine(1, 1, 1, 0, 0);
 
-  vector<Module::File *> files;
+  vector<Module::File*> files;
   m.GetFiles(&files);
   ASSERT_EQ(1U, files.size());
   EXPECT_STREQ("/absolute", files[0]->name.c_str());
@@ -151,7 +151,7 @@ TEST(Filenames, Relative) {
 
   h.AddLine(1, 1, 1, 0, 0);
 
-  vector<Module::File *> files;
+  vector<Module::File*> files;
   m.GetFiles(&files);
   ASSERT_EQ(1U, files.size());
   EXPECT_STREQ("/directory1/relative", files[0]->name.c_str());
diff --git a/src/MEGASync/google_breakpad/common/dwarf_range_list_handler.cc b/src/MEGASync/google_breakpad/common/dwarf_range_list_handler.cc
new file mode 100644
index 00000000..58982aac
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/dwarf_range_list_handler.cc
@@ -0,0 +1,60 @@
+// Copyright (c) 2018 Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// Original author: Gabriele Svelto <gsvelto@mozilla.com>
+//                                  <gabriele.svelto@gmail.com>
+
+// dwarf_range_list_handler.cc: Implementation of DwarfRangeListHandler class.
+// See dwarf_range_list_handler.h for details.
+
+#include <algorithm>
+
+#include "common/dwarf_range_list_handler.h"
+
+namespace google_breakpad {
+
+void DwarfRangeListHandler::AddRange(uint64_t begin, uint64_t end) {
+  Module::Range r(begin + base_address_, end - begin);
+
+  ranges_->push_back(r);
+}
+
+void DwarfRangeListHandler::SetBaseAddress(uint64_t base_address) {
+  base_address_ = base_address;
+}
+
+void DwarfRangeListHandler::Finish() {
+  std::sort(ranges_->begin(), ranges_->end(),
+    [](const Module::Range& a, const Module::Range& b) {
+      return a.address < b.address;
+    }
+  );
+}
+
+} // namespace google_breakpad
diff --git a/src/MEGASync/google_breakpad/common/dwarf_range_list_handler.h b/src/MEGASync/google_breakpad/common/dwarf_range_list_handler.h
new file mode 100644
index 00000000..2adb2f9a
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/dwarf_range_list_handler.h
@@ -0,0 +1,79 @@
+// -*- mode: c++ -*-
+
+// Copyright (c) 2018 Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// Original author: Gabriele Svelto <gsvelto@mozilla.com>
+//                                  <gabriele.svelto@gmail.com>
+
+// The DwarfRangeListHandler class accepts rangelist data from a DWARF parser
+// and adds it to a google_breakpad::Function or other objects supporting
+// ranges.
+
+#ifndef COMMON_LINUX_DWARF_RANGE_LIST_HANDLER_H
+#define COMMON_LINUX_DWARF_RANGE_LIST_HANDLER_H
+
+#include <vector>
+
+#include "common/module.h"
+#include "common/dwarf/dwarf2reader.h"
+
+namespace google_breakpad {
+
+// A class for producing a vector of google_breakpad::Module::Range
+// instances from a parsed DWARF range list.
+
+class DwarfRangeListHandler: public dwarf2reader::RangeListHandler {
+ public:
+  DwarfRangeListHandler(uint64_t base_address, vector<Module::Range>* ranges)
+      : base_address_(base_address), ranges_(ranges) { }
+
+  ~DwarfRangeListHandler() { }
+
+  // Add a range to the list
+  void AddRange(uint64_t begin, uint64_t end);
+
+  // Record the new base address and use it for the following entries
+  void SetBaseAddress(uint64_t base_address);
+
+  // Sort the ranges so that they are in ascending order of starting address
+  void Finish();
+
+ private:
+  // The current PC to add to every entry, this can be overridden by a special
+  // list entry
+  uint64_t base_address_;
+
+  // The list of ranges to be populated
+  vector<Module::Range>* ranges_;
+};
+
+} // namespace google_breakpad
+
+#endif // COMMON_LINUX_DWARF_RANGE_LIST_HANDLER_H
diff --git a/src/MEGASync/google_breakpad/common/language.cc b/src/MEGASync/google_breakpad/common/language.cc
index c2fd81f6..381c8bd4 100644
--- a/src/MEGASync/google_breakpad/common/language.cc
+++ b/src/MEGASync/google_breakpad/common/language.cc
@@ -34,18 +34,92 @@
 
 #include "common/language.h"
 
+#include <stdlib.h>
+
+#if !defined(__ANDROID__)
+#include <cxxabi.h>
+#endif
+
+#if defined(HAVE_RUST_DEMANGLE)
+#include <rust_demangle.h>
+#endif
+
+#include <limits>
+
+namespace {
+
+string MakeQualifiedNameWithSeparator(const string& parent_name,
+                                      const char* separator,
+                                      const string& name) {
+  if (parent_name.empty()) {
+    return name;
+  }
+
+  return parent_name + separator + name;
+}
+
+}  // namespace
+
 namespace google_breakpad {
 
 // C++ language-specific operations.
 class CPPLanguage: public Language {
  public:
   CPPLanguage() {}
-  string MakeQualifiedName(const string &parent_name,
-                           const string &name) const {
-    if (parent_name.empty())
-      return name;
-    else
-      return parent_name + "::" + name;
+
+  string MakeQualifiedName(const string& parent_name,
+                           const string& name) const {
+    return MakeQualifiedNameWithSeparator(parent_name, "::", name);
+  }
+
+  virtual DemangleResult DemangleName(const string& mangled,
+                                      string* demangled) const {
+#if defined(__ANDROID__)
+    // Android NDK doesn't provide abi::__cxa_demangle.
+    demangled->clear();
+    return kDontDemangle;
+#else
+    // Attempting to demangle non-C++ symbols with the C++ demangler would print
+    // warnings and fail, so return kDontDemangle for these.
+    if (!IsMangledName(mangled)) {
+      demangled->clear();
+      return kDontDemangle;
+    }
+
+    int status;
+    char* demangled_c =
+        abi::__cxa_demangle(mangled.c_str(), NULL, NULL, &status);
+
+    DemangleResult result;
+    if (status == 0) {
+      result = kDemangleSuccess;
+      demangled->assign(demangled_c);
+    } else {
+      result = kDemangleFailure;
+      demangled->clear();
+    }
+
+    if (demangled_c) {
+      free(reinterpret_cast<void*>(demangled_c));
+    }
+
+    return result;
+#endif
+  }
+
+ private:
+  static bool IsMangledName(const string& name) {
+    // NOTE: For proper cross-compilation support, this should depend on target
+    // binary's platform, not current build platform.
+#if defined(__APPLE__)
+    // Mac C++ symbols can have up to 4 underscores, followed by a "Z".
+    // Non-C++ symbols are not coded that way, but may have leading underscores.
+    size_t i = name.find_first_not_of('_');
+    return i > 0 && i != string::npos && i <= 4 && name[i] == 'Z';
+#else
+    // Linux C++ symbols always start with "_Z".
+    return name.size() > 2 && name[0] == '_' && name[1] == 'Z';
+#endif
   }
 };
 
@@ -54,22 +128,82 @@ CPPLanguage CPPLanguageSingleton;
 // Java language-specific operations.
 class JavaLanguage: public Language {
  public:
-  string MakeQualifiedName(const string &parent_name,
-                           const string &name) const {
-    if (parent_name.empty())
-      return name;
-    else
-      return parent_name + "." + name;
+  JavaLanguage() {}
+
+  string MakeQualifiedName(const string& parent_name,
+                           const string& name) const {
+    return MakeQualifiedNameWithSeparator(parent_name, ".", name);
   }
 };
 
 JavaLanguage JavaLanguageSingleton;
 
+// Swift language-specific operations.
+class SwiftLanguage: public Language {
+ public:
+  SwiftLanguage() {}
+
+  string MakeQualifiedName(const string& parent_name,
+                           const string& name) const {
+    return MakeQualifiedNameWithSeparator(parent_name, ".", name);
+  }
+
+  virtual DemangleResult DemangleName(const string& mangled,
+                                      string* demangled) const {
+    // There is no programmatic interface to a Swift demangler. Pass through the
+    // mangled form because it encodes more information than the qualified name
+    // that would have been built by MakeQualifiedName(). The output can be
+    // post-processed by xcrun swift-demangle to transform mangled Swift names
+    // into something more readable.
+    demangled->assign(mangled);
+    return kDemangleSuccess;
+  }
+};
+
+SwiftLanguage SwiftLanguageSingleton;
+
+// Rust language-specific operations.
+class RustLanguage: public Language {
+ public:
+  RustLanguage() {}
+
+  string MakeQualifiedName(const string& parent_name,
+                           const string& name) const {
+    return MakeQualifiedNameWithSeparator(parent_name, ".", name);
+  }
+
+  virtual DemangleResult DemangleName(const string& mangled,
+                                      string* demangled) const {
+    // Rust names use GCC C++ name mangling, but demangling them with
+    // abi_demangle doesn't produce stellar results due to them having
+    // another layer of encoding.
+    // If callers provide rustc-demangle, use that.
+#if defined(HAVE_RUST_DEMANGLE)
+    char* rust_demangled = rust_demangle(mangled.c_str());
+    if (rust_demangled == nullptr) {
+      return kDemangleFailure;
+    }
+    demangled->assign(rust_demangled);
+    free_rust_demangled_name(rust_demangled);
+#else
+    // Otherwise, pass through the mangled name so callers can demangle
+    // after the fact.
+    demangled->assign(mangled);
+#endif
+    return kDemangleSuccess;
+  }
+};
+
+RustLanguage RustLanguageSingleton;
+
 // Assembler language-specific operations.
 class AssemblerLanguage: public Language {
+ public:
+  AssemblerLanguage() {}
+
   bool HasFunctions() const { return false; }
-  string MakeQualifiedName(const string &parent_name,
-                           const string &name) const {
+  string MakeQualifiedName(const string& parent_name,
+                           const string& name) const {
     return name;
   }
 };
@@ -78,6 +212,8 @@ AssemblerLanguage AssemblerLanguageSingleton;
 
 const Language * const Language::CPlusPlus = &CPPLanguageSingleton;
 const Language * const Language::Java = &JavaLanguageSingleton;
+const Language * const Language::Swift = &SwiftLanguageSingleton;
+const Language * const Language::Rust = &RustLanguageSingleton;
 const Language * const Language::Assembler = &AssemblerLanguageSingleton;
 
 } // namespace google_breakpad
diff --git a/src/MEGASync/google_breakpad/common/language.h b/src/MEGASync/google_breakpad/common/language.h
index bbe30334..892ea862 100644
--- a/src/MEGASync/google_breakpad/common/language.h
+++ b/src/MEGASync/google_breakpad/common/language.h
@@ -74,12 +74,29 @@ class Language {
   // take into account the parent and child DIE types, allow languages
   // to use their own data type for complex parent names, etc. But if
   // C++ doesn't need all that, who would?
-  virtual string MakeQualifiedName (const string &parent_name,
-                                    const string &name) const = 0;
+  virtual string MakeQualifiedName (const string& parent_name,
+                                    const string& name) const = 0;
+
+  enum DemangleResult {
+    // Demangling was not performed because its not appropriate to attempt.
+    kDontDemangle = -1,
+
+    kDemangleSuccess,
+    kDemangleFailure,
+  };
+
+  // Wraps abi::__cxa_demangle() or similar for languages where appropriate.
+  virtual DemangleResult DemangleName(const string& mangled,
+                                      string* demangled) const {
+    demangled->clear();
+    return kDontDemangle;
+  }
 
   // Instances for specific languages.
   static const Language * const CPlusPlus,
                         * const Java,
+                        * const Swift,
+                        * const Rust,
                         * const Assembler;
 };
 
diff --git a/src/MEGASync/google_breakpad/common/linux/breakpad_getcontext.S b/src/MEGASync/google_breakpad/common/linux/breakpad_getcontext.S
new file mode 100644
index 00000000..528dba7a
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/linux/breakpad_getcontext.S
@@ -0,0 +1,486 @@
+// Copyright (c) 2012, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// A minimalistic implementation of getcontext() to be used by
+// Google Breakpad when getcontext() is not available in libc.
+
+#include "common/linux/ucontext_constants.h"
+
+/* int getcontext (ucontext_t* ucp) */
+
+#if defined(__arm__)
+
+  .text
+  .global breakpad_getcontext
+  .hidden breakpad_getcontext
+  .type breakpad_getcontext, #function
+  .align 0
+  .fnstart
+breakpad_getcontext:
+
+  /* First, save r4-r11 */
+  add   r1, r0, #(MCONTEXT_GREGS_OFFSET + 4*4)
+  stm   r1, {r4-r11}
+
+  /* r12 is a scratch register, don't save it */
+
+  /* Save sp and lr explicitly. */
+  /* - sp can't be stored with stmia in Thumb-2 */
+  /* - STM instructions that store sp and pc are deprecated in ARM */
+  str   sp, [r0, #(MCONTEXT_GREGS_OFFSET + 13*4)]
+  str   lr, [r0, #(MCONTEXT_GREGS_OFFSET + 14*4)]
+
+  /* Save the caller's address in 'pc' */
+  str   lr, [r0, #(MCONTEXT_GREGS_OFFSET + 15*4)]
+
+  /* Save ucontext_t* pointer across next call */
+  mov   r4, r0
+
+  /* Call sigprocmask(SIG_BLOCK, NULL, &(ucontext->uc_sigmask)) */
+  mov   r0, #0  /* SIG_BLOCK */
+  mov   r1, #0  /* NULL */
+  add   r2, r4, #UCONTEXT_SIGMASK_OFFSET
+  bl    sigprocmask(PLT)
+
+  /* Intentionally do not save the FPU state here. This is because on
+   * Linux/ARM, one should instead use ptrace(PTRACE_GETFPREGS) or
+   * ptrace(PTRACE_GETVFPREGS) to get it.
+   *
+   * Note that a real implementation of getcontext() would need to save
+   * this here to allow setcontext()/swapcontext() to work correctly.
+   */
+
+  /* Restore the values of r4 and lr */
+  mov   r0, r4
+  ldr   lr, [r0, #(MCONTEXT_GREGS_OFFSET + 14*4)]
+  ldr   r4, [r0, #(MCONTEXT_GREGS_OFFSET +  4*4)]
+
+  /* Return 0 */
+  mov   r0, #0
+  bx    lr
+
+  .fnend
+  .size breakpad_getcontext, . - breakpad_getcontext
+
+#elif defined(__aarch64__)
+
+#define  _NSIG                       64
+#define  __NR_rt_sigprocmask         135
+
+  .text
+  .global breakpad_getcontext
+  .hidden breakpad_getcontext
+  .type breakpad_getcontext, #function
+  .align 4
+  .cfi_startproc
+breakpad_getcontext:
+
+  /* The saved context will return to the getcontext() call point
+     with a return value of 0 */
+  str     xzr,      [x0, MCONTEXT_GREGS_OFFSET +  0 * REGISTER_SIZE]
+
+  stp     x18, x19, [x0, MCONTEXT_GREGS_OFFSET + 18 * REGISTER_SIZE]
+  stp     x20, x21, [x0, MCONTEXT_GREGS_OFFSET + 20 * REGISTER_SIZE]
+  stp     x22, x23, [x0, MCONTEXT_GREGS_OFFSET + 22 * REGISTER_SIZE]
+  stp     x24, x25, [x0, MCONTEXT_GREGS_OFFSET + 24 * REGISTER_SIZE]
+  stp     x26, x27, [x0, MCONTEXT_GREGS_OFFSET + 26 * REGISTER_SIZE]
+  stp     x28, x29, [x0, MCONTEXT_GREGS_OFFSET + 28 * REGISTER_SIZE]
+  str     x30,      [x0, MCONTEXT_GREGS_OFFSET + 30 * REGISTER_SIZE]
+
+  /* Place LR into the saved PC, this will ensure that when
+     switching to this saved context with setcontext() control
+     will pass back to the caller of getcontext(), we have
+     already arranged to return the appropriate return value in x0
+     above.  */
+  str     x30, [x0, MCONTEXT_PC_OFFSET]
+
+  /* Save the current SP */
+  mov     x2, sp
+  str     x2, [x0, MCONTEXT_SP_OFFSET]
+
+  /* Initialize the pstate.  */
+  str     xzr, [x0, MCONTEXT_PSTATE_OFFSET]
+
+  /* Figure out where to place the first context extension
+     block.  */
+  add     x2, x0, #MCONTEXT_EXTENSION_OFFSET
+
+  /* Write the context extension fpsimd header.  */
+  mov     w3, #(FPSIMD_MAGIC & 0xffff)
+  movk    w3, #(FPSIMD_MAGIC >> 16), lsl #16
+  str     w3, [x2, #FPSIMD_CONTEXT_MAGIC_OFFSET]
+  mov     w3, #FPSIMD_CONTEXT_SIZE
+  str     w3, [x2, #FPSIMD_CONTEXT_SIZE_OFFSET]
+
+  /* Fill in the FP SIMD context.  */
+  add     x3, x2, #(FPSIMD_CONTEXT_VREGS_OFFSET + 8 * SIMD_REGISTER_SIZE)
+  stp     d8,  d9, [x3], #(2 * SIMD_REGISTER_SIZE)
+  stp     d10, d11, [x3], #(2 * SIMD_REGISTER_SIZE)
+  stp     d12, d13, [x3], #(2 * SIMD_REGISTER_SIZE)
+  stp     d14, d15, [x3], #(2 * SIMD_REGISTER_SIZE)
+
+  add     x3, x2, FPSIMD_CONTEXT_FPSR_OFFSET
+
+  mrs     x4, fpsr
+  str     w4, [x3]
+
+  mrs     x4, fpcr
+  str     w4, [x3, FPSIMD_CONTEXT_FPCR_OFFSET - FPSIMD_CONTEXT_FPSR_OFFSET]
+
+  /* Write the termination context extension header.  */
+  add     x2, x2, #FPSIMD_CONTEXT_SIZE
+
+  str     xzr, [x2, #FPSIMD_CONTEXT_MAGIC_OFFSET]
+  str     xzr, [x2, #FPSIMD_CONTEXT_SIZE_OFFSET]
+
+  /* Grab the signal mask */
+  /* rt_sigprocmask (SIG_BLOCK, NULL, &ucp->uc_sigmask, _NSIG8) */
+  add     x2, x0, #UCONTEXT_SIGMASK_OFFSET
+  mov     x0, #0  /* SIG_BLOCK */
+  mov     x1, #0  /* NULL */
+  mov     x3, #(_NSIG / 8)
+  mov     x8, #__NR_rt_sigprocmask
+  svc     0
+
+  /* Return x0 for success */
+  mov     x0, 0
+  ret
+
+  .cfi_endproc
+  .size breakpad_getcontext, . - breakpad_getcontext
+
+#elif defined(__i386__)
+
+  .text
+  .global breakpad_getcontext
+  .hidden breakpad_getcontext
+  .align 4
+  .type breakpad_getcontext, @function
+
+breakpad_getcontext:
+
+  movl 4(%esp), %eax   /* eax = uc */
+
+  /* Save register values */
+  movl %ecx, MCONTEXT_ECX_OFFSET(%eax)
+  movl %edx, MCONTEXT_EDX_OFFSET(%eax)
+  movl %ebx, MCONTEXT_EBX_OFFSET(%eax)
+  movl %edi, MCONTEXT_EDI_OFFSET(%eax)
+  movl %esi, MCONTEXT_ESI_OFFSET(%eax)
+  movl %ebp, MCONTEXT_EBP_OFFSET(%eax)
+
+  movl (%esp), %edx   /* return address */
+  lea  4(%esp), %ecx  /* exclude return address from stack */
+  mov  %edx, MCONTEXT_EIP_OFFSET(%eax)
+  mov  %ecx, MCONTEXT_ESP_OFFSET(%eax)
+
+  xorl %ecx, %ecx
+  movw %fs, %cx
+  mov  %ecx, MCONTEXT_FS_OFFSET(%eax)
+
+  movl $0, MCONTEXT_EAX_OFFSET(%eax)
+
+  /* Save floating point state to fpregstate, then update
+   * the fpregs pointer to point to it */
+  leal UCONTEXT_FPREGS_MEM_OFFSET(%eax), %ecx
+  fnstenv (%ecx)
+  fldenv  (%ecx)
+  mov %ecx, UCONTEXT_FPREGS_OFFSET(%eax)
+
+  /* Save signal mask: sigprocmask(SIGBLOCK, NULL, &uc->uc_sigmask) */
+  leal UCONTEXT_SIGMASK_OFFSET(%eax), %edx
+  xorl %ecx, %ecx
+  push %edx   /* &uc->uc_sigmask */
+  push %ecx   /* NULL */
+  push %ecx   /* SIGBLOCK == 0 on i386 */
+  call sigprocmask@PLT
+  addl $12, %esp
+
+  movl $0, %eax
+  ret
+
+  .size breakpad_getcontext, . - breakpad_getcontext
+
+#elif defined(__mips__)
+
+// This implementation is inspired by implementation of getcontext in glibc.
+#include <asm-mips/asm.h>
+#include <asm-mips/regdef.h>
+#if _MIPS_SIM == _ABIO32
+#include <asm-mips/fpregdef.h>
+#endif
+
+// from asm-mips/asm.h
+#if _MIPS_SIM == _ABIO32
+#define ALSZ 7
+#define ALMASK ~7
+#define SZREG 4
+#else // _MIPS_SIM != _ABIO32
+#define ALSZ 15
+#define ALMASK ~15
+#define SZREG 8
+#endif
+
+#include <asm/unistd.h> // for __NR_rt_sigprocmask
+
+#define _NSIG8 128 / 8
+#define SIG_BLOCK 1
+
+
+  .text
+LOCALS_NUM = 1 // save gp on stack
+FRAME_SIZE = ((LOCALS_NUM * SZREG) + ALSZ) & ALMASK
+
+GP_FRAME_OFFSET = FRAME_SIZE - (1 * SZREG)
+MCONTEXT_REG_SIZE = 8
+
+#if _MIPS_SIM == _ABIO32
+
+NESTED (breakpad_getcontext, FRAME_SIZE, ra)
+  .mask	0x00000000, 0
+  .fmask 0x00000000, 0
+
+  .set noreorder
+  .cpload t9
+  .set reorder
+
+  move a2, sp
+#define _SP a2
+
+  addiu sp, -FRAME_SIZE
+  .cprestore GP_FRAME_OFFSET
+
+  sw s0, (16 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
+  sw s1, (17 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
+  sw s2, (18 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
+  sw s3, (19 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
+  sw s4, (20 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
+  sw s5, (21 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
+  sw s6, (22 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
+  sw s7, (23 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
+  sw _SP, (29 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
+  sw fp, (30 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
+  sw ra, (31 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
+  sw ra, MCONTEXT_PC_OFFSET(a0)
+
+#ifdef __mips_hard_float
+  s.d fs0, (20 * MCONTEXT_REG_SIZE + MCONTEXT_FPREGS_OFFSET)(a0)
+  s.d fs1, (22 * MCONTEXT_REG_SIZE + MCONTEXT_FPREGS_OFFSET)(a0)
+  s.d fs2, (24 * MCONTEXT_REG_SIZE + MCONTEXT_FPREGS_OFFSET)(a0)
+  s.d fs3, (26 * MCONTEXT_REG_SIZE + MCONTEXT_FPREGS_OFFSET)(a0)
+  s.d fs4, (28 * MCONTEXT_REG_SIZE + MCONTEXT_FPREGS_OFFSET)(a0)
+  s.d fs5, (30 * MCONTEXT_REG_SIZE + MCONTEXT_FPREGS_OFFSET)(a0)
+
+  cfc1 v1, fcr31
+  sw v1, MCONTEXT_FPC_CSR(a0)
+#endif  // __mips_hard_float
+
+  /* rt_sigprocmask (SIG_BLOCK, NULL, &ucp->uc_sigmask, _NSIG8) */
+  li a3, _NSIG8
+  addu a2, a0, UCONTEXT_SIGMASK_OFFSET
+  move a1, zero
+  li a0, SIG_BLOCK
+  li v0, __NR_rt_sigprocmask
+  syscall
+
+  addiu sp, FRAME_SIZE
+  jr ra
+
+END (breakpad_getcontext)
+#else
+
+#ifndef NESTED
+/*
+ * NESTED - declare nested routine entry point
+ */
+#define NESTED(symbol, framesize, rpc)  \
+    .globl  symbol;                     \
+    .align  2;                          \
+    .type symbol,@function;             \
+    .ent  symbol,0;                     \
+symbol:   .frame  sp, framesize, rpc;
+#endif
+
+/*
+ * END - mark end of function
+ */
+#ifndef END
+# define END(function)                  \
+    .end  function;                     \
+    .size function,.-function
+#endif
+
+/* int getcontext (ucontext_t* ucp) */
+
+NESTED (breakpad_getcontext, FRAME_SIZE, ra)
+  .mask   0x10000000, 0
+  .fmask  0x00000000, 0
+
+  move  a2, sp
+#define _SP a2
+  move  a3, gp
+#define _GP a3
+
+  daddiu sp, -FRAME_SIZE
+  .cpsetup $25, GP_FRAME_OFFSET, breakpad_getcontext
+
+  /* Store a magic flag.  */
+  li  v1, 1
+  sd v1, (0 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)  /* zero */
+
+  sd s0, (16 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
+  sd s1, (17 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
+  sd s2, (18 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
+  sd s3, (19 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
+  sd s4, (20 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
+  sd s5, (21 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
+  sd s6, (22 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
+  sd s7, (23 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
+  sd _GP, (28 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
+  sd _SP, (29 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
+  sd s8, (30 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
+  sd ra, (31 * MCONTEXT_REG_SIZE + MCONTEXT_GREGS_OFFSET)(a0)
+  sd ra, MCONTEXT_PC_OFFSET(a0)
+
+#ifdef __mips_hard_float
+  s.d $f24, (24 * MCONTEXT_REG_SIZE + MCONTEXT_FPREGS_OFFSET)(a0)
+  s.d $f25, (25 * MCONTEXT_REG_SIZE + MCONTEXT_FPREGS_OFFSET)(a0)
+  s.d $f26, (26 * MCONTEXT_REG_SIZE + MCONTEXT_FPREGS_OFFSET)(a0)
+  s.d $f27, (27 * MCONTEXT_REG_SIZE + MCONTEXT_FPREGS_OFFSET)(a0)
+  s.d $f28, (28 * MCONTEXT_REG_SIZE + MCONTEXT_FPREGS_OFFSET)(a0)
+  s.d $f29, (29 * MCONTEXT_REG_SIZE + MCONTEXT_FPREGS_OFFSET)(a0)
+  s.d $f30, (30 * MCONTEXT_REG_SIZE + MCONTEXT_FPREGS_OFFSET)(a0)
+  s.d $f31, (31 * MCONTEXT_REG_SIZE + MCONTEXT_FPREGS_OFFSET)(a0)
+
+  cfc1  v1, $31
+  sw  v1, MCONTEXT_FPC_CSR(a0)
+#endif /* __mips_hard_float */
+
+/* rt_sigprocmask (SIG_BLOCK, NULL, &ucp->uc_sigmask, _NSIG8) */
+  li  a3, _NSIG8
+  daddu a2, a0, UCONTEXT_SIGMASK_OFFSET
+  move  a1, zero
+  li  a0, SIG_BLOCK
+
+  li  v0, __NR_rt_sigprocmask
+  syscall
+
+  .cpreturn
+  daddiu sp, FRAME_SIZE
+  move  v0, zero
+  jr  ra
+
+END (breakpad_getcontext)
+#endif // _MIPS_SIM == _ABIO32
+
+#elif defined(__x86_64__)
+/* The x64 implementation of breakpad_getcontext was derived in part
+   from the implementation of libunwind which requires the following
+   notice. */
+/* libunwind - a platform-independent unwind library
+   Copyright (C) 2008 Google, Inc
+	Contributed by Paul Pluzhnikov <ppluzhnikov@google.com>
+   Copyright (C) 2010 Konstantin Belousov <kib@freebsd.org>
+
+This file is part of libunwind.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+  .text
+  .global breakpad_getcontext
+  .hidden breakpad_getcontext
+  .align 4
+  .type breakpad_getcontext, @function
+
+breakpad_getcontext:
+  .cfi_startproc
+
+  /* Callee saved: RBX, RBP, R12-R15  */
+  movq %r12, MCONTEXT_GREGS_R12(%rdi)
+  movq %r13, MCONTEXT_GREGS_R13(%rdi)
+  movq %r14, MCONTEXT_GREGS_R14(%rdi)
+  movq %r15, MCONTEXT_GREGS_R15(%rdi)
+  movq %rbp, MCONTEXT_GREGS_RBP(%rdi)
+  movq %rbx, MCONTEXT_GREGS_RBX(%rdi)
+
+  /* Save argument registers (not strictly needed, but setcontext
+     restores them, so don't restore garbage).  */
+  movq %r8,  MCONTEXT_GREGS_R8(%rdi)
+  movq %r9,  MCONTEXT_GREGS_R9(%rdi)
+  movq %rdi, MCONTEXT_GREGS_RDI(%rdi)
+  movq %rsi, MCONTEXT_GREGS_RSI(%rdi)
+  movq %rdx, MCONTEXT_GREGS_RDX(%rdi)
+  movq %rax, MCONTEXT_GREGS_RAX(%rdi)
+  movq %rcx, MCONTEXT_GREGS_RCX(%rdi)
+
+  /* Save fp state (not needed, except for setcontext not
+     restoring garbage).  */
+  leaq MCONTEXT_FPREGS_MEM(%rdi),%r8
+  movq %r8, MCONTEXT_FPREGS_PTR(%rdi)
+  fnstenv (%r8)
+  stmxcsr FPREGS_OFFSET_MXCSR(%r8)
+
+  leaq 8(%rsp), %rax /* exclude this call.  */
+  movq %rax, MCONTEXT_GREGS_RSP(%rdi)
+
+  movq 0(%rsp), %rax
+  movq %rax, MCONTEXT_GREGS_RIP(%rdi)
+
+  /* Save signal mask: sigprocmask(SIGBLOCK, NULL, &uc->uc_sigmask) */
+  leaq UCONTEXT_SIGMASK_OFFSET(%rdi), %rdx  // arg3
+  xorq %rsi, %rsi  // arg2 NULL
+  xorq %rdi, %rdi  // arg1 SIGBLOCK == 0
+  call sigprocmask@PLT
+
+  /* Always return 0 for success, even if sigprocmask failed. */
+  xorl %eax, %eax
+  ret
+  .cfi_endproc
+  .size breakpad_getcontext, . - breakpad_getcontext
+
+#else
+#error "This file has not been ported for your CPU!"
+#endif
diff --git a/src/MEGASync/google_breakpad/common/android/include/ucontext.h b/src/MEGASync/google_breakpad/common/linux/breakpad_getcontext.h
similarity index 82%
rename from src/MEGASync/google_breakpad/common/android/include/ucontext.h
rename to src/MEGASync/google_breakpad/common/linux/breakpad_getcontext.h
index 29db8ade..1418cde6 100644
--- a/src/MEGASync/google_breakpad/common/android/include/ucontext.h
+++ b/src/MEGASync/google_breakpad/common/linux/breakpad_getcontext.h
@@ -27,22 +27,22 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-#ifndef GOOGLE_BREAKPAD_COMMON_ANDROID_INCLUDE_UCONTEXT_H
-#define GOOGLE_BREAKPAD_COMMON_ANDROID_INCLUDE_UCONTEXT_H
+#ifndef GOOGLE_BREAKPAD_COMMON_LINUX_INCLUDE_UCONTEXT_H
+#define GOOGLE_BREAKPAD_COMMON_LINUX_INCLUDE_UCONTEXT_H
 
-#include <sys/cdefs.h>
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
 
-#ifdef __BIONIC_UCONTEXT_H
-#include <ucontext.h>
-#else
+#ifndef HAVE_GETCONTEXT
 
-#include <sys/ucontext.h>
+#include <signal.h>
 
 #ifdef __cplusplus
 extern "C" {
 #endif  // __cplusplus
 
-// Provided by src/android/common/breakpad_getcontext.S
+// Provided by src/common/linux/breakpad_getcontext.S
 int breakpad_getcontext(ucontext_t* ucp);
 
 #define getcontext(x)   breakpad_getcontext(x)
@@ -51,6 +51,6 @@ int breakpad_getcontext(ucontext_t* ucp);
 }  // extern "C"
 #endif  // __cplusplus
 
-#endif  // __BIONIC_UCONTEXT_H
+#endif  // HAVE_GETCONTEXT
 
-#endif  // GOOGLE_BREAKPAD_COMMON_ANDROID_INCLUDE_UCONTEXT_H
+#endif  // GOOGLE_BREAKPAD_COMMON_LINUX_INCLUDE_UCONTEXT_H
diff --git a/src/MEGASync/google_breakpad/common/linux/breakpad_getcontext_unittest.cc b/src/MEGASync/google_breakpad/common/linux/breakpad_getcontext_unittest.cc
new file mode 100644
index 00000000..a57bfedf
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/linux/breakpad_getcontext_unittest.cc
@@ -0,0 +1,194 @@
+// Copyright (c) 2012, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// asm/sigcontext.h can't be included with signal.h on glibc or
+// musl, so only compare _libc_fpstate and _fpstate on Android.
+#if defined(__ANDROID__) && defined(__x86_64__)
+#include <asm/sigcontext.h>
+#endif
+
+#include <sys/ucontext.h>
+
+#include <type_traits>
+
+#include "breakpad_googletest_includes.h"
+#include "common/linux/ucontext_constants.h"
+
+template <int left, int right>
+struct CompileAssertEquals {
+  // a compilation error here indicates left and right are not equal.
+  char left_too_large[right - left];
+  // a compilation error here indicates left and right are not equal.
+  char right_too_large[left - right];
+};
+
+#define COMPILE_ASSERT_EQ(left, right, tag) \
+  CompileAssertEquals<left, right> tag;
+
+TEST(AndroidUContext, GRegsOffset) {
+#if defined(__arm__)
+  // There is no gregs[] array on ARM, so compare to the offset of
+  // first register fields, since they're stored in order.
+  ASSERT_EQ(static_cast<size_t>(MCONTEXT_GREGS_OFFSET),
+            offsetof(ucontext_t,uc_mcontext.arm_r0));
+#elif defined(__aarch64__)
+  // There is no gregs[] array on ARM, so compare to the offset of
+  // first register fields, since they're stored in order.
+  ASSERT_EQ(static_cast<size_t>(MCONTEXT_GREGS_OFFSET),
+            offsetof(ucontext_t,uc_mcontext.regs[0]));
+  ASSERT_EQ(static_cast<size_t>(MCONTEXT_SP_OFFSET),
+            offsetof(ucontext_t,uc_mcontext.sp));
+  ASSERT_EQ(static_cast<size_t>(MCONTEXT_PC_OFFSET),
+            offsetof(ucontext_t,uc_mcontext.pc));
+  ASSERT_EQ(static_cast<size_t>(MCONTEXT_PSTATE_OFFSET),
+            offsetof(ucontext_t,uc_mcontext.pstate));
+  ASSERT_EQ(static_cast<size_t>(MCONTEXT_EXTENSION_OFFSET),
+            offsetof(ucontext_t,uc_mcontext.__reserved));
+#elif defined(__i386__)
+  ASSERT_EQ(static_cast<size_t>(MCONTEXT_GREGS_OFFSET),
+            offsetof(ucontext_t,uc_mcontext.gregs));
+#define CHECK_REG(x) \
+  ASSERT_EQ(static_cast<size_t>(MCONTEXT_##x##_OFFSET),         \
+            offsetof(ucontext_t,uc_mcontext.gregs[REG_##x]))
+  CHECK_REG(GS);
+  CHECK_REG(FS);
+  CHECK_REG(ES);
+  CHECK_REG(DS);
+  CHECK_REG(EDI);
+  CHECK_REG(ESI);
+  CHECK_REG(EBP);
+  CHECK_REG(ESP);
+  CHECK_REG(EBX);
+  CHECK_REG(EDX);
+  CHECK_REG(ECX);
+  CHECK_REG(EAX);
+  CHECK_REG(TRAPNO);
+  CHECK_REG(ERR);
+  CHECK_REG(EIP);
+  CHECK_REG(CS);
+  CHECK_REG(EFL);
+  CHECK_REG(UESP);
+  CHECK_REG(SS);
+
+  ASSERT_EQ(static_cast<size_t>(UCONTEXT_FPREGS_OFFSET),
+            offsetof(ucontext_t,uc_mcontext.fpregs));
+
+  ASSERT_EQ(static_cast<size_t>(UCONTEXT_FPREGS_MEM_OFFSET),
+            offsetof(ucontext_t,__fpregs_mem));
+#elif defined(__mips__)
+  ASSERT_EQ(static_cast<size_t>(MCONTEXT_GREGS_OFFSET),
+            offsetof(ucontext_t,uc_mcontext.gregs));
+
+  // PC for mips is not part of gregs.
+  ASSERT_EQ(static_cast<size_t>(MCONTEXT_PC_OFFSET),
+            offsetof(ucontext_t,uc_mcontext.pc));
+
+  ASSERT_EQ(static_cast<size_t>(MCONTEXT_FPREGS_OFFSET),
+            offsetof(ucontext_t,uc_mcontext.fpregs));
+
+  ASSERT_EQ(static_cast<size_t>(MCONTEXT_FPC_CSR),
+            offsetof(ucontext_t,uc_mcontext.fpc_csr));
+#elif defined(__x86_64__)
+
+  COMPILE_ASSERT_EQ(static_cast<size_t>(MCONTEXT_GREGS_OFFSET),
+                    offsetof(ucontext_t,uc_mcontext.gregs),
+                    mcontext_gregs_offset);
+#define CHECK_REG(x) \
+  COMPILE_ASSERT_EQ(static_cast<size_t>(MCONTEXT_GREGS_##x), \
+                    offsetof(ucontext_t,uc_mcontext.gregs[REG_##x]), reg_##x)
+  CHECK_REG(R8);
+  CHECK_REG(R9);
+  CHECK_REG(R10);
+  CHECK_REG(R11);
+  CHECK_REG(R12);
+  CHECK_REG(R13);
+  CHECK_REG(R14);
+  CHECK_REG(R15);
+  CHECK_REG(RDI);
+  CHECK_REG(RSI);
+  CHECK_REG(RBP);
+  CHECK_REG(RBX);
+  CHECK_REG(RDX);
+  CHECK_REG(RAX);
+  CHECK_REG(RCX);
+  CHECK_REG(RSP);
+  CHECK_REG(RIP);
+
+  // sigcontext is an analog to mcontext_t. The layout should be the same.
+  COMPILE_ASSERT_EQ(offsetof(mcontext_t,fpregs),
+                    offsetof(sigcontext,fpstate), sigcontext_fpstate);
+
+#if defined(__ANDROID__)
+  // Check that _fpstate from asm/sigcontext.h is essentially the same
+  // as _libc_fpstate.
+  COMPILE_ASSERT_EQ(sizeof(_libc_fpstate), sizeof(_fpstate),
+                    sigcontext_fpstate_size);
+  COMPILE_ASSERT_EQ(offsetof(_libc_fpstate,cwd),offsetof(_fpstate,cwd),
+                    sigcontext_fpstate_cwd);
+  COMPILE_ASSERT_EQ(offsetof(_libc_fpstate,swd),offsetof(_fpstate,swd),
+                    sigcontext_fpstate_swd);
+  COMPILE_ASSERT_EQ(offsetof(_libc_fpstate,ftw),offsetof(_fpstate,twd),
+                    sigcontext_fpstate_twd);
+  COMPILE_ASSERT_EQ(offsetof(_libc_fpstate,fop),offsetof(_fpstate,fop),
+                    sigcontext_fpstate_fop);
+  COMPILE_ASSERT_EQ(offsetof(_libc_fpstate,rip),offsetof(_fpstate,rip),
+                    sigcontext_fpstate_rip);
+  COMPILE_ASSERT_EQ(offsetof(_libc_fpstate,rdp),offsetof(_fpstate,rdp),
+                    sigcontext_fpstate_rdp);
+  COMPILE_ASSERT_EQ(offsetof(_libc_fpstate,mxcsr),offsetof(_fpstate,mxcsr),
+                    sigcontext_fpstate_mxcsr);
+  COMPILE_ASSERT_EQ(offsetof(_libc_fpstate,mxcr_mask),
+                    offsetof(_fpstate,mxcsr_mask),
+                    sigcontext_fpstate_mxcsr_mask);
+  COMPILE_ASSERT_EQ(offsetof(_libc_fpstate,_st), offsetof(_fpstate,st_space),
+                    sigcontext_fpstate_stspace);
+  COMPILE_ASSERT_EQ(offsetof(_libc_fpstate,_xmm), offsetof(_fpstate,xmm_space),
+                    sigcontext_fpstate_xmm_space);
+#endif
+
+  COMPILE_ASSERT_EQ(MCONTEXT_FPREGS_PTR,
+                    offsetof(ucontext_t,uc_mcontext.fpregs),
+                    mcontext_fpregs_ptr);
+  COMPILE_ASSERT_EQ(MCONTEXT_FPREGS_MEM, offsetof(ucontext_t,__fpregs_mem),
+                    mcontext_fpregs_mem);
+  COMPILE_ASSERT_EQ(FPREGS_OFFSET_MXCSR,
+                    offsetof(std::remove_pointer<fpregset_t>::type,mxcsr),
+                    fpregs_offset_mxcsr);
+  COMPILE_ASSERT_EQ(UCONTEXT_SIGMASK_OFFSET, offsetof(ucontext_t, uc_sigmask),
+                    ucontext_sigmask);
+#else
+  ASSERT_EQ(static_cast<size_t>(MCONTEXT_GREGS_OFFSET),
+            offsetof(ucontext_t,uc_mcontext.gregs));
+#endif
+}
+
+TEST(AndroidUContext, SigmakOffset) {
+  ASSERT_EQ(static_cast<size_t>(UCONTEXT_SIGMASK_OFFSET),
+            offsetof(ucontext_t,uc_sigmask));
+}
diff --git a/src/MEGASync/google_breakpad/common/linux/crc32.cc b/src/MEGASync/google_breakpad/common/linux/crc32.cc
new file mode 100644
index 00000000..8df636ce
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/linux/crc32.cc
@@ -0,0 +1,70 @@
+// Copyright 2014 Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "common/linux/crc32.h"
+
+namespace google_breakpad {
+
+// This implementation is based on the sample implementation in RFC 1952.
+
+// CRC32 polynomial, in reversed form.
+// See RFC 1952, or http://en.wikipedia.org/wiki/Cyclic_redundancy_check
+static const uint32_t kCrc32Polynomial = 0xEDB88320;
+static uint32_t kCrc32Table[256] = { 0 };
+
+#define arraysize(f) (sizeof(f) / sizeof(*f))
+
+static void EnsureCrc32TableInited() {
+  if (kCrc32Table[arraysize(kCrc32Table) - 1])
+    return;  // already inited
+  for (uint32_t i = 0; i < arraysize(kCrc32Table); ++i) {
+    uint32_t c = i;
+    for (size_t j = 0; j < 8; ++j) {
+      if (c & 1) {
+        c = kCrc32Polynomial ^ (c >> 1);
+      } else {
+        c >>= 1;
+      }
+    }
+    kCrc32Table[i] = c;
+  }
+}
+
+uint32_t UpdateCrc32(uint32_t start, const void* buf, size_t len) {
+  EnsureCrc32TableInited();
+
+  uint32_t c = start ^ 0xFFFFFFFF;
+  const uint8_t* u = static_cast<const uint8_t*>(buf);
+  for (size_t i = 0; i < len; ++i) {
+    c = kCrc32Table[(c ^ u[i]) & 0xFF] ^ (c >> 8);
+  }
+  return c ^ 0xFFFFFFFF;
+}
+
+}  // namespace google_breakpad
diff --git a/src/MEGASync/google_breakpad/common/linux/crc32.h b/src/MEGASync/google_breakpad/common/linux/crc32.h
new file mode 100644
index 00000000..e3d9db92
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/linux/crc32.h
@@ -0,0 +1,53 @@
+// Copyright 2014 Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef COMMON_LINUX_CRC32_H_
+#define COMMON_LINUX_CRC32_H_
+
+#include <stdint.h>
+
+#include <string>
+
+namespace google_breakpad {
+
+// Updates a CRC32 checksum with |len| bytes from |buf|. |initial| holds the
+// checksum result from the previous update; for the first call, it should be 0.
+uint32_t UpdateCrc32(uint32_t initial, const void* buf, size_t len);
+
+// Computes a CRC32 checksum using |len| bytes from |buf|.
+inline uint32_t ComputeCrc32(const void* buf, size_t len) {
+  return UpdateCrc32(0, buf, len);
+}
+inline uint32_t ComputeCrc32(const std::string& str) {
+  return ComputeCrc32(str.c_str(), str.size());
+}
+
+}  // namespace google_breakpad
+
+#endif  // COMMON_LINUX_CRC32_H_
diff --git a/src/MEGASync/google_breakpad/common/linux/dump_symbols.cc b/src/MEGASync/google_breakpad/common/linux/dump_symbols.cc
index 75dcfd4c..8ecf0bc4 100644
--- a/src/MEGASync/google_breakpad/common/linux/dump_symbols.cc
+++ b/src/MEGASync/google_breakpad/common/linux/dump_symbols.cc
@@ -38,7 +38,9 @@
 #include <elf.h>
 #include <errno.h>
 #include <fcntl.h>
+#include <limits.h>
 #include <link.h>
+#include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -57,11 +59,16 @@
 #include "common/dwarf_cfi_to_module.h"
 #include "common/dwarf_cu_to_module.h"
 #include "common/dwarf_line_to_module.h"
+#include "common/dwarf_range_list_handler.h"
+#include "common/linux/crc32.h"
+#include "common/linux/eintr_wrapper.h"
 #include "common/linux/elfutils.h"
 #include "common/linux/elfutils-inl.h"
 #include "common/linux/elf_symbols_to_module.h"
 #include "common/linux/file_id.h"
+#include "common/memory_allocator.h"
 #include "common/module.h"
+#include "common/path_helper.h"
 #include "common/scoped_ptr.h"
 #ifndef NO_STABS_SUPPORT
 #include "common/stabs_reader.h"
@@ -76,17 +83,27 @@ using google_breakpad::DumpOptions;
 using google_breakpad::DwarfCFIToModule;
 using google_breakpad::DwarfCUToModule;
 using google_breakpad::DwarfLineToModule;
+using google_breakpad::DwarfRangeListHandler;
 using google_breakpad::ElfClass;
 using google_breakpad::ElfClass32;
 using google_breakpad::ElfClass64;
+using google_breakpad::FileID;
 using google_breakpad::FindElfSectionByName;
 using google_breakpad::GetOffset;
 using google_breakpad::IsValidElf;
+using google_breakpad::kDefaultBuildIdSize;
 using google_breakpad::Module;
+using google_breakpad::PageAllocator;
 #ifndef NO_STABS_SUPPORT
 using google_breakpad::StabsToModule;
 #endif
 using google_breakpad::scoped_ptr;
+using google_breakpad::wasteful_vector;
+
+// Define AARCH64 ELF architecture if host machine does not include this define.
+#ifndef EM_AARCH64
+#define EM_AARCH64      183
+#endif
 
 //
 // FDWrapper
@@ -127,7 +144,7 @@ class MmapWrapper {
       munmap(base_, size_);
     }
   }
-  void set(void *mapped_address, size_t mapped_size) {
+  void set(void* mapped_address, size_t mapped_size) {
     is_set_ = true;
     base_ = mapped_address;
     size_ = mapped_size;
@@ -141,7 +158,7 @@ class MmapWrapper {
 
  private:
   bool is_set_;
-  void *base_;
+  void* base_;
   size_t size_;
 };
 
@@ -165,6 +182,23 @@ typename ElfClass::Addr GetLoadingAddress(
   return 0;
 }
 
+// Find the set of address ranges for all PT_LOAD segments.
+template <typename ElfClass>
+vector<Module::Range> GetPtLoadSegmentRanges(
+    const typename ElfClass::Phdr* program_headers,
+    int nheader) {
+  typedef typename ElfClass::Phdr Phdr;
+  vector<Module::Range> ranges;
+
+  for (int i = 0; i < nheader; ++i) {
+    const Phdr& header = program_headers[i];
+    if (header.p_type == PT_LOAD) {
+      ranges.push_back(Module::Range(header.p_vaddr, header.p_memsz));
+    }
+  }
+  return ranges;
+}
+
 #ifndef NO_STABS_SUPPORT
 template<typename ElfClass>
 bool LoadStabs(const typename ElfClass::Ehdr* elf_header,
@@ -193,26 +227,58 @@ bool LoadStabs(const typename ElfClass::Ehdr* elf_header,
 }
 #endif  // NO_STABS_SUPPORT
 
+// A range handler that accepts rangelist data parsed by
+// dwarf2reader::RangeListReader and populates a range vector (typically
+// owned by a function) with the results.
+class DumperRangesHandler : public DwarfCUToModule::RangesHandler {
+ public:
+  DumperRangesHandler(const uint8_t* buffer, uint64_t size,
+                      dwarf2reader::ByteReader* reader)
+      : buffer_(buffer), size_(size), reader_(reader) { }
+
+  bool ReadRanges(uint64_t offset, Module::Address base_address,
+                  vector<Module::Range>* ranges) {
+    DwarfRangeListHandler handler(base_address, ranges);
+    dwarf2reader::RangeListReader rangelist_reader(buffer_, size_, reader_,
+                                                   &handler);
+
+    return rangelist_reader.ReadRangeList(offset);
+  }
+
+ private:
+  const uint8_t* buffer_;
+  uint64_t size_;
+  dwarf2reader::ByteReader* reader_;
+};
+
 // A line-to-module loader that accepts line number info parsed by
 // dwarf2reader::LineInfo and populates a Module and a line vector
 // with the results.
 class DumperLineToModule: public DwarfCUToModule::LineToModuleHandler {
  public:
   // Create a line-to-module converter using BYTE_READER.
-  explicit DumperLineToModule(dwarf2reader::ByteReader *byte_reader)
+  explicit DumperLineToModule(dwarf2reader::ByteReader* byte_reader)
       : byte_reader_(byte_reader) { }
   void StartCompilationUnit(const string& compilation_dir) {
     compilation_dir_ = compilation_dir;
   }
-  void ReadProgram(const char *program, uint64 length,
-                   Module *module, std::vector<Module::Line> *lines) {
+  void ReadProgram(const uint8_t* program, uint64_t length,
+                   const uint8_t* string_section,
+                   uint64_t string_section_length,
+                   const uint8_t* line_string_section,
+                   uint64_t line_string_section_length,
+                   Module* module, std::vector<Module::Line>* lines) {
     DwarfLineToModule handler(module, compilation_dir_, lines);
-    dwarf2reader::LineInfo parser(program, length, byte_reader_, &handler);
+    dwarf2reader::LineInfo parser(program, length, byte_reader_,
+                                  string_section, string_section_length,
+                                  line_string_section,
+                                  line_string_section_length,
+                                  &handler);
     parser.Start();
   }
  private:
   string compilation_dir_;
-  dwarf2reader::ByteReader *byte_reader_;
+  dwarf2reader::ByteReader* byte_reader_;
 };
 
 template<typename ElfClass>
@@ -242,31 +308,45 @@ bool LoadDwarf(const string& dwarf_filename,
     string name = GetOffset<ElfClass, char>(elf_header,
                                             section_names->sh_offset) +
                   section->sh_name;
-    const char* contents = GetOffset<ElfClass, char>(elf_header,
-                                                     section->sh_offset);
+    const uint8_t* contents = GetOffset<ElfClass, uint8_t>(elf_header,
+                                                           section->sh_offset);
     file_context.AddSectionToSectionMap(name, contents, section->sh_size);
   }
 
+  // Optional .debug_ranges reader
+  scoped_ptr<DumperRangesHandler> ranges_handler;
+  dwarf2reader::SectionMap::const_iterator ranges_entry =
+      file_context.section_map().find(".debug_ranges");
+  if (ranges_entry != file_context.section_map().end()) {
+    const std::pair<const uint8_t*, uint64_t>& ranges_section =
+      ranges_entry->second;
+    ranges_handler.reset(
+      new DumperRangesHandler(ranges_section.first, ranges_section.second,
+                              &byte_reader));
+  }
+
   // Parse all the compilation units in the .debug_info section.
   DumperLineToModule line_to_module(&byte_reader);
   dwarf2reader::SectionMap::const_iterator debug_info_entry =
       file_context.section_map().find(".debug_info");
   assert(debug_info_entry != file_context.section_map().end());
-  const std::pair<const char*, uint64>& debug_info_section =
+  const std::pair<const uint8_t*, uint64_t>& debug_info_section =
       debug_info_entry->second;
   // This should never have been called if the file doesn't have a
   // .debug_info section.
   assert(debug_info_section.first);
-  uint64 debug_info_length = debug_info_section.second;
-  for (uint64 offset = 0; offset < debug_info_length;) {
+  uint64_t debug_info_length = debug_info_section.second;
+  for (uint64_t offset = 0; offset < debug_info_length;) {
     // Make a handler for the root DIE that populates MODULE with the
     // data that was found.
     DwarfCUToModule::WarningReporter reporter(dwarf_filename, offset);
-    DwarfCUToModule root_handler(&file_context, &line_to_module, &reporter);
+    DwarfCUToModule root_handler(&file_context, &line_to_module,
+                                 ranges_handler.get(), &reporter);
     // Make a Dwarf2Handler that drives the DIEHandler.
     dwarf2reader::DIEDispatcher die_dispatcher(&root_handler);
     // Make a DWARF parser for the compilation unit at OFFSET.
-    dwarf2reader::CompilationUnit reader(file_context.section_map(),
+    dwarf2reader::CompilationUnit reader(dwarf_filename,
+                                         file_context.section_map(),
                                          offset,
                                          &byte_reader,
                                          &die_dispatcher);
@@ -291,6 +371,9 @@ bool DwarfCFIRegisterNames(const typename ElfClass::Ehdr* elf_header,
     case EM_ARM:
       *register_names = DwarfCFIToModule::RegisterNames::ARM();
       return true;
+    case EM_AARCH64:
+      *register_names = DwarfCFIToModule::RegisterNames::ARM64();
+      return true;
     case EM_MIPS:
       *register_names = DwarfCFIToModule::RegisterNames::MIPS();
       return true;
@@ -326,8 +409,8 @@ bool LoadDwarfCFI(const string& dwarf_filename,
       dwarf2reader::ENDIANNESS_BIG : dwarf2reader::ENDIANNESS_LITTLE;
 
   // Find the call frame information and its size.
-  const char* cfi =
-      GetOffset<ElfClass, char>(elf_header, section->sh_offset);
+  const uint8_t* cfi =
+      GetOffset<ElfClass, uint8_t>(elf_header, section->sh_offset);
   size_t cfi_size = section->sh_size;
 
   // Plug together the parser, handler, and their entourages.
@@ -369,7 +452,7 @@ bool LoadELF(const string& obj_file, MmapWrapper* map_wrapper,
             obj_file.c_str(), strerror(errno));
     return false;
   }
-  void *obj_base = mmap(NULL, st.st_size,
+  void* obj_base = mmap(NULL, st.st_size,
                         PROT_READ | PROT_WRITE, MAP_PRIVATE, obj_fd, 0);
   if (obj_base == MAP_FAILED) {
     fprintf(stderr, "Failed to mmap ELF file '%s': %s\n",
@@ -403,52 +486,99 @@ bool ElfEndianness(const typename ElfClass::Ehdr* elf_header,
   return false;
 }
 
+// Given |left_abspath|, find the absolute path for |right_path| and see if the
+// two absolute paths are the same.
+bool IsSameFile(const char* left_abspath, const string& right_path) {
+  char right_abspath[PATH_MAX];
+  if (!realpath(right_path.c_str(), right_abspath))
+    return false;
+  return strcmp(left_abspath, right_abspath) == 0;
+}
+
 // Read the .gnu_debuglink and get the debug file name. If anything goes
 // wrong, return an empty string.
-template<typename ElfClass>
-string ReadDebugLink(const char* debuglink,
-                     size_t debuglink_size,
+string ReadDebugLink(const uint8_t* debuglink,
+                     const size_t debuglink_size,
+                     const bool big_endian,
                      const string& obj_file,
                      const std::vector<string>& debug_dirs) {
-  size_t debuglink_len = strlen(debuglink) + 5;  // '\0' + CRC32.
-  debuglink_len = 4 * ((debuglink_len + 3) / 4);  // Round to nearest 4 bytes.
+  // Include '\0' + CRC32 (4 bytes).
+  size_t debuglink_len = strlen(reinterpret_cast<const char*>(debuglink)) + 5;
+  debuglink_len = 4 * ((debuglink_len + 3) / 4);  // Round up to 4 bytes.
 
   // Sanity check.
   if (debuglink_len != debuglink_size) {
     fprintf(stderr, "Mismatched .gnu_debuglink string / section size: "
             "%zx %zx\n", debuglink_len, debuglink_size);
-    return "";
+    return string();
+  }
+
+  char obj_file_abspath[PATH_MAX];
+  if (!realpath(obj_file.c_str(), obj_file_abspath)) {
+    fprintf(stderr, "Cannot resolve absolute path for %s\n", obj_file.c_str());
+    return string();
   }
 
-  bool found = false;
-  int debuglink_fd = -1;
+  std::vector<string> searched_paths;
   string debuglink_path;
   std::vector<string>::const_iterator it;
   for (it = debug_dirs.begin(); it < debug_dirs.end(); ++it) {
     const string& debug_dir = *it;
-    debuglink_path = debug_dir + "/" + debuglink;
-    debuglink_fd = open(debuglink_path.c_str(), O_RDONLY);
-    if (debuglink_fd >= 0) {
-      found = true;
-      break;
+    debuglink_path = debug_dir + "/" +
+                     reinterpret_cast<const char*>(debuglink);
+
+    // There is the annoying case of /path/to/foo.so having foo.so as the
+    // debug link file name. Thus this may end up opening /path/to/foo.so again,
+    // and there is a small chance of the two files having the same CRC.
+    if (IsSameFile(obj_file_abspath, debuglink_path))
+      continue;
+
+    searched_paths.push_back(debug_dir);
+    int debuglink_fd = open(debuglink_path.c_str(), O_RDONLY);
+    if (debuglink_fd < 0)
+      continue;
+
+    FDWrapper debuglink_fd_wrapper(debuglink_fd);
+
+    // The CRC is the last 4 bytes in |debuglink|.
+    const dwarf2reader::Endianness endianness = big_endian ?
+        dwarf2reader::ENDIANNESS_BIG : dwarf2reader::ENDIANNESS_LITTLE;
+    dwarf2reader::ByteReader byte_reader(endianness);
+    uint32_t expected_crc =
+        byte_reader.ReadFourBytes(&debuglink[debuglink_size - 4]);
+
+    uint32_t actual_crc = 0;
+    while (true) {
+      const size_t kReadSize = 4096;
+      char buf[kReadSize];
+      ssize_t bytes_read = HANDLE_EINTR(read(debuglink_fd, &buf, kReadSize));
+      if (bytes_read < 0) {
+        fprintf(stderr, "Error reading debug ELF file %s.\n",
+                debuglink_path.c_str());
+        return string();
+      }
+      if (bytes_read == 0)
+        break;
+      actual_crc = google_breakpad::UpdateCrc32(actual_crc, buf, bytes_read);
     }
-  }
-
-  if (!found) {
-    fprintf(stderr, "Failed to find debug ELF file for '%s' after trying:\n",
-            obj_file.c_str());
-    for (it = debug_dirs.begin(); it < debug_dirs.end(); ++it) {
-      const string debug_dir = *it;
-      fprintf(stderr, "  %s/%s\n", debug_dir.c_str(), debuglink);
+    if (actual_crc != expected_crc) {
+      fprintf(stderr, "Error reading debug ELF file - CRC32 mismatch: %s\n",
+              debuglink_path.c_str());
+      continue;
     }
-    return "";
-  }
 
-  FDWrapper debuglink_fd_wrapper(debuglink_fd);
-  // TODO(thestig) check the CRC-32 at the end of the .gnu_debuglink
-  // section.
+    // Found debug file.
+    return debuglink_path;
+  }
 
-  return debuglink_path;
+  // Not found case.
+  fprintf(stderr, "Failed to find debug ELF file for '%s' after trying:\n",
+          obj_file.c_str());
+  for (it = searched_paths.begin(); it < searched_paths.end(); ++it) {
+    const string& debug_dir = *it;
+    fprintf(stderr, "  %s/%s\n", debug_dir.c_str(), debuglink);
+  }
+  return string();
 }
 
 //
@@ -469,7 +599,7 @@ class LoadSymbolsInfo {
 
   // Keeps track of which sections have been loaded so sections don't
   // accidentally get loaded twice from two different files.
-  void LoadedSection(const string &section) {
+  void LoadedSection(const string& section) {
     if (loaded_sections_.count(section) == 0) {
       loaded_sections_.insert(section);
     } else {
@@ -480,7 +610,7 @@ class LoadSymbolsInfo {
 
   // The ELF file and linked debug file are expected to have the same preferred
   // loading address.
-  void set_loading_addr(Addr addr, const string &filename) {
+  void set_loading_addr(Addr addr, const string& filename) {
     if (!has_loading_addr_) {
       loading_addr_ = addr;
       loaded_file_ = filename;
@@ -537,7 +667,6 @@ bool LoadSymbols(const string& obj_file,
   typedef typename ElfClass::Addr Addr;
   typedef typename ElfClass::Phdr Phdr;
   typedef typename ElfClass::Shdr Shdr;
-  typedef typename ElfClass::Word Word;
 
   Addr loading_addr = GetLoadingAddress<ElfClass>(
       GetOffset<ElfClass, Phdr>(elf_header, elf_header->e_phoff),
@@ -545,14 +674,20 @@ bool LoadSymbols(const string& obj_file,
   module->SetLoadAddress(loading_addr);
   info->set_loading_addr(loading_addr, obj_file);
 
-  Word debug_section_type = 
-      elf_header->e_machine == EM_MIPS ? SHT_MIPS_DWARF : SHT_PROGBITS;
+  // Allow filtering of extraneous debug information in partitioned libraries.
+  // Such libraries contain debug information for all libraries extracted from
+  // the same combined library, implying extensive duplication.
+  vector<Module::Range> address_ranges = GetPtLoadSegmentRanges<ElfClass>(
+      GetOffset<ElfClass, Phdr>(elf_header, elf_header->e_phoff),
+      elf_header->e_phnum);
+  module->SetAddressRanges(address_ranges);
+
   const Shdr* sections =
       GetOffset<ElfClass, Shdr>(elf_header, elf_header->e_shoff);
   const Shdr* section_names = sections + elf_header->e_shstrndx;
   const char* names =
       GetOffset<ElfClass, char>(elf_header, section_names->sh_offset);
-  const char *names_end = names + section_names->sh_size;
+  const char* names_end = names + section_names->sh_size;
   bool found_debug_info_section = false;
   bool found_usable_info = false;
 
@@ -580,9 +715,19 @@ bool LoadSymbols(const string& obj_file,
 
     // Look for DWARF debugging information, and load it if present.
     const Shdr* dwarf_section =
-      FindElfSectionByName<ElfClass>(".debug_info", debug_section_type,
+      FindElfSectionByName<ElfClass>(".debug_info", SHT_PROGBITS,
                                      sections, names, names_end,
                                      elf_header->e_shnum);
+
+    // .debug_info section type is SHT_PROGBITS for mips on pnacl toolchains,
+    // but MIPS_DWARF for regular gnu toolchains, so both need to be checked
+    if (elf_header->e_machine == EM_MIPS && !dwarf_section) {
+      dwarf_section =
+        FindElfSectionByName<ElfClass>(".debug_info", SHT_MIPS_DWARF,
+                                       sections, names, names_end,
+                                       elf_header->e_shnum);
+    }
+
     if (dwarf_section) {
       found_debug_info_section = true;
       found_usable_info = true;
@@ -593,15 +738,83 @@ bool LoadSymbols(const string& obj_file,
                 "DWARF debugging information\n", obj_file.c_str());
       }
     }
+
+    // See if there are export symbols available.
+    const Shdr* symtab_section =
+        FindElfSectionByName<ElfClass>(".symtab", SHT_SYMTAB,
+                                       sections, names, names_end,
+                                       elf_header->e_shnum);
+    const Shdr* strtab_section =
+        FindElfSectionByName<ElfClass>(".strtab", SHT_STRTAB,
+                                       sections, names, names_end,
+                                       elf_header->e_shnum);
+    if (symtab_section && strtab_section) {
+      info->LoadedSection(".symtab");
+
+      const uint8_t* symtab =
+          GetOffset<ElfClass, uint8_t>(elf_header,
+                                       symtab_section->sh_offset);
+      const uint8_t* strtab =
+          GetOffset<ElfClass, uint8_t>(elf_header,
+                                       strtab_section->sh_offset);
+      bool result =
+          ELFSymbolsToModule(symtab,
+                             symtab_section->sh_size,
+                             strtab,
+                             strtab_section->sh_size,
+                             big_endian,
+                             ElfClass::kAddrSize,
+                             module);
+      found_usable_info = found_usable_info || result;
+    } else {
+      // Look in dynsym only if full symbol table was not available.
+      const Shdr* dynsym_section =
+          FindElfSectionByName<ElfClass>(".dynsym", SHT_DYNSYM,
+                                         sections, names, names_end,
+                                         elf_header->e_shnum);
+      const Shdr* dynstr_section =
+          FindElfSectionByName<ElfClass>(".dynstr", SHT_STRTAB,
+                                         sections, names, names_end,
+                                         elf_header->e_shnum);
+      if (dynsym_section && dynstr_section) {
+        info->LoadedSection(".dynsym");
+
+        const uint8_t* dynsyms =
+            GetOffset<ElfClass, uint8_t>(elf_header,
+                                         dynsym_section->sh_offset);
+        const uint8_t* dynstrs =
+            GetOffset<ElfClass, uint8_t>(elf_header,
+                                         dynstr_section->sh_offset);
+        bool result =
+            ELFSymbolsToModule(dynsyms,
+                               dynsym_section->sh_size,
+                               dynstrs,
+                               dynstr_section->sh_size,
+                               big_endian,
+                               ElfClass::kAddrSize,
+                               module);
+        found_usable_info = found_usable_info || result;
+      }
+    }
   }
 
   if (options.symbol_data != NO_CFI) {
     // Dwarf Call Frame Information (CFI) is actually independent from
     // the other DWARF debugging information, and can be used alone.
     const Shdr* dwarf_cfi_section =
-        FindElfSectionByName<ElfClass>(".debug_frame", debug_section_type,
+        FindElfSectionByName<ElfClass>(".debug_frame", SHT_PROGBITS,
                                        sections, names, names_end,
                                        elf_header->e_shnum);
+
+    // .debug_frame section type is SHT_PROGBITS for mips on pnacl toolchains,
+    // but MIPS_DWARF for regular gnu toolchains, so both need to be checked
+    if (elf_header->e_machine == EM_MIPS && !dwarf_cfi_section) {
+      dwarf_cfi_section =
+          FindElfSectionByName<ElfClass>(".debug_frame", SHT_MIPS_DWARF,
+                                        sections, names, names_end,
+                                        elf_header->e_shnum);
+    }
+
     if (dwarf_cfi_section) {
       // Ignore the return value of this function; even without call frame
       // information, the other debugging information could be perfectly
@@ -654,13 +867,15 @@ bool LoadSymbols(const string& obj_file,
                                            names_end, elf_header->e_shnum);
       if (gnu_debuglink_section) {
         if (!info->debug_dirs().empty()) {
-          const char* debuglink_contents =
-              GetOffset<ElfClass, char>(elf_header,
-                                        gnu_debuglink_section->sh_offset);
-          string debuglink_file
-              = ReadDebugLink<ElfClass>(debuglink_contents,
-                                        gnu_debuglink_section->sh_size,
-                                        obj_file, info->debug_dirs());
+          const uint8_t* debuglink_contents =
+              GetOffset<ElfClass, uint8_t>(elf_header,
+                                           gnu_debuglink_section->sh_offset);
+          string debuglink_file =
+              ReadDebugLink(debuglink_contents,
+                            gnu_debuglink_section->sh_size,
+                            big_endian,
+                            obj_file,
+                            info->debug_dirs());
           info->set_debuglink_file(debuglink_file);
         } else {
           fprintf(stderr, ".gnu_debuglink section found in '%s', "
@@ -671,40 +886,8 @@ bool LoadSymbols(const string& obj_file,
                 obj_file.c_str());
       }
     } else {
-      if (options.symbol_data != ONLY_CFI) {
-        // The caller doesn't want to consult .gnu_debuglink.
-        // See if there are export symbols available.
-        const Shdr* dynsym_section =
-          FindElfSectionByName<ElfClass>(".dynsym", SHT_DYNSYM,
-                                         sections, names, names_end,
-                                         elf_header->e_shnum);
-        const Shdr* dynstr_section =
-          FindElfSectionByName<ElfClass>(".dynstr", SHT_STRTAB,
-                                         sections, names, names_end,
-                                         elf_header->e_shnum);
-        if (dynsym_section && dynstr_section) {
-          info->LoadedSection(".dynsym");
-
-          const uint8_t* dynsyms =
-              GetOffset<ElfClass, uint8_t>(elf_header,
-                                           dynsym_section->sh_offset);
-          const uint8_t* dynstrs =
-              GetOffset<ElfClass, uint8_t>(elf_header,
-                                           dynstr_section->sh_offset);
-          bool result =
-              ELFSymbolsToModule(dynsyms,
-                                 dynsym_section->sh_size,
-                                 dynstrs,
-                                 dynstr_section->sh_size,
-                                 big_endian,
-                                 ElfClass::kAddrSize,
-                                 module);
-          found_usable_info = found_usable_info || result;
-        }
-      }
-
-      // Return true if some usable information was found, since
-      // the caller doesn't want to use .gnu_debuglink.
+      // Return true if some usable information was found, since the caller
+      // doesn't want to use .gnu_debuglink.
       return found_usable_info;
     }
 
@@ -725,6 +908,7 @@ const char* ElfArchitecture(const typename ElfClass::Ehdr* elf_header) {
   switch (arch) {
     case EM_386:        return "x86";
     case EM_ARM:        return "arm";
+    case EM_AARCH64:    return "arm64";
     case EM_MIPS:       return "mips";
     case EM_PPC64:      return "ppc64";
     case EM_PPC:        return "ppc";
@@ -736,72 +920,98 @@ const char* ElfArchitecture(const typename ElfClass::Ehdr* elf_header) {
   }
 }
 
-// Format the Elf file identifier in IDENTIFIER as a UUID with the
-// dashes removed.
-string FormatIdentifier(unsigned char identifier[16]) {
-  char identifier_str[40];
-  google_breakpad::FileID::ConvertIdentifierToString(
-      identifier,
-      identifier_str,
-      sizeof(identifier_str));
-  string id_no_dash;
-  for (int i = 0; identifier_str[i] != '\0'; ++i)
-    if (identifier_str[i] != '-')
-      id_no_dash += identifier_str[i];
-  // Add an extra "0" by the end.  PDB files on Windows have an 'age'
-  // number appended to the end of the file identifier; this isn't
-  // really used or necessary on other platforms, but be consistent.
-  id_no_dash += '0';
-  return id_no_dash;
-}
-
-// Return the non-directory portion of FILENAME: the portion after the
-// last slash, or the whole filename if there are no slashes.
-string BaseFileName(const string &filename) {
-  // Lots of copies!  basename's behavior is less than ideal.
-  char *c_filename = strdup(filename.c_str());
-  string base = basename(c_filename);
-  free(c_filename);
-  return base;
+template<typename ElfClass>
+bool SanitizeDebugFile(const typename ElfClass::Ehdr* debug_elf_header,
+                       const string& debuglink_file,
+                       const string& obj_filename,
+                       const char* obj_file_architecture,
+                       const bool obj_file_is_big_endian) {
+  const char* debug_architecture =
+      ElfArchitecture<ElfClass>(debug_elf_header);
+  if (!debug_architecture) {
+    fprintf(stderr, "%s: unrecognized ELF machine architecture: %d\n",
+            debuglink_file.c_str(), debug_elf_header->e_machine);
+    return false;
+  }
+  if (strcmp(obj_file_architecture, debug_architecture)) {
+    fprintf(stderr, "%s with ELF machine architecture %s does not match "
+            "%s with ELF architecture %s\n",
+            debuglink_file.c_str(), debug_architecture,
+            obj_filename.c_str(), obj_file_architecture);
+    return false;
+  }
+  bool debug_big_endian;
+  if (!ElfEndianness<ElfClass>(debug_elf_header, &debug_big_endian))
+    return false;
+  if (debug_big_endian != obj_file_is_big_endian) {
+    fprintf(stderr, "%s and %s does not match in endianness\n",
+            obj_filename.c_str(), debuglink_file.c_str());
+    return false;
+  }
+  return true;
 }
 
 template<typename ElfClass>
-bool ReadSymbolDataElfClass(const typename ElfClass::Ehdr* elf_header,
-                             const string& obj_filename,
-                             const std::vector<string>& debug_dirs,
-                             const DumpOptions& options,
-                             Module** out_module) {
-  typedef typename ElfClass::Ehdr Ehdr;
-  typedef typename ElfClass::Shdr Shdr;
-
-  *out_module = NULL;
-
-  unsigned char identifier[16];
-  if (!google_breakpad::FileID::ElfFileIdentifierFromMappedFile(elf_header,
-                                                                identifier)) {
+bool InitModuleForElfClass(const typename ElfClass::Ehdr* elf_header,
+                           const string& obj_filename,
+                           const string& obj_os,
+                           scoped_ptr<Module>& module) {
+  PageAllocator allocator;
+  wasteful_vector<uint8_t> identifier(&allocator, kDefaultBuildIdSize);
+  if (!FileID::ElfFileIdentifierFromMappedFile(elf_header, identifier)) {
     fprintf(stderr, "%s: unable to generate file identifier\n",
             obj_filename.c_str());
     return false;
   }
 
-  const char *architecture = ElfArchitecture<ElfClass>(elf_header);
+  const char* architecture = ElfArchitecture<ElfClass>(elf_header);
   if (!architecture) {
     fprintf(stderr, "%s: unrecognized ELF machine architecture: %d\n",
             obj_filename.c_str(), elf_header->e_machine);
     return false;
   }
 
+  char name_buf[NAME_MAX] = {};
+  std::string name = google_breakpad::ElfFileSoNameFromMappedFile(
+                         elf_header, name_buf, sizeof(name_buf))
+                         ? name_buf
+                         : google_breakpad::BaseName(obj_filename);
+
+  // Add an extra "0" at the end.  PDB files on Windows have an 'age'
+  // number appended to the end of the file identifier; this isn't
+  // really used or necessary on other platforms, but be consistent.
+  string id = FileID::ConvertIdentifierToUUIDString(identifier) + "0";
+  // This is just the raw Build ID in hex.
+  string code_id = FileID::ConvertIdentifierToString(identifier);
+
+  module.reset(new Module(name, obj_os, architecture, id, code_id));
+
+  return true;
+}
+
+template<typename ElfClass>
+bool ReadSymbolDataElfClass(const typename ElfClass::Ehdr* elf_header,
+                            const string& obj_filename,
+                            const string& obj_os,
+                            const std::vector<string>& debug_dirs,
+                            const DumpOptions& options,
+                            Module** out_module) {
+  typedef typename ElfClass::Ehdr Ehdr;
+
+  *out_module = NULL;
+
+  scoped_ptr<Module> module;
+  if (!InitModuleForElfClass<ElfClass>(elf_header, obj_filename, obj_os,
+                                       module)) {
+    return false;
+  }
+
   // Figure out what endianness this file is.
   bool big_endian;
   if (!ElfEndianness<ElfClass>(elf_header, &big_endian))
     return false;
 
-  string name = BaseFileName(obj_filename);
-  string os = "Linux";
-  string id = FormatIdentifier(identifier);
-
   LoadSymbolsInfo<ElfClass> info(debug_dirs);
-  scoped_ptr<Module> module(new Module(name, os, architecture, id));
   if (!LoadSymbols<ElfClass>(obj_filename, big_endian, elf_header,
                              !debug_dirs.empty(), &info,
                              options, module.get())) {
@@ -814,34 +1024,15 @@ bool ReadSymbolDataElfClass(const typename ElfClass::Ehdr* elf_header,
     MmapWrapper debug_map_wrapper;
     Ehdr* debug_elf_header = NULL;
     if (!LoadELF(debuglink_file, &debug_map_wrapper,
-                 reinterpret_cast<void**>(&debug_elf_header)))
-      return false;
-    // Sanity checks to make sure everything matches up.
-    const char *debug_architecture =
-        ElfArchitecture<ElfClass>(debug_elf_header);
-    if (!debug_architecture) {
-      fprintf(stderr, "%s: unrecognized ELF machine architecture: %d\n",
-              debuglink_file.c_str(), debug_elf_header->e_machine);
-      return false;
-    }
-    if (strcmp(architecture, debug_architecture)) {
-      fprintf(stderr, "%s with ELF machine architecture %s does not match "
-              "%s with ELF architecture %s\n",
-              debuglink_file.c_str(), debug_architecture,
-              obj_filename.c_str(), architecture);
+                 reinterpret_cast<void**>(&debug_elf_header)) ||
+        !SanitizeDebugFile<ElfClass>(debug_elf_header, debuglink_file,
+                                     obj_filename,
+                                     module->architecture().c_str(),
+                                     big_endian)) {
       return false;
     }
 
-    bool debug_big_endian;
-    if (!ElfEndianness<ElfClass>(debug_elf_header, &debug_big_endian))
-      return false;
-    if (debug_big_endian != big_endian) {
-      fprintf(stderr, "%s and %s does not match in endianness\n",
-              obj_filename.c_str(), debuglink_file.c_str());
-      return false;
-    }
-
-    if (!LoadSymbols<ElfClass>(debuglink_file, debug_big_endian,
+    if (!LoadSymbols<ElfClass>(debuglink_file, big_endian,
                                debug_elf_header, false, &info,
                                options, module.get())) {
       return false;
@@ -859,6 +1050,7 @@ namespace google_breakpad {
 // Not explicitly exported, but not static so it can be used in unit tests.
 bool ReadSymbolDataInternal(const uint8_t* obj_file,
                             const string& obj_filename,
+                            const string& obj_os,
                             const std::vector<string>& debug_dirs,
                             const DumpOptions& options,
                             Module** module) {
@@ -870,24 +1062,27 @@ bool ReadSymbolDataInternal(const uint8_t* obj_file,
   int elfclass = ElfClass(obj_file);
   if (elfclass == ELFCLASS32) {
     return ReadSymbolDataElfClass<ElfClass32>(
-        reinterpret_cast<const Elf32_Ehdr*>(obj_file), obj_filename, debug_dirs,
-        options, module);
+        reinterpret_cast<const Elf32_Ehdr*>(obj_file), obj_filename, obj_os,
+        debug_dirs, options, module);
   }
   if (elfclass == ELFCLASS64) {
     return ReadSymbolDataElfClass<ElfClass64>(
-        reinterpret_cast<const Elf64_Ehdr*>(obj_file), obj_filename, debug_dirs,
-        options, module);
+        reinterpret_cast<const Elf64_Ehdr*>(obj_file), obj_filename, obj_os,
+        debug_dirs, options, module);
   }
 
   return false;
 }
 
-bool WriteSymbolFile(const string &obj_file,
+bool WriteSymbolFile(const string& load_path,
+                     const string& obj_file,
+                     const string& obj_os,
                      const std::vector<string>& debug_dirs,
                      const DumpOptions& options,
-                     std::ostream &sym_stream) {
+                     std::ostream& sym_stream) {
   Module* module;
-  if (!ReadSymbolData(obj_file, debug_dirs, options, &module))
+  if (!ReadSymbolData(load_path, obj_file, obj_os, debug_dirs, options,
+                      &module))
     return false;
 
   bool result = module->Write(sym_stream, options.symbol_data);
@@ -895,17 +1090,62 @@ bool WriteSymbolFile(const string &obj_file,
   return result;
 }
 
-bool ReadSymbolData(const string& obj_file,
+// Read the selected object file's debugging information, and write out the
+// header only to |stream|. Return true on success; if an error occurs, report
+// it and return false.
+bool WriteSymbolFileHeader(const string& load_path,
+                           const string& obj_file,
+                           const string& obj_os,
+                           std::ostream& sym_stream) {
+  MmapWrapper map_wrapper;
+  void* elf_header = NULL;
+  if (!LoadELF(load_path, &map_wrapper, &elf_header)) {
+    fprintf(stderr, "Could not load ELF file: %s\n", obj_file.c_str());
+    return false;
+  }
+
+  if (!IsValidElf(elf_header)) {
+    fprintf(stderr, "Not a valid ELF file: %s\n", obj_file.c_str());
+    return false;
+  }
+
+  int elfclass = ElfClass(elf_header);
+  scoped_ptr<Module> module;
+  if (elfclass == ELFCLASS32) {
+    if (!InitModuleForElfClass<ElfClass32>(
+        reinterpret_cast<const Elf32_Ehdr*>(elf_header), obj_file, obj_os,
+        module)) {
+      fprintf(stderr, "Failed to load ELF module: %s\n", obj_file.c_str());
+      return false;
+    }
+  } else if (elfclass == ELFCLASS64) {
+    if (!InitModuleForElfClass<ElfClass64>(
+        reinterpret_cast<const Elf64_Ehdr*>(elf_header), obj_file, obj_os,
+        module)) {
+      fprintf(stderr, "Failed to load ELF module: %s\n", obj_file.c_str());
+      return false;
+    }
+  } else {
+    fprintf(stderr, "Unsupported module file: %s\n", obj_file.c_str());
+    return false;
+  }
+
+  return module->Write(sym_stream, ALL_SYMBOL_DATA);
+}
+
+bool ReadSymbolData(const string& load_path,
+                    const string& obj_file,
+                    const string& obj_os,
                     const std::vector<string>& debug_dirs,
                     const DumpOptions& options,
                     Module** module) {
   MmapWrapper map_wrapper;
   void* elf_header = NULL;
-  if (!LoadELF(obj_file, &map_wrapper, &elf_header))
+  if (!LoadELF(load_path, &map_wrapper, &elf_header))
     return false;
 
   return ReadSymbolDataInternal(reinterpret_cast<uint8_t*>(elf_header),
-                                obj_file, debug_dirs, options, module);
+                                obj_file, obj_os, debug_dirs, options, module);
 }
 
 }  // namespace google_breakpad
diff --git a/src/MEGASync/google_breakpad/common/linux/dump_symbols.h b/src/MEGASync/google_breakpad/common/linux/dump_symbols.h
index 636bb72f..b033ce00 100644
--- a/src/MEGASync/google_breakpad/common/linux/dump_symbols.h
+++ b/src/MEGASync/google_breakpad/common/linux/dump_symbols.h
@@ -62,15 +62,28 @@ struct DumpOptions {
 // If OBJ_FILE has been stripped but contains a .gnu_debuglink section,
 // then look for the debug file in DEBUG_DIRS.
 // SYMBOL_DATA allows limiting the type of symbol data written.
-bool WriteSymbolFile(const string &obj_file,
+bool WriteSymbolFile(const string& load_path,
+                     const string& obj_file,
+                     const string& obj_os,
                      const std::vector<string>& debug_dirs,
                      const DumpOptions& options,
-                     std::ostream &sym_stream);
+                     std::ostream& sym_stream);
+
+// Read the selected object file's debugging information, and write out the
+// header only to |stream|. Return true on success; if an error occurs, report
+// it and return false. |obj_file| becomes the MODULE file name and |obj_os|
+// becomes the MODULE operating system.
+bool WriteSymbolFileHeader(const string& load_path,
+                           const string& obj_file,
+                           const string& obj_os,
+                           std::ostream& sym_stream);
 
 // As above, but simply return the debugging information in MODULE
 // instead of writing it to a stream. The caller owns the resulting
 // Module object and must delete it when finished.
-bool ReadSymbolData(const string& obj_file,
+bool ReadSymbolData(const string& load_path,
+                    const string& obj_file,
+                    const string& obj_os,
                     const std::vector<string>& debug_dirs,
                     const DumpOptions& options,
                     Module** module);
diff --git a/src/MEGASync/google_breakpad/common/linux/dump_symbols_unittest.cc b/src/MEGASync/google_breakpad/common/linux/dump_symbols_unittest.cc
index 3f86dbe6..54c21096 100644
--- a/src/MEGASync/google_breakpad/common/linux/dump_symbols_unittest.cc
+++ b/src/MEGASync/google_breakpad/common/linux/dump_symbols_unittest.cc
@@ -40,6 +40,8 @@
 #include <vector>
 
 #include "breakpad_googletest_includes.h"
+#include "common/linux/elf_gnu_compat.h"
+#include "common/linux/elfutils.h"
 #include "common/linux/dump_symbols.h"
 #include "common/linux/synth_elf.h"
 #include "common/module.h"
@@ -49,11 +51,13 @@ namespace google_breakpad {
 
 bool ReadSymbolDataInternal(const uint8_t* obj_file,
                             const string& obj_filename,
+                            const string& obj_os,
                             const std::vector<string>& debug_dir,
                             const DumpOptions& options,
                             Module** module);
 
 using google_breakpad::synth_elf::ELF;
+using google_breakpad::synth_elf::Notes;
 using google_breakpad::synth_elf::StringTable;
 using google_breakpad::synth_elf::SymbolTable;
 using google_breakpad::test_assembler::kLittleEndian;
@@ -61,7 +65,9 @@ using google_breakpad::test_assembler::Section;
 using std::stringstream;
 using std::vector;
 using ::testing::Test;
+using ::testing::Types;
 
+template<typename ElfClass>
 class DumpSymbols : public Test {
  public:
   void GetElfContents(ELF& elf) {
@@ -78,20 +84,25 @@ class DumpSymbols : public Test {
   uint8_t* elfdata;
 };
 
-TEST_F(DumpSymbols, Invalid) {
+typedef Types<ElfClass32, ElfClass64> ElfClasses;
+
+TYPED_TEST_SUITE(DumpSymbols, ElfClasses);
+
+TYPED_TEST(DumpSymbols, Invalid) {
   Elf32_Ehdr header;
   memset(&header, 0, sizeof(header));
   Module* module;
   DumpOptions options(ALL_SYMBOL_DATA, true);
   EXPECT_FALSE(ReadSymbolDataInternal(reinterpret_cast<uint8_t*>(&header),
                                       "foo",
+                                      "Linux",
                                       vector<string>(),
                                       options,
                                       &module));
 }
 
-TEST_F(DumpSymbols, SimplePublic32) {
-  ELF elf(EM_386, ELFCLASS32, kLittleEndian);
+TYPED_TEST(DumpSymbols, SimplePublic) {
+  ELF elf(TypeParam::kMachine, TypeParam::kClass, kLittleEndian);
   // Zero out text section for simplicity.
   Section text(kLittleEndian);
   text.Append(4096, 0);
@@ -99,8 +110,11 @@ TEST_F(DumpSymbols, SimplePublic32) {
 
   // Add a public symbol.
   StringTable table(kLittleEndian);
-  SymbolTable syms(kLittleEndian, 4, table);
-  syms.AddSymbol("superfunc", (uint32_t)0x1000, (uint32_t)0x10,
+  SymbolTable syms(kLittleEndian, TypeParam::kAddrSize, table);
+  syms.AddSymbol("superfunc",
+                   (typename TypeParam::Addr)0x1000,
+                   (typename TypeParam::Addr)0x10,
+                 // ELF32_ST_INFO works for 32-or 64-bit.
                  ELF32_ST_INFO(STB_GLOBAL, STT_FUNC),
                  SHN_UNDEF + 1);
   int index = elf.AddSection(".dynstr", table, SHT_STRTAB);
@@ -109,39 +123,56 @@ TEST_F(DumpSymbols, SimplePublic32) {
                  SHF_ALLOC,           // flags
                  0,                   // addr
                  index,               // link
-                 sizeof(Elf32_Sym));  // entsize
+                 sizeof(typename TypeParam::Sym));  // entsize
 
   elf.Finish();
-  GetElfContents(elf);
+  this->GetElfContents(elf);
 
   Module* module;
   DumpOptions options(ALL_SYMBOL_DATA, true);
-  EXPECT_TRUE(ReadSymbolDataInternal(elfdata,
+  EXPECT_TRUE(ReadSymbolDataInternal(this->elfdata,
                                      "foo",
+                                     "Linux",
                                      vector<string>(),
                                      options,
                                      &module));
 
   stringstream s;
   module->Write(s, ALL_SYMBOL_DATA);
-  EXPECT_EQ("MODULE Linux x86 000000000000000000000000000000000 foo\n"
-            "PUBLIC 1000 0 superfunc\n",
-            s.str());
+  const string expected =
+    string("MODULE Linux ") + TypeParam::kMachineName
+    + " 000000000000000000000000000000000 foo\n"
+    "INFO CODE_ID 00000000000000000000000000000000\n"
+    "PUBLIC 1000 0 superfunc\n";
+  EXPECT_EQ(expected, s.str());
   delete module;
 }
 
-TEST_F(DumpSymbols, SimplePublic64) {
-  ELF elf(EM_X86_64, ELFCLASS64, kLittleEndian);
+TYPED_TEST(DumpSymbols, SimpleBuildID) {
+  ELF elf(TypeParam::kMachine, TypeParam::kClass, kLittleEndian);
   // Zero out text section for simplicity.
   Section text(kLittleEndian);
   text.Append(4096, 0);
   elf.AddSection(".text", text, SHT_PROGBITS);
 
+  // Add a Build ID
+  const uint8_t kExpectedIdentifierBytes[] =
+    {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+     0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
+     0x10, 0x11, 0x12, 0x13};
+  Notes notes(kLittleEndian);
+  notes.AddNote(NT_GNU_BUILD_ID, "GNU", kExpectedIdentifierBytes,
+                sizeof(kExpectedIdentifierBytes));
+  elf.AddSection(".note.gnu.build-id", notes, SHT_NOTE);
+
   // Add a public symbol.
   StringTable table(kLittleEndian);
-  SymbolTable syms(kLittleEndian, 8, table);
-  syms.AddSymbol("superfunc", (uint64_t)0x1000, (uint64_t)0x10,
-                 ELF64_ST_INFO(STB_GLOBAL, STT_FUNC),
+  SymbolTable syms(kLittleEndian, TypeParam::kAddrSize, table);
+  syms.AddSymbol("superfunc",
+                   (typename TypeParam::Addr)0x1000,
+                   (typename TypeParam::Addr)0x10,
+                 // ELF32_ST_INFO works for 32-or 64-bit.
+                 ELF32_ST_INFO(STB_GLOBAL, STT_FUNC),
                  SHN_UNDEF + 1);
   int index = elf.AddSection(".dynstr", table, SHT_STRTAB);
   elf.AddSection(".dynsym", syms,
@@ -149,24 +180,29 @@ TEST_F(DumpSymbols, SimplePublic64) {
                  SHF_ALLOC,           // flags
                  0,                   // addr
                  index,               // link
-                 sizeof(Elf64_Sym));  // entsize
+                 sizeof(typename TypeParam::Sym));  // entsize
 
   elf.Finish();
-  GetElfContents(elf);
+  this->GetElfContents(elf);
 
   Module* module;
   DumpOptions options(ALL_SYMBOL_DATA, true);
-  EXPECT_TRUE(ReadSymbolDataInternal(elfdata,
+  EXPECT_TRUE(ReadSymbolDataInternal(this->elfdata,
                                      "foo",
+                                     "Linux",
                                      vector<string>(),
                                      options,
                                      &module));
 
   stringstream s;
   module->Write(s, ALL_SYMBOL_DATA);
-  EXPECT_EQ("MODULE Linux x86_64 000000000000000000000000000000000 foo\n"
-            "PUBLIC 1000 0 superfunc\n",
-            s.str());
+  const string expected =
+    string("MODULE Linux ") + TypeParam::kMachineName
+    + " 030201000504070608090A0B0C0D0E0F0 foo\n"
+    "INFO CODE_ID 000102030405060708090A0B0C0D0E0F10111213\n"
+    "PUBLIC 1000 0 superfunc\n";
+  EXPECT_EQ(expected, s.str());
+  delete module;
 }
 
 }  // namespace google_breakpad
diff --git a/src/MEGASync/google_breakpad/common/linux/eintr_wrapper.h b/src/MEGASync/google_breakpad/common/linux/eintr_wrapper.h
index f1de306b..3f1d1848 100644
--- a/src/MEGASync/google_breakpad/common/linux/eintr_wrapper.h
+++ b/src/MEGASync/google_breakpad/common/linux/eintr_wrapper.h
@@ -36,17 +36,8 @@
 // signal and return EINTR. See man 7 signal.
 //
 
-
-#if __cplusplus >= 201103L
-#include <type_traits>
-#define TYPEOF(x) std::remove_reference<decltype(x)>::type
-#else
-#define TYPEOF(x) typeof(x)
-#endif
-
-
 #define HANDLE_EINTR(x) ({ \
-  TYPEOF(x) eintr_wrapper_result; \
+  __typeof__(x) eintr_wrapper_result; \
   do { \
     eintr_wrapper_result = (x); \
   } while (eintr_wrapper_result == -1 && errno == EINTR); \
@@ -54,7 +45,7 @@
 })
 
 #define IGNORE_EINTR(x) ({ \
-  typeof(x) eintr_wrapper_result; \
+  __typeof__(x) eintr_wrapper_result; \
   do { \
     eintr_wrapper_result = (x); \
     if (eintr_wrapper_result == -1 && errno == EINTR) { \
diff --git a/src/MEGASync/google_breakpad/common/linux/elf_core_dump.h b/src/MEGASync/google_breakpad/common/linux/elf_core_dump.h
index d03c7a88..6e153745 100644
--- a/src/MEGASync/google_breakpad/common/linux/elf_core_dump.h
+++ b/src/MEGASync/google_breakpad/common/linux/elf_core_dump.h
@@ -34,6 +34,7 @@
 #define COMMON_LINUX_ELF_CORE_DUMP_H_
 
 #include <elf.h>
+#include <limits.h>
 #include <link.h>
 #include <stddef.h>
 
@@ -45,18 +46,18 @@ namespace google_breakpad {
 // provides methods for accessing program headers and the note section.
 class ElfCoreDump {
  public:
-  // ELF types based on the value of __WORDSIZE.
+  // ELF types based on the native word size.
   typedef ElfW(Ehdr) Ehdr;
   typedef ElfW(Nhdr) Nhdr;
   typedef ElfW(Phdr) Phdr;
   typedef ElfW(Word) Word;
   typedef ElfW(Addr) Addr;
-#if __WORDSIZE == 32
+#if ULONG_MAX == 0xffffffff
   static const int kClass = ELFCLASS32;
-#elif __WORDSIZE == 64
+#elif ULONG_MAX == 0xffffffffffffffff
   static const int kClass = ELFCLASS64;
 #else
-#error "Unsupported __WORDSIZE for ElfCoreDump."
+#error "Unsupported word size for ElfCoreDump."
 #endif
 
   // A class encapsulating the note content in a core dump, which provides
diff --git a/src/MEGASync/google_breakpad/common/linux/elf_core_dump_unittest.cc b/src/MEGASync/google_breakpad/common/linux/elf_core_dump_unittest.cc
index 45aa5364..2399c12f 100644
--- a/src/MEGASync/google_breakpad/common/linux/elf_core_dump_unittest.cc
+++ b/src/MEGASync/google_breakpad/common/linux/elf_core_dump_unittest.cc
@@ -70,7 +70,7 @@ TEST(ElfCoreDumpTest, TestElfHeader) {
   ElfCoreDump core;
 
   ASSERT_TRUE(WriteFile(core_file, &header, sizeof(header) - 1));
-  ASSERT_TRUE(mapped_core_file.Map(core_file));
+  ASSERT_TRUE(mapped_core_file.Map(core_file, 0));
   core.SetContent(mapped_core_file.content());
   EXPECT_FALSE(core.IsValid());
   EXPECT_EQ(NULL, core.GetHeader());
@@ -80,49 +80,49 @@ TEST(ElfCoreDumpTest, TestElfHeader) {
   EXPECT_FALSE(core.GetFirstNote().IsValid());
 
   ASSERT_TRUE(WriteFile(core_file, &header, sizeof(header)));
-  ASSERT_TRUE(mapped_core_file.Map(core_file));
+  ASSERT_TRUE(mapped_core_file.Map(core_file, 0));
   core.SetContent(mapped_core_file.content());
   EXPECT_FALSE(core.IsValid());
 
   header.e_ident[0] = ELFMAG0;
   ASSERT_TRUE(WriteFile(core_file, &header, sizeof(header)));
-  ASSERT_TRUE(mapped_core_file.Map(core_file));
+  ASSERT_TRUE(mapped_core_file.Map(core_file, 0));
   core.SetContent(mapped_core_file.content());
   EXPECT_FALSE(core.IsValid());
 
   header.e_ident[1] = ELFMAG1;
   ASSERT_TRUE(WriteFile(core_file, &header, sizeof(header)));
-  ASSERT_TRUE(mapped_core_file.Map(core_file));
+  ASSERT_TRUE(mapped_core_file.Map(core_file, 0));
   core.SetContent(mapped_core_file.content());
   EXPECT_FALSE(core.IsValid());
 
   header.e_ident[2] = ELFMAG2;
   ASSERT_TRUE(WriteFile(core_file, &header, sizeof(header)));
-  ASSERT_TRUE(mapped_core_file.Map(core_file));
+  ASSERT_TRUE(mapped_core_file.Map(core_file, 0));
   core.SetContent(mapped_core_file.content());
   EXPECT_FALSE(core.IsValid());
 
   header.e_ident[3] = ELFMAG3;
   ASSERT_TRUE(WriteFile(core_file, &header, sizeof(header)));
-  ASSERT_TRUE(mapped_core_file.Map(core_file));
+  ASSERT_TRUE(mapped_core_file.Map(core_file, 0));
   core.SetContent(mapped_core_file.content());
   EXPECT_FALSE(core.IsValid());
 
   header.e_ident[4] = ElfCoreDump::kClass;
   ASSERT_TRUE(WriteFile(core_file, &header, sizeof(header)));
-  ASSERT_TRUE(mapped_core_file.Map(core_file));
+  ASSERT_TRUE(mapped_core_file.Map(core_file, 0));
   core.SetContent(mapped_core_file.content());
   EXPECT_FALSE(core.IsValid());
 
   header.e_version = EV_CURRENT;
   ASSERT_TRUE(WriteFile(core_file, &header, sizeof(header)));
-  ASSERT_TRUE(mapped_core_file.Map(core_file));
+  ASSERT_TRUE(mapped_core_file.Map(core_file, 0));
   core.SetContent(mapped_core_file.content());
   EXPECT_FALSE(core.IsValid());
 
   header.e_type = ET_CORE;
   ASSERT_TRUE(WriteFile(core_file, &header, sizeof(header)));
-  ASSERT_TRUE(mapped_core_file.Map(core_file));
+  ASSERT_TRUE(mapped_core_file.Map(core_file, 0));
   core.SetContent(mapped_core_file.content());
   EXPECT_TRUE(core.IsValid());
 }
@@ -138,22 +138,26 @@ TEST(ElfCoreDumpTest, ValidCoreFile) {
   const unsigned kNumOfThreads = 3;
   const unsigned kCrashThread = 1;
   const int kCrashSignal = SIGABRT;
-  // TODO(benchan): Revert to use ASSERT_TRUE once the flakiness in
-  // CrashGenerator is identified and fixed.
-  if (!crash_generator.CreateChildCrash(kNumOfThreads, kCrashThread,
-                                        kCrashSignal, NULL)) {
-    fprintf(stderr, "ElfCoreDumpTest.ValidCoreFile test is skipped "
-            "due to no core dump generated");
-    return;
-  }
+  ASSERT_TRUE(crash_generator.CreateChildCrash(kNumOfThreads, kCrashThread,
+                                               kCrashSignal, NULL));
   pid_t expected_crash_thread_id = crash_generator.GetThreadId(kCrashThread);
   set<pid_t> expected_thread_ids;
   for (unsigned i = 0; i < kNumOfThreads; ++i) {
     expected_thread_ids.insert(crash_generator.GetThreadId(i));
   }
 
+#if defined(__ANDROID__)
+  struct stat st;
+  if (stat(crash_generator.GetCoreFilePath().c_str(), &st) != 0) {
+    fprintf(stderr, "ElfCoreDumpTest.ValidCoreFile test is skipped "
+            "due to no core file being generated");
+    return;
+  }
+#endif
+
   MemoryMappedFile mapped_core_file;
-  ASSERT_TRUE(mapped_core_file.Map(crash_generator.GetCoreFilePath().c_str()));
+  ASSERT_TRUE(
+      mapped_core_file.Map(crash_generator.GetCoreFilePath().c_str(), 0));
 
   ElfCoreDump core;
   core.SetContent(mapped_core_file.content());
@@ -182,6 +186,7 @@ TEST(ElfCoreDumpTest, ValidCoreFile) {
 
   size_t num_nt_prpsinfo = 0;
   size_t num_nt_prstatus = 0;
+  size_t num_pr_fpvalid = 0;
 #if defined(__i386__) || defined(__x86_64__)
   size_t num_nt_fpregset = 0;
 #endif
@@ -213,6 +218,8 @@ TEST(ElfCoreDumpTest, ValidCoreFile) {
           EXPECT_EQ(kCrashSignal, status->pr_info.si_signo);
         }
         ++num_nt_prstatus;
+        if (status->pr_fpvalid)
+          ++num_pr_fpvalid;
         break;
       }
 #if defined(__i386__) || defined(__x86_64__)
@@ -237,13 +244,22 @@ TEST(ElfCoreDumpTest, ValidCoreFile) {
     note = note.GetNextNote();
   }
 
-  EXPECT_TRUE(expected_thread_ids == actual_thread_ids);
+#if defined(THREAD_SANITIZER)
+  for (std::set<pid_t>::const_iterator expected = expected_thread_ids.begin();
+       expected != expected_thread_ids.end();
+       ++expected) {
+    EXPECT_NE(actual_thread_ids.find(*expected), actual_thread_ids.end());
+  }
+  EXPECT_GE(num_nt_prstatus, kNumOfThreads);
+#else
+  EXPECT_EQ(actual_thread_ids, expected_thread_ids);
+  EXPECT_EQ(num_nt_prstatus, kNumOfThreads);
+#endif
   EXPECT_EQ(1U, num_nt_prpsinfo);
-  EXPECT_EQ(kNumOfThreads, num_nt_prstatus);
 #if defined(__i386__) || defined(__x86_64__)
-  EXPECT_EQ(kNumOfThreads, num_nt_fpregset);
+  EXPECT_EQ(num_pr_fpvalid, num_nt_fpregset);
 #endif
 #if defined(__i386__)
-  EXPECT_EQ(kNumOfThreads, num_nt_prxfpreg);
+  EXPECT_EQ(num_pr_fpvalid, num_nt_prxfpreg);
 #endif
 }
diff --git a/src/MEGASync/google_breakpad/common/linux/elf_gnu_compat.h b/src/MEGASync/google_breakpad/common/linux/elf_gnu_compat.h
index f870cbc7..0a3dfedb 100644
--- a/src/MEGASync/google_breakpad/common/linux/elf_gnu_compat.h
+++ b/src/MEGASync/google_breakpad/common/linux/elf_gnu_compat.h
@@ -43,4 +43,9 @@
 #define NT_GNU_BUILD_ID 3
 #endif
 
+// Newer Linux systems offer this.
+#ifndef NT_SIGINFO
+#define NT_SIGINFO 0x53494749
+#endif
+
 #endif  // COMMON_LINUX_ELF_GNU_COMPAT_H_
diff --git a/src/MEGASync/google_breakpad/common/linux/elf_symbols_to_module.cc b/src/MEGASync/google_breakpad/common/linux/elf_symbols_to_module.cc
index 82d53dd1..81e985a7 100644
--- a/src/MEGASync/google_breakpad/common/linux/elf_symbols_to_module.cc
+++ b/src/MEGASync/google_breakpad/common/linux/elf_symbols_to_module.cc
@@ -32,6 +32,7 @@
 
 #include "common/linux/elf_symbols_to_module.h"
 
+#include <cxxabi.h>
 #include <elf.h>
 #include <string.h>
 
@@ -68,7 +69,7 @@ public:
   // otherwise. Assume each symbol has a 'value' field whose size is
   // VALUE_SIZE.
   //
-  ELFSymbolIterator(const ByteBuffer *buffer, bool big_endian,
+  ELFSymbolIterator(const ByteBuffer* buffer, bool big_endian,
                     size_t value_size)
     : value_size_(value_size), cursor_(buffer, big_endian) {
     // Actually, weird sizes could be handled just fine, but they're
@@ -80,13 +81,13 @@ public:
 
   // Move to the next symbol. This function's behavior is undefined if
   // at_end() is true when it is called.
-  ELFSymbolIterator &operator++() { Fetch(); symbol_.index++; return *this; }
+  ELFSymbolIterator& operator++() { Fetch(); symbol_.index++; return *this; }
 
   // Dereferencing this iterator produces a reference to an Symbol structure
   // that holds the current symbol's values. The symbol is owned by this
   // SymbolIterator, and will be invalidated at the next call to operator++.
-  const Symbol &operator*() const { return symbol_; }
-  const Symbol *operator->() const { return &symbol_; }
+  const Symbol& operator*() const { return symbol_; }
+  const Symbol* operator->() const { return &symbol_; }
 
 private:
   // Read the symbol at cursor_, and set symbol_ appropriately.
@@ -125,21 +126,21 @@ private:
   Symbol symbol_;
 };
 
-const char *SymbolString(ptrdiff_t offset, ByteBuffer& strings) {
+const char* SymbolString(ptrdiff_t offset, ByteBuffer& strings) {
   if (offset < 0 || (size_t) offset >= strings.Size()) {
     // Return the null string.
     offset = 0;
   }
-  return reinterpret_cast<const char *>(strings.start + offset);
+  return reinterpret_cast<const char*>(strings.start + offset);
 }
 
-bool ELFSymbolsToModule(const uint8_t *symtab_section,
+bool ELFSymbolsToModule(const uint8_t* symtab_section,
                         size_t symtab_size,
-                        const uint8_t *string_section,
+                        const uint8_t* string_section,
                         size_t string_size,
                         const bool big_endian,
                         size_t value_size,
-                        Module *module) {
+                        Module* module) {
   ByteBuffer symbols(symtab_section, symtab_size);
   // Ensure that the string section is null-terminated.
   if (string_section[string_size - 1] != '\0') {
@@ -155,9 +156,18 @@ bool ELFSymbolsToModule(const uint8_t *symtab_section,
   while(!iterator->at_end) {
     if (ELF32_ST_TYPE(iterator->info) == STT_FUNC &&
         iterator->shndx != SHN_UNDEF) {
-      Module::Extern *ext = new Module::Extern;
+      Module::Extern* ext = new Module::Extern(iterator->value);
       ext->name = SymbolString(iterator->name_offset, strings);
-      ext->address = iterator->value;
+#if !defined(__ANDROID__)  // Android NDK doesn't provide abi::__cxa_demangle.
+      int status = 0;
+      char* demangled =
+          abi::__cxa_demangle(ext->name.c_str(), NULL, NULL, &status);
+      if (demangled) {
+        if (status == 0)
+          ext->name = demangled;
+        free(demangled);
+      }
+#endif
       module->AddExtern(ext);
     }
     ++iterator;
diff --git a/src/MEGASync/google_breakpad/common/linux/elf_symbols_to_module.h b/src/MEGASync/google_breakpad/common/linux/elf_symbols_to_module.h
index 2e7c0971..861f7252 100644
--- a/src/MEGASync/google_breakpad/common/linux/elf_symbols_to_module.h
+++ b/src/MEGASync/google_breakpad/common/linux/elf_symbols_to_module.h
@@ -44,13 +44,13 @@ namespace google_breakpad {
 
 class Module;
 
-bool ELFSymbolsToModule(const uint8_t *symtab_section,
+bool ELFSymbolsToModule(const uint8_t* symtab_section,
                         size_t symtab_size,
-                        const uint8_t *string_section,
+                        const uint8_t* string_section,
                         size_t string_size,
                         const bool big_endian,
                         size_t value_size,
-                        Module *module);
+                        Module* module);
 
 }  // namespace google_breakpad
 
diff --git a/src/MEGASync/google_breakpad/common/linux/elf_symbols_to_module_unittest.cc b/src/MEGASync/google_breakpad/common/linux/elf_symbols_to_module_unittest.cc
index 8984449a..3f665898 100644
--- a/src/MEGASync/google_breakpad/common/linux/elf_symbols_to_module_unittest.cc
+++ b/src/MEGASync/google_breakpad/common/linux/elf_symbols_to_module_unittest.cc
@@ -86,7 +86,7 @@ public:
   // 4 or 8 (bytes)
   size_t value_size;
 
-  vector<Module::Extern *> externs;
+  vector<Module::Extern*> externs;
 };
 
 class ELFSymbolsToModuleTest32 : public ELFSymbolsToModuleTestFixture,
diff --git a/src/MEGASync/google_breakpad/common/linux/elfutils.cc b/src/MEGASync/google_breakpad/common/linux/elfutils.cc
index 1fd504d9..aa95357a 100644
--- a/src/MEGASync/google_breakpad/common/linux/elfutils.cc
+++ b/src/MEGASync/google_breakpad/common/linux/elfutils.cc
@@ -40,11 +40,11 @@ namespace google_breakpad {
 namespace {
 
 template<typename ElfClass>
-void FindElfClassSection(const char *elf_base,
-                         const char *section_name,
+void FindElfClassSection(const char* elf_base,
+                         const char* section_name,
                          typename ElfClass::Word section_type,
-                         const void **section_start,
-                         int *section_size) {
+                         const void** section_start,
+                         size_t* section_size) {
   typedef typename ElfClass::Ehdr Ehdr;
   typedef typename ElfClass::Shdr Shdr;
 
@@ -57,12 +57,18 @@ void FindElfClassSection(const char *elf_base,
   const Ehdr* elf_header = reinterpret_cast<const Ehdr*>(elf_base);
   assert(elf_header->e_ident[EI_CLASS] == ElfClass::kClass);
 
+  if (elf_header->e_shoff == 0) {
+    *section_start = NULL;
+    *section_size = 0;
+    return;
+  }
+
   const Shdr* sections =
-    GetOffset<ElfClass,Shdr>(elf_header, elf_header->e_shoff);
+    GetOffset<ElfClass, Shdr>(elf_header, elf_header->e_shoff);
   const Shdr* section_names = sections + elf_header->e_shstrndx;
   const char* names =
-    GetOffset<ElfClass,char>(elf_header, section_names->sh_offset);
-  const char *names_end = names + section_names->sh_size;
+    GetOffset<ElfClass, char>(elf_header, section_names->sh_offset);
+  const char* names_end = names + section_names->sh_size;
 
   const Shdr* section =
     FindElfSectionByName<ElfClass>(section_name, section_type,
@@ -76,16 +82,14 @@ void FindElfClassSection(const char *elf_base,
 }
 
 template<typename ElfClass>
-void FindElfClassSegment(const char *elf_base,
+void FindElfClassSegment(const char* elf_base,
                          typename ElfClass::Word segment_type,
-                         const void **segment_start,
-                         int *segment_size) {
+                         wasteful_vector<ElfSegment>* segments) {
   typedef typename ElfClass::Ehdr Ehdr;
   typedef typename ElfClass::Phdr Phdr;
 
   assert(elf_base);
-  assert(segment_start);
-  assert(segment_size);
+  assert(segments);
 
   assert(my_strncmp(elf_base, ELFMAG, SELFMAG) == 0);
 
@@ -93,13 +97,14 @@ void FindElfClassSegment(const char *elf_base,
   assert(elf_header->e_ident[EI_CLASS] == ElfClass::kClass);
 
   const Phdr* phdrs =
-    GetOffset<ElfClass,Phdr>(elf_header, elf_header->e_phoff);
+    GetOffset<ElfClass, Phdr>(elf_header, elf_header->e_phoff);
 
   for (int i = 0; i < elf_header->e_phnum; ++i) {
     if (phdrs[i].p_type == segment_type) {
-      *segment_start = elf_base + phdrs[i].p_offset;
-      *segment_size = phdrs[i].p_filesz;
-      return;
+      ElfSegment seg = {};
+      seg.start = elf_base + phdrs[i].p_offset;
+      seg.size = phdrs[i].p_filesz;
+      segments->push_back(seg);
     }
   }
 }
@@ -118,12 +123,11 @@ int ElfClass(const void* elf_base) {
   return elf_header->e_ident[EI_CLASS];
 }
 
-bool FindElfSection(const void *elf_mapped_base,
-                    const char *section_name,
+bool FindElfSection(const void* elf_mapped_base,
+                    const char* section_name,
                     uint32_t section_type,
-                    const void **section_start,
-                    int *section_size,
-                    int *elfclass) {
+                    const void** section_start,
+                    size_t* section_size) {
   assert(elf_mapped_base);
   assert(section_start);
   assert(section_size);
@@ -135,10 +139,6 @@ bool FindElfSection(const void *elf_mapped_base,
     return false;
 
   int cls = ElfClass(elf_mapped_base);
-  if (elfclass) {
-    *elfclass = cls;
-  }
-
   const char* elf_base =
     static_cast<const char*>(elf_mapped_base);
 
@@ -155,40 +155,89 @@ bool FindElfSection(const void *elf_mapped_base,
   return false;
 }
 
-bool FindElfSegment(const void *elf_mapped_base,
-                    uint32_t segment_type,
-                    const void **segment_start,
-                    int *segment_size,
-                    int *elfclass) {
+bool FindElfSegments(const void* elf_mapped_base,
+                     uint32_t segment_type,
+                     wasteful_vector<ElfSegment>* segments) {
   assert(elf_mapped_base);
-  assert(segment_start);
-  assert(segment_size);
-
-  *segment_start = NULL;
-  *segment_size = 0;
+  assert(segments);
 
   if (!IsValidElf(elf_mapped_base))
     return false;
 
   int cls = ElfClass(elf_mapped_base);
-  if (elfclass) {
-    *elfclass = cls;
-  }
-
   const char* elf_base =
     static_cast<const char*>(elf_mapped_base);
 
   if (cls == ELFCLASS32) {
-    FindElfClassSegment<ElfClass32>(elf_base, segment_type,
-                                    segment_start, segment_size);
-    return *segment_start != NULL;
+    FindElfClassSegment<ElfClass32>(elf_base, segment_type, segments);
+    return true;
   } else if (cls == ELFCLASS64) {
-    FindElfClassSegment<ElfClass64>(elf_base, segment_type,
-                                    segment_start, segment_size);
-    return *segment_start != NULL;
+    FindElfClassSegment<ElfClass64>(elf_base, segment_type, segments);
+    return true;
+  }
+
+  return false;
+}
+
+template <typename ElfClass>
+bool FindElfSoNameFromDynamicSection(const void* section_start,
+                                     size_t section_size,
+                                     const void* dynstr_start,
+                                     size_t dynstr_size,
+                                     char* soname,
+                                     size_t soname_size) {
+  typedef typename ElfClass::Dyn Dyn;
+
+  auto* dynamic = static_cast<const Dyn*>(section_start);
+  size_t dcount = section_size / sizeof(Dyn);
+  for (const Dyn* dyn = dynamic; dyn < dynamic + dcount; ++dyn) {
+    if (dyn->d_tag == DT_SONAME) {
+      const char* dynstr = static_cast<const char*>(dynstr_start);
+      if (dyn->d_un.d_val >= dynstr_size) {
+        // Beyond the end of the dynstr section
+        return false;
+      }
+      const char* str = dynstr + dyn->d_un.d_val;
+      const size_t maxsize = dynstr_size - dyn->d_un.d_val;
+      my_strlcpy(soname, str, maxsize < soname_size ? maxsize : soname_size);
+      return true;
+    }
   }
 
   return false;
 }
 
+bool ElfFileSoNameFromMappedFile(const void* elf_base,
+                                 char* soname,
+                                 size_t soname_size) {
+  if (!IsValidElf(elf_base)) {
+    // Not ELF
+    return false;
+  }
+
+  const void* segment_start;
+  size_t segment_size;
+  if (!FindElfSection(elf_base, ".dynamic", SHT_DYNAMIC, &segment_start,
+                      &segment_size)) {
+    // No dynamic section
+    return false;
+  }
+
+  const void* dynstr_start;
+  size_t dynstr_size;
+  if (!FindElfSection(elf_base, ".dynstr", SHT_STRTAB, &dynstr_start,
+                      &dynstr_size)) {
+    // No dynstr section
+    return false;
+  }
+
+  int cls = ElfClass(elf_base);
+  return cls == ELFCLASS32 ? FindElfSoNameFromDynamicSection<ElfClass32>(
+                                 segment_start, segment_size, dynstr_start,
+                                 dynstr_size, soname, soname_size)
+                           : FindElfSoNameFromDynamicSection<ElfClass64>(
+                                 segment_start, segment_size, dynstr_start,
+                                 dynstr_size, soname, soname_size);
+}
+
 }  // namespace google_breakpad
diff --git a/src/MEGASync/google_breakpad/common/linux/elfutils.h b/src/MEGASync/google_breakpad/common/linux/elfutils.h
index fe12e251..ec5872a4 100644
--- a/src/MEGASync/google_breakpad/common/linux/elfutils.h
+++ b/src/MEGASync/google_breakpad/common/linux/elfutils.h
@@ -30,41 +30,53 @@
 // elfutils.h: Utilities for dealing with ELF files.
 //
 
-#ifndef COMMON_LINUX_ELFUTILS_H__
-#define COMMON_LINUX_ELFUTILS_H__
+#ifndef COMMON_LINUX_ELFUTILS_H_
+#define COMMON_LINUX_ELFUTILS_H_
 
 #include <elf.h>
 #include <link.h>
 #include <stdint.h>
 
+#include "common/memory_allocator.h"
+
 namespace google_breakpad {
 
 // Traits classes so consumers can write templatized code to deal
 // with specific ELF bits.
 struct ElfClass32 {
   typedef Elf32_Addr Addr;
+  typedef Elf32_Dyn Dyn;
   typedef Elf32_Ehdr Ehdr;
   typedef Elf32_Nhdr Nhdr;
   typedef Elf32_Phdr Phdr;
   typedef Elf32_Shdr Shdr;
   typedef Elf32_Half Half;
   typedef Elf32_Off Off;
+  typedef Elf32_Sym Sym;
   typedef Elf32_Word Word;
+
   static const int kClass = ELFCLASS32;
+  static const uint16_t kMachine = EM_386;
   static const size_t kAddrSize = sizeof(Elf32_Addr);
+  static constexpr const char* kMachineName = "x86";
 };
 
 struct ElfClass64 {
   typedef Elf64_Addr Addr;
+  typedef Elf64_Dyn Dyn;
   typedef Elf64_Ehdr Ehdr;
   typedef Elf64_Nhdr Nhdr;
   typedef Elf64_Phdr Phdr;
   typedef Elf64_Shdr Shdr;
   typedef Elf64_Half Half;
   typedef Elf64_Off Off;
+  typedef Elf64_Sym Sym;
   typedef Elf64_Word Word;
+
   static const int kClass = ELFCLASS64;
+  static const uint16_t kMachine = EM_X86_64;
   static const size_t kAddrSize = sizeof(Elf64_Addr);
+  static constexpr const char* kMachineName = "x86_64";
 };
 
 bool IsValidElf(const void* elf_header);
@@ -73,14 +85,12 @@ int ElfClass(const void* elf_base);
 // Attempt to find a section named |section_name| of type |section_type|
 // in the ELF binary data at |elf_mapped_base|. On success, returns true
 // and sets |*section_start| to point to the start of the section data,
-// and |*section_size| to the size of the section's data. If |elfclass|
-// is not NULL, set |*elfclass| to the ELF file class.
-bool FindElfSection(const void *elf_mapped_base,
-                    const char *section_name,
+// and |*section_size| to the size of the section's data.
+bool FindElfSection(const void* elf_mapped_base,
+                    const char* section_name,
                     uint32_t section_type,
-                    const void **section_start,
-                    int *section_size,
-                    int *elfclass);
+                    const void** section_start,
+                    size_t* section_size);
 
 // Internal helper method, exposed for convenience for callers
 // that already have more info.
@@ -93,16 +103,17 @@ FindElfSectionByName(const char* name,
                      const char* names_end,
                      int nsection);
 
-// Attempt to find the first segment of type |segment_type| in the ELF
-// binary data at |elf_mapped_base|. On success, returns true and sets
-// |*segment_start| to point to the start of the segment data, and
-// and |*segment_size| to the size of the segment's data. If |elfclass|
-// is not NULL, set |*elfclass| to the ELF file class.
-bool FindElfSegment(const void *elf_mapped_base,
-                    uint32_t segment_type,
-                    const void **segment_start,
-                    int *segment_size,
-                    int *elfclass);
+struct ElfSegment {
+  const void* start;
+  size_t size;
+};
+
+// Attempt to find all segments of type |segment_type| in the ELF
+// binary data at |elf_mapped_base|. On success, returns true and fills
+// |*segments| with a list of segments of the given type.
+bool FindElfSegments(const void* elf_mapped_base,
+                     uint32_t segment_type,
+                     wasteful_vector<ElfSegment>* segments);
 
 // Convert an offset from an Elf header into a pointer to the mapped
 // address in the current process. Takes an extra template parameter
@@ -113,6 +124,12 @@ const T*
 GetOffset(const typename ElfClass::Ehdr* elf_header,
           typename ElfClass::Off offset);
 
+// Read the value of DT_SONAME from the elf file mapped at |elf_base|. Returns
+// true and fills |soname| with the result if found.
+bool ElfFileSoNameFromMappedFile(const void* elf_base,
+                                 char* soname,
+                                 size_t soname_size);
+
 }  // namespace google_breakpad
 
-#endif  // COMMON_LINUX_ELFUTILS_H__
+#endif  // COMMON_LINUX_ELFUTILS_H_
diff --git a/src/MEGASync/google_breakpad/common/linux/file_id.cc b/src/MEGASync/google_breakpad/common/linux/file_id.cc
index e3631785..9944af7a 100644
--- a/src/MEGASync/google_breakpad/common/linux/file_id.cc
+++ b/src/MEGASync/google_breakpad/common/linux/file_id.cc
@@ -39,18 +39,21 @@
 #include <string.h>
 
 #include <algorithm>
+#include <string>
 
 #include "common/linux/elf_gnu_compat.h"
 #include "common/linux/elfutils.h"
 #include "common/linux/linux_libc_support.h"
 #include "common/linux/memory_mapped_file.h"
+#include "common/using_std_string.h"
 #include "third_party/lss/linux_syscall_support.h"
 
 namespace google_breakpad {
 
-FileID::FileID(const char* path) {
-  strncpy(path_, path, sizeof(path_));
-}
+// Used in a few places for backwards-compatibility.
+const size_t kMDGUIDSize = sizeof(MDGUID);
+
+FileID::FileID(const char* path) : path_(path) {}
 
 // ELF note name and desc are 32-bits word padded.
 #define NOTE_PADDING(a) ((a + 3) & ~3)
@@ -58,14 +61,15 @@ FileID::FileID(const char* path) {
 // These functions are also used inside the crashed process, so be safe
 // and use the syscall/libc wrappers instead of direct syscalls or libc.
 
-template<typename ElfClass>
-static bool ElfClassBuildIDNoteIdentifier(const void *section, int length,
-                                          uint8_t identifier[kMDGUIDSize]) {
-  typedef typename ElfClass::Nhdr Nhdr;
+static bool ElfClassBuildIDNoteIdentifier(const void* section, size_t length,
+                                          wasteful_vector<uint8_t>& identifier) {
+  static_assert(sizeof(ElfClass32::Nhdr) == sizeof(ElfClass64::Nhdr),
+                "Elf32_Nhdr and Elf64_Nhdr should be the same");
+  typedef typename ElfClass32::Nhdr Nhdr;
 
   const void* section_end = reinterpret_cast<const char*>(section) + length;
   const Nhdr* note_header = reinterpret_cast<const Nhdr*>(section);
-  while (reinterpret_cast<const void *>(note_header) < section_end) {
+  while (reinterpret_cast<const void*>(note_header) < section_end) {
     if (note_header->n_type == NT_GNU_BUILD_ID)
       break;
     note_header = reinterpret_cast<const Nhdr*>(
@@ -73,43 +77,40 @@ static bool ElfClassBuildIDNoteIdentifier(const void *section, int length,
                   NOTE_PADDING(note_header->n_namesz) +
                   NOTE_PADDING(note_header->n_descsz));
   }
-  if (reinterpret_cast<const void *>(note_header) >= section_end ||
+  if (reinterpret_cast<const void*>(note_header) >= section_end ||
       note_header->n_descsz == 0) {
     return false;
   }
 
-  const char* build_id = reinterpret_cast<const char*>(note_header) +
+  const uint8_t* build_id = reinterpret_cast<const uint8_t*>(note_header) +
     sizeof(Nhdr) + NOTE_PADDING(note_header->n_namesz);
-  // Copy as many bits of the build ID as will fit
-  // into the GUID space.
-  my_memset(identifier, 0, kMDGUIDSize);
-  memcpy(identifier, build_id,
-         std::min(kMDGUIDSize, (size_t)note_header->n_descsz));
+  identifier.insert(identifier.end(),
+                    build_id,
+                    build_id + note_header->n_descsz);
 
   return true;
 }
 
 // Attempt to locate a .note.gnu.build-id section in an ELF binary
-// and copy as many bytes of it as will fit into |identifier|.
-static bool FindElfBuildIDNote(const void *elf_mapped_base,
-                               uint8_t identifier[kMDGUIDSize]) {
-  void* note_section;
-  int note_size, elfclass;
-  if ((!FindElfSegment(elf_mapped_base, PT_NOTE,
-                       (const void**)&note_section, &note_size, &elfclass) ||
-      note_size == 0)  &&
-      (!FindElfSection(elf_mapped_base, ".note.gnu.build-id", SHT_NOTE,
-                       (const void**)&note_section, &note_size, &elfclass) ||
-      note_size == 0)) {
-    return false;
+// and copy it into |identifier|.
+static bool FindElfBuildIDNote(const void* elf_mapped_base,
+                               wasteful_vector<uint8_t>& identifier) {
+  PageAllocator allocator;
+  // lld normally creates 2 PT_NOTEs, gold normally creates 1.
+  auto_wasteful_vector<ElfSegment, 2> segs(&allocator);
+  if (FindElfSegments(elf_mapped_base, PT_NOTE, &segs)) {
+    for (ElfSegment& seg : segs) {
+      if (ElfClassBuildIDNoteIdentifier(seg.start, seg.size, identifier)) {
+        return true;
+      }
+    }
   }
 
-  if (elfclass == ELFCLASS32) {
-    return ElfClassBuildIDNoteIdentifier<ElfClass32>(note_section, note_size,
-                                                     identifier);
-  } else if (elfclass == ELFCLASS64) {
-    return ElfClassBuildIDNoteIdentifier<ElfClass64>(note_section, note_size,
-                                                     identifier);
+  void* note_section;
+  size_t note_size;
+  if (FindElfSection(elf_mapped_base, ".note.gnu.build-id", SHT_NOTE,
+                     (const void**)&note_section, &note_size)) {
+    return ElfClassBuildIDNoteIdentifier(note_section, note_size, identifier);
   }
 
   return false;
@@ -117,19 +118,23 @@ static bool FindElfBuildIDNote(const void *elf_mapped_base,
 
 // Attempt to locate the .text section of an ELF binary and generate
 // a simple hash by XORing the first page worth of bytes into |identifier|.
-static bool HashElfTextSection(const void *elf_mapped_base,
-                               uint8_t identifier[kMDGUIDSize]) {
+static bool HashElfTextSection(const void* elf_mapped_base,
+                               wasteful_vector<uint8_t>& identifier) {
+  identifier.resize(kMDGUIDSize);
+
   void* text_section;
-  int text_size;
+  size_t text_size;
   if (!FindElfSection(elf_mapped_base, ".text", SHT_PROGBITS,
-                      (const void**)&text_section, &text_size, NULL) ||
+                      (const void**)&text_section, &text_size) ||
       text_size == 0) {
     return false;
   }
 
-  my_memset(identifier, 0, kMDGUIDSize);
+  // Only provide |kMDGUIDSize| bytes to keep identifiers produced by this
+  // function backwards-compatible.
+  my_memset(&identifier[0], 0, kMDGUIDSize);
   const uint8_t* ptr = reinterpret_cast<const uint8_t*>(text_section);
-  const uint8_t* ptr_end = ptr + std::min(text_size, 4096);
+  const uint8_t* ptr_end = ptr + std::min(text_size, static_cast<size_t>(4096));
   while (ptr < ptr_end) {
     for (unsigned i = 0; i < kMDGUIDSize; i++)
       identifier[i] ^= ptr[i];
@@ -140,7 +145,7 @@ static bool HashElfTextSection(const void *elf_mapped_base,
 
 // static
 bool FileID::ElfFileIdentifierFromMappedFile(const void* base,
-                                             uint8_t identifier[kMDGUIDSize]) {
+                                             wasteful_vector<uint8_t>& identifier) {
   // Look for a build id note first.
   if (FindElfBuildIDNote(base, identifier))
     return true;
@@ -149,21 +154,34 @@ bool FileID::ElfFileIdentifierFromMappedFile(const void* base,
   return HashElfTextSection(base, identifier);
 }
 
-bool FileID::ElfFileIdentifier(uint8_t identifier[kMDGUIDSize]) {
-  MemoryMappedFile mapped_file(path_);
+bool FileID::ElfFileIdentifier(wasteful_vector<uint8_t>& identifier) {
+  MemoryMappedFile mapped_file(path_.c_str(), 0);
   if (!mapped_file.data())  // Should probably check if size >= ElfW(Ehdr)?
     return false;
 
   return ElfFileIdentifierFromMappedFile(mapped_file.data(), identifier);
 }
 
+// These three functions are not ever called in an unsafe context, so it's OK
+// to allocate memory and use libc.
+static string bytes_to_hex_string(const uint8_t* bytes, size_t count) {
+  string result;
+  for (unsigned int idx = 0; idx < count; ++idx) {
+    char buf[3];
+    snprintf(buf, sizeof(buf), "%02X", bytes[idx]);
+    result.append(buf);
+  }
+  return result;
+}
+
 // static
-void FileID::ConvertIdentifierToString(const uint8_t identifier[kMDGUIDSize],
-                                       char* buffer, int buffer_length) {
-  uint8_t identifier_swapped[kMDGUIDSize];
+string FileID::ConvertIdentifierToUUIDString(
+    const wasteful_vector<uint8_t>& identifier) {
+  uint8_t identifier_swapped[kMDGUIDSize] = { 0 };
 
   // Endian-ness swap to match dump processor expectation.
-  memcpy(identifier_swapped, identifier, kMDGUIDSize);
+  memcpy(identifier_swapped, &identifier[0],
+         std::min(kMDGUIDSize, identifier.size()));
   uint32_t* data1 = reinterpret_cast<uint32_t*>(identifier_swapped);
   *data1 = htonl(*data1);
   uint16_t* data2 = reinterpret_cast<uint16_t*>(identifier_swapped + 4);
@@ -171,22 +189,13 @@ void FileID::ConvertIdentifierToString(const uint8_t identifier[kMDGUIDSize],
   uint16_t* data3 = reinterpret_cast<uint16_t*>(identifier_swapped + 6);
   *data3 = htons(*data3);
 
-  int buffer_idx = 0;
-  for (unsigned int idx = 0;
-       (buffer_idx < buffer_length) && (idx < kMDGUIDSize);
-       ++idx) {
-    int hi = (identifier_swapped[idx] >> 4) & 0x0F;
-    int lo = (identifier_swapped[idx]) & 0x0F;
-
-    if (idx == 4 || idx == 6 || idx == 8 || idx == 10)
-      buffer[buffer_idx++] = '-';
-
-    buffer[buffer_idx++] = (hi >= 10) ? 'A' + hi - 10 : '0' + hi;
-    buffer[buffer_idx++] = (lo >= 10) ? 'A' + lo - 10 : '0' + lo;
-  }
+  return bytes_to_hex_string(identifier_swapped, kMDGUIDSize);
+}
 
-  // NULL terminate
-  buffer[(buffer_idx < buffer_length) ? buffer_idx : buffer_idx - 1] = 0;
+// static
+string FileID::ConvertIdentifierToString(
+    const wasteful_vector<uint8_t>& identifier) {
+  return bytes_to_hex_string(&identifier[0], identifier.size());
 }
 
 }  // namespace google_breakpad
diff --git a/src/MEGASync/google_breakpad/common/linux/file_id.h b/src/MEGASync/google_breakpad/common/linux/file_id.h
index 70a6b3f5..4aff021d 100644
--- a/src/MEGASync/google_breakpad/common/linux/file_id.h
+++ b/src/MEGASync/google_breakpad/common/linux/file_id.h
@@ -34,12 +34,19 @@
 #define COMMON_LINUX_FILE_ID_H__
 
 #include <limits.h>
+#include <string>
 
 #include "common/linux/guid_creator.h"
+#include "common/memory_allocator.h"
+#include "common/using_std_string.h"
 
 namespace google_breakpad {
 
-static const size_t kMDGUIDSize = sizeof(MDGUID);
+// GNU binutils' ld defaults to 'sha1', which is 160 bits == 20 bytes,
+// so this is enough to fit that, which most binaries will use.
+// This is just a sensible default for auto_wasteful_vector so most
+// callers can get away with stack allocation.
+static const size_t kDefaultBuildIdSize = 20;
 
 class FileID {
  public:
@@ -47,29 +54,33 @@ class FileID {
   ~FileID() {}
 
   // Load the identifier for the elf file path specified in the constructor into
-  // |identifier|.  Return false if the identifier could not be created for the
-  // file.
+  // |identifier|.
+  //
   // The current implementation will look for a .note.gnu.build-id
   // section and use that as the file id, otherwise it falls back to
   // XORing the first 4096 bytes of the .text section to generate an identifier.
-  bool ElfFileIdentifier(uint8_t identifier[kMDGUIDSize]);
+  bool ElfFileIdentifier(wasteful_vector<uint8_t>& identifier);
 
   // Load the identifier for the elf file mapped into memory at |base| into
-  // |identifier|.  Return false if the identifier could not be created for the
+  // |identifier|. Return false if the identifier could not be created for this
   // file.
-  static bool ElfFileIdentifierFromMappedFile(const void* base,
-                                              uint8_t identifier[kMDGUIDSize]);
+  static bool ElfFileIdentifierFromMappedFile(
+      const void* base,
+      wasteful_vector<uint8_t>& identifier);
+
+  // Convert the |identifier| data to a string.  The string will
+  // be formatted as a UUID in all uppercase without dashes.
+  // (e.g., 22F065BBFC9C49F780FE26A7CEBD7BCE).
+  static string ConvertIdentifierToUUIDString(
+      const wasteful_vector<uint8_t>& identifier);
 
-  // Convert the |identifier| data to a NULL terminated string.  The string will
-  // be formatted as a UUID (e.g., 22F065BB-FC9C-49F7-80FE-26A7CEBD7BCE).
-  // The |buffer| should be at least 37 bytes long to receive all of the data
-  // and termination.  Shorter buffers will contain truncated data.
-  static void ConvertIdentifierToString(const uint8_t identifier[kMDGUIDSize],
-                                        char* buffer, int buffer_length);
+  // Convert the entire |identifier| data to a hex string.
+  static string ConvertIdentifierToString(
+      const wasteful_vector<uint8_t>& identifier);
 
  private:
   // Storage for the path specified
-  char path_[PATH_MAX];
+  string path_;
 };
 
 }  // namespace google_breakpad
diff --git a/src/MEGASync/google_breakpad/common/linux/file_id_unittest.cc b/src/MEGASync/google_breakpad/common/linux/file_id_unittest.cc
index 760eae82..8225e5ac 100644
--- a/src/MEGASync/google_breakpad/common/linux/file_id_unittest.cc
+++ b/src/MEGASync/google_breakpad/common/linux/file_id_unittest.cc
@@ -30,9 +30,13 @@
 // Unit tests for FileID
 
 #include <elf.h>
+#include <spawn.h>
 #include <stdlib.h>
+#include <sys/types.h>
+#include <sys/wait.h>
 
 #include <string>
+#include <vector>
 
 #include "common/linux/elf_gnu_compat.h"
 #include "common/linux/elfutils.h"
@@ -41,17 +45,16 @@
 #include "common/linux/synth_elf.h"
 #include "common/test_assembler.h"
 #include "common/tests/auto_tempdir.h"
+#include "common/tests/file_utils.h"
 #include "common/using_std_string.h"
 #include "breakpad_googletest_includes.h"
 
 using namespace google_breakpad;
-using google_breakpad::ElfClass32;
-using google_breakpad::ElfClass64;
-using google_breakpad::SafeReadLink;
 using google_breakpad::synth_elf::ELF;
 using google_breakpad::synth_elf::Notes;
 using google_breakpad::test_assembler::kLittleEndian;
 using google_breakpad::test_assembler::Section;
+using std::vector;
 using ::testing::Types;
 
 namespace {
@@ -64,6 +67,8 @@ void PopulateSection(Section* section, int size, int prime_number) {
     section->Append(1, (i % prime_number) % 256);
 }
 
+typedef wasteful_vector<uint8_t> id_vector;
+
 }  // namespace
 
 #ifndef __ANDROID__
@@ -79,27 +84,33 @@ TEST(FileIDStripTest, StripSelf) {
   // copy our binary to a temp file, and strip it
   AutoTempDir temp_dir;
   string templ = temp_dir.path() + "/file-id-unittest";
-  char cmdline[4096];
-  sprintf(cmdline, "cp \"%s\" \"%s\"", exe_name, templ.c_str());
-  ASSERT_EQ(0, system(cmdline)) << "Failed to execute: " << cmdline;
-  sprintf(cmdline, "chmod u+w \"%s\"", templ.c_str());
-  ASSERT_EQ(0, system(cmdline)) << "Failed to execute: " << cmdline;
-  sprintf(cmdline, "strip \"%s\"", templ.c_str());
-  ASSERT_EQ(0, system(cmdline)) << "Failed to execute: " << cmdline;
-
-  uint8_t identifier1[sizeof(MDGUID)];
-  uint8_t identifier2[sizeof(MDGUID)];
+  ASSERT_TRUE(CopyFile(exe_name, templ));
+  pid_t pid;
+  char* argv[] = {
+      const_cast<char*>("strip"),
+      const_cast<char*>(templ.c_str()),
+      nullptr,
+  };
+  ASSERT_EQ(0, posix_spawnp(&pid, argv[0], nullptr, nullptr, argv, nullptr));
+  int status;
+  ASSERT_EQ(pid, waitpid(pid, &status, 0));
+  ASSERT_TRUE(WIFEXITED(status));
+  ASSERT_EQ(0, WEXITSTATUS(status));
+
+  PageAllocator allocator;
+  id_vector identifier1(&allocator, kDefaultBuildIdSize);
+  id_vector identifier2(&allocator, kDefaultBuildIdSize);
+
   FileID fileid1(exe_name);
   EXPECT_TRUE(fileid1.ElfFileIdentifier(identifier1));
   FileID fileid2(templ.c_str());
   EXPECT_TRUE(fileid2.ElfFileIdentifier(identifier2));
-  char identifier_string1[37];
-  char identifier_string2[37];
-  FileID::ConvertIdentifierToString(identifier1, identifier_string1,
-                                    37);
-  FileID::ConvertIdentifierToString(identifier2, identifier_string2,
-                                    37);
-  EXPECT_STREQ(identifier_string1, identifier_string2);
+
+  string identifier_string1 =
+      FileID::ConvertIdentifierToUUIDString(identifier1);
+  string identifier_string2 =
+      FileID::ConvertIdentifierToUUIDString(identifier2);
+  EXPECT_EQ(identifier_string1, identifier_string2);
 }
 #endif  // !__ANDROID__
 
@@ -116,19 +127,31 @@ public:
     elfdata = &elfdata_v[0];
   }
 
+  id_vector make_vector() {
+    return id_vector(&allocator, kDefaultBuildIdSize);
+  }
+
+  template<size_t N>
+  string get_file_id(const uint8_t (&data)[N]) {
+    id_vector expected_identifier(make_vector());
+    expected_identifier.insert(expected_identifier.end(),
+                               &data[0],
+                               data + N);
+    return FileID::ConvertIdentifierToUUIDString(expected_identifier);
+  }
+
   vector<uint8_t> elfdata_v;
   uint8_t* elfdata;
+  PageAllocator allocator;
 };
 
 typedef Types<ElfClass32, ElfClass64> ElfClasses;
 
-TYPED_TEST_CASE(FileIDTest, ElfClasses);
+TYPED_TEST_SUITE(FileIDTest, ElfClasses);
 
 TYPED_TEST(FileIDTest, ElfClass) {
-  uint8_t identifier[sizeof(MDGUID)];
   const char expected_identifier_string[] =
-      "80808080-8080-0000-0000-008080808080";
-  char identifier_string[sizeof(expected_identifier_string)];
+      "80808080808000000000008080808080";
   const size_t kTextSectionSize = 128;
 
   ELF elf(EM_386, TypeParam::kClass, kLittleEndian);
@@ -140,58 +163,106 @@ TYPED_TEST(FileIDTest, ElfClass) {
   elf.Finish();
   this->GetElfContents(elf);
 
+  id_vector identifier(this->make_vector());
   EXPECT_TRUE(FileID::ElfFileIdentifierFromMappedFile(this->elfdata,
                                                       identifier));
 
-  FileID::ConvertIdentifierToString(identifier, identifier_string,
-                                    sizeof(identifier_string));
-  EXPECT_STREQ(expected_identifier_string, identifier_string);
+  string identifier_string = FileID::ConvertIdentifierToUUIDString(identifier);
+  EXPECT_EQ(expected_identifier_string, identifier_string);
 }
 
 TYPED_TEST(FileIDTest, BuildID) {
-  const uint8_t kExpectedIdentifier[sizeof(MDGUID)] =
+  const uint8_t kExpectedIdentifierBytes[] =
     {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
-     0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F};
-  char expected_identifier_string[] =
-    "00000000-0000-0000-0000-000000000000";
-  FileID::ConvertIdentifierToString(kExpectedIdentifier,
-                                    expected_identifier_string,
-                                    sizeof(expected_identifier_string));
+     0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
+     0x10, 0x11, 0x12, 0x13};
+  const string expected_identifier_string =
+      this->get_file_id(kExpectedIdentifierBytes);
+
+  ELF elf(EM_386, TypeParam::kClass, kLittleEndian);
+  Section text(kLittleEndian);
+  text.Append(4096, 0);
+  elf.AddSection(".text", text, SHT_PROGBITS);
+  Notes notes(kLittleEndian);
+  notes.AddNote(NT_GNU_BUILD_ID, "GNU", kExpectedIdentifierBytes,
+                sizeof(kExpectedIdentifierBytes));
+  elf.AddSection(".note.gnu.build-id", notes, SHT_NOTE);
+  elf.Finish();
+  this->GetElfContents(elf);
+
+  id_vector identifier(this->make_vector());
+  EXPECT_TRUE(FileID::ElfFileIdentifierFromMappedFile(this->elfdata,
+                                                      identifier));
+  EXPECT_EQ(sizeof(kExpectedIdentifierBytes), identifier.size());
+
+  string identifier_string = FileID::ConvertIdentifierToUUIDString(identifier);
+  EXPECT_EQ(expected_identifier_string, identifier_string);
+}
 
-  uint8_t identifier[sizeof(MDGUID)];
-  char identifier_string[sizeof(expected_identifier_string)];
+// Test that a build id note with fewer bytes than usual is handled.
+TYPED_TEST(FileIDTest, BuildIDShort) {
+  const uint8_t kExpectedIdentifierBytes[] =
+    {0x00, 0x01, 0x02, 0x03};
+  const string expected_identifier_string =
+      this->get_file_id(kExpectedIdentifierBytes);
 
   ELF elf(EM_386, TypeParam::kClass, kLittleEndian);
   Section text(kLittleEndian);
   text.Append(4096, 0);
   elf.AddSection(".text", text, SHT_PROGBITS);
   Notes notes(kLittleEndian);
-  notes.AddNote(NT_GNU_BUILD_ID, "GNU", kExpectedIdentifier,
-                sizeof(kExpectedIdentifier));
+  notes.AddNote(NT_GNU_BUILD_ID, "GNU", kExpectedIdentifierBytes,
+                sizeof(kExpectedIdentifierBytes));
   elf.AddSection(".note.gnu.build-id", notes, SHT_NOTE);
   elf.Finish();
   this->GetElfContents(elf);
 
+  id_vector identifier(this->make_vector());
   EXPECT_TRUE(FileID::ElfFileIdentifierFromMappedFile(this->elfdata,
                                                       identifier));
+  EXPECT_EQ(sizeof(kExpectedIdentifierBytes), identifier.size());
 
-  FileID::ConvertIdentifierToString(identifier, identifier_string,
-                                    sizeof(identifier_string));
-  EXPECT_STREQ(expected_identifier_string, identifier_string);
+  string identifier_string = FileID::ConvertIdentifierToUUIDString(identifier);
+  EXPECT_EQ(expected_identifier_string, identifier_string);
 }
 
-TYPED_TEST(FileIDTest, BuildIDPH) {
-  const uint8_t kExpectedIdentifier[sizeof(MDGUID)] =
+// Test that a build id note with more bytes than usual is handled.
+TYPED_TEST(FileIDTest, BuildIDLong) {
+  const uint8_t kExpectedIdentifierBytes[] =
     {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
-     0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F};
-  char expected_identifier_string[] =
-    "00000000-0000-0000-0000-000000000000";
-  FileID::ConvertIdentifierToString(kExpectedIdentifier,
-                                    expected_identifier_string,
-                                    sizeof(expected_identifier_string));
+     0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
+     0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
+     0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F};
+  const string expected_identifier_string =
+      this->get_file_id(kExpectedIdentifierBytes);
+
+  ELF elf(EM_386, TypeParam::kClass, kLittleEndian);
+  Section text(kLittleEndian);
+  text.Append(4096, 0);
+  elf.AddSection(".text", text, SHT_PROGBITS);
+  Notes notes(kLittleEndian);
+  notes.AddNote(NT_GNU_BUILD_ID, "GNU", kExpectedIdentifierBytes,
+                sizeof(kExpectedIdentifierBytes));
+  elf.AddSection(".note.gnu.build-id", notes, SHT_NOTE);
+  elf.Finish();
+  this->GetElfContents(elf);
+
+  id_vector identifier(this->make_vector());
+  EXPECT_TRUE(FileID::ElfFileIdentifierFromMappedFile(this->elfdata,
+                                                      identifier));
+  EXPECT_EQ(sizeof(kExpectedIdentifierBytes), identifier.size());
+
+  string identifier_string = FileID::ConvertIdentifierToUUIDString(identifier);
+  EXPECT_EQ(expected_identifier_string, identifier_string);
+}
 
-  uint8_t identifier[sizeof(MDGUID)];
-  char identifier_string[sizeof(expected_identifier_string)];
+TYPED_TEST(FileIDTest, BuildIDPH) {
+  const uint8_t kExpectedIdentifierBytes[] =
+    {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+     0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
+     0x10, 0x11, 0x12, 0x13};
+  const string expected_identifier_string =
+      this->get_file_id(kExpectedIdentifierBytes);
 
   ELF elf(EM_386, TypeParam::kClass, kLittleEndian);
   Section text(kLittleEndian);
@@ -199,32 +270,60 @@ TYPED_TEST(FileIDTest, BuildIDPH) {
   elf.AddSection(".text", text, SHT_PROGBITS);
   Notes notes(kLittleEndian);
   notes.AddNote(0, "Linux",
-                reinterpret_cast<const uint8_t *>("\0x42\0x02\0\0"), 4);
-  notes.AddNote(NT_GNU_BUILD_ID, "GNU", kExpectedIdentifier,
-                sizeof(kExpectedIdentifier));
+                reinterpret_cast<const uint8_t*>("\0x42\0x02\0\0"), 4);
+  notes.AddNote(NT_GNU_BUILD_ID, "GNU", kExpectedIdentifierBytes,
+                sizeof(kExpectedIdentifierBytes));
   int note_idx = elf.AddSection(".note", notes, SHT_NOTE);
   elf.AddSegment(note_idx, note_idx, PT_NOTE);
   elf.Finish();
   this->GetElfContents(elf);
 
+  id_vector identifier(this->make_vector());
+  EXPECT_TRUE(FileID::ElfFileIdentifierFromMappedFile(this->elfdata,
+                                                      identifier));
+  EXPECT_EQ(sizeof(kExpectedIdentifierBytes), identifier.size());
+
+  string identifier_string = FileID::ConvertIdentifierToUUIDString(identifier);
+  EXPECT_EQ(expected_identifier_string, identifier_string);
+}
+
+TYPED_TEST(FileIDTest, BuildIDMultiplePH) {
+  const uint8_t kExpectedIdentifierBytes[] =
+    {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+     0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
+     0x10, 0x11, 0x12, 0x13};
+  const string expected_identifier_string =
+      this->get_file_id(kExpectedIdentifierBytes);
+
+  ELF elf(EM_386, TypeParam::kClass, kLittleEndian);
+  Section text(kLittleEndian);
+  text.Append(4096, 0);
+  elf.AddSection(".text", text, SHT_PROGBITS);
+  Notes notes1(kLittleEndian);
+  notes1.AddNote(0, "Linux",
+                reinterpret_cast<const uint8_t*>("\0x42\0x02\0\0"), 4);
+  Notes notes2(kLittleEndian);
+  notes2.AddNote(NT_GNU_BUILD_ID, "GNU", kExpectedIdentifierBytes,
+                 sizeof(kExpectedIdentifierBytes));
+  int note1_idx = elf.AddSection(".note1", notes1, SHT_NOTE);
+  int note2_idx = elf.AddSection(".note2", notes2, SHT_NOTE);
+  elf.AddSegment(note1_idx, note1_idx, PT_NOTE);
+  elf.AddSegment(note2_idx, note2_idx, PT_NOTE);
+  elf.Finish();
+  this->GetElfContents(elf);
+
+  id_vector identifier(this->make_vector());
   EXPECT_TRUE(FileID::ElfFileIdentifierFromMappedFile(this->elfdata,
                                                       identifier));
+  EXPECT_EQ(sizeof(kExpectedIdentifierBytes), identifier.size());
 
-  FileID::ConvertIdentifierToString(identifier, identifier_string,
-                                    sizeof(identifier_string));
-  EXPECT_STREQ(expected_identifier_string, identifier_string);
+  string identifier_string = FileID::ConvertIdentifierToUUIDString(identifier);
+  EXPECT_EQ(expected_identifier_string, identifier_string);
 }
 
 // Test to make sure two files with different text sections produce
 // different hashes when not using a build id.
 TYPED_TEST(FileIDTest, UniqueHashes) {
-  char identifier_string_1[] =
-    "00000000-0000-0000-0000-000000000000";
-  char identifier_string_2[] =
-    "00000000-0000-0000-0000-000000000000";
-  uint8_t identifier_1[sizeof(MDGUID)];
-  uint8_t identifier_2[sizeof(MDGUID)];
-
   {
     ELF elf1(EM_386, TypeParam::kClass, kLittleEndian);
     Section foo_1(kLittleEndian);
@@ -237,10 +336,11 @@ TYPED_TEST(FileIDTest, UniqueHashes) {
     this->GetElfContents(elf1);
   }
 
+  id_vector identifier_1(this->make_vector());
   EXPECT_TRUE(FileID::ElfFileIdentifierFromMappedFile(this->elfdata,
                                                       identifier_1));
-  FileID::ConvertIdentifierToString(identifier_1, identifier_string_1,
-                                    sizeof(identifier_string_1));
+  string identifier_string_1 =
+      FileID::ConvertIdentifierToUUIDString(identifier_1);
 
   {
     ELF elf2(EM_386, TypeParam::kClass, kLittleEndian);
@@ -254,10 +354,28 @@ TYPED_TEST(FileIDTest, UniqueHashes) {
     this->GetElfContents(elf2);
   }
 
+  id_vector identifier_2(this->make_vector());
   EXPECT_TRUE(FileID::ElfFileIdentifierFromMappedFile(this->elfdata,
                                                       identifier_2));
-  FileID::ConvertIdentifierToString(identifier_2, identifier_string_2,
-                                    sizeof(identifier_string_2));
+  string identifier_string_2 =
+      FileID::ConvertIdentifierToUUIDString(identifier_2);
 
-  EXPECT_STRNE(identifier_string_1, identifier_string_2);
+  EXPECT_NE(identifier_string_1, identifier_string_2);
+}
+
+TYPED_TEST(FileIDTest, ConvertIdentifierToString) {
+  const uint8_t kIdentifierBytes[] =
+    {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+     0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
+     0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
+     0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F};
+  const char* kExpected =
+    "000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F";
+
+  id_vector identifier(this->make_vector());
+  identifier.insert(identifier.end(),
+                    kIdentifierBytes,
+                    kIdentifierBytes + sizeof(kIdentifierBytes));
+  ASSERT_EQ(kExpected,
+            FileID::ConvertIdentifierToString(identifier));
 }
diff --git a/src/MEGASync/google_breakpad/common/linux/google_crashdump_uploader.cc b/src/MEGASync/google_breakpad/common/linux/google_crashdump_uploader.cc
index b5f32c69..a0d940b6 100644
--- a/src/MEGASync/google_breakpad/common/linux/google_crashdump_uploader.cc
+++ b/src/MEGASync/google_breakpad/common/linux/google_crashdump_uploader.cc
@@ -29,7 +29,6 @@
 
 
 #include "common/linux/google_crashdump_uploader.h"
-#include "common/linux/libcurl_wrapper.h"
 
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -112,7 +111,7 @@ void GoogleCrashdumpUploader::Init(const string& product,
   ctime_ = ctime;
   email_ = email;
   comments_ = comments;
-  http_layer_ = http_layer;
+  http_layer_.reset(http_layer);
 
   crash_server_ = crash_server;
   proxy_host_ = proxy_host;
@@ -162,7 +161,9 @@ bool GoogleCrashdumpUploader::CheckRequiredParametersArePresent() {
 
 }
 
-bool GoogleCrashdumpUploader::Upload() {
+bool GoogleCrashdumpUploader::Upload(int* http_status_code,
+                                     string* http_response_header,
+                                     string* http_response_body) {
   bool ok = http_layer_->Init();
   if (!ok) {
     std::cout << "http layer init failed";
@@ -192,8 +193,15 @@ bool GoogleCrashdumpUploader::Upload() {
     return false;
   }
   std::cout << "Sending request to " << crash_server_;
-  return http_layer_->SendRequest(crash_server_,
-                                  parameters_,
-                                  NULL);
+  long status_code;
+  bool success = http_layer_->SendRequest(crash_server_,
+                                          parameters_,
+                                          &status_code,
+                                          http_response_header,
+                                          http_response_body);
+  if (http_status_code) {
+    *http_status_code = status_code;
+  }
+  return success;
 }
 }
diff --git a/src/MEGASync/google_breakpad/common/linux/google_crashdump_uploader.h b/src/MEGASync/google_breakpad/common/linux/google_crashdump_uploader.h
index 5eef28b3..a2d0575b 100644
--- a/src/MEGASync/google_breakpad/common/linux/google_crashdump_uploader.h
+++ b/src/MEGASync/google_breakpad/common/linux/google_crashdump_uploader.h
@@ -28,15 +28,18 @@
 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 
+#ifndef COMMON_LINUX_GOOGLE_CRASHDUMP_UPLOADER_H_
+#define COMMON_LINUX_GOOGLE_CRASHDUMP_UPLOADER_H_
+
 #include <string>
 #include <map>
 
+#include "common/linux/libcurl_wrapper.h"
+#include "common/scoped_ptr.h"
 #include "common/using_std_string.h"
 
 namespace google_breakpad {
 
-class LibcurlWrapper;
-
 class GoogleCrashdumpUploader {
  public:
   GoogleCrashdumpUploader(const string& product,
@@ -76,12 +79,14 @@ class GoogleCrashdumpUploader {
             const string& proxy_host,
             const string& proxy_userpassword,
             LibcurlWrapper* http_layer);
-  bool Upload();
+  bool Upload(int* http_status_code,
+              string* http_response_header,
+              string* http_response_body);
 
  private:
   bool CheckRequiredParametersArePresent();
 
-  LibcurlWrapper* http_layer_;
+  scoped_ptr<LibcurlWrapper> http_layer_;
   string product_;
   string version_;
   string guid_;
@@ -98,3 +103,5 @@ class GoogleCrashdumpUploader {
   std::map<string, string> parameters_;
 };
 }
+
+#endif  // COMMON_LINUX_GOOGLE_CRASHDUMP_UPLOADER_H_
diff --git a/src/MEGASync/google_breakpad/common/linux/google_crashdump_uploader_test.cc b/src/MEGASync/google_breakpad/common/linux/google_crashdump_uploader_test.cc
index 957874ad..3d6612e8 100644
--- a/src/MEGASync/google_breakpad/common/linux/google_crashdump_uploader_test.cc
+++ b/src/MEGASync/google_breakpad/common/linux/google_crashdump_uploader_test.cc
@@ -32,7 +32,6 @@
 #include <string>
 
 #include "common/linux/google_crashdump_uploader.h"
-#include "common/linux/libcurl_wrapper.h"
 #include "breakpad_googletest_includes.h"
 #include "common/using_std_string.h"
 
@@ -48,10 +47,12 @@ class MockLibcurlWrapper : public LibcurlWrapper {
                               const string& proxy_userpwd));
   MOCK_METHOD2(AddFile, bool(const string& upload_file_path,
                              const string& basename));
-  MOCK_METHOD3(SendRequest,
+  MOCK_METHOD5(SendRequest,
                bool(const string& url,
                     const std::map<string, string>& parameters,
-                    string* server_response));
+                    long* http_status_code,
+                    string* http_header_data,
+                    string* http_response_data));
 };
 
 class GoogleCrashdumpUploaderTest : public ::testing::Test {
@@ -72,7 +73,7 @@ TEST_F(GoogleCrashdumpUploaderTest, InitFailsCausesUploadFailure) {
                                                                   "",
                                                                   "",
                                                                   &m);
-  ASSERT_FALSE(uploader->Upload());
+  ASSERT_FALSE(uploader->Upload(NULL, NULL, NULL));
 }
 
 TEST_F(GoogleCrashdumpUploaderTest, TestSendRequestHappensWithValidParameters) {
@@ -86,7 +87,7 @@ TEST_F(GoogleCrashdumpUploaderTest, TestSendRequestHappensWithValidParameters) {
   EXPECT_CALL(m, Init()).Times(1).WillOnce(Return(true));
   EXPECT_CALL(m, AddFile(tempfn, _)).WillOnce(Return(true));
   EXPECT_CALL(m,
-              SendRequest("http://foo.com",_,_)).Times(1).WillOnce(Return(true));
+              SendRequest("http://foo.com",_,_,_,_)).Times(1).WillOnce(Return(true));
   GoogleCrashdumpUploader *uploader = new GoogleCrashdumpUploader("foobar",
                                                                   "1.0",
                                                                   "AAA-BBB",
@@ -99,14 +100,14 @@ TEST_F(GoogleCrashdumpUploaderTest, TestSendRequestHappensWithValidParameters) {
                                                                   "",
                                                                   "",
                                                                   &m);
-  ASSERT_TRUE(uploader->Upload());
+  ASSERT_TRUE(uploader->Upload(NULL, NULL, NULL));
 }
 
 
 TEST_F(GoogleCrashdumpUploaderTest, InvalidPathname) {
   MockLibcurlWrapper m;
   EXPECT_CALL(m, Init()).Times(1).WillOnce(Return(true));
-  EXPECT_CALL(m, SendRequest(_,_,_)).Times(0);
+  EXPECT_CALL(m, SendRequest(_,_,_,_,_)).Times(0);
   GoogleCrashdumpUploader *uploader = new GoogleCrashdumpUploader("foobar",
                                                                   "1.0",
                                                                   "AAA-BBB",
@@ -119,7 +120,7 @@ TEST_F(GoogleCrashdumpUploaderTest, InvalidPathname) {
                                                                   "",
                                                                   "",
                                                                   &m);
-  ASSERT_FALSE(uploader->Upload());
+  ASSERT_FALSE(uploader->Upload(NULL, NULL, NULL));
 }
 
 TEST_F(GoogleCrashdumpUploaderTest, TestRequiredParametersMustBePresent) {
@@ -135,7 +136,7 @@ TEST_F(GoogleCrashdumpUploaderTest, TestRequiredParametersMustBePresent) {
                                    "http://foo.com",
                                    "",
                                    "");
-  ASSERT_FALSE(uploader.Upload());
+  ASSERT_FALSE(uploader.Upload(NULL, NULL, NULL));
 
   // Test with empty product version.
   GoogleCrashdumpUploader uploader1("product",
@@ -150,7 +151,7 @@ TEST_F(GoogleCrashdumpUploaderTest, TestRequiredParametersMustBePresent) {
                                     "",
                                     "");
 
-  ASSERT_FALSE(uploader1.Upload());
+  ASSERT_FALSE(uploader1.Upload(NULL, NULL, NULL));
 
   // Test with empty client GUID.
   GoogleCrashdumpUploader uploader2("product",
@@ -164,6 +165,6 @@ TEST_F(GoogleCrashdumpUploaderTest, TestRequiredParametersMustBePresent) {
                                     "",
                                     "",
                                     "");
-  ASSERT_FALSE(uploader2.Upload());
+  ASSERT_FALSE(uploader2.Upload(NULL, NULL, NULL));
 }
 }
diff --git a/src/MEGASync/google_breakpad/common/linux/guid_creator.cc b/src/MEGASync/google_breakpad/common/linux/guid_creator.cc
index bfb308ee..63740638 100644
--- a/src/MEGASync/google_breakpad/common/linux/guid_creator.cc
+++ b/src/MEGASync/google_breakpad/common/linux/guid_creator.cc
@@ -27,15 +27,27 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "common/linux/eintr_wrapper.h"
 #include "common/linux/guid_creator.h"
 
 #include <assert.h>
+#include <fcntl.h>
 #include <pthread.h>
 #include <stdio.h>
 #include <stdlib.h>
+#include <string.h>
+#include <sys/stat.h>
 #include <time.h>
 #include <unistd.h>
 
+#if defined(HAVE_SYS_RANDOM_H)
+#include <sys/random.h>
+#endif
+
 //
 // GUIDGenerator
 //
@@ -61,28 +73,101 @@ class GUIDGenerator {
   }
 
   static bool CreateGUID(GUID *guid) {
-    InitOnce();
-    guid->data1 = random();
-    guid->data2 = (uint16_t)(random());
-    guid->data3 = (uint16_t)(random());
-    UInt32ToBytes(&guid->data4[0], random());
-    UInt32ToBytes(&guid->data4[4], random());
+#if defined(HAVE_ARC4RANDOM) // Android, BSD, ...
+    CreateGuidFromArc4Random(guid);
+#else // Linux
+    bool success = false;
+
+#if defined(HAVE_SYS_RANDOM_H) && defined(HAVE_GETRANDOM)
+    success = CreateGUIDFromGetrandom(guid);
+#endif // HAVE_SYS_RANDOM_H && HAVE_GETRANDOM
+    if (!success) {
+      success = CreateGUIDFromDevUrandom(guid);
+    }
+
+    if (!success) {
+      CreateGUIDFromRand(guid);
+      success = true;
+    }
+#endif
+
+    // Put in the version according to RFC 4122.
+    guid->data3 &= 0x0fff;
+    guid->data3 |= 0x4000;
+
+    // Put in the variant according to RFC 4122.
+    guid->data4[0] &= 0x3f;
+    guid->data4[0] |= 0x80;
+
     return true;
   }
 
  private:
+#ifdef HAVE_ARC4RANDOM
+  static void CreateGuidFromArc4Random(GUID *guid) {
+    char *buf = reinterpret_cast<char*>(guid);
+
+    for (size_t i = 0; i < sizeof(GUID); i += sizeof(uint32_t)) {
+      uint32_t random_data = arc4random();
+
+      memcpy(buf + i, &random_data, sizeof(uint32_t));
+    }
+  }
+#else
   static void InitOnce() {
     pthread_once(&once_control, &InitOnceImpl);
   }
 
   static void InitOnceImpl() {
-    srandom(time(NULL));
+    // time(NULL) is a very poor seed, so lacking anything better mix an
+    // address into it. We drop the four rightmost bits as they're likely to
+    // be 0 on almost all architectures.
+    srand(time(NULL) | ((uintptr_t)&once_control >> 4));
   }
 
   static pthread_once_t once_control;
+
+#if defined(HAVE_SYS_RANDOM_H) && defined(HAVE_GETRANDOM)
+  static bool CreateGUIDFromGetrandom(GUID *guid) {
+    char *buf = reinterpret_cast<char*>(guid);
+    int read_bytes = getrandom(buf, sizeof(GUID), GRND_NONBLOCK);
+
+    return (read_bytes == static_cast<int>(sizeof(GUID)));
+  }
+#endif // HAVE_SYS_RANDOM_H && HAVE_GETRANDOM
+
+  // Populate the GUID using random bytes read from /dev/urandom, returns false
+  // if the GUID wasn't fully populated with random data.
+  static bool CreateGUIDFromDevUrandom(GUID *guid) {
+    char *buf = reinterpret_cast<char*>(guid);
+    int fd = open("/dev/urandom", O_RDONLY | O_CLOEXEC);
+
+    if (fd == -1) {
+      return false;
+    }
+
+    ssize_t read_bytes = HANDLE_EINTR(read(fd, buf, sizeof(GUID)));
+    close(fd);
+
+    return (read_bytes == static_cast<ssize_t>(sizeof(GUID)));
+  }
+
+  // Populate the GUID using a stream of random bytes obtained from rand().
+  static void CreateGUIDFromRand(GUID *guid) {
+    char *buf = reinterpret_cast<char*>(guid);
+
+    InitOnce();
+
+    for (size_t i = 0; i < sizeof(GUID); i++) {
+      buf[i] = rand();
+    }
+  }
+#endif
 };
 
+#ifndef HAVE_ARC4RANDOM
 pthread_once_t GUIDGenerator::once_control = PTHREAD_ONCE_INIT;
+#endif
 
 bool CreateGUID(GUID *guid) {
   return GUIDGenerator::CreateGUID(guid);
diff --git a/src/MEGASync/google_breakpad/common/linux/http_upload.cc b/src/MEGASync/google_breakpad/common/linux/http_upload.cc
index fead76e9..ace12b84 100644
--- a/src/MEGASync/google_breakpad/common/linux/http_upload.cc
+++ b/src/MEGASync/google_breakpad/common/linux/http_upload.cc
@@ -36,14 +36,14 @@
 namespace {
 
 // Callback to get the response data from server.
-static size_t WriteCallback(void *ptr, size_t size,
-                            size_t nmemb, void *userp) {
+static size_t WriteCallback(void* ptr, size_t size,
+                            size_t nmemb, void* userp) {
   if (!userp)
     return 0;
 
-  string *response = reinterpret_cast<string *>(userp);
+  string* response = reinterpret_cast<string*>(userp);
   size_t real_size = size * nmemb;
-  response->append(reinterpret_cast<char *>(ptr), real_size);
+  response->append(reinterpret_cast<char*>(ptr), real_size);
   return real_size;
 }
 
@@ -54,23 +54,34 @@ namespace google_breakpad {
 static const char kUserAgent[] = "Breakpad/1.0 (Linux)";
 
 // static
-bool HTTPUpload::SendRequest(const string &url,
-                             const map<string, string> &parameters,
-                             const string &upload_file,
-                             const string &file_part_name,
-                             const string &proxy,
-                             const string &proxy_user_pwd,
-                             const string &ca_certificate_file,
-                             string *response_body,
-                             long *response_code,
-                             string *error_description) {
+bool HTTPUpload::SendRequest(const string& url,
+                             const map<string, string>& parameters,
+                             const map<string, string>& files,
+                             const string& proxy,
+                             const string& proxy_user_pwd,
+                             const string& ca_certificate_file,
+                             string* response_body,
+                             long* response_code,
+                             string* error_description) {
   if (response_code != NULL)
     *response_code = 0;
 
   if (!CheckParameters(parameters))
     return false;
 
-  void *curl_lib = dlopen("libcurl.so", RTLD_NOW);
+  // We may have been linked statically; if curl_easy_init is in the
+  // current binary, no need to search for a dynamic version.
+  void* curl_lib = dlopen(NULL, RTLD_NOW);
+  if (!CheckCurlLib(curl_lib)) {
+    fprintf(stderr,
+            "Failed to open curl lib from binary, use libcurl.so instead\n");
+    dlerror();  // Clear dlerror before attempting to open libraries.
+    dlclose(curl_lib);
+    curl_lib = NULL;
+  }
+  if (!curl_lib) {
+    curl_lib = dlopen("libcurl.so", RTLD_NOW);
+  }
   if (!curl_lib) {
     if (error_description != NULL)
       *error_description = dlerror();
@@ -90,7 +101,7 @@ bool HTTPUpload::SendRequest(const string &url,
 
   CURL* (*curl_easy_init)(void);
   *(void**) (&curl_easy_init) = dlsym(curl_lib, "curl_easy_init");
-  CURL *curl = (*curl_easy_init)();
+  CURL* curl = (*curl_easy_init)();
   if (error_description != NULL)
     *error_description = "No Error";
 
@@ -100,10 +111,14 @@ bool HTTPUpload::SendRequest(const string &url,
   }
 
   CURLcode err_code = CURLE_OK;
-  CURLcode (*curl_easy_setopt)(CURL *, CURLoption, ...);
+  CURLcode (*curl_easy_setopt)(CURL*, CURLoption, ...);
   *(void**) (&curl_easy_setopt) = dlsym(curl_lib, "curl_easy_setopt");
   (*curl_easy_setopt)(curl, CURLOPT_URL, url.c_str());
   (*curl_easy_setopt)(curl, CURLOPT_USERAGENT, kUserAgent);
+  // Support multithread by disabling timeout handling, would get SIGSEGV with
+  // Curl_resolv_timeout in stack trace otherwise.
+  // See https://curl.haxx.se/libcurl/c/threadsafe.html
+  (*curl_easy_setopt)(curl, CURLOPT_NOSIGNAL, 1);
   // Set proxy information if necessary.
   if (!proxy.empty())
     (*curl_easy_setopt)(curl, CURLOPT_PROXY, proxy.c_str());
@@ -113,10 +128,10 @@ bool HTTPUpload::SendRequest(const string &url,
   if (!ca_certificate_file.empty())
     (*curl_easy_setopt)(curl, CURLOPT_CAINFO, ca_certificate_file.c_str());
 
-  struct curl_httppost *formpost = NULL;
-  struct curl_httppost *lastptr = NULL;
+  struct curl_httppost* formpost = NULL;
+  struct curl_httppost* lastptr = NULL;
   // Add form data.
-  CURLFORMcode (*curl_formadd)(struct curl_httppost **, struct curl_httppost **, ...);
+  CURLFORMcode (*curl_formadd)(struct curl_httppost**, struct curl_httppost**, ...);
   *(void**) (&curl_formadd) = dlsym(curl_lib, "curl_formadd");
   map<string, string>::const_iterator iter = parameters.begin();
   for (; iter != parameters.end(); ++iter)
@@ -125,18 +140,20 @@ bool HTTPUpload::SendRequest(const string &url,
                  CURLFORM_COPYCONTENTS, iter->second.c_str(),
                  CURLFORM_END);
 
-  // Add form file.
-  (*curl_formadd)(&formpost, &lastptr,
-               CURLFORM_COPYNAME, file_part_name.c_str(),
-               CURLFORM_FILE, upload_file.c_str(),
-               CURLFORM_END);
+  // Add form files.
+  for (iter = files.begin(); iter != files.end(); ++iter) {
+    (*curl_formadd)(&formpost, &lastptr,
+                 CURLFORM_COPYNAME, iter->first.c_str(),
+                 CURLFORM_FILE, iter->second.c_str(),
+                 CURLFORM_END);
+  }
 
   (*curl_easy_setopt)(curl, CURLOPT_HTTPPOST, formpost);
 
   // Disable 100-continue header.
-  struct curl_slist *headerlist = NULL;
+  struct curl_slist* headerlist = NULL;
   char buf[] = "Expect:";
-  struct curl_slist* (*curl_slist_append)(struct curl_slist *, const char *);
+  struct curl_slist* (*curl_slist_append)(struct curl_slist*, const char*);
   *(void**) (&curl_slist_append) = dlsym(curl_lib, "curl_slist_append");
   headerlist = (*curl_slist_append)(headerlist, buf);
   (*curl_easy_setopt)(curl, CURLOPT_HTTPHEADER, headerlist);
@@ -144,17 +161,17 @@ bool HTTPUpload::SendRequest(const string &url,
   if (response_body != NULL) {
     (*curl_easy_setopt)(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
     (*curl_easy_setopt)(curl, CURLOPT_WRITEDATA,
-                     reinterpret_cast<void *>(response_body));
+                     reinterpret_cast<void*>(response_body));
   }
 
   // Fail if 400+ is returned from the web server.
   (*curl_easy_setopt)(curl, CURLOPT_FAILONERROR, 1);
 
-  CURLcode (*curl_easy_perform)(CURL *);
+  CURLcode (*curl_easy_perform)(CURL*);
   *(void**) (&curl_easy_perform) = dlsym(curl_lib, "curl_easy_perform");
   err_code = (*curl_easy_perform)(curl);
   if (response_code != NULL) {
-    CURLcode (*curl_easy_getinfo)(CURL *, CURLINFO, ...);
+    CURLcode (*curl_easy_getinfo)(CURL*, CURLINFO, ...);
     *(void**) (&curl_easy_getinfo) = dlsym(curl_lib, "curl_easy_getinfo");
     (*curl_easy_getinfo)(curl, CURLINFO_RESPONSE_CODE, response_code);
   }
@@ -169,16 +186,16 @@ bool HTTPUpload::SendRequest(const string &url,
   if (error_description != NULL)
     *error_description = (*curl_easy_strerror)(err_code);
 
-  void (*curl_easy_cleanup)(CURL *);
+  void (*curl_easy_cleanup)(CURL*);
   *(void**) (&curl_easy_cleanup) = dlsym(curl_lib, "curl_easy_cleanup");
   (*curl_easy_cleanup)(curl);
   if (formpost != NULL) {
-    void (*curl_formfree)(struct curl_httppost *);
+    void (*curl_formfree)(struct curl_httppost*);
     *(void**) (&curl_formfree) = dlsym(curl_lib, "curl_formfree");
     (*curl_formfree)(formpost);
   }
   if (headerlist != NULL) {
-    void (*curl_slist_free_all)(struct curl_slist *);
+    void (*curl_slist_free_all)(struct curl_slist*);
     *(void**) (&curl_slist_free_all) = dlsym(curl_lib, "curl_slist_free_all");
     (*curl_slist_free_all)(headerlist);
   }
@@ -187,10 +204,17 @@ bool HTTPUpload::SendRequest(const string &url,
 }
 
 // static
-bool HTTPUpload::CheckParameters(const map<string, string> &parameters) {
+bool HTTPUpload::CheckCurlLib(void* curl_lib) {
+  return curl_lib &&
+      dlsym(curl_lib, "curl_easy_init") &&
+      dlsym(curl_lib, "curl_easy_setopt");
+}
+
+// static
+bool HTTPUpload::CheckParameters(const map<string, string>& parameters) {
   for (map<string, string>::const_iterator pos = parameters.begin();
        pos != parameters.end(); ++pos) {
-    const string &str = pos->first;
+    const string& str = pos->first;
     if (str.size() == 0)
       return false;  // disallow empty parameter names
     for (unsigned int i = 0; i < str.size(); ++i) {
diff --git a/src/MEGASync/google_breakpad/common/linux/http_upload.h b/src/MEGASync/google_breakpad/common/linux/http_upload.h
index 6dd36ea0..13f3d56c 100644
--- a/src/MEGASync/google_breakpad/common/linux/http_upload.h
+++ b/src/MEGASync/google_breakpad/common/linux/http_upload.h
@@ -45,9 +45,9 @@ using std::map;
 
 class HTTPUpload {
  public:
-  // Sends the given set of parameters, along with the contents of
-  // upload_file, as a multipart POST request to the given URL.
-  // file_part_name contains the name of the file part of the request
+  // Sends the given sets of parameters and files as a multipart POST
+  // request to the given URL.
+  // Each key in |files| is the name of the file part of the request
   // (i.e. it corresponds to the name= attribute on an <input type="file">.
   // Parameter names must contain only printable ASCII characters,
   // and may not contain a quote (") character.
@@ -58,28 +58,30 @@ class HTTPUpload {
   // received (or 0 if the request failed before getting an HTTP response).
   // If the send fails, a description of the error will be
   // returned in error_description.
-  static bool SendRequest(const string &url,
-                          const map<string, string> &parameters,
-                          const string &upload_file,
-                          const string &file_part_name,
-                          const string &proxy,
-                          const string &proxy_user_pwd,
-                          const string &ca_certificate_file,
-                          string *response_body,
-                          long *response_code,
-                          string *error_description);
+  static bool SendRequest(const string& url,
+                          const map<string, string>& parameters,
+                          const map<string, string>& files,
+                          const string& proxy,
+                          const string& proxy_user_pwd,
+                          const string& ca_certificate_file,
+                          string* response_body,
+                          long* response_code,
+                          string* error_description);
 
  private:
   // Checks that the given list of parameters has only printable
   // ASCII characters in the parameter name, and does not contain
   // any quote (") characters.  Returns true if so.
-  static bool CheckParameters(const map<string, string> &parameters);
+  static bool CheckParameters(const map<string, string>& parameters);
+
+  // Checks the curl_lib parameter points to a valid curl lib.
+  static bool CheckCurlLib(void* curl_lib);
 
   // No instances of this class should be created.
   // Disallow all constructors, destructors, and operator=.
   HTTPUpload();
-  explicit HTTPUpload(const HTTPUpload &);
-  void operator=(const HTTPUpload &);
+  explicit HTTPUpload(const HTTPUpload&);
+  void operator=(const HTTPUpload&);
   ~HTTPUpload();
 };
 
diff --git a/src/MEGASync/google_breakpad/common/linux/ignore_ret.h b/src/MEGASync/google_breakpad/common/linux/ignore_ret.h
index f60384bb..efd274c2 100644
--- a/src/MEGASync/google_breakpad/common/linux/ignore_ret.h
+++ b/src/MEGASync/google_breakpad/common/linux/ignore_ret.h
@@ -35,6 +35,6 @@
 // the call fails, IGNORE_RET() can be used to mark the return code as ignored.
 // This avoids spurious compiler warnings.
 
-#define IGNORE_RET(x) do { if (x); } while (0)
+#define IGNORE_RET(x) do { if (x) {} } while (0)
 
 #endif  // COMMON_LINUX_IGNORE_RET_H_
diff --git a/src/MEGASync/google_breakpad/common/linux/libcurl_wrapper.cc b/src/MEGASync/google_breakpad/common/linux/libcurl_wrapper.cc
index 08307f02..fdb200f8 100644
--- a/src/MEGASync/google_breakpad/common/linux/libcurl_wrapper.cc
+++ b/src/MEGASync/google_breakpad/common/linux/libcurl_wrapper.cc
@@ -38,30 +38,24 @@
 namespace google_breakpad {
 LibcurlWrapper::LibcurlWrapper()
     : init_ok_(false),
-      formpost_(NULL),
-      lastptr_(NULL),
-      headerlist_(NULL) {
-  curl_lib_ = dlopen("libcurl.so", RTLD_NOW);
-  if (!curl_lib_) {
-    curl_lib_ = dlopen("libcurl.so.4", RTLD_NOW);
-  }
-  if (!curl_lib_) {
-    curl_lib_ = dlopen("libcurl.so.3", RTLD_NOW);
-  }
-  if (!curl_lib_) {
-    std::cout << "Could not find libcurl via dlopen";
-    return;
+      curl_lib_(nullptr),
+      last_curl_error_(""),
+      curl_(nullptr),
+      formpost_(nullptr),
+      lastptr_(nullptr),
+      headerlist_(nullptr) {}
+
+LibcurlWrapper::~LibcurlWrapper() {
+  if (init_ok_) {
+    (*easy_cleanup_)(curl_);
+    dlclose(curl_lib_);
   }
-  std::cout << "LibcurlWrapper init succeeded";
-  init_ok_ = true;
-  return;
 }
 
 bool LibcurlWrapper::SetProxy(const string& proxy_host,
                               const string& proxy_userpwd) {
-  if (!init_ok_) {
-    return false;
-  }
+  if (!CheckInit()) return false;
+
   // Set proxy information if necessary.
   if (!proxy_host.empty()) {
     (*easy_setopt_)(curl_, CURLOPT_PROXY, proxy_host.c_str());
@@ -81,9 +75,8 @@ bool LibcurlWrapper::SetProxy(const string& proxy_host,
 
 bool LibcurlWrapper::AddFile(const string& upload_file_path,
                              const string& basename) {
-  if (!init_ok_) {
-    return false;
-  }
+  if (!CheckInit()) return false;
+
   std::cout << "Adding " << upload_file_path << " to form upload.";
   // Add form file.
   (*formadd_)(&formpost_, &lastptr_,
@@ -95,21 +88,24 @@ bool LibcurlWrapper::AddFile(const string& upload_file_path,
 }
 
 // Callback to get the response data from server.
-static size_t WriteCallback(void *ptr, size_t size,
-                            size_t nmemb, void *userp) {
+static size_t WriteCallback(void* ptr, size_t size,
+                            size_t nmemb, void* userp) {
   if (!userp)
     return 0;
 
-  string *response = reinterpret_cast<string *>(userp);
+  string* response = reinterpret_cast<string*>(userp);
   size_t real_size = size * nmemb;
-  response->append(reinterpret_cast<char *>(ptr), real_size);
+  response->append(reinterpret_cast<char*>(ptr), real_size);
   return real_size;
 }
 
 bool LibcurlWrapper::SendRequest(const string& url,
                                  const std::map<string, string>& parameters,
-                                 string* server_response) {
-  (*easy_setopt_)(curl_, CURLOPT_URL, url.c_str());
+                                 long* http_status_code,
+                                 string* http_header_data,
+                                 string* http_response_data) {
+  if (!CheckInit()) return false;
+
   std::map<string, string>::const_iterator iter = parameters.begin();
   for (; iter != parameters.end(); ++iter)
     (*formadd_)(&formpost_, &lastptr_,
@@ -118,44 +114,91 @@ bool LibcurlWrapper::SendRequest(const string& url,
                 CURLFORM_END);
 
   (*easy_setopt_)(curl_, CURLOPT_HTTPPOST, formpost_);
-  if (server_response != NULL) {
-    (*easy_setopt_)(curl_, CURLOPT_WRITEFUNCTION, WriteCallback);
-    (*easy_setopt_)(curl_, CURLOPT_WRITEDATA,
-                     reinterpret_cast<void *>(server_response));
-  }
 
-  CURLcode err_code = CURLE_OK;
-  err_code = (*easy_perform_)(curl_);
-  easy_strerror_ = reinterpret_cast<const char* (*)(CURLcode)>
-                       (dlsym(curl_lib_, "curl_easy_strerror"));
+  return SendRequestInner(url, http_status_code, http_header_data,
+                          http_response_data);
+}
 
-#ifndef NDEBUG
-  if (err_code != CURLE_OK)
-    fprintf(stderr, "Failed to send http request to %s, error: %s\n",
-            url.c_str(),
-            (*easy_strerror_)(err_code));
-#endif
-  if (headerlist_ != NULL) {
-    (*slist_free_all_)(headerlist_);
-  }
+bool LibcurlWrapper::SendGetRequest(const string& url,
+                                    long* http_status_code,
+                                    string* http_header_data,
+                                    string* http_response_data) {
+  if (!CheckInit()) return false;
 
-  (*easy_cleanup_)(curl_);
-  if (formpost_ != NULL) {
-    (*formfree_)(formpost_);
+  (*easy_setopt_)(curl_, CURLOPT_HTTPGET, 1L);
+
+  return SendRequestInner(url, http_status_code, http_header_data,
+                          http_response_data);
+}
+
+bool LibcurlWrapper::SendPutRequest(const string& url,
+                                    const string& path,
+                                    long* http_status_code,
+                                    string* http_header_data,
+                                    string* http_response_data) {
+  if (!CheckInit()) return false;
+
+  FILE* file = fopen(path.c_str(), "rb");
+  (*easy_setopt_)(curl_, CURLOPT_UPLOAD, 1L);
+  (*easy_setopt_)(curl_, CURLOPT_PUT, 1L);
+  (*easy_setopt_)(curl_, CURLOPT_READDATA, file);
+
+  bool success = SendRequestInner(url, http_status_code, http_header_data,
+                                  http_response_data);
+
+  fclose(file);
+  return success;
+}
+
+bool LibcurlWrapper::SendSimplePostRequest(const string& url,
+                                           const string& body,
+                                           const string& content_type,
+                                           long* http_status_code,
+                                           string* http_header_data,
+                                           string* http_response_data) {
+  if (!CheckInit()) return false;
+
+  (*easy_setopt_)(curl_, CURLOPT_POSTFIELDSIZE, body.size());
+  (*easy_setopt_)(curl_, CURLOPT_COPYPOSTFIELDS, body.c_str());
+
+  if (!content_type.empty()) {
+    string content_type_header = "Content-Type: " + content_type;
+    headerlist_ = (*slist_append_)(
+        headerlist_,
+        content_type_header.c_str());
   }
 
-  return err_code == CURLE_OK;
+  return SendRequestInner(url, http_status_code, http_header_data,
+                          http_response_data);
 }
 
 bool LibcurlWrapper::Init() {
-  if (!init_ok_) {
-    std::cout << "Init_OK was not true in LibcurlWrapper::Init(), check earlier log messages";
+  // First check to see if libcurl was statically linked:
+  curl_lib_ = dlopen(nullptr, RTLD_NOW);
+  if (curl_lib_ &&
+      (!dlsym(curl_lib_, "curl_easy_init") ||
+      !dlsym(curl_lib_, "curl_easy_setopt"))) {
+    // Not statically linked, try again below.
+    dlerror();  // Clear dlerror before attempting to open libraries.
+    dlclose(curl_lib_);
+    curl_lib_ = nullptr;
+  }
+  if (!curl_lib_) {
+    curl_lib_ = dlopen("libcurl.so", RTLD_NOW);
+  }
+  if (!curl_lib_) {
+    curl_lib_ = dlopen("libcurl.so.4", RTLD_NOW);
+  }
+  if (!curl_lib_) {
+    curl_lib_ = dlopen("libcurl.so.3", RTLD_NOW);
+  }
+  if (!curl_lib_) {
+    std::cout << "Could not find libcurl via dlopen";
     return false;
   }
 
   if (!SetFunctionPointers()) {
     std::cout << "Could not find function pointers";
-    init_ok_ = false;
     return false;
   }
 
@@ -169,11 +212,7 @@ bool LibcurlWrapper::Init() {
     return false;
   }
 
-  // Disable 100-continue header.
-  char buf[] = "Expect:";
-
-  headerlist_ = (*slist_append_)(headerlist_, buf);
-  (*easy_setopt_)(curl_, CURLOPT_HTTPHEADER, headerlist_);
+  init_ok_ = true;
   return true;
 }
 
@@ -209,6 +248,14 @@ bool LibcurlWrapper::SetFunctionPointers() {
                                  "curl_easy_cleanup",
                                  void(*)(CURL*));
 
+  SET_AND_CHECK_FUNCTION_POINTER(easy_getinfo_,
+                                 "curl_easy_getinfo",
+                                 CURLcode(*)(CURL*, CURLINFO info, ...));
+
+  SET_AND_CHECK_FUNCTION_POINTER(easy_reset_,
+                                 "curl_easy_reset",
+                                 void(*)(CURL*));
+
   SET_AND_CHECK_FUNCTION_POINTER(slist_free_all_,
                                  "curl_slist_free_all",
                                  void(*)(curl_slist*));
@@ -219,4 +266,73 @@ bool LibcurlWrapper::SetFunctionPointers() {
   return true;
 }
 
+bool LibcurlWrapper::SendRequestInner(const string& url,
+                                      long* http_status_code,
+                                      string* http_header_data,
+                                      string* http_response_data) {
+  string url_copy(url);
+  (*easy_setopt_)(curl_, CURLOPT_URL, url_copy.c_str());
+
+  // Disable 100-continue header.
+  char buf[] = "Expect:";
+  headerlist_ = (*slist_append_)(headerlist_, buf);
+  (*easy_setopt_)(curl_, CURLOPT_HTTPHEADER, headerlist_);
+
+  if (http_response_data != nullptr) {
+    http_response_data->clear();
+    (*easy_setopt_)(curl_, CURLOPT_WRITEFUNCTION, WriteCallback);
+    (*easy_setopt_)(curl_, CURLOPT_WRITEDATA,
+                    reinterpret_cast<void*>(http_response_data));
+  }
+  if (http_header_data != nullptr) {
+    http_header_data->clear();
+    (*easy_setopt_)(curl_, CURLOPT_HEADERFUNCTION, WriteCallback);
+    (*easy_setopt_)(curl_, CURLOPT_HEADERDATA,
+                    reinterpret_cast<void*>(http_header_data));
+  }
+  CURLcode err_code = CURLE_OK;
+  err_code = (*easy_perform_)(curl_);
+  easy_strerror_ = reinterpret_cast<const char* (*)(CURLcode)>
+      (dlsym(curl_lib_, "curl_easy_strerror"));
+
+  if (http_status_code != nullptr) {
+    (*easy_getinfo_)(curl_, CURLINFO_RESPONSE_CODE, http_status_code);
+  }
+
+#ifndef NDEBUG
+  if (err_code != CURLE_OK)
+    fprintf(stderr, "Failed to send http request to %s, error: %s\n",
+            url.c_str(),
+            (*easy_strerror_)(err_code));
+#endif
+
+  Reset();
+
+  return err_code == CURLE_OK;
+}
+
+void LibcurlWrapper::Reset() {
+  if (headerlist_ != nullptr) {
+    (*slist_free_all_)(headerlist_);
+    headerlist_ = nullptr;
+  }
+
+  if (formpost_ != nullptr) {
+    (*formfree_)(formpost_);
+    formpost_ = nullptr;
+  }
+
+  (*easy_reset_)(curl_);
 }
+
+bool LibcurlWrapper::CheckInit() {
+  if (!init_ok_) {
+    std::cout << "LibcurlWrapper: You must call Init(), and have it return "
+                 "'true' before invoking any other methods.\n";
+    return false;
+  }
+
+  return true;
+}
+
+}  // namespace google_breakpad
diff --git a/src/MEGASync/google_breakpad/common/linux/libcurl_wrapper.h b/src/MEGASync/google_breakpad/common/linux/libcurl_wrapper.h
index 3b72b5e7..823f83c7 100644
--- a/src/MEGASync/google_breakpad/common/linux/libcurl_wrapper.h
+++ b/src/MEGASync/google_breakpad/common/linux/libcurl_wrapper.h
@@ -30,6 +30,9 @@
 // A wrapper for libcurl to do HTTP Uploads, to support easy mocking
 // and unit testing of the HTTPUpload class.
 
+#ifndef COMMON_LINUX_LIBCURL_WRAPPER_H_
+#define COMMON_LINUX_LIBCURL_WRAPPER_H_
+
 #include <string>
 #include <map>
 
@@ -40,6 +43,7 @@ namespace google_breakpad {
 class LibcurlWrapper {
  public:
   LibcurlWrapper();
+  virtual ~LibcurlWrapper();
   virtual bool Init();
   virtual bool SetProxy(const string& proxy_host,
                         const string& proxy_userpwd);
@@ -47,12 +51,39 @@ class LibcurlWrapper {
                        const string& basename);
   virtual bool SendRequest(const string& url,
                            const std::map<string, string>& parameters,
-                           string* server_response);
+                           long* http_status_code,
+                           string* http_header_data,
+                           string* http_response_data);
+  bool SendGetRequest(const string& url,
+                      long* http_status_code,
+                      string* http_header_data,
+                      string* http_response_data);
+  bool SendPutRequest(const string& url,
+                      const string& path,
+                      long* http_status_code,
+                      string* http_header_data,
+                      string* http_response_data);
+  bool SendSimplePostRequest(const string& url,
+                             const string& body,
+                             const string& content_type,
+                             long* http_status_code,
+                             string* http_header_data,
+                             string* http_response_data);
+
  private:
   // This function initializes class state corresponding to function
   // pointers into the CURL library.
   bool SetFunctionPointers();
 
+  bool SendRequestInner(const string& url,
+                        long* http_status_code,
+                        string* http_header_data,
+                        string* http_response_data);
+
+  void Reset();
+
+  bool CheckInit();
+
   bool init_ok_;                 // Whether init succeeded
   void* curl_lib_;               // Pointer to result of dlopen() on
                                  // curl library
@@ -60,25 +91,29 @@ class LibcurlWrapper {
                                  // dealing
   // with CURL.
 
-  CURL *curl_;                   // Pointer for handle for CURL calls.
+  CURL* curl_;                   // Pointer for handle for CURL calls.
 
   CURL* (*easy_init_)(void);
 
   // Stateful pointers for calling into curl_formadd()
-  struct curl_httppost *formpost_;
-  struct curl_httppost *lastptr_;
-  struct curl_slist *headerlist_;
+  struct curl_httppost* formpost_;
+  struct curl_httppost* lastptr_;
+  struct curl_slist* headerlist_;
 
   // Function pointers into CURL library
-  CURLcode (*easy_setopt_)(CURL *, CURLoption, ...);
-  CURLFORMcode (*formadd_)(struct curl_httppost **,
-                           struct curl_httppost **, ...);
-  struct curl_slist* (*slist_append_)(struct curl_slist *, const char *);
-  void (*slist_free_all_)(struct curl_slist *);
-  CURLcode (*easy_perform_)(CURL *);
+  CURLcode (*easy_setopt_)(CURL*, CURLoption, ...);
+  CURLFORMcode (*formadd_)(struct curl_httppost**,
+                           struct curl_httppost**, ...);
+  struct curl_slist* (*slist_append_)(struct curl_slist*, const char*);
+  void (*slist_free_all_)(struct curl_slist*);
+  CURLcode (*easy_perform_)(CURL*);
   const char* (*easy_strerror_)(CURLcode);
-  void (*easy_cleanup_)(CURL *);
-  void (*formfree_)(struct curl_httppost *);
+  void (*easy_cleanup_)(CURL*);
+  CURLcode (*easy_getinfo_)(CURL*, CURLINFO info, ...);
+  void (*easy_reset_)(CURL*);
+  void (*formfree_)(struct curl_httppost*);
 
 };
 }
+
+#endif  // COMMON_LINUX_LIBCURL_WRAPPER_H_
diff --git a/src/MEGASync/google_breakpad/common/linux/linux_libc_support.cc b/src/MEGASync/google_breakpad/common/linux/linux_libc_support.cc
index 08b0325e..dd292962 100644
--- a/src/MEGASync/google_breakpad/common/linux/linux_libc_support.cc
+++ b/src/MEGASync/google_breakpad/common/linux/linux_libc_support.cc
@@ -190,7 +190,7 @@ const char* my_read_decimal_ptr(uintptr_t* result, const char* s) {
 }
 
 void my_memset(void* ip, char c, size_t len) {
-  char* p = (char *) ip;
+  char* p = (char*) ip;
   while (len--)
     *p++ = c;
 }
diff --git a/src/MEGASync/google_breakpad/common/linux/memory_mapped_file.cc b/src/MEGASync/google_breakpad/common/linux/memory_mapped_file.cc
index 853cce57..99362945 100644
--- a/src/MEGASync/google_breakpad/common/linux/memory_mapped_file.cc
+++ b/src/MEGASync/google_breakpad/common/linux/memory_mapped_file.cc
@@ -46,15 +46,17 @@ namespace google_breakpad {
 
 MemoryMappedFile::MemoryMappedFile() {}
 
-MemoryMappedFile::MemoryMappedFile(const char* path) {
-  Map(path);
+MemoryMappedFile::MemoryMappedFile(const char* path, size_t offset) {
+  Map(path, offset);
 }
 
 MemoryMappedFile::~MemoryMappedFile() {
   Unmap();
 }
 
-bool MemoryMappedFile::Map(const char* path) {
+#include <unistd.h>
+
+bool MemoryMappedFile::Map(const char* path, size_t offset) {
   Unmap();
 
   int fd = sys_open(path, O_RDONLY, 0);
@@ -62,7 +64,9 @@ bool MemoryMappedFile::Map(const char* path) {
     return false;
   }
 
-#if defined(__x86_64__)
+#if defined(__x86_64__) || defined(__aarch64__) || \
+   (defined(__mips__) && _MIPS_SIM == _ABI64)
+
   struct kernel_stat st;
   if (sys_fstat(fd, &st) == -1 || st.st_size < 0) {
 #else
@@ -73,25 +77,24 @@ bool MemoryMappedFile::Map(const char* path) {
     return false;
   }
 
-  // If the file size is zero, simply use an empty MemoryRange and return
-  // true. Don't bother to call mmap() even though mmap() can handle an
-  // empty file on some platforms.
-  if (st.st_size == 0) {
+  // Strangely file size can be negative, but we check above that it is not.
+  size_t file_len = static_cast<size_t>(st.st_size);
+  // If the file does not extend beyond the offset, simply use an empty
+  // MemoryRange and return true. Don't bother to call mmap()
+  // even though mmap() can handle an empty file on some platforms.
+  if (offset >= file_len) {
     sys_close(fd);
     return true;
   }
 
-#if defined(__x86_64__)
-  void* data = sys_mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
-#else
-  void* data = sys_mmap2(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
-#endif
+  size_t content_len = file_len - offset;
+  void* data = sys_mmap(NULL, content_len, PROT_READ, MAP_PRIVATE, fd, offset);
   sys_close(fd);
   if (data == MAP_FAILED) {
     return false;
   }
 
-  content_.Set(data, st.st_size);
+  content_.Set(data, content_len);
   return true;
 }
 
diff --git a/src/MEGASync/google_breakpad/common/linux/memory_mapped_file.h b/src/MEGASync/google_breakpad/common/linux/memory_mapped_file.h
index 6abd5b0c..fa660cc9 100644
--- a/src/MEGASync/google_breakpad/common/linux/memory_mapped_file.h
+++ b/src/MEGASync/google_breakpad/common/linux/memory_mapped_file.h
@@ -33,6 +33,7 @@
 #ifndef COMMON_LINUX_MEMORY_MAPPED_FILE_H_
 #define COMMON_LINUX_MEMORY_MAPPED_FILE_H_
 
+#include <stddef.h>
 #include "common/basictypes.h"
 #include "common/memory_range.h"
 
@@ -47,7 +48,7 @@ class MemoryMappedFile {
 
   // Constructor that calls Map() to map a file at |path| into memory.
   // If Map() fails, the object behaves as if it is default constructed.
-  explicit MemoryMappedFile(const char* path);
+  MemoryMappedFile(const char* path, size_t offset);
 
   ~MemoryMappedFile();
 
@@ -56,7 +57,7 @@ class MemoryMappedFile {
   // success. Mapping an empty file will succeed but with data() and size()
   // returning NULL and 0, respectively. An existing mapping is unmapped
   // before a new mapping is created.
-  bool Map(const char* path);
+  bool Map(const char* path, size_t offset);
 
   // Unmaps the memory for the mapped file. It's a no-op if no file is
   // mapped.
diff --git a/src/MEGASync/google_breakpad/common/linux/memory_mapped_file_unittest.cc b/src/MEGASync/google_breakpad/common/linux/memory_mapped_file_unittest.cc
index 4fa50cf9..fad59f40 100644
--- a/src/MEGASync/google_breakpad/common/linux/memory_mapped_file_unittest.cc
+++ b/src/MEGASync/google_breakpad/common/linux/memory_mapped_file_unittest.cc
@@ -71,12 +71,12 @@ TEST_F(MemoryMappedFileTest, UnmapWithoutMap) {
 
 TEST_F(MemoryMappedFileTest, MapNonexistentFile) {
   {
-    MemoryMappedFile mapped_file("nonexistent-file");
+    MemoryMappedFile mapped_file("nonexistent-file", 0);
     ExpectNoMappedData(mapped_file);
   }
   {
     MemoryMappedFile mapped_file;
-    EXPECT_FALSE(mapped_file.Map("nonexistent-file"));
+    EXPECT_FALSE(mapped_file.Map("nonexistent-file", 0));
     ExpectNoMappedData(mapped_file);
   }
 }
@@ -87,12 +87,12 @@ TEST_F(MemoryMappedFileTest, MapEmptyFile) {
   ASSERT_TRUE(WriteFile(test_file.c_str(), NULL, 0));
 
   {
-    MemoryMappedFile mapped_file(test_file.c_str());
+    MemoryMappedFile mapped_file(test_file.c_str(), 0);
     ExpectNoMappedData(mapped_file);
   }
   {
     MemoryMappedFile mapped_file;
-    EXPECT_TRUE(mapped_file.Map(test_file.c_str()));
+    EXPECT_TRUE(mapped_file.Map(test_file.c_str(), 0));
     ExpectNoMappedData(mapped_file);
   }
 }
@@ -109,7 +109,7 @@ TEST_F(MemoryMappedFileTest, MapNonEmptyFile) {
   ASSERT_TRUE(WriteFile(test_file.c_str(), data, data_size));
 
   {
-    MemoryMappedFile mapped_file(test_file.c_str());
+    MemoryMappedFile mapped_file(test_file.c_str(), 0);
     EXPECT_FALSE(mapped_file.content().IsEmpty());
     EXPECT_TRUE(mapped_file.data() != NULL);
     EXPECT_EQ(data_size, mapped_file.size());
@@ -117,7 +117,7 @@ TEST_F(MemoryMappedFileTest, MapNonEmptyFile) {
   }
   {
     MemoryMappedFile mapped_file;
-    EXPECT_TRUE(mapped_file.Map(test_file.c_str()));
+    EXPECT_TRUE(mapped_file.Map(test_file.c_str(), 0));
     EXPECT_FALSE(mapped_file.content().IsEmpty());
     EXPECT_TRUE(mapped_file.data() != NULL);
     EXPECT_EQ(data_size, mapped_file.size());
@@ -145,13 +145,13 @@ TEST_F(MemoryMappedFileTest, RemapAfterMap) {
   ASSERT_TRUE(WriteFile(test_file2.c_str(), data2, data2_size));
 
   {
-    MemoryMappedFile mapped_file(test_file1.c_str());
+    MemoryMappedFile mapped_file(test_file1.c_str(), 0);
     EXPECT_FALSE(mapped_file.content().IsEmpty());
     EXPECT_TRUE(mapped_file.data() != NULL);
     EXPECT_EQ(data1_size, mapped_file.size());
     EXPECT_EQ(0, memcmp(data1, mapped_file.data(), data1_size));
 
-    mapped_file.Map(test_file2.c_str());
+    mapped_file.Map(test_file2.c_str(), 0);
     EXPECT_FALSE(mapped_file.content().IsEmpty());
     EXPECT_TRUE(mapped_file.data() != NULL);
     EXPECT_EQ(data2_size, mapped_file.size());
@@ -159,16 +159,50 @@ TEST_F(MemoryMappedFileTest, RemapAfterMap) {
   }
   {
     MemoryMappedFile mapped_file;
-    EXPECT_TRUE(mapped_file.Map(test_file1.c_str()));
+    EXPECT_TRUE(mapped_file.Map(test_file1.c_str(), 0));
     EXPECT_FALSE(mapped_file.content().IsEmpty());
     EXPECT_TRUE(mapped_file.data() != NULL);
     EXPECT_EQ(data1_size, mapped_file.size());
     EXPECT_EQ(0, memcmp(data1, mapped_file.data(), data1_size));
 
-    mapped_file.Map(test_file2.c_str());
+    mapped_file.Map(test_file2.c_str(), 0);
     EXPECT_FALSE(mapped_file.content().IsEmpty());
     EXPECT_TRUE(mapped_file.data() != NULL);
     EXPECT_EQ(data2_size, mapped_file.size());
     EXPECT_EQ(0, memcmp(data2, mapped_file.data(), data2_size));
   }
 }
+
+TEST_F(MemoryMappedFileTest, MapWithOffset) {
+  // Put more data in the test file this time. Offsets can only be
+  // done on page boundaries, so we need a two page file to test this.
+  const int page_size = 4096;
+  char data1[2 * page_size];
+  size_t data1_size = sizeof(data1);
+  for (size_t i = 0; i < data1_size; ++i) {
+    data1[i] = i & 0x7f;
+  }
+
+  AutoTempDir temp_dir;
+  string test_file1 = temp_dir.path() + "/test_file1";
+  ASSERT_TRUE(WriteFile(test_file1.c_str(), data1, data1_size));
+  {
+    MemoryMappedFile mapped_file(test_file1.c_str(), page_size);
+    EXPECT_FALSE(mapped_file.content().IsEmpty());
+    EXPECT_TRUE(mapped_file.data() != NULL);
+    EXPECT_EQ(data1_size - page_size, mapped_file.size());
+    EXPECT_EQ(
+        0,
+        memcmp(data1 + page_size, mapped_file.data(), data1_size - page_size));
+  }
+  {
+    MemoryMappedFile mapped_file;
+    mapped_file.Map(test_file1.c_str(), page_size);
+    EXPECT_FALSE(mapped_file.content().IsEmpty());
+    EXPECT_TRUE(mapped_file.data() != NULL);
+    EXPECT_EQ(data1_size - page_size, mapped_file.size());
+    EXPECT_EQ(
+        0,
+        memcmp(data1 + page_size, mapped_file.data(), data1_size - page_size));
+  }
+}
diff --git a/src/MEGASync/google_breakpad/common/linux/symbol_collector_client.cc b/src/MEGASync/google_breakpad/common/linux/symbol_collector_client.cc
new file mode 100644
index 00000000..92b25ddb
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/linux/symbol_collector_client.cc
@@ -0,0 +1,195 @@
+// Copyright (c) 2019 Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "common/linux/symbol_collector_client.h"
+
+#include <stdio.h>
+
+#include <iostream>
+#include <regex>
+
+#include "common/linux/libcurl_wrapper.h"
+
+namespace google_breakpad {
+namespace sym_upload {
+
+// static
+bool SymbolCollectorClient::CreateUploadUrl(
+    LibcurlWrapper* libcurl_wrapper,
+    const string& api_url,
+    const string& api_key,
+    UploadUrlResponse* uploadUrlResponse) {
+  string header, response;
+  long response_code;
+
+  string url = api_url + "/v1/uploads:create";
+  if (!api_key.empty()) {
+    url += "?key=" + api_key;
+  }
+
+  if (!libcurl_wrapper->SendSimplePostRequest(url,
+                                              /*body=*/"",
+                                              /*content_type=*/"",
+                                              &response_code,
+                                              &header,
+                                              &response)) {
+    printf("Failed to create upload url.\n");
+    printf("Response code: %ld\n", response_code);
+    printf("Response:\n");
+    printf("%s\n", response.c_str());
+    return false;
+  }
+
+  // Note camel-case rather than underscores.
+  std::regex upload_url_regex("\"uploadUrl\": \"([^\"]+)\"");
+  std::regex upload_key_regex("\"uploadKey\": \"([^\"]+)\"");
+
+  std::smatch upload_url_match;
+  if (!std::regex_search(response, upload_url_match, upload_url_regex) ||
+      upload_url_match.size() != 2) {
+    printf("Failed to parse create url response.");
+    printf("Response:\n");
+    printf("%s\n", response.c_str());
+    return false;
+  }
+  string upload_url = upload_url_match[1].str();
+
+  std::smatch upload_key_match;
+  if (!std::regex_search(response, upload_key_match, upload_key_regex) ||
+      upload_key_match.size() != 2) {
+    printf("Failed to parse create url response.");
+    printf("Response:\n");
+    printf("%s\n", response.c_str());
+    return false;
+  }
+  string upload_key = upload_key_match[1].str();
+
+  uploadUrlResponse->upload_url = upload_url;
+  uploadUrlResponse->upload_key = upload_key;
+  return true;
+}
+
+// static
+CompleteUploadResult SymbolCollectorClient::CompleteUpload(
+    LibcurlWrapper* libcurl_wrapper,
+    const string& api_url,
+    const string& api_key,
+    const string& upload_key,
+    const string& debug_file,
+    const string& debug_id,
+    const string& type) {
+  string header, response;
+  long response_code;
+
+  string url = api_url + "/v1/uploads/" + upload_key + ":complete";
+  if (!api_key.empty()) {
+    url += "?key=" + api_key;
+  }
+  string body =
+      "{ symbol_id: {"
+      "debug_file: \"" + debug_file + "\", "
+      "debug_id: \"" + debug_id + "\" }, "
+      "symbol_upload_type: \"" + type + "\" }";
+
+  if (!libcurl_wrapper->SendSimplePostRequest(url,
+                                              body,
+                                              "application/son",
+                                              &response_code,
+                                              &header,
+                                              &response)) {
+    printf("Failed to complete upload.\n");
+    printf("Response code: %ld\n", response_code);
+    printf("Response:\n");
+    printf("%s\n", response.c_str());
+    return CompleteUploadResult::Error;
+  }
+
+  std::regex result_regex("\"result\": \"([^\"]+)\"");
+  std::smatch result_match;
+  if (!std::regex_search(response, result_match, result_regex) ||
+      result_match.size() != 2) {
+    printf("Failed to parse complete upload response.");
+    printf("Response:\n");
+    printf("%s\n", response.c_str());
+    return CompleteUploadResult::Error;
+  }
+  string result = result_match[1].str();
+
+  if (result.compare("DUPLICATE_DATA") == 0) {
+    return CompleteUploadResult::DuplicateData;
+  }
+
+  return CompleteUploadResult::Ok;
+}
+
+// static
+SymbolStatus SymbolCollectorClient::CheckSymbolStatus(
+    LibcurlWrapper* libcurl_wrapper,
+    const string& api_url,
+    const string& api_key,
+    const string& debug_file,
+    const string& debug_id) {
+  string header, response;
+  long response_code;
+  string url = api_url +
+               "/v1/symbols/" + debug_file + "/" + debug_id + ":checkStatus";
+  if (!api_key.empty()) {
+    url += "?key=" + api_key;
+  }
+
+  if (!libcurl_wrapper->SendGetRequest(
+      url,
+      &response_code,
+      &header,
+      &response)) {
+    printf("Failed to check symbol status, error message.\n");
+    printf("Response code: %ld\n", response_code);
+    printf("Response:\n");
+    printf("%s\n", response.c_str());
+    return SymbolStatus::Unknown;
+  }
+
+  std::regex status_regex("\"status\": \"([^\"]+)\"");
+  std::smatch status_match;
+  if (!std::regex_search(response, status_match, status_regex) ||
+      status_match.size() != 2) {
+    printf("Failed to parse check symbol status response.");
+    printf("Response:\n");
+    printf("%s\n", response.c_str());
+    return SymbolStatus::Unknown;
+  }
+  string status = status_match[1].str();
+
+  return (status.compare("FOUND") == 0) ?
+      SymbolStatus::Found :
+      SymbolStatus::Missing;
+}
+
+}  // namespace sym_upload
+}  // namespace google_breakpad
diff --git a/src/MEGASync/google_breakpad/common/linux/symbol_collector_client.h b/src/MEGASync/google_breakpad/common/linux/symbol_collector_client.h
new file mode 100644
index 00000000..0e23242a
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/linux/symbol_collector_client.h
@@ -0,0 +1,88 @@
+// Copyright (c) 2019, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef COMMON_LINUX_SYMBOL_COLLECTOR_CLIENT_H_
+#define COMMON_LINUX_SYMBOL_COLLECTOR_CLIENT_H_
+
+#include <string>
+
+#include "common/linux/libcurl_wrapper.h"
+#include "common/using_std_string.h"
+
+namespace google_breakpad {
+namespace sym_upload {
+
+struct UploadUrlResponse {
+  string upload_url;
+  string upload_key;
+};
+
+enum SymbolStatus {
+  Found,
+  Missing,
+  Unknown
+};
+
+enum CompleteUploadResult {
+  Ok,
+  DuplicateData,
+  Error
+};
+
+// Helper class to communicate with a sym-upload-v2 service over HTTP/REST,
+// via libcurl.
+class SymbolCollectorClient {
+ public:
+  static bool CreateUploadUrl(
+      LibcurlWrapper* libcurl_wrapper,
+      const string& api_url,
+      const string& api_key,
+      UploadUrlResponse* uploadUrlResponse);
+
+  static CompleteUploadResult CompleteUpload(
+      LibcurlWrapper* libcurl_wrapper,
+      const string& api_url,
+      const string& api_key,
+      const string& upload_key,
+      const string& debug_file,
+      const string& debug_id,
+      const string& type);
+
+  static SymbolStatus CheckSymbolStatus(
+      LibcurlWrapper* libcurl_wrapper,
+      const string& api_url,
+      const string& api_key,
+      const string& debug_file,
+      const string& debug_id);
+};
+
+}  // namespace sym_upload
+}  // namespace google_breakpad
+
+#endif  // COMMON_LINUX_SYMBOL_COLLECTOR_CLIENT_H_
diff --git a/src/MEGASync/google_breakpad/common/linux/symbol_upload.cc b/src/MEGASync/google_breakpad/common/linux/symbol_upload.cc
new file mode 100644
index 00000000..1d5ff719
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/linux/symbol_upload.cc
@@ -0,0 +1,284 @@
+// Copyright (c) 2011 Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// symbol_upload.cc: implemented google_breakpad::sym_upload::Start, a helper
+// function for linux symbol upload tool.
+
+#include "common/linux/symbol_upload.h"
+
+#include <assert.h>
+#include <stdio.h>
+
+#include <functional>
+#include <iostream>
+#include <vector>
+
+#include "common/linux/http_upload.h"
+#include "common/linux/libcurl_wrapper.h"
+#include "common/linux/symbol_collector_client.h"
+
+namespace google_breakpad {
+namespace sym_upload {
+
+void TokenizeByChar(const string& source_string, int c,
+                    std::vector<string>* results) {
+  assert(results);
+  string::size_type cur_pos = 0, next_pos = 0;
+  while ((next_pos = source_string.find(c, cur_pos)) != string::npos) {
+    if (next_pos != cur_pos)
+      results->push_back(source_string.substr(cur_pos, next_pos - cur_pos));
+    cur_pos = next_pos + 1;
+  }
+  if (cur_pos < source_string.size() && next_pos != cur_pos)
+    results->push_back(source_string.substr(cur_pos));
+}
+
+//=============================================================================
+// Parse out the module line which have 5 parts.
+// MODULE <os> <cpu> <uuid> <module-name>
+bool ModuleDataForSymbolFile(const string& file,
+                             std::vector<string>* module_parts) {
+  assert(module_parts);
+  const size_t kModulePartNumber = 5;
+  FILE* fp = fopen(file.c_str(), "r");
+  if (fp) {
+    char buffer[1024];
+    if (fgets(buffer, sizeof(buffer), fp)) {
+      string line(buffer);
+      string::size_type line_break_pos = line.find_first_of('\n');
+      if (line_break_pos == string::npos) {
+        assert(0 && "The file is invalid!");
+        fclose(fp);
+        return false;
+      }
+      line.resize(line_break_pos);
+      const char kDelimiter = ' ';
+      TokenizeByChar(line, kDelimiter, module_parts);
+      if (module_parts->size() != kModulePartNumber)
+        module_parts->clear();
+    }
+    fclose(fp);
+  }
+
+  return module_parts->size() == kModulePartNumber;
+}
+
+//=============================================================================
+string CompactIdentifier(const string& uuid) {
+  std::vector<string> components;
+  TokenizeByChar(uuid, '-', &components);
+  string result;
+  for (size_t i = 0; i < components.size(); ++i)
+    result += components[i];
+  return result;
+}
+
+// |options| describes the current sym_upload options.
+// |module_parts| contains the strings parsed from the MODULE entry of the
+// Breakpad symbol file being uploaded.
+// |compacted_id| is the debug_id from the MODULE entry of the Breakpad symbol
+// file being uploaded, with all hyphens removed.
+bool SymUploadV1Start(
+    const Options& options,
+    std::vector<string> module_parts,
+    const string& compacted_id) {
+  std::map<string, string> parameters;
+  // Add parameters
+  if (!options.version.empty())
+    parameters["version"] = options.version;
+
+  // MODULE <os> <cpu> <uuid> <module-name>
+  // 0      1    2     3      4
+  parameters["os"] = module_parts[1];
+  parameters["cpu"] = module_parts[2];
+  parameters["debug_file"] = module_parts[4];
+  parameters["code_file"] = module_parts[4];
+  parameters["debug_identifier"] = compacted_id;
+
+  std::map<string, string> files;
+  files["symbol_file"] = options.symbolsPath;
+
+  string response, error;
+  long response_code;
+  bool success = HTTPUpload::SendRequest(options.uploadURLStr,
+                                         parameters,
+                                         files,
+                                         options.proxy,
+                                         options.proxy_user_pwd,
+                                         /*ca_certificate_file=*/"",
+                                         &response,
+                                         &response_code,
+                                         &error);
+
+  if (!success) {
+    printf("Failed to send symbol file: %s\n", error.c_str());
+    printf("Response code: %ld\n", response_code);
+    printf("Response:\n");
+    printf("%s\n", response.c_str());
+  } else if (response_code == 0) {
+    printf("Failed to send symbol file: No response code\n");
+  } else if (response_code != 200) {
+    printf("Failed to send symbol file: Response code %ld\n", response_code);
+    printf("Response:\n");
+    printf("%s\n", response.c_str());
+  } else {
+    printf("Successfully sent the symbol file.\n");
+  }
+
+  return success;
+}
+
+// |options| describes the current sym_upload options.
+// |code_id| is the basename of the module for which symbols are being
+// uploaded.
+// |debug_id| is the debug_id of the module for which symbols are being
+// uploaded.
+bool SymUploadV2Start(
+    const Options& options,
+    const string& code_file,
+    const string& debug_id,
+    const string& type) {
+  google_breakpad::LibcurlWrapper libcurl_wrapper;
+  if (!libcurl_wrapper.Init()) {
+    printf("Failed to init google_breakpad::LibcurlWrapper.\n");
+    return false;
+  }
+
+  if (!options.force) {
+    SymbolStatus symbolStatus = SymbolCollectorClient::CheckSymbolStatus(
+        &libcurl_wrapper,
+        options.uploadURLStr,
+        options.api_key,
+        code_file,
+        debug_id);
+    if (symbolStatus == SymbolStatus::Found) {
+      printf("Symbol file already exists, upload aborted."
+          " Use \"-f\" to overwrite.\n");
+      return true;
+    } else if (symbolStatus == SymbolStatus::Unknown) {
+      printf("Failed to check for existing symbol.\n");
+      return false;
+    }
+  }
+
+  UploadUrlResponse uploadUrlResponse;
+  if (!SymbolCollectorClient::CreateUploadUrl(
+      &libcurl_wrapper,
+      options.uploadURLStr,
+      options.api_key,
+      &uploadUrlResponse)) {
+    printf("Failed to create upload URL.\n");
+    return false;
+  }
+
+  string signed_url = uploadUrlResponse.upload_url;
+  string upload_key = uploadUrlResponse.upload_key;
+  string header;
+  string response;
+  long response_code;
+
+  if (!libcurl_wrapper.SendPutRequest(signed_url,
+                                      options.symbolsPath,
+                                      &response_code,
+                                      &header,
+                                      &response)) {
+    printf("Failed to send symbol file.\n");
+    printf("Response code: %ld\n", response_code);
+    printf("Response:\n");
+    printf("%s\n", response.c_str());
+    return false;
+  } else if (response_code == 0) {
+    printf("Failed to send symbol file: No response code\n");
+    return false;
+  } else if (response_code != 200) {
+    printf("Failed to send symbol file: Response code %ld\n", response_code);
+    printf("Response:\n");
+    printf("%s\n", response.c_str());
+    return false;
+  }
+
+  CompleteUploadResult completeUploadResult =
+      SymbolCollectorClient::CompleteUpload(&libcurl_wrapper,
+                                            options.uploadURLStr,
+                                            options.api_key,
+                                            upload_key,
+                                            code_file,
+                                            debug_id,
+                                            type);
+  if (completeUploadResult == CompleteUploadResult::Error) {
+    printf("Failed to complete upload.\n");
+    return false;
+  } else if (completeUploadResult == CompleteUploadResult::DuplicateData) {
+    printf("Uploaded file checksum matched existing file checksum,"
+      " no change necessary.\n");
+  } else {
+    printf("Successfully sent the symbol file.\n");
+  }
+
+  return true;
+}
+
+//=============================================================================
+void Start(Options* options) {
+  if (options->upload_protocol == UploadProtocol::SYM_UPLOAD_V2) {
+    string code_file;
+    string debug_id;
+    string type;
+
+    if (options->type.empty() || options->type == kBreakpadSymbolType) {
+      // Breakpad upload so read these from input file.
+      std::vector<string> module_parts;
+      if (!ModuleDataForSymbolFile(options->symbolsPath, &module_parts)) {
+        fprintf(stderr, "Failed to parse symbol file!\n");
+        return;
+      }
+      code_file = module_parts[4];
+      debug_id = CompactIdentifier(module_parts[3]);
+      type = kBreakpadSymbolType;
+    } else {
+      // Native upload so these must be explicitly set.
+      code_file = options->code_file;
+      debug_id = options->debug_id;
+      type = options->type;
+    }
+
+    options->success = SymUploadV2Start(*options, code_file, debug_id, type);
+  } else {
+    std::vector<string> module_parts;
+    if (!ModuleDataForSymbolFile(options->symbolsPath, &module_parts)) {
+      fprintf(stderr, "Failed to parse symbol file!\n");
+      return;
+    }
+    const string compacted_id = CompactIdentifier(module_parts[3]);
+    options->success = SymUploadV1Start(*options, module_parts, compacted_id);
+  }
+}
+
+}  // namespace sym_upload
+}  // namespace google_breakpad
diff --git a/src/MEGASync/google_breakpad/common/linux/symbol_upload.h b/src/MEGASync/google_breakpad/common/linux/symbol_upload.h
new file mode 100644
index 00000000..9033152b
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/linux/symbol_upload.h
@@ -0,0 +1,76 @@
+// -*- mode: c++ -*-
+
+// Copyright (c) 2011 Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// symbol_upload.h: helper functions for linux symbol upload tool.
+
+#ifndef COMMON_LINUX_SYMBOL_UPLOAD_H_
+#define COMMON_LINUX_SYMBOL_UPLOAD_H_
+
+#include <string>
+
+#include "common/using_std_string.h"
+
+namespace google_breakpad {
+namespace sym_upload {
+
+enum class UploadProtocol {
+  SYM_UPLOAD_V1,
+  SYM_UPLOAD_V2,
+};
+
+constexpr char kBreakpadSymbolType[] = "BREAKPAD";
+
+struct Options {
+  Options() : upload_protocol(UploadProtocol::SYM_UPLOAD_V1), force(false) {}
+
+  string symbolsPath;
+  string uploadURLStr;
+  string proxy;
+  string proxy_user_pwd;
+  string version;
+  bool success;
+  UploadProtocol upload_protocol;
+  bool force;
+  string api_key;
+
+  // These only need to be set for native symbol uploads.
+  string code_file;
+  string debug_id;
+  string type;
+};
+
+// Starts upload to symbol server with options.
+void Start(Options* options);
+
+}  // namespace sym_upload
+}  // namespace google_breakpad
+
+#endif  // COMMON_LINUX_SYMBOL_UPLOAD_H_
diff --git a/src/MEGASync/google_breakpad/common/linux/synth_elf.cc b/src/MEGASync/google_breakpad/common/linux/synth_elf.cc
index b978550f..2ba25e61 100644
--- a/src/MEGASync/google_breakpad/common/linux/synth_elf.cc
+++ b/src/MEGASync/google_breakpad/common/linux/synth_elf.cc
@@ -118,7 +118,7 @@ int ELF::AddSection(const string& name, const Section& section,
   return index;
 }
 
-void ELF::AppendSection(ElfSection &section) {
+void ELF::AppendSection(ElfSection& section) {
   // NULL and NOBITS sections have no content, so they
   // don't need to be written to the file.
   if (section.type_ == SHT_NULL) {
@@ -213,8 +213,10 @@ void ELF::Finish() {
 SymbolTable::SymbolTable(Endianness endianness,
                          size_t addr_size,
                          StringTable& table) : Section(endianness),
-                                               addr_size_(addr_size),
                                                table_(table) {
+#ifndef NDEBUG
+  addr_size_ = addr_size;
+#endif
   assert(addr_size_ == 4 || addr_size_ == 8);
 }
 
@@ -240,7 +242,7 @@ void SymbolTable::AddSymbol(const string& name, uint64_t value,
   D64(size);
 }
 
-void Notes::AddNote(int type, const string &name, const uint8_t* desc_bytes,
+void Notes::AddNote(int type, const string& name, const uint8_t* desc_bytes,
                     size_t desc_size) {
   // Elf32_Nhdr and Elf64_Nhdr are exactly the same.
   Elf32_Nhdr note_header;
diff --git a/src/MEGASync/google_breakpad/common/linux/synth_elf.h b/src/MEGASync/google_breakpad/common/linux/synth_elf.h
index 330ceae8..90fa28c0 100644
--- a/src/MEGASync/google_breakpad/common/linux/synth_elf.h
+++ b/src/MEGASync/google_breakpad/common/linux/synth_elf.h
@@ -154,7 +154,7 @@ class ELF : public Section {
 
   vector<ElfSection> sections_;
 
-  void AppendSection(ElfSection &section);
+  void AppendSection(ElfSection& section);
 };
 
 // A class to build .symtab or .dynsym sections.
@@ -173,7 +173,9 @@ class SymbolTable : public Section {
                  uint64_t size, unsigned info, uint16_t shndx);
 
  private:
+#ifndef NDEBUG
   size_t addr_size_;
+#endif
   StringTable& table_;
 };
 
@@ -185,7 +187,7 @@ public:
   }
 
   // Add a note.
-  void AddNote(int type, const string &name, const uint8_t* desc_bytes,
+  void AddNote(int type, const string& name, const uint8_t* desc_bytes,
                size_t desc_size);
 };
 
diff --git a/src/MEGASync/google_breakpad/common/linux/synth_elf_unittest.cc b/src/MEGASync/google_breakpad/common/linux/synth_elf_unittest.cc
index 3715b6e6..fb3601e6 100644
--- a/src/MEGASync/google_breakpad/common/linux/synth_elf_unittest.cc
+++ b/src/MEGASync/google_breakpad/common/linux/synth_elf_unittest.cc
@@ -193,7 +193,7 @@ class BasicElf : public Test {};
 
 typedef Types<ElfClass32, ElfClass64> ElfClasses;
 
-TYPED_TEST_CASE(BasicElf, ElfClasses);
+TYPED_TEST_SUITE(BasicElf, ElfClasses);
 
 TYPED_TEST(BasicElf, EmptyLE) {
   typedef typename TypeParam::Ehdr Ehdr;
@@ -381,9 +381,9 @@ TEST_F(ElfNotesTest, Empty) {
 
 TEST_F(ElfNotesTest, Notes) {
   Notes notes(kLittleEndian);
-  notes.AddNote(1, "Linux", reinterpret_cast<const uint8_t *>("\x42\x02\0\0"),
+  notes.AddNote(1, "Linux", reinterpret_cast<const uint8_t*>("\x42\x02\0\0"),
                 4);
-  notes.AddNote(2, "a", reinterpret_cast<const uint8_t *>("foobar"),
+  notes.AddNote(2, "a", reinterpret_cast<const uint8_t*>("foobar"),
                 sizeof("foobar") - 1);
 
   const uint8_t kExpectedNotesContents[] = {
diff --git a/src/MEGASync/google_breakpad/common/linux/tests/crash_generator.cc b/src/MEGASync/google_breakpad/common/linux/tests/crash_generator.cc
index 9262c323..a70df28a 100644
--- a/src/MEGASync/google_breakpad/common/linux/tests/crash_generator.cc
+++ b/src/MEGASync/google_breakpad/common/linux/tests/crash_generator.cc
@@ -33,6 +33,7 @@
 #include "common/linux/tests/crash_generator.h"
 
 #include <pthread.h>
+#include <sched.h>
 #include <signal.h>
 #include <stdio.h>
 #include <sys/mman.h>
@@ -65,19 +66,30 @@ const char* const kProcFilesToCopy[] = {
 const size_t kNumProcFilesToCopy =
     sizeof(kProcFilesToCopy) / sizeof(kProcFilesToCopy[0]);
 
+int gettid() {
+  // Glibc does not provide a wrapper for this.
+  return syscall(__NR_gettid);
+}
+
+int tkill(pid_t tid, int sig) {
+  // Glibc does not provide a wrapper for this.
+  return syscall(__NR_tkill, tid, sig);
+}
+
 // Core file size limit set to 1 MB, which is big enough for test purposes.
 const rlim_t kCoreSizeLimit = 1024 * 1024;
 
-void *thread_function(void *data) {
+void* thread_function(void* data) {
   ThreadData* thread_data = reinterpret_cast<ThreadData*>(data);
-  volatile pid_t thread_id = syscall(__NR_gettid);
+  volatile pid_t thread_id = gettid();
   *(thread_data->thread_id_ptr) = thread_id;
   int result = pthread_barrier_wait(thread_data->barrier);
   if (result != 0 && result != PTHREAD_BARRIER_SERIAL_THREAD) {
+    perror("Failed to wait for sync barrier");
     exit(1);
   }
   while (true) {
-    pthread_yield();
+    sched_yield();
   }
 }
 
@@ -160,14 +172,25 @@ bool CrashGenerator::SetCoreFileSizeLimit(rlim_t limit) const {
 bool CrashGenerator::CreateChildCrash(
     unsigned num_threads, unsigned crash_thread, int crash_signal,
     pid_t* child_pid) {
-  if (num_threads == 0 || crash_thread >= num_threads)
+  if (num_threads == 0 || crash_thread >= num_threads) {
+    fprintf(stderr, "CrashGenerator: Invalid thread counts; num_threads=%u"
+                    " crash_thread=%u\n", num_threads, crash_thread);
     return false;
+  }
 
-  if (!MapSharedMemory(num_threads * sizeof(pid_t)))
+  if (!MapSharedMemory(num_threads * sizeof(pid_t))) {
+    perror("CrashGenerator: Unable to map shared memory");
     return false;
+  }
 
   pid_t pid = fork();
   if (pid == 0) {
+    // Custom signal handlers, which may have been installed by a test launcher,
+    // are undesirable in this child.
+    if (signal(crash_signal, SIG_DFL) == SIG_ERR) {
+      perror("CrashGenerator: signal");
+      exit(1);
+    }
     if (chdir(temp_dir_.path().c_str()) == -1) {
       perror("CrashGenerator: Failed to change directory");
       exit(1);
@@ -183,9 +206,35 @@ bool CrashGenerator::CreateChildCrash(
         fprintf(stderr, "CrashGenerator: Failed to copy proc files\n");
         exit(1);
       }
-      if (kill(*GetThreadIdPointer(crash_thread), crash_signal) == -1) {
-        perror("CrashGenerator: Failed to kill thread by signal");
+      // On Android the signal sometimes doesn't seem to get sent even though
+      // tkill returns '0'.  Retry a couple of times if the signal doesn't get
+      // through on the first go:
+      // https://bugs.chromium.org/p/google-breakpad/issues/detail?id=579
+#if defined(__ANDROID__)
+      const int kRetries = 60;
+      const unsigned int kSleepTimeInSeconds = 1;
+#else
+      const int kRetries = 1;
+      const unsigned int kSleepTimeInSeconds = 600;
+#endif
+      for (int i = 0; i < kRetries; i++) {
+        if (tkill(*GetThreadIdPointer(crash_thread), crash_signal) == -1) {
+          perror("CrashGenerator: Failed to kill thread by signal");
+        } else {
+          // At this point, we've queued the signal for delivery, but there's no
+          // guarantee when it'll be delivered.  We don't want the main thread to
+          // race and exit before the thread we signaled is processed.  So sleep
+          // long enough that we won't flake even under fairly high load.
+          // TODO: See if we can't be a bit more deterministic.  There doesn't
+          // seem to be an API to check on signal delivery status, so we can't
+          // really poll and wait for the kernel to declare the signal has been
+          // delivered.  If it has, and things worked, we'd be killed, so the
+          // sleep length doesn't really matter.
+          sleep(kSleepTimeInSeconds);
+        }
       }
+    } else {
+      perror("CrashGenerator: Failed to set core limit");
     }
     exit(1);
   } else if (pid == -1) {
@@ -200,8 +249,8 @@ bool CrashGenerator::CreateChildCrash(
   }
   if (!WIFSIGNALED(status) || WTERMSIG(status) != crash_signal) {
     fprintf(stderr, "CrashGenerator: Child process not killed by the expected signal\n"
-                    "  exit status=0x%x signaled=%s sig=%d expected=%d\n",
-                    status, WIFSIGNALED(status) ? "true" : "false",
+                    "  exit status=0x%x pid=%u signaled=%s sig=%d expected=%d\n",
+                    status, pid, WIFSIGNALED(status) ? "true" : "false",
                     WTERMSIG(status), crash_signal);
     return false;
   }
diff --git a/src/MEGASync/google_breakpad/common/android/ucontext_constants.h b/src/MEGASync/google_breakpad/common/linux/ucontext_constants.h
similarity index 63%
rename from src/MEGASync/google_breakpad/common/android/ucontext_constants.h
rename to src/MEGASync/google_breakpad/common/linux/ucontext_constants.h
index c99c51fa..c390508a 100644
--- a/src/MEGASync/google_breakpad/common/android/ucontext_constants.h
+++ b/src/MEGASync/google_breakpad/common/linux/ucontext_constants.h
@@ -31,20 +31,43 @@
 // Its purpose is to contain constants that must match the offsets of
 // various fields in ucontext_t.
 //
-// They should match the definitions from
-// src/common/android/include/sys/ucontext.h
+// They should match the definitions from signal.h.
 //
-// Used by src/common/android/breakpad_getcontext.S
-// Tested by src/common/android/testing/breakpad_getcontext_unittest.cc
+// Used by src/common/linux/breakpad_getcontext.S
+// Tested by src/common/linux/breakpad_getcontext_unittest.cc
+//
+// This header should not be used by anything else.
 
-#ifndef GOOGLEBREAKPAD_COMMON_ANDROID_UCONTEXT_CONSTANTS_H
-#define GOOGLEBREAKPAD_COMMON_ANDROID_UCONTEXT_CONSTANTS_H
+#ifndef GOOGLEBREAKPAD_COMMON_LINUX_UCONTEXT_CONSTANTS_H
+#define GOOGLEBREAKPAD_COMMON_LINUX_UCONTEXT_CONSTANTS_H
 
 #if defined(__arm__)
 
 #define  MCONTEXT_GREGS_OFFSET     32
 #define  UCONTEXT_SIGMASK_OFFSET   104
 
+#elif defined(__aarch64__)
+
+#define  UCONTEXT_SIGMASK_OFFSET     40
+
+#define  MCONTEXT_GREGS_OFFSET       184
+#define  MCONTEXT_SP_OFFSET          432
+#define  MCONTEXT_PC_OFFSET          440
+#define  MCONTEXT_PSTATE_OFFSET      448
+#define  MCONTEXT_EXTENSION_OFFSET   464
+
+#define  FPSIMD_MAGIC                0x46508001
+
+#define  FPSIMD_CONTEXT_MAGIC_OFFSET 0
+#define  FPSIMD_CONTEXT_SIZE_OFFSET  4
+#define  FPSIMD_CONTEXT_FPSR_OFFSET  8
+#define  FPSIMD_CONTEXT_FPCR_OFFSET  12
+#define  FPSIMD_CONTEXT_VREGS_OFFSET 16
+#define  FPSIMD_CONTEXT_SIZE         528
+
+#define  REGISTER_SIZE               8
+#define  SIMD_REGISTER_SIZE          16
+
 #elif defined(__i386__)
 
 #define  MCONTEXT_GREGS_OFFSET     20
@@ -71,15 +94,57 @@
 #define  UCONTEXT_SIGMASK_OFFSET   108
 
 #define  UCONTEXT_FPREGS_OFFSET       96
+#if defined(__BIONIC__)
 #define  UCONTEXT_FPREGS_MEM_OFFSET   116
+#else
+#define  UCONTEXT_FPREGS_MEM_OFFSET   236
+#endif
 
 #elif defined(__mips__)
 
+#if _MIPS_SIM == _ABIO32
 #define  MCONTEXT_PC_OFFSET        32
 #define  MCONTEXT_GREGS_OFFSET     40
 #define  MCONTEXT_FPREGS_OFFSET    296
 #define  MCONTEXT_FPC_CSR          556
 #define  UCONTEXT_SIGMASK_OFFSET   616
+#else
+#define  MCONTEXT_GREGS_OFFSET     40
+#define  MCONTEXT_FPREGS_OFFSET    296
+#define  MCONTEXT_PC_OFFSET        616
+#define  MCONTEXT_FPC_CSR          624
+#define  UCONTEXT_SIGMASK_OFFSET   640
+#endif
+
+#elif defined(__x86_64__)
+
+#define MCONTEXT_GREGS_OFFSET     40
+#define UCONTEXT_SIGMASK_OFFSET   296
+
+#define MCONTEXT_GREGS_R8    40
+#define MCONTEXT_GREGS_R9    48
+#define MCONTEXT_GREGS_R10   56
+#define MCONTEXT_GREGS_R11   64
+#define MCONTEXT_GREGS_R12   72
+#define MCONTEXT_GREGS_R13   80
+#define MCONTEXT_GREGS_R14   88
+#define MCONTEXT_GREGS_R15   96
+#define MCONTEXT_GREGS_RDI   104
+#define MCONTEXT_GREGS_RSI   112
+#define MCONTEXT_GREGS_RBP   120
+#define MCONTEXT_GREGS_RBX   128
+#define MCONTEXT_GREGS_RDX   136
+#define MCONTEXT_GREGS_RAX   144
+#define MCONTEXT_GREGS_RCX   152
+#define MCONTEXT_GREGS_RSP   160
+#define MCONTEXT_GREGS_RIP   168
+#define MCONTEXT_FPREGS_PTR  224
+#if defined(__BIONIC__)
+#define MCONTEXT_FPREGS_MEM  304
+#else
+#define MCONTEXT_FPREGS_MEM  424
+#endif
+#define FPREGS_OFFSET_MXCSR  24
 
 #else
 #error "This header has not been ported for your CPU"
diff --git a/src/MEGASync/google_breakpad/common/long_string_dictionary.cc b/src/MEGASync/google_breakpad/common/long_string_dictionary.cc
new file mode 100644
index 00000000..46bbf613
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/long_string_dictionary.cc
@@ -0,0 +1,178 @@
+// Copyright (c) 2017, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "common/long_string_dictionary.h"
+
+#include <assert.h>
+#include <string.h>
+
+#include <algorithm>
+#include <string>
+
+#include "common/simple_string_dictionary.h"
+
+#define arraysize(f) (sizeof(f) / sizeof(*f))
+
+namespace {
+// Suffixes for segment keys.
+const char* const kSuffixes[] = {"__1", "__2", "__3", "__4", "__5", "__6",
+    "__7", "__8", "__9", "__10"};
+#if !defined(NDEBUG)
+// The maximum suffix string length.
+const size_t kMaxSuffixLength = 4;
+#endif
+} // namespace
+
+namespace google_breakpad {
+
+using std::string;
+
+void LongStringDictionary::SetKeyValue(const char* key, const char* value) {
+  assert(key);
+  if (!key)
+    return;
+
+  RemoveKey(key);
+
+  if (!value) {
+    return;
+  }
+
+  // Key must not be an empty string.
+  assert(key[0] != '\0');
+  if (key[0] == '\0')
+    return;
+
+  // If the value is not valid for segmentation, forwards the key and the value
+  // to SetKeyValue of SimpleStringDictionary and returns.
+  size_t value_length = strlen(value);
+  if (value_length <= (value_size - 1)) {
+    SimpleStringDictionary::SetKeyValue(key, value);
+    return;
+  }
+
+  size_t key_length = strlen(key);
+  assert(key_length + kMaxSuffixLength <= (key_size - 1));
+
+  char segment_key[key_size];
+  char segment_value[value_size];
+
+  strcpy(segment_key, key);
+
+  const char* remain_value = value;
+  size_t remain_value_length = strlen(value);
+
+  for (unsigned long i = 0; i < arraysize(kSuffixes); i++) {
+    if (remain_value_length == 0) {
+      return;
+    }
+
+    strcpy(segment_key + key_length, kSuffixes[i]);
+
+    size_t segment_value_length =
+        std::min(remain_value_length, value_size - 1);
+
+    strncpy(segment_value, remain_value, segment_value_length);
+    segment_value[segment_value_length] = '\0';
+
+    remain_value += segment_value_length;
+    remain_value_length -= segment_value_length;
+
+    SimpleStringDictionary::SetKeyValue(segment_key, segment_value);
+  }
+}
+
+bool LongStringDictionary::RemoveKey(const char* key) {
+  assert(key);
+  if (!key)
+    return false;
+
+  if (SimpleStringDictionary::RemoveKey(key)) {
+    return true;
+  }
+
+  size_t key_length = strlen(key);
+  assert(key_length + kMaxSuffixLength <= (key_size - 1));
+
+  char segment_key[key_size];
+  strcpy(segment_key, key);
+
+  unsigned long i = 0;
+  for (; i < arraysize(kSuffixes); i++) {
+    strcpy(segment_key + key_length, kSuffixes[i]);
+    if (!SimpleStringDictionary::RemoveKey(segment_key)) {
+      break;
+    }
+  }
+  return i != 0;
+}
+
+const string LongStringDictionary::GetValueForKey(const char* key) const {
+  assert(key);
+  if (!key)
+    return "";
+
+  // Key must not be an empty string.
+  assert(key[0] != '\0');
+  if (key[0] == '\0')
+    return "";
+
+  const char* value = SimpleStringDictionary::GetValueForKey(key);
+  if (value)
+    return string(value);
+
+  size_t key_length = strlen(key);
+  assert(key_length + kMaxSuffixLength <= (key_size - 1));
+
+  bool found_segment = false;
+  char segment_key[key_size];
+  string return_value;
+
+  strcpy(segment_key, key);
+  for (unsigned long i = 0; i < arraysize(kSuffixes); i++) {
+    strcpy(segment_key + key_length, kSuffixes[i]);
+
+    const char* segment_value =
+        SimpleStringDictionary::GetValueForKey(segment_key);
+
+    if (segment_value != NULL) {
+      found_segment = true;
+      return_value.append(segment_value);
+    } else {
+      break;
+    }
+  }
+
+  if (found_segment) {
+    return return_value;
+  }
+  return "";
+}
+
+}  // namespace google_breakpad
diff --git a/src/MEGASync/google_breakpad/common/long_string_dictionary.h b/src/MEGASync/google_breakpad/common/long_string_dictionary.h
new file mode 100644
index 00000000..68bf03de
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/long_string_dictionary.h
@@ -0,0 +1,87 @@
+// Copyright (c) 2017, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef COMMON_LONG_STRING_DICTIONARY_H_
+#define COMMON_LONG_STRING_DICTIONARY_H_
+
+#include <string>
+
+#include "common/simple_string_dictionary.h"
+
+namespace google_breakpad {
+// key_size is the maxium size that |key| can take in
+// SimpleStringDictionary which is defined in simple_string_dictionary.h.
+//
+// value_size is the maxium size that |value| can take in
+// SimpleStringDictionary which is defined in simple_string_dictionary.h.
+//
+// LongStringDictionary is a subclass of SimpleStringDictionary which supports
+// longer values to be stored in the dictionary. The maximum length supported is
+// (value_size - 1) * 10.
+//
+// For example, LongStringDictionary will store long value with key 'abc' into
+// segment values with segment keys 'abc__1', 'abc__2', 'abc__3', ...
+//
+// Clients must avoid using the same suffixes as their key's suffix when
+// LongStringDictionary is used.
+class LongStringDictionary : public SimpleStringDictionary {
+ public:
+  // Stores |value| into |key|, or segment values into segment keys. The maxium
+  // number of segments is 10. If |value| can not be stored in 10 segments, it
+  // will be truncated. Replacing the existing value if |key| is already present
+  // and replacing the existing segment values if segment keys are already
+  // present.
+  //
+  // |key| must not be NULL. If the |value| need to be divided into segments,
+  // the lengh of |key| must be smaller enough so that lengths of segment keys
+  // which are key with suffixes are all samller than (key_size - 1). Currently,
+  // the max length of suffixes are 4.
+  //
+  // If |value| is NULL, the key and its corresponding segment keys are removed
+  // from the map. If there is no more space in the map, then the operation
+  // silently fails.
+  void SetKeyValue(const char* key, const char* value);
+
+  // Given |key|, removes any associated value or associated segment values.
+  // |key| must not be NULL. If the key is not found, searchs its segment keys
+  // and removes corresponding segment values if found.
+  bool RemoveKey(const char* key);
+
+  // Given |key|, returns its corresponding |value|. |key| must not be NULL. If
+  // the key is found, its corresponding |value| is returned.
+  //
+  // If no corresponding |value| is found, segment keys of the given |key| will
+  // be used to search for corresponding segment values. If segment values
+  // exist, assembled value from them is returned. If no segment value exists,
+  // NULL is returned.
+  const std::string GetValueForKey(const char* key) const;
+};
+} // namespace google_breakpad
+
+#endif // COMMON_LONG_STRING_DICTIONARY_H_
diff --git a/src/MEGASync/google_breakpad/common/long_string_dictionary_unittest.cc b/src/MEGASync/google_breakpad/common/long_string_dictionary_unittest.cc
new file mode 100644
index 00000000..f9b645ba
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/long_string_dictionary_unittest.cc
@@ -0,0 +1,301 @@
+// Copyright (c) 2017, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include <algorithm>
+#include <string>
+
+#include "breakpad_googletest_includes.h"
+#include "common/long_string_dictionary.h"
+
+namespace google_breakpad {
+
+using std::string;
+
+TEST(LongStringDictionary, LongStringDictionary) {
+  // Make a new dictionary
+  LongStringDictionary dict;
+
+  // Set three distinct values on three keys
+  dict.SetKeyValue("key1", "value1");
+  dict.SetKeyValue("key2", "value2");
+  dict.SetKeyValue("key3", "value3");
+
+  EXPECT_EQ("value1", dict.GetValueForKey("key1"));
+  EXPECT_EQ("value2", dict.GetValueForKey("key2"));
+  EXPECT_EQ("value3", dict.GetValueForKey("key3"));
+  EXPECT_EQ(3u, dict.GetCount());
+  // try an unknown key
+  EXPECT_EQ("", dict.GetValueForKey("key4"));
+
+  // Remove a key
+  dict.RemoveKey("key3");
+
+  // Now make sure it's not there anymore
+  EXPECT_EQ("", dict.GetValueForKey("key3"));
+
+  // Remove by setting value to NULL
+  dict.SetKeyValue("key2", NULL);
+
+  // Now make sure it's not there anymore
+  EXPECT_EQ("", dict.GetValueForKey("key2"));
+}
+
+// Add a bunch of values to the dictionary, remove some entries in the middle,
+// and then add more.
+TEST(LongStringDictionary, Iterator) {
+  LongStringDictionary* dict = new LongStringDictionary();
+  ASSERT_TRUE(dict);
+
+  char key[LongStringDictionary::key_size];
+  char value[LongStringDictionary::value_size];
+
+  const int kDictionaryCapacity = LongStringDictionary::num_entries;
+  const int kPartitionIndex = kDictionaryCapacity - 5;
+
+  // We assume at least this size in the tests below
+  ASSERT_GE(kDictionaryCapacity, 64);
+
+  // We'll keep track of the number of key/value pairs we think should
+  // be in the dictionary
+  int expectedDictionarySize = 0;
+
+  // Set a bunch of key/value pairs like key0/value0, key1/value1, ...
+  for (int i = 0; i < kPartitionIndex; ++i) {
+    sprintf(key, "key%d", i);
+    sprintf(value, "value%d", i);
+    dict->SetKeyValue(key, value);
+  }
+  expectedDictionarySize = kPartitionIndex;
+
+  // set a couple of the keys twice (with the same value) - should be nop
+  dict->SetKeyValue("key2", "value2");
+  dict->SetKeyValue("key4", "value4");
+  dict->SetKeyValue("key15", "value15");
+
+  // Remove some random elements in the middle
+  dict->RemoveKey("key7");
+  dict->RemoveKey("key18");
+  dict->RemoveKey("key23");
+  dict->RemoveKey("key31");
+  expectedDictionarySize -= 4; // we just removed four key/value pairs
+
+  // Set some more key/value pairs like key59/value59, key60/value60, ...
+  for (int i = kPartitionIndex; i < kDictionaryCapacity; ++i) {
+    sprintf(key, "key%d", i);
+    sprintf(value, "value%d", i);
+    dict->SetKeyValue(key, value);
+  }
+  expectedDictionarySize += kDictionaryCapacity - kPartitionIndex;
+
+  // Now create an iterator on the dictionary
+  SimpleStringDictionary::Iterator iter(*dict);
+
+  // We then verify that it iterates through exactly the number of
+  // key/value pairs we expect, and that they match one-for-one with what we
+  // would expect.  The ordering of the iteration does not matter...
+
+  // used to keep track of number of occurrences found for key/value pairs
+  int count[kDictionaryCapacity];
+  memset(count, 0, sizeof(count));
+
+  int totalCount = 0;
+
+  const SimpleStringDictionary::Entry* entry;
+  while ((entry = iter.Next())) {
+    totalCount++;
+
+    // Extract keyNumber from a string of the form key<keyNumber>
+    int keyNumber;
+    sscanf(entry->key, "key%d", &keyNumber);
+
+    // Extract valueNumber from a string of the form value<valueNumber>
+    int valueNumber;
+    sscanf(entry->value, "value%d", &valueNumber);
+
+    // The value number should equal the key number since that's how we set them
+    EXPECT_EQ(keyNumber, valueNumber);
+
+    // Key and value numbers should be in proper range:
+    // 0 <= keyNumber < kDictionaryCapacity
+    bool isKeyInGoodRange = (keyNumber >= 0 && keyNumber < kDictionaryCapacity);
+    bool isValueInGoodRange =
+        (valueNumber >= 0 && valueNumber < kDictionaryCapacity);
+    EXPECT_TRUE(isKeyInGoodRange);
+    EXPECT_TRUE(isValueInGoodRange);
+
+    if (isKeyInGoodRange && isValueInGoodRange) {
+      ++count[keyNumber];
+    }
+  }
+
+  // Make sure each of the key/value pairs showed up exactly one time, except
+  // for the ones which we removed.
+  for (size_t i = 0; i < kDictionaryCapacity; ++i) {
+    // Skip over key7, key18, key23, and key31, since we removed them
+    if (!(i == 7 || i == 18 || i == 23 || i == 31)) {
+      EXPECT_EQ(count[i], 1);
+    }
+  }
+
+  // Make sure the number of iterations matches the expected dictionary size.
+  EXPECT_EQ(totalCount, expectedDictionarySize);
+}
+
+TEST(LongStringDictionary, AddRemove) {
+  LongStringDictionary dict;
+  dict.SetKeyValue("rob", "ert");
+  dict.SetKeyValue("mike", "pink");
+  dict.SetKeyValue("mark", "allays");
+
+  EXPECT_EQ(3u, dict.GetCount());
+  EXPECT_EQ("ert", dict.GetValueForKey("rob"));
+  EXPECT_EQ("pink", dict.GetValueForKey("mike"));
+  EXPECT_EQ("allays", dict.GetValueForKey("mark"));
+
+  dict.RemoveKey("mike");
+
+  EXPECT_EQ(2u, dict.GetCount());
+  EXPECT_EQ("", dict.GetValueForKey("mike"));
+
+  dict.SetKeyValue("mark", "mal");
+  EXPECT_EQ(2u, dict.GetCount());
+  EXPECT_EQ("mal", dict.GetValueForKey("mark"));
+
+  dict.RemoveKey("mark");
+  EXPECT_EQ(1u, dict.GetCount());
+  EXPECT_EQ("", dict.GetValueForKey("mark"));
+}
+
+TEST(LongStringDictionary, AddRemoveLongValue) {
+  LongStringDictionary dict;
+
+  string long_value = string(256, 'x');
+  dict.SetKeyValue("rob", long_value.c_str());
+
+  EXPECT_EQ(2u, dict.GetCount());
+
+  string long_value_part_1 = string(255, 'x');
+
+  EXPECT_EQ(long_value_part_1, dict.GetValueForKey("rob__1"));
+  EXPECT_EQ("x", dict.GetValueForKey("rob__2"));
+
+  EXPECT_EQ(long_value, dict.GetValueForKey("rob"));
+
+  dict.RemoveKey("rob");
+  EXPECT_EQ(0u, dict.GetCount());
+}
+
+TEST(LongStringDictionary, AddRemoveSuperLongValue) {
+  LongStringDictionary dict;
+
+  string long_value = string(255 * 10, 'x');
+  dict.SetKeyValue("rob", long_value.c_str());
+
+  EXPECT_EQ(10u, dict.GetCount());
+
+  string long_value_part = string(255, 'x');
+
+  EXPECT_EQ(long_value_part, dict.GetValueForKey("rob__1"));
+  EXPECT_EQ(long_value_part, dict.GetValueForKey("rob__2"));
+  EXPECT_EQ(long_value_part, dict.GetValueForKey("rob__3"));
+  EXPECT_EQ(long_value_part, dict.GetValueForKey("rob__4"));
+  EXPECT_EQ(long_value_part, dict.GetValueForKey("rob__5"));
+  EXPECT_EQ(long_value_part, dict.GetValueForKey("rob__6"));
+  EXPECT_EQ(long_value_part, dict.GetValueForKey("rob__7"));
+  EXPECT_EQ(long_value_part, dict.GetValueForKey("rob__8"));
+  EXPECT_EQ(long_value_part, dict.GetValueForKey("rob__9"));
+  EXPECT_EQ(long_value_part, dict.GetValueForKey("rob__10"));
+  EXPECT_EQ(10u, dict.GetCount());
+
+  EXPECT_EQ(long_value, dict.GetValueForKey("rob"));
+
+  dict.RemoveKey("rob");
+  EXPECT_EQ(0u, dict.GetCount());
+}
+
+TEST(LongStringDictionary, TruncateSuperLongValue) {
+  LongStringDictionary dict;
+
+  string long_value = string(255 * 11, 'x');
+  dict.SetKeyValue("rob", long_value.c_str());
+
+  EXPECT_EQ(10u, dict.GetCount());
+
+  string long_value_part = string(255, 'x');
+
+  EXPECT_EQ(long_value_part, dict.GetValueForKey("rob__1"));
+  EXPECT_EQ(long_value_part, dict.GetValueForKey("rob__2"));
+  EXPECT_EQ(long_value_part, dict.GetValueForKey("rob__3"));
+  EXPECT_EQ(long_value_part, dict.GetValueForKey("rob__4"));
+  EXPECT_EQ(long_value_part, dict.GetValueForKey("rob__5"));
+  EXPECT_EQ(long_value_part, dict.GetValueForKey("rob__6"));
+  EXPECT_EQ(long_value_part, dict.GetValueForKey("rob__7"));
+  EXPECT_EQ(long_value_part, dict.GetValueForKey("rob__8"));
+  EXPECT_EQ(long_value_part, dict.GetValueForKey("rob__9"));
+  EXPECT_EQ(long_value_part, dict.GetValueForKey("rob__10"));
+  EXPECT_EQ(10u, dict.GetCount());
+
+  string expected_long_value = string(255 * 10, 'x');
+  EXPECT_EQ(expected_long_value, dict.GetValueForKey("rob"));
+
+  dict.RemoveKey("rob");
+  EXPECT_EQ(0u, dict.GetCount());
+}
+
+TEST(LongStringDictionary, OverrideLongValue) {
+  LongStringDictionary dict;
+
+  string long_value = string(255 * 10, 'x');
+  dict.SetKeyValue("rob", long_value.c_str());
+
+  EXPECT_EQ(10u, dict.GetCount());
+  EXPECT_EQ(long_value, dict.GetValueForKey("rob"));
+
+  dict.SetKeyValue("rob", "short_value");
+
+  EXPECT_EQ(1u, dict.GetCount());
+  EXPECT_EQ("short_value", dict.GetValueForKey("rob"));
+}
+
+TEST(LongStringDictionary, OverrideShortValue) {
+  LongStringDictionary dict;
+
+  dict.SetKeyValue("rob", "short_value");
+
+  EXPECT_EQ(1u, dict.GetCount());
+  EXPECT_EQ("short_value", dict.GetValueForKey("rob"));
+
+  string long_value = string(255 * 10, 'x');
+  dict.SetKeyValue("rob", long_value.c_str());
+
+  EXPECT_EQ(10u, dict.GetCount());
+  EXPECT_EQ(long_value, dict.GetValueForKey("rob"));
+}
+
+} // namespace google_breakpad
diff --git a/src/MEGASync/google_breakpad/common/mac/Breakpad.xcconfig b/src/MEGASync/google_breakpad/common/mac/Breakpad.xcconfig
index 672be2ce..f0913690 100644
--- a/src/MEGASync/google_breakpad/common/mac/Breakpad.xcconfig
+++ b/src/MEGASync/google_breakpad/common/mac/Breakpad.xcconfig
@@ -27,12 +27,6 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-ARCHS = $(ARCHS_STANDARD_32_64_BIT)
-SDKROOT = macosx10.5
-
-GCC_VERSION = 4.2
-GCC_VERSION[sdk=macosx10.4][arch=*] = 4.0
-
 GCC_C_LANGUAGE_STANDARD = c99
 
 GCC_WARN_CHECK_SWITCH_STATEMENTS = YES
@@ -41,7 +35,10 @@ GCC_WARN_64_TO_32_BIT_CONVERSION = NO
 GCC_WARN_INITIALIZER_NOT_FULLY_BRACKETED = YES
 GCC_WARN_ABOUT_RETURN_TYPE = YES
 GCC_WARN_MISSING_PARENTHESES = YES
-GCC_WARN_ABOUT_MISSING_FIELD_INITIALIZERS = YES
+
+// Once https://bugs.chromium.org/p/google-breakpad/issues/detail?id=697
+// is fixed this should be reenabled.
+//GCC_WARN_ABOUT_MISSING_FIELD_INITIALIZERS = YES
 GCC_WARN_ABOUT_MISSING_NEWLINE = YES
 GCC_WARN_SIGN_COMPARE = YES
 GCC_TREAT_IMPLICIT_FUNCTION_DECLARATIONS_AS_ERRORS = YES
@@ -51,6 +48,5 @@ GCC_WARN_UNUSED_VARIABLE = YES
 GCC_TREAT_WARNINGS_AS_ERRORS = YES
 
 DEBUG_INFORMATION_FORMAT = dwarf-with-dsym
-DEBUG_INFORMATION_FORMAT[sdk=macosx10.4][arch=*] = stabs
 
 ALWAYS_SEARCH_USER_PATHS = NO
diff --git a/src/MEGASync/google_breakpad/common/mac/GTMDefines.h b/src/MEGASync/google_breakpad/common/mac/GTMDefines.h
index b970d69c..04fcf6d0 100644
--- a/src/MEGASync/google_breakpad/common/mac/GTMDefines.h
+++ b/src/MEGASync/google_breakpad/common/mac/GTMDefines.h
@@ -117,7 +117,7 @@
 // developer level errors.  This implementation simply macros to NSLog/NSAssert.
 // It is not intended to be a general logging/reporting system.
 //
-// Please see http://code.google.com/p/google-toolbox-for-mac/wiki/DevLogNAssert
+// Please see https://github.com/google/google-toolbox-for-mac/wiki/DevLogNAssert
 // for a little more background on the usage of these macros.
 //
 //    _GTMDevLog           log some error/problem in debug builds
@@ -193,9 +193,11 @@
   // For iPhone specific stuff
   #define GTM_IPHONE_SDK 1
   #if TARGET_IPHONE_SIMULATOR
+    #define GTM_IPHONE_DEVICE 0
     #define GTM_IPHONE_SIMULATOR 1
   #else
     #define GTM_IPHONE_DEVICE 1
+    #define GTM_IPHONE_SIMULATOR 0
   #endif  // TARGET_IPHONE_SIMULATOR
   // By default, GTM has provided it's own unittesting support, define this
   // to use the support provided by Xcode, especially for the Xcode4 support
@@ -203,9 +205,14 @@
   #ifndef GTM_IPHONE_USE_SENTEST
     #define GTM_IPHONE_USE_SENTEST 0
   #endif
+  #define GTM_MACOS_SDK 0
 #else
   // For MacOS specific stuff
   #define GTM_MACOS_SDK 1
+  #define GTM_IPHONE_SDK 0
+  #define GTM_IPHONE_SIMULATOR 0
+  #define GTM_IPHONE_DEVICE 0
+  #define GTM_IPHONE_USE_SENTEST 0
 #endif
 
 // Some of our own availability macros
@@ -217,21 +224,10 @@
 #define GTM_AVAILABLE_ONLY_ON_MACOS UNAVAILABLE_ATTRIBUTE
 #endif
 
-// Provide a symbol to include/exclude extra code for GC support.  (This mainly
-// just controls the inclusion of finalize methods).
+// GC was dropped by Apple, define the old constant incase anyone still keys
+// off of it.
 #ifndef GTM_SUPPORT_GC
-  #if GTM_IPHONE_SDK
-    // iPhone never needs GC
-    #define GTM_SUPPORT_GC 0
-  #else
-    // We can't find a symbol to tell if GC is supported/required, so best we
-    // do on Mac targets is include it if we're on 10.5 or later.
-    #if MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_5
-      #define GTM_SUPPORT_GC 0
-    #else
-      #define GTM_SUPPORT_GC 1
-    #endif
-  #endif
+  #define GTM_SUPPORT_GC 0
 #endif
 
 // To simplify support for 64bit (and Leopard in general), we provide the type
@@ -239,7 +235,7 @@
 #if !(MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
  // NSInteger/NSUInteger and Max/Mins
   #ifndef NSINTEGER_DEFINED
-    #if __LP64__ || NS_BUILD_32_LIKE_64
+    #if (defined(__LP64__) && __LP64__) || NS_BUILD_32_LIKE_64
       typedef long NSInteger;
       typedef unsigned long NSUInteger;
     #else
@@ -352,7 +348,15 @@
 #endif
 
 #ifndef GTM_NONNULL
-  #define GTM_NONNULL(x) __attribute__((nonnull(x)))
+  #if defined(__has_attribute)
+    #if __has_attribute(nonnull)
+      #define GTM_NONNULL(x) __attribute__((nonnull x))
+    #else
+      #define GTM_NONNULL(x)
+    #endif
+  #else
+    #define GTM_NONNULL(x)
+  #endif
 #endif
 
 // Invalidates the initializer from which it's called.
@@ -374,6 +378,14 @@
   #endif
 #endif
 
+#ifndef GTMCFAutorelease
+  #if __has_feature(objc_arc)
+    #define GTMCFAutorelease(x) CFBridgingRelease(x)
+  #else
+    #define GTMCFAutorelease(x) ([(id)x autorelease])
+  #endif
+#endif
+
 #ifdef __OBJC__
 
 // Declared here so that it can easily be used for logging tracking if
diff --git a/src/MEGASync/google_breakpad/common/mac/GTMGarbageCollection.h b/src/MEGASync/google_breakpad/common/mac/GTMGarbageCollection.h
deleted file mode 100644
index 93d4efab..00000000
--- a/src/MEGASync/google_breakpad/common/mac/GTMGarbageCollection.h
+++ /dev/null
@@ -1,72 +0,0 @@
-//
-//  GTMGarbageCollection.h
-//
-//  Copyright 2007-2008 Google Inc.
-//
-//  Licensed under the Apache License, Version 2.0 (the "License"); you may not
-//  use this file except in compliance with the License.  You may obtain a copy
-//  of the License at
-// 
-//  http://www.apache.org/licenses/LICENSE-2.0
-// 
-//  Unless required by applicable law or agreed to in writing, software
-//  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
-//  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
-//  License for the specific language governing permissions and limitations under
-//  the License.
-//
-
-#import <Foundation/Foundation.h>
-
-#import "GTMDefines.h"
-
-// This allows us to easily move our code from GC to non GC.
-// They are no-ops unless we are require Leopard or above.
-// See 
-// http://developer.apple.com/documentation/Cocoa/Conceptual/GarbageCollection/index.html
-// and
-// http://developer.apple.com/documentation/Cocoa/Conceptual/GarbageCollection/Articles/gcCoreFoundation.html#//apple_ref/doc/uid/TP40006687-SW1
-// for details.
-
-#if (MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_5) && !GTM_IPHONE_SDK
-// General use would be to call this through GTMCFAutorelease
-// but there may be a reason the you want to make something collectable
-// but not autoreleased, especially in pure GC code where you don't
-// want to bother with the nop autorelease. Done as a define instead of an 
-// inline so that tools like Clang's scan-build don't report code as leaking.
-#define GTMNSMakeCollectable(cf) ((id)NSMakeCollectable(cf))
-
-// GTMNSMakeUncollectable is for global maps, etc. that we don't
-// want released ever. You should still retain these in non-gc code.
-GTM_INLINE void GTMNSMakeUncollectable(id object) {
-  [[NSGarbageCollector defaultCollector] disableCollectorForPointer:object];
-}
-
-// Hopefully no code really needs this, but GTMIsGarbageCollectionEnabled is
-// a common way to check at runtime if GC is on.
-// There are some places where GC doesn't work w/ things w/in Apple's
-// frameworks, so this is here so GTM unittests and detect it, and not run
-// individual tests to work around bugs in Apple's frameworks.
-GTM_INLINE BOOL GTMIsGarbageCollectionEnabled(void) {
-  return ([NSGarbageCollector defaultCollector] != nil);
-}
-
-#else
-
-#define GTMNSMakeCollectable(cf) ((id)(cf))
-
-GTM_INLINE void GTMNSMakeUncollectable(id object) {
-}
-
-GTM_INLINE BOOL GTMIsGarbageCollectionEnabled(void) {
-  return NO;
-}
-
-#endif
-
-// GTMCFAutorelease makes a CF object collectable in GC mode, or adds it 
-// to the autorelease pool in non-GC mode. Either way it is taken care
-// of. Done as a define instead of an inline so that tools like Clang's
-// scan-build don't report code as leaking.
-#define GTMCFAutorelease(cf) ([GTMNSMakeCollectable(cf) autorelease])
-
diff --git a/src/MEGASync/google_breakpad/common/mac/GTMLogger.m b/src/MEGASync/google_breakpad/common/mac/GTMLogger.m
index 4b40747b..ebc5836a 100644
--- a/src/MEGASync/google_breakpad/common/mac/GTMLogger.m
+++ b/src/MEGASync/google_breakpad/common/mac/GTMLogger.m
@@ -17,7 +17,6 @@
 //
 
 #import "GTMLogger.h"
-#import "GTMGarbageCollection.h"
 #import <fcntl.h>
 #import <unistd.h>
 #import <stdlib.h>
@@ -506,7 +505,7 @@ static BOOL IsVerboseLoggingEnabled(void) {
 // In DEBUG builds, log everything. If we're not in a debug build we'll assume
 // that we're in a Release build.
 - (BOOL)filterAllowsMessage:(NSString *)msg level:(GTMLoggerLevel)level {
-#if DEBUG
+#if defined(DEBUG) && DEBUG
   return YES;
 #endif
 
diff --git a/src/MEGASync/google_breakpad/common/android/include/sys/signal.h b/src/MEGASync/google_breakpad/common/mac/HTTPGetRequest.h
similarity index 86%
rename from src/MEGASync/google_breakpad/common/android/include/sys/signal.h
rename to src/MEGASync/google_breakpad/common/mac/HTTPGetRequest.h
index 20c81e93..3aa316b5 100644
--- a/src/MEGASync/google_breakpad/common/android/include/sys/signal.h
+++ b/src/MEGASync/google_breakpad/common/mac/HTTPGetRequest.h
@@ -1,4 +1,4 @@
-// Copyright (c) 2012, Google Inc.
+// Copyright (c) 2020, Google Inc.
 // All rights reserved.
 //
 // Redistribution and use in source and binary forms, with or without
@@ -27,9 +27,16 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-#ifndef GOOGLE_BREAKPAD_COMMON_ANDROID_INCLUDE_SYS_SIGNAL_H
-#define GOOGLE_BREAKPAD_COMMON_ANDROID_INCLUDE_SYS_SIGNAL_H
+#import <Foundation/Foundation.h>
 
-#include <signal.h>
+#import "HTTPRequest.h"
 
-#endif  // GOOGLE_BREAKPAD_COMMON_ANDROID_INCLUDE_SYS_SIGNAL_H
+NS_ASSUME_NONNULL_BEGIN
+
+/**
+ Represents a HTTP GET request
+ */
+@interface HTTPGetRequest : HTTPRequest
+@end
+
+NS_ASSUME_NONNULL_END
diff --git a/src/MEGASync/google_breakpad/common/android/include/sys/stat.h b/src/MEGASync/google_breakpad/common/mac/HTTPGetRequest.m
similarity index 84%
rename from src/MEGASync/google_breakpad/common/android/include/sys/stat.h
rename to src/MEGASync/google_breakpad/common/mac/HTTPGetRequest.m
index 93ebd080..f9b7bf0e 100644
--- a/src/MEGASync/google_breakpad/common/android/include/sys/stat.h
+++ b/src/MEGASync/google_breakpad/common/mac/HTTPGetRequest.m
@@ -1,4 +1,4 @@
-// Copyright (c) 2012, Google Inc.
+// Copyright (c) 2020, Google Inc.
 // All rights reserved.
 //
 // Redistribution and use in source and binary forms, with or without
@@ -27,13 +27,13 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-#ifndef GOOGLE_BREAKPAD_COMMON_ANDROID_INCLUDE_SYS_STAT_H
-#define GOOGLE_BREAKPAD_COMMON_ANDROID_INCLUDE_SYS_STAT_H
+#import "HTTPGetRequest.h"
 
-#include_next <sys/stat.h>
+@implementation HTTPGetRequest
 
-#ifndef S_IRWXU
-#define S_IRWXU  00700
-#endif
+//=============================================================================
+- (NSString*)HTTPMethod {
+  return @"GET";
+}
 
-#endif // GOOGLE_BREAKPAD_COMMON_ANDROID_INCLUDE_SYS_STAT_H
+@end
diff --git a/src/MEGASync/google_breakpad/common/mac/HTTPMultipartUpload.h b/src/MEGASync/google_breakpad/common/mac/HTTPMultipartUpload.h
index 42e8fed3..56d5394d 100644
--- a/src/MEGASync/google_breakpad/common/mac/HTTPMultipartUpload.h
+++ b/src/MEGASync/google_breakpad/common/mac/HTTPMultipartUpload.h
@@ -27,35 +27,37 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-// HTTPMultipartUpload: A multipart/form-data HTTP uploader.
-// Each parameter pair is sent as a boundary
-// Each file is sent with a name field in addition to the filename and data
-// The data will be sent synchronously.
-
 #import <Foundation/Foundation.h>
 
-@interface HTTPMultipartUpload : NSObject {
+#import "HTTPRequest.h"
+/**
+ Represents a multipart/form-data HTTP upload (POST request).
+ Each parameter pair is sent as a boundary.
+ Each file is sent with a name field in addition to the filename and data.
+ */
+@interface HTTPMultipartUpload : HTTPRequest {
  @protected
-  NSURL *url_;                  // The destination URL (STRONG)
-  NSDictionary *parameters_;    // The key/value pairs for sending data (STRONG)
-  NSMutableDictionary *files_;  // Dictionary of name/file-path (STRONG)
-  NSString *boundary_;          // The boundary string (STRONG)
-  NSHTTPURLResponse *response_; // The response from the send (STRONG)
+  NSDictionary* parameters_;    // The key/value pairs for sending data (STRONG)
+  NSMutableDictionary* files_;  // Dictionary of name/file-path (STRONG)
+  NSString* boundary_;          // The boundary string (STRONG)
 }
 
-- (id)initWithURL:(NSURL *)url;
-
-- (NSURL *)URL;
-
-- (void)setParameters:(NSDictionary *)parameters;
-- (NSDictionary *)parameters;
-
-- (void)addFileAtPath:(NSString *)path name:(NSString *)name;
-- (void)addFileContents:(NSData *)data name:(NSString *)name;
-- (NSDictionary *)files;
-
-// Set the data and return the response
-- (NSData *)send:(NSError **)error;
-- (NSHTTPURLResponse *)response;
+/**
+ Sets the parameters that will be sent in the multipart POST request.
+ */
+- (void)setParameters:(NSDictionary*)parameters;
+- (NSDictionary*)parameters;
+
+/**
+ Adds a file to be uploaded in the multipart POST request, by its file path.
+ */
+- (void)addFileAtPath:(NSString*)path name:(NSString*)name;
+
+/**
+ Adds a file to be uploaded in the multipart POST request, by its name and
+ contents.
+ */
+- (void)addFileContents:(NSData*)data name:(NSString*)name;
+- (NSDictionary*)files;
 
 @end
diff --git a/src/MEGASync/google_breakpad/common/mac/HTTPMultipartUpload.m b/src/MEGASync/google_breakpad/common/mac/HTTPMultipartUpload.m
index 76f38f8a..2aa64f79 100644
--- a/src/MEGASync/google_breakpad/common/mac/HTTPMultipartUpload.m
+++ b/src/MEGASync/google_breakpad/common/mac/HTTPMultipartUpload.m
@@ -28,15 +28,17 @@
 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #import "HTTPMultipartUpload.h"
+
 #import "GTMDefines.h"
+#import "encoding_util.h"
 
-@interface HTTPMultipartUpload(PrivateMethods)
-- (NSString *)multipartBoundary;
+@interface HTTPMultipartUpload (PrivateMethods)
+- (NSString*)multipartBoundary;
 // Each of the following methods will append the starting multipart boundary,
 // but not the ending one.
-- (NSData *)formDataForKey:(NSString *)key value:(NSString *)value;
-- (NSData *)formDataForFileContents:(NSData *)contents name:(NSString *)name;
-- (NSData *)formDataForFile:(NSString *)file name:(NSString *)name;
+- (NSData*)formDataForKey:(NSString*)key value:(NSString*)value;
+- (NSData*)formDataForFileContents:(NSData*)contents name:(NSString*)name;
+- (NSData*)formDataForFile:(NSString*)file name:(NSString*)name;
 @end
 
 @implementation HTTPMultipartUpload
@@ -44,52 +46,39 @@
 #pragma mark -
 #pragma mark || Private ||
 //=============================================================================
-- (NSString *)multipartBoundary {
+- (NSString*)multipartBoundary {
   // The boundary has 27 '-' characters followed by 16 hex digits
-  return [NSString stringWithFormat:@"---------------------------%08X%08X",
-    rand(), rand()];
-}
-
-//=============================================================================
-- (NSData *)formDataForKey:(NSString *)key value:(NSString *)value {
-  NSString *escaped =
-    [key stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
-  NSString *fmt =
-    @"--%@\r\nContent-Disposition: form-data; name=\"%@\"\r\n\r\n%@\r\n";
-  NSString *form = [NSString stringWithFormat:fmt, boundary_, escaped, value];
-
-  return [form dataUsingEncoding:NSUTF8StringEncoding];
+  return [NSString
+      stringWithFormat:@"---------------------------%08X%08X", rand(), rand()];
 }
 
 //=============================================================================
-- (NSData *)formDataForFileContents:(NSData *)contents name:(NSString *)name {
-  NSMutableData *data = [NSMutableData data];
-  NSString *escaped =
-    [name stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
-  NSString *fmt = @"--%@\r\nContent-Disposition: form-data; name=\"%@\"; "
-    "filename=\"minidump.dmp\"\r\nContent-Type: application/octet-stream\r\n\r\n";
-  NSString *pre = [NSString stringWithFormat:fmt, boundary_, escaped];
+- (NSData*)formDataForKey:(NSString*)key value:(NSString*)value {
+  NSMutableData* data = [NSMutableData data];
+  [self appendBoundaryData:data];
 
-  [data appendData:[pre dataUsingEncoding:NSUTF8StringEncoding]];
-  [data appendData:contents];
+  NSString* escaped = PercentEncodeNSString(key);
+  NSString* fmt = @"Content-Disposition: form-data; name=\"%@\"\r\n\r\n%@\r\n";
+  NSString *form = [NSString stringWithFormat:fmt, escaped, value];
 
+  [data appendData:[form dataUsingEncoding:NSUTF8StringEncoding]];
   return data;
 }
 
 //=============================================================================
-- (NSData *)formDataForFile:(NSString *)file name:(NSString *)name {
-  NSData *contents = [NSData dataWithContentsOfFile:file];
+- (void)appendBoundaryData:(NSMutableData*)data {
+  NSString* fmt = @"--%@\r\n";
+  NSString* pre = [NSString stringWithFormat:fmt, boundary_];
 
-  return [self formDataForFileContents:contents name:name];
+  [data appendData:[pre dataUsingEncoding:NSUTF8StringEncoding]];
 }
 
 //=============================================================================
 #pragma mark -
 #pragma mark || Public ||
 //=============================================================================
-- (id)initWithURL:(NSURL *)url {
-  if ((self = [super init])) {
-    url_ = [url copy];
+- (id)initWithURL:(NSURL*)url {
+  if ((self = [super initWithURL:url])) {
     boundary_ = [[self multipartBoundary] retain];
     files_ = [[NSMutableDictionary alloc] init];
   }
@@ -99,22 +88,15 @@
 
 //=============================================================================
 - (void)dealloc {
-  [url_ release];
   [parameters_ release];
   [files_ release];
   [boundary_ release];
-  [response_ release];
 
   [super dealloc];
 }
 
 //=============================================================================
-- (NSURL *)URL {
-  return url_;
-}
-
-//=============================================================================
-- (void)setParameters:(NSDictionary *)parameters {
+- (void)setParameters:(NSDictionary*)parameters {
   if (parameters != parameters_) {
     [parameters_ release];
     parameters_ = [parameters copy];
@@ -122,40 +104,43 @@
 }
 
 //=============================================================================
-- (NSDictionary *)parameters {
+- (NSDictionary*)parameters {
   return parameters_;
 }
 
 //=============================================================================
-- (void)addFileAtPath:(NSString *)path name:(NSString *)name {
+- (void)addFileAtPath:(NSString*)path name:(NSString*)name {
   [files_ setObject:path forKey:name];
 }
 
 //=============================================================================
-- (void)addFileContents:(NSData *)data name:(NSString *)name {
+- (void)addFileContents:(NSData*)data name:(NSString*)name {
   [files_ setObject:data forKey:name];
 }
 
 //=============================================================================
-- (NSDictionary *)files {
+- (NSDictionary*)files {
   return files_;
 }
 
 //=============================================================================
-- (NSData *)send:(NSError **)error {
-  NSMutableURLRequest *req = 
-    [[NSMutableURLRequest alloc]
-          initWithURL:url_ cachePolicy:NSURLRequestUseProtocolCachePolicy
-      timeoutInterval:10.0 ];
+- (NSString*)HTTPMethod {
+  return @"POST";
+}
 
-  NSMutableData *postBody = [NSMutableData data];
+//=============================================================================
+- (NSString*)contentType {
+  return [NSString
+      stringWithFormat:@"multipart/form-data; boundary=%@", boundary_];
+}
 
-  [req setValue:[NSString stringWithFormat:@"multipart/form-data; boundary=%@",
-    boundary_] forHTTPHeaderField:@"Content-type"];
+//=============================================================================
+- (NSData*)bodyData {
+  NSMutableData* postBody = [NSMutableData data];
 
   // Add any parameters to the message
-  NSArray *parameterKeys = [parameters_ allKeys];
-  NSString *key;
+  NSArray* parameterKeys = [parameters_ allKeys];
+  NSString* key;
 
   NSInteger count = [parameterKeys count];
   for (NSInteger i = 0; i < count; ++i) {
@@ -165,45 +150,21 @@
   }
 
   // Add any files to the message
-  NSArray *fileNames = [files_ allKeys];
-  count = [fileNames count];
-  for (NSInteger i = 0; i < count; ++i) {
-    NSString *name = [fileNames objectAtIndex:i];
+  NSArray* fileNames = [files_ allKeys];
+  for (NSString* name in fileNames) {
+    // First append boundary
+    [self appendBoundaryData:postBody];
+    // Then the formdata
     id fileOrData = [files_ objectForKey:name];
-    NSData *fileData;
-
-    // The object can be either the path to a file (NSString) or the contents
-    // of the file (NSData).
-    if ([fileOrData isKindOfClass:[NSData class]])
-      fileData = [self formDataForFileContents:fileOrData name:name];
-    else
-      fileData = [self formDataForFile:fileOrData name:name];
-
-    [postBody appendData:fileData];
+    [HTTPRequest appendFileToBodyData:postBody
+                             withName:name
+                       withFileOrData:fileOrData];
   }
 
-  NSString *epilogue = [NSString stringWithFormat:@"\r\n--%@--\r\n", boundary_];
+  NSString* epilogue = [NSString stringWithFormat:@"\r\n--%@--\r\n", boundary_];
   [postBody appendData:[epilogue dataUsingEncoding:NSUTF8StringEncoding]];
 
-  [req setHTTPBody:postBody];
-  [req setHTTPMethod:@"POST"];
-
-  [response_ release];
-  response_ = nil;
-  
-  NSData *data =  [NSURLConnection sendSynchronousRequest:req
-                               returningResponse:&response_
-                                           error:error];
-
-  [response_ retain];
-  [req release];
-
-  return data;
-}
-
-//=============================================================================
-- (NSHTTPURLResponse *)response {
-  return response_;
+  return postBody;
 }
 
 @end
diff --git a/src/MEGASync/google_breakpad/common/mac/HTTPPutRequest.h b/src/MEGASync/google_breakpad/common/mac/HTTPPutRequest.h
new file mode 100644
index 00000000..431ea610
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/mac/HTTPPutRequest.h
@@ -0,0 +1,51 @@
+// Copyright (c) 2020, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Foundation/Foundation.h>
+
+#import "HTTPRequest.h"
+
+NS_ASSUME_NONNULL_BEGIN
+
+/**
+ Represents an HTTP PUT request.
+ */
+@interface HTTPPutRequest : HTTPRequest {
+ @protected
+  NSString* file_;
+}
+
+/**
+ Sets the path of the file that will be sent in the PUT request.
+ */
+- (void)setFile:(NSString*)file;
+
+@end
+
+NS_ASSUME_NONNULL_END
diff --git a/src/MEGASync/google_breakpad/common/mac/HTTPPutRequest.m b/src/MEGASync/google_breakpad/common/mac/HTTPPutRequest.m
new file mode 100644
index 00000000..ec67376b
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/mac/HTTPPutRequest.m
@@ -0,0 +1,62 @@
+// Copyright (c) 2020, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "HTTPPutRequest.h"
+
+@implementation HTTPPutRequest
+
+//=============================================================================
+- (void)dealloc {
+  [file_ release];
+
+  [super dealloc];
+}
+
+//=============================================================================
+- (void)setFile:(NSString*)file {
+  file_ = [file copy];
+}
+
+//=============================================================================
+- (NSString*)HTTPMethod {
+  return @"PUT";
+}
+
+//=============================================================================
+- (NSData*)bodyData {
+  NSMutableData* postBody = [NSMutableData data];
+
+  [HTTPRequest appendFileToBodyData:postBody
+                           withName:@"symbol_file"
+                     withFileOrData:file_];
+
+  return postBody;
+}
+
+@end
diff --git a/src/MEGASync/google_breakpad/common/mac/HTTPRequest.h b/src/MEGASync/google_breakpad/common/mac/HTTPRequest.h
new file mode 100644
index 00000000..b78fad6b
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/mac/HTTPRequest.h
@@ -0,0 +1,73 @@
+// Copyright (c) 2020, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Foundation/Foundation.h>
+
+NS_ASSUME_NONNULL_BEGIN
+/**
+ Represents a single HTTP request. Sending the request is synchronous.
+ Once the send is complete, the response will be set.
+
+ This is a base interface that specific HTTP requests derive from.
+ It is not intended to be instantiated directly.
+ */
+@interface HTTPRequest : NSObject {
+ @protected
+  NSURL* URL_;                   // The destination URL (STRONG)
+  NSHTTPURLResponse* response_;  // The response from the send (STRONG)
+}
+
+/**
+ Initializes the HTTPRequest and sets its URL.
+ */
+- (id)initWithURL:(NSURL*)URL;
+
+- (NSURL*)URL;
+
+- (NSHTTPURLResponse*)response;
+
+- (NSString*)HTTPMethod;  // Internal, don't call outside class hierarchy.
+
+- (NSString*)contentType;  // Internal, don't call outside class hierarchy.
+
+- (NSData*)bodyData;  // Internal, don't call outside class hierarchy.
+
+- (NSData*)send:(NSError**)error;
+
+/**
+ Appends a file to the HTTP request, either by filename or by file content
+ (in the form of NSData).
+ */
++ (void)appendFileToBodyData:(NSMutableData*)data
+                    withName:(NSString*)name
+              withFileOrData:(id)fileOrData;
+
+@end
+
+NS_ASSUME_NONNULL_END
diff --git a/src/MEGASync/google_breakpad/common/mac/HTTPRequest.m b/src/MEGASync/google_breakpad/common/mac/HTTPRequest.m
new file mode 100644
index 00000000..ee7de3af
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/mac/HTTPRequest.m
@@ -0,0 +1,213 @@
+// Copyright (c) 2020, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "HTTPRequest.h"
+
+#include <Availability.h>
+#include <AvailabilityMacros.h>
+
+#import "encoding_util.h"
+
+// As -[NSURLConnection sendSynchronousRequest:returningResponse:error:] has
+// been deprecated with iOS 9.0 / OS X 10.11 SDKs, this function re-implements
+// it using -[NSURLSession dataTaskWithRequest:completionHandler:] which is
+// available on iOS 7+.
+static NSData* SendSynchronousNSURLRequest(NSURLRequest* req,
+                                           NSURLResponse** outResponse,
+                                           NSError** outError) {
+#if (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && defined(__IPHONE_7_0) && \
+     __IPHONE_OS_VERSION_MIN_REQUIRED >= __IPHONE_7_0) ||                  \
+    (defined(MAC_OS_X_VERSION_MIN_REQUIRED) &&                             \
+     defined(MAC_OS_X_VERSION_10_11) &&                                    \
+     MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_11)
+  __block NSData* result = nil;
+  __block NSError* error = nil;
+  __block NSURLResponse* response = nil;
+  dispatch_semaphore_t waitSemaphone = dispatch_semaphore_create(0);
+  NSURLSessionConfiguration* config =
+      [NSURLSessionConfiguration defaultSessionConfiguration];
+  [config setTimeoutIntervalForRequest:240.0];
+  NSURLSession* session = [NSURLSession sessionWithConfiguration:config];
+  [[session
+      dataTaskWithRequest:req
+        completionHandler:^(NSData* data, NSURLResponse* resp, NSError* err) {
+          if (outError)
+            error = [err retain];
+          if (outResponse)
+            response = [resp retain];
+          if (err == nil)
+            result = [data retain];
+          dispatch_semaphore_signal(waitSemaphone);
+        }] resume];
+  dispatch_semaphore_wait(waitSemaphone, DISPATCH_TIME_FOREVER);
+  dispatch_release(waitSemaphone);
+  if (outError)
+    *outError = [error autorelease];
+  if (outResponse)
+    *outResponse = [response autorelease];
+  return [result autorelease];
+#else
+  return [NSURLConnection sendSynchronousRequest:req
+                               returningResponse:outResponse
+                                           error:outError];
+#endif
+}
+
+@implementation HTTPRequest
+
+//=============================================================================
+- (id)initWithURL:(NSURL*)URL {
+  if ((self = [super init])) {
+    URL_ = [URL copy];
+  }
+
+  return self;
+}
+
+//=============================================================================
+- (void)dealloc {
+  [URL_ release];
+  [response_ release];
+
+  [super dealloc];
+}
+
+//=============================================================================
+- (NSURL*)URL {
+  return URL_;
+}
+
+//=============================================================================
+- (NSHTTPURLResponse*)response {
+  return response_;
+}
+
+//=============================================================================
+- (NSString*)HTTPMethod {
+  @throw [NSException
+      exceptionWithName:NSInternalInconsistencyException
+                 reason:[NSString stringWithFormat:@"You must"
+                                                    "override %@ in a subclass",
+                                                   NSStringFromSelector(_cmd)]
+               userInfo:nil];
+}
+
+//=============================================================================
+- (NSString*)contentType {
+  return nil;
+}
+
+//=============================================================================
+- (NSData*)bodyData {
+  return nil;
+}
+
+//=============================================================================
+- (NSData*)send:(NSError**)withError {
+  NSMutableURLRequest* req = [[NSMutableURLRequest alloc]
+          initWithURL:URL_
+          cachePolicy:NSURLRequestUseProtocolCachePolicy
+      timeoutInterval:60.0];
+
+  NSString* contentType = [self contentType];
+  if ([contentType length] > 0) {
+    [req setValue:contentType forHTTPHeaderField:@"Content-type"];
+  }
+
+  NSData* bodyData = [self bodyData];
+  if ([bodyData length] > 0) {
+    [req setHTTPBody:bodyData];
+  }
+
+  [req setHTTPMethod:[self HTTPMethod]];
+
+  [response_ release];
+  response_ = nil;
+
+  NSData* data = nil;
+  if ([[req URL] isFileURL]) {
+    [[req HTTPBody] writeToURL:[req URL] options:0 error:withError];
+  } else {
+    NSURLResponse* response = nil;
+    data = SendSynchronousNSURLRequest(req, &response, withError);
+    response_ = (NSHTTPURLResponse*)[response retain];
+  }
+  [req release];
+
+  return data;
+}
+
+//=============================================================================
++ (NSData*)formDataForFileContents:(NSData*)contents withName:(NSString*)name {
+  NSMutableData* data = [NSMutableData data];
+  NSString* escaped = PercentEncodeNSString(name);
+  NSString* fmt = @"Content-Disposition: form-data; name=\"%@\"; "
+                   "filename=\"minidump.dmp\"\r\nContent-Type: "
+                   "application/octet-stream\r\n\r\n";
+  NSString* pre = [NSString stringWithFormat:fmt, escaped];
+
+  [data appendData:[pre dataUsingEncoding:NSUTF8StringEncoding]];
+  [data appendData:contents];
+
+  return data;
+}
+
+//=============================================================================
++ (NSData*)formDataForFile:(NSString*)file withName:(NSString*)name {
+  NSData* contents = [NSData dataWithContentsOfFile:file];
+
+  return [HTTPRequest formDataForFileContents:contents withName:name];
+}
+
+//=============================================================================
++ (NSData*)formDataForKey:(NSString*)key value:(NSString*)value {
+  NSString* escaped = PercentEncodeNSString(key);
+  NSString* fmt = @"Content-Disposition: form-data; name=\"%@\"\r\n\r\n%@\r\n";
+  NSString* form = [NSString stringWithFormat:fmt, escaped, value];
+
+  return [form dataUsingEncoding:NSUTF8StringEncoding];
+}
+
+//=============================================================================
++ (void)appendFileToBodyData:(NSMutableData*)data
+                    withName:(NSString*)name
+              withFileOrData:(id)fileOrData {
+  NSData* fileData;
+
+  // The object can be either the path to a file (NSString) or the contents
+  // of the file (NSData).
+  if ([fileOrData isKindOfClass:[NSData class]])
+    fileData = [self formDataForFileContents:fileOrData withName:name];
+  else
+    fileData = [HTTPRequest formDataForFile:fileOrData withName:name];
+
+  [data appendData:fileData];
+}
+
+@end
diff --git a/src/MEGASync/google_breakpad/common/mac/HTTPSimplePostRequest.h b/src/MEGASync/google_breakpad/common/mac/HTTPSimplePostRequest.h
new file mode 100644
index 00000000..bfabfead
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/mac/HTTPSimplePostRequest.h
@@ -0,0 +1,57 @@
+// Copyright (c) 2020, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Foundation/Foundation.h>
+
+#import "HTTPRequest.h"
+
+NS_ASSUME_NONNULL_BEGIN
+
+/**
+ Represents a simple (non-multipart) HTTP POST request.
+ */
+@interface HTTPSimplePostRequest : HTTPRequest {
+ @protected
+  NSString* contentType_;
+  NSString* body_;
+}
+
+/**
+ Sets the content type of the POST request.
+ */
+- (void)setContentType:(NSString*)contentType;
+
+/**
+ Sets the contents of the POST request's body.
+ */
+- (void)setBody:(NSString*)body;
+
+@end
+
+NS_ASSUME_NONNULL_END
diff --git a/src/MEGASync/google_breakpad/common/mac/HTTPSimplePostRequest.m b/src/MEGASync/google_breakpad/common/mac/HTTPSimplePostRequest.m
new file mode 100644
index 00000000..4cb3ef15
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/mac/HTTPSimplePostRequest.m
@@ -0,0 +1,69 @@
+// Copyright (c) 2020, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "HTTPSimplePostRequest.h"
+
+@implementation HTTPSimplePostRequest
+
+//=============================================================================
+- (void)dealloc {
+  [contentType_ release];
+  [body_ release];
+
+  [super dealloc];
+}
+
+//=============================================================================
+- (void)setContentType:(NSString*)contentType {
+  contentType_ = [contentType copy];
+}
+
+//=============================================================================
+- (void)setBody:(NSString*)body {
+  body_ = [body copy];
+}
+
+//=============================================================================
+- (NSString*)HTTPMethod {
+  return @"POST";
+}
+
+//=============================================================================
+- (NSString*)contentType {
+  return contentType_;
+}
+
+//=============================================================================
+- (NSData*)bodyData {
+  NSMutableData* data = [NSMutableData data];
+  [data appendData:[body_ dataUsingEncoding:NSUTF8StringEncoding]];
+  return data;
+}
+
+@end
diff --git a/src/MEGASync/google_breakpad/common/mac/MachIPC.h b/src/MEGASync/google_breakpad/common/mac/MachIPC.h
index 8df9165b..a3fae5a1 100644
--- a/src/MEGASync/google_breakpad/common/mac/MachIPC.h
+++ b/src/MEGASync/google_breakpad/common/mac/MachIPC.h
@@ -73,7 +73,7 @@
 //          mach_port_t task = message.GetTranslatedPort(0);
 //          mach_port_t thread = message.GetTranslatedPort(1);
 //
-//          char *messageString = message.GetData();
+//          char* messageString = message.GetData();
 //
 //          printf("message string = %s\n", messageString);
 //        }
@@ -164,7 +164,7 @@ class MachMessage {
  public:
 
   // The receiver of the message can retrieve the raw data this way
-  uint8_t *GetData() {
+  uint8_t* GetData() {
     return GetDataLength() > 0 ? GetDataPacket()->data : NULL;
   }
 
@@ -181,10 +181,10 @@ class MachMessage {
 
   // Adds a descriptor (typically a mach port) to be translated
   // returns true if successful, otherwise not enough space
-  bool AddDescriptor(const MachMsgPortDescriptor &desc);
+  bool AddDescriptor(const MachMsgPortDescriptor& desc);
 
   int GetDescriptorCount() const { return body.msgh_descriptor_count; }
-  MachMsgPortDescriptor *GetDescriptor(int n);
+  MachMsgPortDescriptor* GetDescriptor(int n);
 
   // Convenience method which gets the mach port described by the descriptor
   mach_port_t GetTranslatedPort(int n);
@@ -193,7 +193,7 @@ class MachMessage {
   bool IsSimpleMessage() const { return GetDescriptorCount() == 0; }
 
   // Sets raw data for the message (returns false if not enough space)
-  bool SetData(void *data, int32_t data_length);
+  bool SetData(void* data, int32_t data_length);
 
  protected:
   // Consider this an abstract base class - must create an actual instance
@@ -216,7 +216,7 @@ class MachMessage {
   MessageDataPacket* GetDataPacket();
 
   void SetDescriptorCount(int n);
-  void SetDescriptor(int n, const MachMsgPortDescriptor &desc);
+  void SetDescriptor(int n, const MachMsgPortDescriptor& desc);
 
   // Returns total message size setting msgh_size in the header to this value
   mach_msg_size_t CalculateSize();
@@ -236,7 +236,7 @@ class MachMessage {
 //==============================================================================
 class MachReceiveMessage : public MachMessage {
  public:
-  MachReceiveMessage() : MachMessage() {};
+  MachReceiveMessage() : MachMessage() {}
 };
 
 //==============================================================================
@@ -250,7 +250,7 @@ class MachSendMessage : public MachMessage {
 class ReceivePort {
  public:
   // Creates a new mach port for receiving messages and registers a name for it
-  explicit ReceivePort(const char *receive_port_name);
+  explicit ReceivePort(const char* receive_port_name);
 
   // Given an already existing mach port, use it.  We take ownership of the
   // port and deallocate it in our destructor.
@@ -262,7 +262,7 @@ class ReceivePort {
   ~ReceivePort();
 
   // Waits on the mach port until message received or timeout
-  kern_return_t WaitForMessage(MachReceiveMessage *out_message,
+  kern_return_t WaitForMessage(MachReceiveMessage* out_message,
                                mach_msg_timeout_t timeout);
 
   // The underlying mach port that we wrap
@@ -280,13 +280,13 @@ class ReceivePort {
 class MachPortSender {
  public:
   // get a port with send rights corresponding to a named registered service
-  explicit MachPortSender(const char *receive_port_name);
+  explicit MachPortSender(const char* receive_port_name);
 
 
   // Given an already existing mach port, use it.
   explicit MachPortSender(mach_port_t send_port);
 
-  kern_return_t SendMessage(MachSendMessage &message,
+  kern_return_t SendMessage(MachSendMessage& message,
                             mach_msg_timeout_t timeout);
 
  private:
diff --git a/src/MEGASync/google_breakpad/common/mac/MachIPC.mm b/src/MEGASync/google_breakpad/common/mac/MachIPC.mm
index dc9773f7..b41a825d 100644
--- a/src/MEGASync/google_breakpad/common/mac/MachIPC.mm
+++ b/src/MEGASync/google_breakpad/common/mac/MachIPC.mm
@@ -52,7 +52,7 @@ MachSendMessage::MachSendMessage(int32_t message_id) : MachMessage() {
 
 //==============================================================================
 // returns true if successful
-bool MachMessage::SetData(void *data,
+bool MachMessage::SetData(void* data,
                           int32_t data_length) {
   // first check to make sure we have enough space
   size_t size = CalculateSize();
@@ -90,9 +90,9 @@ mach_msg_size_t MachMessage::CalculateSize() {
 }
 
 //==============================================================================
-MachMessage::MessageDataPacket *MachMessage::GetDataPacket() {
+MachMessage::MessageDataPacket* MachMessage::GetDataPacket() {
   size_t desc_size = sizeof(MachMsgPortDescriptor)*GetDescriptorCount();
-  MessageDataPacket *packet =
+  MessageDataPacket* packet =
     reinterpret_cast<MessageDataPacket*>(padding + desc_size);
 
   return packet;
@@ -100,15 +100,15 @@ MachMessage::MessageDataPacket *MachMessage::GetDataPacket() {
 
 //==============================================================================
 void MachMessage::SetDescriptor(int n,
-                                const MachMsgPortDescriptor &desc) {
-  MachMsgPortDescriptor *desc_array =
+                                const MachMsgPortDescriptor& desc) {
+  MachMsgPortDescriptor* desc_array =
     reinterpret_cast<MachMsgPortDescriptor*>(padding);
   desc_array[n] = desc;
 }
 
 //==============================================================================
 // returns true if successful otherwise there was not enough space
-bool MachMessage::AddDescriptor(const MachMsgPortDescriptor &desc) {
+bool MachMessage::AddDescriptor(const MachMsgPortDescriptor& desc) {
   // first check to make sure we have enough space
   int size = CalculateSize();
   size_t new_size = size + sizeof(MachMsgPortDescriptor);
@@ -119,7 +119,7 @@ bool MachMessage::AddDescriptor(const MachMsgPortDescriptor &desc) {
 
   // unfortunately, we need to move the data to allow space for the
   // new descriptor
-  u_int8_t *p = reinterpret_cast<u_int8_t*>(GetDataPacket());
+  u_int8_t* p = reinterpret_cast<u_int8_t*>(GetDataPacket());
   bcopy(p, p+sizeof(MachMsgPortDescriptor), GetDataLength()+2*sizeof(int32_t));
   
   SetDescriptor(GetDescriptorCount(), desc);
@@ -142,9 +142,9 @@ void MachMessage::SetDescriptorCount(int n) {
 }
 
 //==============================================================================
-MachMsgPortDescriptor *MachMessage::GetDescriptor(int n) {
+MachMsgPortDescriptor* MachMessage::GetDescriptor(int n) {
   if (n < GetDescriptorCount()) {
-    MachMsgPortDescriptor *desc =
+    MachMsgPortDescriptor* desc =
       reinterpret_cast<MachMsgPortDescriptor*>(padding);
     return desc + n;
   }
@@ -164,7 +164,7 @@ mach_port_t MachMessage::GetTranslatedPort(int n) {
 
 //==============================================================================
 // create a new mach port for receiving messages and register a name for it
-ReceivePort::ReceivePort(const char *receive_port_name) {
+ReceivePort::ReceivePort(const char* receive_port_name) {
   mach_port_t current_task = mach_task_self();
 
   init_result_ = mach_port_allocate(current_task,
@@ -227,7 +227,7 @@ ReceivePort::~ReceivePort() {
 }
 
 //==============================================================================
-kern_return_t ReceivePort::WaitForMessage(MachReceiveMessage *out_message,
+kern_return_t ReceivePort::WaitForMessage(MachReceiveMessage* out_message,
                                           mach_msg_timeout_t timeout) {
   if (!out_message) {
     return KERN_INVALID_ARGUMENT;
@@ -261,7 +261,7 @@ kern_return_t ReceivePort::WaitForMessage(MachReceiveMessage *out_message,
 
 //==============================================================================
 // get a port with send rights corresponding to a named registered service
-MachPortSender::MachPortSender(const char *receive_port_name) {
+MachPortSender::MachPortSender(const char* receive_port_name) {
   mach_port_t task_bootstrap_port = 0;
   init_result_ = task_get_bootstrap_port(mach_task_self(), 
                                          &task_bootstrap_port);
@@ -281,7 +281,7 @@ MachPortSender::MachPortSender(mach_port_t send_port)
 }
 
 //==============================================================================
-kern_return_t MachPortSender::SendMessage(MachSendMessage &message,
+kern_return_t MachPortSender::SendMessage(MachSendMessage& message,
                                           mach_msg_timeout_t timeout) {
   if (message.head.msgh_size == 0) {
     return KERN_INVALID_VALUE;    // just for safety -- never should occur
diff --git a/src/MEGASync/google_breakpad/common/mac/SymbolCollectorClient.h b/src/MEGASync/google_breakpad/common/mac/SymbolCollectorClient.h
new file mode 100644
index 00000000..9e955c8e
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/mac/SymbolCollectorClient.h
@@ -0,0 +1,103 @@
+// Copyright (c) 2020, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Foundation/Foundation.h>
+
+NS_ASSUME_NONNULL_BEGIN
+
+/**
+ Represents a response from a sym-upload-v2 server to a createUploadURLOnServer
+ call.
+ */
+@interface UploadURLResponse : NSObject {
+ @protected
+  NSString* uploadURL_;
+  NSString* uploadKey_;
+}
+
+- (id)initWithUploadURL:(NSString*)uploadURL withUploadKey:(NSString*)uploadKey;
+
+- (NSString*)uploadURL;
+- (NSString*)uploadKey;
+@end
+
+/**
+ Possible return statuses from a sym-upload-v2 server to a
+ completeUploadOnServer call.
+ */
+typedef NS_ENUM(NSInteger, CompleteUploadResult) {
+  CompleteUploadResultOk,
+  CompleteUploadResultDuplicateData,
+  CompleteUploadResultError
+};
+
+/**
+ Possible return statuses from a sym-upload-v2 server to a
+ checkSymbolStatusOnServer call.
+ */
+typedef NS_ENUM(NSInteger, SymbolStatus) {
+  SymbolStatusFound,
+  SymbolStatusMissing,
+  SymbolStatusUnknown
+};
+
+/**
+ Interface to help a client interact with a sym-upload-v2 server, over HTTP.
+ For details of the API and protocol, see :/docs/sym_upload_v2_protocol.md.
+ */
+@interface SymbolCollectorClient : NSObject
+;
+
+/**
+ Calls the /v1/symbols/{debug_file}/{debug_id}:checkStatus API on the server.
+ */
++ (SymbolStatus)checkSymbolStatusOnServer:(NSString*)APIURL
+                               withAPIKey:(NSString*)APIKey
+                            withDebugFile:(NSString*)debugFile
+                              withDebugID:(NSString*)debugID;
+
+/**
+ Calls the /v1/uploads:create API on the server.
+ */
++ (UploadURLResponse*)createUploadURLOnServer:(NSString*)APIURL
+                                   withAPIKey:(NSString*)APIKey;
+
+/**
+ Calls the /v1/uploads/{key}:complete API on the server.
+ */
++ (CompleteUploadResult)completeUploadOnServer:(NSString*)APIURL
+                                    withAPIKey:(NSString*)APIKey
+                                 withUploadKey:(NSString*)uploadKey
+                                 withDebugFile:(NSString*)debugFile
+                                   withDebugID:(NSString*)debugID
+                                      withType:(NSString*)type;
+
+@end
+
+NS_ASSUME_NONNULL_END
diff --git a/src/MEGASync/google_breakpad/common/mac/SymbolCollectorClient.m b/src/MEGASync/google_breakpad/common/mac/SymbolCollectorClient.m
new file mode 100644
index 00000000..5926d2ad
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/mac/SymbolCollectorClient.m
@@ -0,0 +1,268 @@
+// Copyright (c) 2020, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "SymbolCollectorClient.h"
+
+#import "HTTPGetRequest.h"
+#import "HTTPSimplePostRequest.h"
+
+@implementation UploadURLResponse
+
+//=============================================================================
+- (id)initWithUploadURL:(NSString*)uploadURL
+          withUploadKey:(NSString*)uploadKey {
+  if (self = [super init]) {
+    uploadURL_ = [uploadURL copy];
+    uploadKey_ = [uploadKey copy];
+  }
+  return self;
+}
+
+//=============================================================================
+- (void)dealloc {
+  [uploadURL_ release];
+  [uploadKey_ release];
+
+  [super dealloc];
+}
+
+//=============================================================================
+- (NSString*)uploadURL {
+  return uploadURL_;
+}
+
+//=============================================================================
+- (NSString*)uploadKey {
+  return uploadKey_;
+}
+@end
+
+@implementation SymbolCollectorClient
+
+//=============================================================================
++ (SymbolStatus)checkSymbolStatusOnServer:(NSString*)APIURL
+                               withAPIKey:(NSString*)APIKey
+                            withDebugFile:(NSString*)debugFile
+                              withDebugID:(NSString*)debugID {
+  // Note that forward-slash is listed as a character to escape here, for
+  // completeness, however it is illegal in a debugFile input.
+  NSMutableCharacterSet* allowedDebugFileCharacters = [NSMutableCharacterSet
+      characterSetWithCharactersInString:@" \"\\/#%:?@|^`{}<>[]&=;"];
+  [allowedDebugFileCharacters
+      formUnionWithCharacterSet:[NSCharacterSet controlCharacterSet]];
+  [allowedDebugFileCharacters invert];
+  NSString* escapedDebugFile =
+      [debugFile stringByAddingPercentEncodingWithAllowedCharacters:
+                     allowedDebugFileCharacters];
+
+  NSURL* URL = [NSURL
+      URLWithString:[NSString
+                        stringWithFormat:@"%@/v1/symbols/%@/%@:checkStatus"
+                                         @"?key=%@",
+                                         APIURL, escapedDebugFile, debugID,
+                                         APIKey]];
+
+  HTTPGetRequest* getRequest = [[HTTPGetRequest alloc] initWithURL:URL];
+  NSError* error = nil;
+  NSData* data = [getRequest send:&error];
+  NSString* result = [[NSString alloc] initWithData:data
+                                           encoding:NSUTF8StringEncoding];
+  int responseCode = [[getRequest response] statusCode];
+  [getRequest release];
+
+  if (error || responseCode != 200) {
+    fprintf(stdout, "Failed to check symbol status.\n");
+    fprintf(stdout, "Response code: %d\n", responseCode);
+    fprintf(stdout, "Response:\n");
+    fprintf(stdout, "%s\n", [result UTF8String]);
+    return SymbolStatusUnknown;
+  }
+
+  error = nil;
+  NSRegularExpression* statusRegex = [NSRegularExpression
+      regularExpressionWithPattern:@"\"status\": \"([^\"]+)\""
+                           options:0
+                             error:&error];
+  NSArray* matches =
+      [statusRegex matchesInString:result
+                           options:0
+                             range:NSMakeRange(0, [result length])];
+  if ([matches count] != 1) {
+    fprintf(stdout, "Failed to parse check symbol status response.");
+    fprintf(stdout, "Response:\n");
+    fprintf(stdout, "%s\n", [result UTF8String]);
+    return SymbolStatusUnknown;
+  }
+
+  NSString* status = [result substringWithRange:[matches[0] rangeAtIndex:1]];
+  [result release];
+
+  return [status isEqualToString:@"FOUND"] ? SymbolStatusFound
+                                           : SymbolStatusMissing;
+}
+
+//=============================================================================
++ (UploadURLResponse*)createUploadURLOnServer:(NSString*)APIURL
+                                   withAPIKey:(NSString*)APIKey {
+  NSURL* URL = [NSURL
+      URLWithString:[NSString stringWithFormat:@"%@/v1/uploads:create?key=%@",
+                                               APIURL, APIKey]];
+
+  HTTPSimplePostRequest* postRequest =
+      [[HTTPSimplePostRequest alloc] initWithURL:URL];
+  NSError* error = nil;
+  NSData* data = [postRequest send:&error];
+  NSString* result = [[NSString alloc] initWithData:data
+                                           encoding:NSUTF8StringEncoding];
+  int responseCode = [[postRequest response] statusCode];
+  [postRequest release];
+
+  if (error || responseCode != 200) {
+    fprintf(stdout, "Failed to create upload URL.\n");
+    fprintf(stdout, "Response code: %d\n", responseCode);
+    fprintf(stdout, "Response:\n");
+    fprintf(stdout, "%s\n", [result UTF8String]);
+    return nil;
+  }
+
+  // Note camel-case rather than underscores.
+  NSRegularExpression* uploadURLRegex = [NSRegularExpression
+      regularExpressionWithPattern:@"\"uploadUrl\": \"([^\"]+)\""
+                           options:0
+                             error:&error];
+  NSRegularExpression* uploadKeyRegex = [NSRegularExpression
+      regularExpressionWithPattern:@"\"uploadKey\": \"([^\"]+)\""
+                           options:0
+                             error:&error];
+
+  NSArray* uploadURLMatches =
+      [uploadURLRegex matchesInString:result
+                              options:0
+                                range:NSMakeRange(0, [result length])];
+  NSArray* uploadKeyMatches =
+      [uploadKeyRegex matchesInString:result
+                              options:0
+                                range:NSMakeRange(0, [result length])];
+  if ([uploadURLMatches count] != 1 || [uploadKeyMatches count] != 1) {
+    fprintf(stdout, "Failed to parse create url response.");
+    fprintf(stdout, "Response:\n");
+    fprintf(stdout, "%s\n", [result UTF8String]);
+    return nil;
+  }
+  NSString* uploadURL =
+      [result substringWithRange:[uploadURLMatches[0] rangeAtIndex:1]];
+  NSString* uploadKey =
+      [result substringWithRange:[uploadKeyMatches[0] rangeAtIndex:1]];
+
+  return [[UploadURLResponse alloc] initWithUploadURL:uploadURL
+                                        withUploadKey:uploadKey];
+}
+
+//=============================================================================
++ (CompleteUploadResult)completeUploadOnServer:(NSString*)APIURL
+                                    withAPIKey:(NSString*)APIKey
+                                 withUploadKey:(NSString*)uploadKey
+                                 withDebugFile:(NSString*)debugFile
+                                   withDebugID:(NSString*)debugID
+                                      withType:(NSString*)type {
+  NSURL* URL = [NSURL
+      URLWithString:[NSString
+                        stringWithFormat:@"%@/v1/uploads/%@:complete?key=%@",
+                                         APIURL, uploadKey, APIKey]];
+
+  NSDictionary* symbolIdDictionary =
+      [NSDictionary dictionaryWithObjectsAndKeys:debugFile, @"debug_file",
+                                                 debugID, @"debug_id", nil];
+  NSDictionary* jsonDictionary = [NSDictionary
+      dictionaryWithObjectsAndKeys:symbolIdDictionary, @"symbol_id", type,
+                                   @"symbol_upload_type", nil];
+  NSError* error = nil;
+  NSData* jsonData =
+      [NSJSONSerialization dataWithJSONObject:jsonDictionary
+                                      options:NSJSONWritingPrettyPrinted
+                                        error:&error];
+  if (jsonData == nil) {
+    fprintf(stdout, "Error: %s\n", [[error localizedDescription] UTF8String]);
+    fprintf(stdout,
+            "Failed to complete upload. Could not write JSON payload.\n");
+    return CompleteUploadResultError;
+  }
+
+  NSString* body = [[NSString alloc] initWithData:jsonData
+                                         encoding:NSUTF8StringEncoding];
+  HTTPSimplePostRequest* postRequest =
+      [[HTTPSimplePostRequest alloc] initWithURL:URL];
+  [postRequest setBody:body];
+  [postRequest setContentType:@"application/json"];
+
+  NSData* data = [postRequest send:&error];
+  if (data == nil) {
+    fprintf(stdout, "Error: %s\n", [[error localizedDescription] UTF8String]);
+    fprintf(stdout, "Failed to complete upload URL.\n");
+    return CompleteUploadResultError;
+  }
+
+  NSString* result = [[NSString alloc] initWithData:data
+                                           encoding:NSUTF8StringEncoding];
+  int responseCode = [[postRequest response] statusCode];
+  [postRequest release];
+  if (responseCode != 200) {
+    fprintf(stdout, "Failed to complete upload URL.\n");
+    fprintf(stdout, "Response code: %d\n", responseCode);
+    fprintf(stdout, "Response:\n");
+    fprintf(stdout, "%s\n", [result UTF8String]);
+    return CompleteUploadResultError;
+  }
+
+  // Note camel-case rather than underscores.
+  NSRegularExpression* completeResultRegex = [NSRegularExpression
+      regularExpressionWithPattern:@"\"result\": \"([^\"]+)\""
+                           options:0
+                             error:&error];
+
+  NSArray* completeResultMatches =
+      [completeResultRegex matchesInString:result
+                                   options:0
+                                     range:NSMakeRange(0, [result length])];
+
+  if ([completeResultMatches count] != 1) {
+    fprintf(stdout, "Failed to parse complete upload response.");
+    fprintf(stdout, "Response:\n");
+    fprintf(stdout, "%s\n", [result UTF8String]);
+    return CompleteUploadResultError;
+  }
+  NSString* completeResult =
+      [result substringWithRange:[completeResultMatches[0] rangeAtIndex:1]];
+  [result release];
+
+  return ([completeResult isEqualToString:@"DUPLICATE_DATA"])
+             ? CompleteUploadResultDuplicateData
+             : CompleteUploadResultOk;
+}
+@end
diff --git a/src/MEGASync/google_breakpad/common/mac/arch_utilities.cc b/src/MEGASync/google_breakpad/common/mac/arch_utilities.cc
index 94e3be3b..c0e4bac5 100644
--- a/src/MEGASync/google_breakpad/common/mac/arch_utilities.cc
+++ b/src/MEGASync/google_breakpad/common/mac/arch_utilities.cc
@@ -30,38 +30,47 @@
 #include "common/mac/arch_utilities.h"
 
 #include <mach-o/arch.h>
+#include <mach-o/fat.h>
 #include <stdio.h>
 #include <string.h>
 
-#ifndef CPU_TYPE_ARM
-#define CPU_TYPE_ARM (static_cast<cpu_type_t>(12))
-#endif  // CPU_TYPE_ARM
-
-#ifndef CPU_SUBTYPE_ARM_V7
-#define CPU_SUBTYPE_ARM_V7 (static_cast<cpu_subtype_t>(9))
-#endif  // CPU_SUBTYPE_ARM_V7
-
 #ifndef CPU_SUBTYPE_ARM_V7S
 #define CPU_SUBTYPE_ARM_V7S (static_cast<cpu_subtype_t>(11))
 #endif  // CPU_SUBTYPE_ARM_V7S
 
 #ifndef CPU_TYPE_ARM64
-#define CPU_TYPE_ARM64 (static_cast<cpu_type_t>(16777228))
+#define CPU_TYPE_ARM64 (CPU_TYPE_ARM | CPU_ARCH_ABI64)
 #endif  // CPU_TYPE_ARM64
 
 #ifndef CPU_SUBTYPE_ARM64_ALL
-#define CPU_SUBTYPE_ARM64_ALL (static_cast<cpu_type_t>(0))
+#define CPU_SUBTYPE_ARM64_ALL (static_cast<cpu_subtype_t>(0))
 #endif  // CPU_SUBTYPE_ARM64_ALL
 
+#ifndef CPU_SUBTYPE_ARM64_E
+#define CPU_SUBTYPE_ARM64_E (static_cast<cpu_subtype_t>(2))
+#endif  // CPU_SUBTYPE_ARM64_E
+
 namespace {
 
-const NXArchInfo* ArchInfo_arm64() {
+const NXArchInfo* ArchInfo_arm64(cpu_subtype_t cpu_subtype) {
+  const char* name = NULL;
+  switch (cpu_subtype) {
+    case CPU_SUBTYPE_ARM64_ALL:
+      name = "arm64";
+      break;
+    case CPU_SUBTYPE_ARM64_E:
+      name = "arm64e";
+      break;
+    default:
+      return NULL;
+  }
+
   NXArchInfo* arm64 = new NXArchInfo;
   *arm64 = *NXGetArchInfoFromCpuType(CPU_TYPE_ARM,
                                      CPU_SUBTYPE_ARM_V7);
-  arm64->name = "arm64";
+  arm64->name = name;
   arm64->cputype = CPU_TYPE_ARM64;
-  arm64->cpusubtype = CPU_SUBTYPE_ARM64_ALL;
+  arm64->cpusubtype = cpu_subtype;
   arm64->description = "arm 64";
   return arm64;
 }
@@ -86,6 +95,10 @@ const NXArchInfo* BreakpadGetArchInfoFromName(const char* arch_name) {
     return BreakpadGetArchInfoFromCpuType(CPU_TYPE_ARM64,
                                           CPU_SUBTYPE_ARM64_ALL);
 
+  if (!strcmp("arm64e", arch_name))
+    return BreakpadGetArchInfoFromCpuType(CPU_TYPE_ARM64,
+                                          CPU_SUBTYPE_ARM64_E);
+
   // TODO: Remove this when the OS knows about armv7s.
   if (!strcmp("armv7s", arch_name))
     return BreakpadGetArchInfoFromCpuType(CPU_TYPE_ARM, CPU_SUBTYPE_ARM_V7S);
@@ -97,10 +110,15 @@ const NXArchInfo* BreakpadGetArchInfoFromCpuType(cpu_type_t cpu_type,
                                                  cpu_subtype_t cpu_subtype) {
   // TODO: Remove this when the OS knows about arm64.
   if (cpu_type == CPU_TYPE_ARM64 && cpu_subtype == CPU_SUBTYPE_ARM64_ALL) {
-    static const NXArchInfo* arm64 = ArchInfo_arm64();
+    static const NXArchInfo* arm64 = ArchInfo_arm64(cpu_subtype);
     return arm64;
   }
 
+  if (cpu_type == CPU_TYPE_ARM64 && cpu_subtype == CPU_SUBTYPE_ARM64_E) {
+    static const NXArchInfo* arm64e = ArchInfo_arm64(cpu_subtype);
+    return arm64e;
+  }
+
   // TODO: Remove this when the OS knows about armv7s.
   if (cpu_type == CPU_TYPE_ARM && cpu_subtype == CPU_SUBTYPE_ARM_V7S) {
     static const NXArchInfo* armv7s = ArchInfo_armv7s();
@@ -111,3 +129,136 @@ const NXArchInfo* BreakpadGetArchInfoFromCpuType(cpu_type_t cpu_type,
 }
 
 }  // namespace google_breakpad
+
+#ifndef __APPLE__
+namespace {
+
+enum Architecture {
+  kArch_i386 = 0,
+  kArch_x86_64,
+  kArch_x86_64h,
+  kArch_arm,
+  kArch_arm64,
+  kArch_arm64e,
+  kArch_ppc,
+  // This must be last.
+  kNumArchitectures
+};
+
+// enum Architecture above and kKnownArchitectures below
+// must be kept in sync.
+const NXArchInfo kKnownArchitectures[] = {
+  {
+    "i386",
+    CPU_TYPE_I386,
+    CPU_SUBTYPE_I386_ALL,
+    NX_LittleEndian,
+    "Intel 80x86"
+  },
+  {
+    "x86_64",
+    CPU_TYPE_X86_64,
+    CPU_SUBTYPE_X86_64_ALL,
+    NX_LittleEndian,
+    "Intel x86-64"
+  },
+  {
+    "x86_64h",
+    CPU_TYPE_X86_64,
+    CPU_SUBTYPE_X86_64_H,
+    NX_LittleEndian,
+    "Intel x86-64h Haswell"
+  },
+  {
+    "arm",
+    CPU_TYPE_ARM,
+    CPU_SUBTYPE_ARM_ALL,
+    NX_LittleEndian,
+    "ARM"
+  },
+  {
+    "arm64",
+    CPU_TYPE_ARM64,
+    CPU_SUBTYPE_ARM64_ALL,
+    NX_LittleEndian,
+    "ARM64"
+  },
+  {
+    "arm64e",
+    CPU_TYPE_ARM64,
+    CPU_SUBTYPE_ARM64_E,
+    NX_LittleEndian,
+    "ARM64e"
+  },
+  {
+    "ppc",
+    CPU_TYPE_POWERPC,
+    CPU_SUBTYPE_POWERPC_ALL,
+    NX_BigEndian,
+    "PowerPC"
+  }
+};
+
+}  // namespace
+
+const NXArchInfo *NXGetLocalArchInfo(void) {
+  Architecture arch;
+#if defined(__i386__)
+  arch = kArch_i386;
+#elif defined(__x86_64__)
+  arch = kArch_x86_64;
+#elif defined(__arm64)
+  arch = kArch_arm64;
+#elif defined(__arm__)
+  arch = kArch_arm;
+#elif defined(__powerpc__)
+  arch = kArch_ppc;
+#else
+  #error "Unsupported CPU architecture"
+#endif
+  return &kKnownArchitectures[arch];
+}
+
+const NXArchInfo *NXGetArchInfoFromName(const char *name) {
+  for (int arch = 0; arch < kNumArchitectures; ++arch) {
+    if (!strcmp(name, kKnownArchitectures[arch].name)) {
+      return &kKnownArchitectures[arch];
+    }
+  }
+  return NULL;
+}
+
+const NXArchInfo *NXGetArchInfoFromCpuType(cpu_type_t cputype,
+                                           cpu_subtype_t cpusubtype) {
+  const NXArchInfo *candidate = NULL;
+  for (int arch = 0; arch < kNumArchitectures; ++arch) {
+    if (kKnownArchitectures[arch].cputype == cputype) {
+      if (kKnownArchitectures[arch].cpusubtype == cpusubtype) {
+        return &kKnownArchitectures[arch];
+      }
+      if (!candidate) {
+        candidate = &kKnownArchitectures[arch];
+      }
+    }
+  }
+  return candidate;
+}
+
+struct fat_arch *NXFindBestFatArch(cpu_type_t cputype,
+                                   cpu_subtype_t cpusubtype,
+                                   struct fat_arch *fat_archs,
+                                   uint32_t nfat_archs) {
+  struct fat_arch *candidate = NULL;
+  for (uint32_t f = 0; f < nfat_archs; ++f) {
+    if (fat_archs[f].cputype == cputype) {
+      if (fat_archs[f].cpusubtype == cpusubtype) {
+        return &fat_archs[f];
+      }
+      if (!candidate) {
+        candidate = &fat_archs[f];
+      }
+    }
+  }
+  return candidate;
+}
+#endif  // !__APPLE__
diff --git a/src/MEGASync/google_breakpad/common/mac/byteswap.h b/src/MEGASync/google_breakpad/common/mac/byteswap.h
index a5d745b3..b7bbc0b9 100644
--- a/src/MEGASync/google_breakpad/common/mac/byteswap.h
+++ b/src/MEGASync/google_breakpad/common/mac/byteswap.h
@@ -36,6 +36,7 @@
 #ifndef COMMON_MAC_BYTESWAP_H_
 #define COMMON_MAC_BYTESWAP_H_
 
+#ifdef __APPLE__
 #include <libkern/OSByteOrder.h>
 
 static inline uint16_t ByteSwap(uint16_t v) { return OSSwapInt16(v); }
@@ -45,4 +46,28 @@ static inline int16_t  ByteSwap(int16_t  v) { return OSSwapInt16(v); }
 static inline int32_t  ByteSwap(int32_t  v) { return OSSwapInt32(v); }
 static inline int64_t  ByteSwap(int64_t  v) { return OSSwapInt64(v); }
 
+#elif defined(__linux__)
+// For NXByteOrder
+#include <architecture/byte_order.h>
+#include <stdint.h>
+#include <endian.h>
+#include_next <byteswap.h>
+
+static inline uint16_t ByteSwap(uint16_t v) { return bswap_16(v); }
+static inline uint32_t ByteSwap(uint32_t v) { return bswap_32(v); }
+static inline uint64_t ByteSwap(uint64_t v) { return bswap_64(v); }
+static inline int16_t  ByteSwap(int16_t  v) { return bswap_16(v); }
+static inline int32_t  ByteSwap(int32_t  v) { return bswap_32(v); }
+static inline int64_t  ByteSwap(int64_t  v) { return bswap_64(v); }
+
+static inline NXByteOrder NXHostByteOrder() {
+#ifdef __LITTLE_ENDIAN
+  return NX_LittleEndian;
+#else
+  return NX_BigEndian;
+#endif
+}
+
+#endif  // __APPLE__
+
 #endif  // COMMON_MAC_BYTESWAP_H_
diff --git a/src/MEGASync/google_breakpad/common/mac/dump_syms.mm b/src/MEGASync/google_breakpad/common/mac/dump_syms.cc
similarity index 60%
rename from src/MEGASync/google_breakpad/common/mac/dump_syms.mm
rename to src/MEGASync/google_breakpad/common/mac/dump_syms.cc
index 2e3a6a96..24bcd653 100644
--- a/src/MEGASync/google_breakpad/common/mac/dump_syms.mm
+++ b/src/MEGASync/google_breakpad/common/mac/dump_syms.cc
@@ -31,14 +31,20 @@
 
 // Author: Jim Blandy <jimb@mozilla.com> <jimb@red-bean.com>
 
-// dump_syms.mm: Create a symbol file for use with minidumps
+// dump_syms.cc: Create a symbol file for use with minidumps
 
 #include "common/mac/dump_syms.h"
 
-#include <Foundation/Foundation.h>
+#include <assert.h>
+#include <dirent.h>
+#include <errno.h>
 #include <mach-o/arch.h>
 #include <mach-o/fat.h>
+#include <stdint.h>
 #include <stdio.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
 
 #include <ostream>
 #include <string>
@@ -49,10 +55,12 @@
 #include "common/dwarf_cfi_to_module.h"
 #include "common/dwarf_cu_to_module.h"
 #include "common/dwarf_line_to_module.h"
+#include "common/dwarf_range_list_handler.h"
 #include "common/mac/file_id.h"
 #include "common/mac/arch_utilities.h"
 #include "common/mac/macho_reader.h"
 #include "common/module.h"
+#include "common/path_helper.h"
 #include "common/scoped_ptr.h"
 #include "common/stabs_reader.h"
 #include "common/stabs_to_module.h"
@@ -62,9 +70,14 @@
 #define CPU_TYPE_ARM (static_cast<cpu_type_t>(12))
 #endif //  CPU_TYPE_ARM
 
+#ifndef CPU_TYPE_ARM64
+#define CPU_TYPE_ARM64 (static_cast<cpu_type_t>(16777228))
+#endif  // CPU_TYPE_ARM64
+
 using dwarf2reader::ByteReader;
 using google_breakpad::DwarfCUToModule;
 using google_breakpad::DwarfLineToModule;
+using google_breakpad::DwarfRangeListHandler;
 using google_breakpad::FileID;
 using google_breakpad::mach_o::FatReader;
 using google_breakpad::mach_o::Section;
@@ -78,104 +91,120 @@ using std::pair;
 using std::string;
 using std::vector;
 
+namespace {
+// Return a vector<string> with absolute paths to all the entries
+// in directory (excluding . and ..).
+vector<string> list_directory(const string& directory) {
+  vector<string> entries;
+  DIR* dir = opendir(directory.c_str());
+  if (!dir) {
+    return entries;
+  }
+
+  string path = directory;
+  if (path[path.length() - 1] != '/') {
+    path += '/';
+  }
+
+  struct dirent* entry = NULL;
+  while ((entry = readdir(dir))) {
+    if (strcmp(entry->d_name, ".") != 0 && strcmp(entry->d_name, "..") != 0) {
+      entries.push_back(path + entry->d_name);
+    }
+  }
+
+  closedir(dir);
+  return entries;
+}
+}
+
 namespace google_breakpad {
 
-bool DumpSymbols::Read(NSString *filename) {
-  if (![[NSFileManager defaultManager] fileExistsAtPath:filename]) {
-    fprintf(stderr, "Object file does not exist: %s\n",
-            [filename fileSystemRepresentation]);
+bool DumpSymbols::Read(const string& filename) {
+  struct stat st;
+  if (stat(filename.c_str(), &st) == -1) {
+    fprintf(stderr, "Could not access object file %s: %s\n",
+            filename.c_str(), strerror(errno));
     return false;
   }
 
-  input_pathname_ = [filename retain];
+  input_pathname_ = filename;
 
   // Does this filename refer to a dSYM bundle?
-  NSBundle *bundle = [NSBundle bundleWithPath:input_pathname_];
-
-  if (bundle) {
-    // Filenames referring to bundles usually have names of the form
-    // "<basename>.dSYM"; however, if the user has specified a wrapper
-    // suffix (the WRAPPER_SUFFIX and WRAPPER_EXTENSION build settings),
-    // then the name may have the form "<basename>.<extension>.dSYM". In
-    // either case, the resource name for the file containing the DWARF
-    // info within the bundle is <basename>.
-    //
-    // Since there's no way to tell how much to strip off, remove one
-    // extension at a time, and use the first one that
-    // pathForResource:ofType:inDirectory likes.
-    NSString *base_name = [input_pathname_ lastPathComponent];
-    NSString *dwarf_resource;
-
-    do {
-      NSString *new_base_name = [base_name stringByDeletingPathExtension];
-
-      // If stringByDeletingPathExtension returned the name unchanged, then
-      // there's nothing more for us to strip off --- lose.
-      if ([new_base_name isEqualToString:base_name]) {
-        fprintf(stderr, "Unable to find DWARF-bearing file in bundle: %s\n",
-                [input_pathname_ fileSystemRepresentation]);
-        return false;
-      }
-
-      // Take the shortened result as our new base_name.
-      base_name = new_base_name;
-
-      // Try to find a DWARF resource in the bundle under the new base_name.
-      dwarf_resource = [bundle pathForResource:base_name
-                        ofType:nil inDirectory:@"DWARF"];
-    } while (!dwarf_resource);
+  string contents_path = input_pathname_ + "/Contents/Resources/DWARF";
+  if (S_ISDIR(st.st_mode) &&
+      access(contents_path.c_str(), F_OK) == 0) {
+    // If there's one file under Contents/Resources/DWARF then use that,
+    // otherwise bail out.
+    const vector<string> entries = list_directory(contents_path);
+    if (entries.size() == 0) {
+      fprintf(stderr, "Unable to find DWARF-bearing file in bundle: %s\n",
+              input_pathname_.c_str());
+      return false;
+    }
+    if (entries.size() > 1) {
+      fprintf(stderr, "Too many DWARF files in bundle: %s\n",
+              input_pathname_.c_str());
+      return false;
+    }
 
-    object_filename_ = [dwarf_resource retain];
+    object_filename_ = entries[0];
   } else {
-    object_filename_ = [input_pathname_ retain];
+    object_filename_ = input_pathname_;
   }
 
   // Read the file's contents into memory.
-  //
-  // The documentation for dataWithContentsOfMappedFile says:
-  //
-  //     Because of file mapping restrictions, this method should only be
-  //     used if the file is guaranteed to exist for the duration of the
-  //     data objects existence. It is generally safer to use the
-  //     dataWithContentsOfFile: method.
-  //
-  // I gather this means that OS X doesn't have (or at least, that method
-  // doesn't use) a form of mapping like Linux's MAP_PRIVATE, where the
-  // process appears to get its own copy of the data, and changes to the
-  // file don't affect memory and vice versa).
-  NSError *error;
-  contents_ = [NSData dataWithContentsOfFile:object_filename_
-                                     options:0
-                                       error:&error];
-  if (!contents_) {
+  bool read_ok = true;
+  string error;
+  if (stat(object_filename_.c_str(), &st) != -1) {
+    FILE* f = fopen(object_filename_.c_str(), "rb");
+    if (f) {
+      contents_.reset(new uint8_t[st.st_size]);
+      off_t total = 0;
+      while (total < st.st_size && !feof(f)) {
+        size_t read = fread(&contents_[0] + total, 1, st.st_size - total, f);
+        if (read == 0) {
+          if (ferror(f)) {
+            read_ok = false;
+            error = strerror(errno);
+          }
+          break;
+        }
+        total += read;
+      }
+      fclose(f);
+    } else {
+      error = strerror(errno);
+    }
+  }
+
+  if (!read_ok) {
     fprintf(stderr, "Error reading object file: %s: %s\n",
-            [object_filename_ fileSystemRepresentation],
-            [[error localizedDescription] UTF8String]);
+            object_filename_.c_str(),
+            error.c_str());
     return false;
   }
-  [contents_ retain];
 
   // Get the list of object files present in the file.
-  FatReader::Reporter fat_reporter([object_filename_
-                                    fileSystemRepresentation]);
+  FatReader::Reporter fat_reporter(object_filename_);
   FatReader fat_reader(&fat_reporter);
-  if (!fat_reader.Read(reinterpret_cast<const uint8_t *>([contents_ bytes]),
-                       [contents_ length])) {
+  if (!fat_reader.Read(&contents_[0],
+                       st.st_size)) {
     return false;
   }
 
   // Get our own copy of fat_reader's object file list.
   size_t object_files_count;
-  const struct fat_arch *object_files =
+  const SuperFatArch* object_files =
     fat_reader.object_files(&object_files_count);
   if (object_files_count == 0) {
     fprintf(stderr, "Fat binary file contains *no* architectures: %s\n",
-            [object_filename_ fileSystemRepresentation]);
+            object_filename_.c_str());
     return false;
   }
   object_files_.resize(object_files_count);
   memcpy(&object_files_[0], object_files,
-         sizeof(struct fat_arch) * object_files_count);
+         sizeof(SuperFatArch) * object_files_count);
 
   return true;
 }
@@ -183,9 +212,8 @@ bool DumpSymbols::Read(NSString *filename) {
 bool DumpSymbols::SetArchitecture(cpu_type_t cpu_type,
                                   cpu_subtype_t cpu_subtype) {
   // Find the best match for the architecture the user requested.
-  const struct fat_arch *best_match
-    = NXFindBestFatArch(cpu_type, cpu_subtype, &object_files_[0],
-                        static_cast<uint32_t>(object_files_.size()));
+  const SuperFatArch* best_match = FindBestMatchForArchitecture(
+      cpu_type, cpu_subtype);
   if (!best_match) return false;
 
   // Record the selected object file.
@@ -193,9 +221,9 @@ bool DumpSymbols::SetArchitecture(cpu_type_t cpu_type,
   return true;
 }
 
-bool DumpSymbols::SetArchitecture(const std::string &arch_name) {
+bool DumpSymbols::SetArchitecture(const std::string& arch_name) {
   bool arch_set = false;
-  const NXArchInfo *arch_info =
+  const NXArchInfo* arch_info =
       google_breakpad::BreakpadGetArchInfoFromName(arch_name.c_str());
   if (arch_info) {
     arch_set = SetArchitecture(arch_info->cputype, arch_info->cpusubtype);
@@ -203,14 +231,65 @@ bool DumpSymbols::SetArchitecture(const std::string &arch_name) {
   return arch_set;
 }
 
+SuperFatArch* DumpSymbols::FindBestMatchForArchitecture(
+    cpu_type_t cpu_type, cpu_subtype_t cpu_subtype) {
+  // Check if all the object files can be converted to struct fat_arch.
+  bool can_convert_to_fat_arch = true;
+  vector<struct fat_arch> fat_arch_vector;
+  for (vector<SuperFatArch>::const_iterator it = object_files_.begin();
+       it != object_files_.end();
+       ++it) {
+    struct fat_arch arch;
+    bool success = it->ConvertToFatArch(&arch);
+    if (!success) {
+      can_convert_to_fat_arch = false;
+      break;
+    }
+    fat_arch_vector.push_back(arch);
+  }
+
+  // If all the object files can be converted to struct fat_arch, use
+  // NXFindBestFatArch.
+  if (can_convert_to_fat_arch) {
+    const struct fat_arch* best_match
+      = NXFindBestFatArch(cpu_type, cpu_subtype, &fat_arch_vector[0],
+                          static_cast<uint32_t>(fat_arch_vector.size()));
+
+    for (size_t i = 0; i < fat_arch_vector.size(); ++i) {
+      if (best_match == &fat_arch_vector[i])
+        return &object_files_[i];
+    }
+    assert(best_match == NULL);
+    return NULL;
+  }
+
+  // Check for an exact match with cpu_type and cpu_subtype.
+  for (vector<SuperFatArch>::iterator it = object_files_.begin();
+       it != object_files_.end();
+       ++it) {
+    if (static_cast<cpu_type_t>(it->cputype) == cpu_type &&
+        static_cast<cpu_subtype_t>(it->cpusubtype) == cpu_subtype)
+      return &*it;
+  }
+
+  // No exact match found.
+  // TODO(erikchen): If it becomes necessary, we can copy the implementation of
+  // NXFindBestFatArch, located at
+  // http://web.mit.edu/darwin/src/modules/cctools/libmacho/arch.c.
+  fprintf(stderr, "Failed to find an exact match for an object file with cpu "
+      "type: %d and cpu subtype: %d. Furthermore, at least one object file is "
+      "larger than 2**32.\n", cpu_type, cpu_subtype);
+  return NULL;
+}
+
 string DumpSymbols::Identifier() {
-  FileID file_id([object_filename_ fileSystemRepresentation]);
+  FileID file_id(object_filename_.c_str());
   unsigned char identifier_bytes[16];
   cpu_type_t cpu_type = selected_object_file_->cputype;
   cpu_subtype_t cpu_subtype = selected_object_file_->cpusubtype;
   if (!file_id.MachoIdentifier(cpu_type, cpu_subtype, identifier_bytes)) {
     fprintf(stderr, "Unable to calculate UUID of mach-o binary %s!\n",
-            [object_filename_ fileSystemRepresentation]);
+            object_filename_.c_str());
     return "";
   }
 
@@ -226,6 +305,31 @@ string DumpSymbols::Identifier() {
   return compacted;
 }
 
+// A range handler that accepts rangelist data parsed by
+// dwarf2reader::RangeListReader and populates a range vector (typically
+// owned by a function) with the results.
+class DumpSymbols::DumperRangesHandler:
+      public DwarfCUToModule::RangesHandler {
+ public:
+  DumperRangesHandler(const uint8_t* buffer, uint64_t size,
+                      dwarf2reader::ByteReader* reader)
+      : buffer_(buffer), size_(size), reader_(reader) { }
+
+  bool ReadRanges(uint64_t offset, Module::Address base_address,
+                  vector<Module::Range>* ranges) {
+    DwarfRangeListHandler handler(base_address, ranges);
+    dwarf2reader::RangeListReader rangelist_reader(buffer_, size_, reader_,
+                                                   &handler);
+
+    return rangelist_reader.ReadRangeList(offset);
+  }
+
+ private:
+  const uint8_t* buffer_;
+  uint64_t size_;
+  dwarf2reader::ByteReader* reader_;
+};
+
 // A line-to-module loader that accepts line number info parsed by
 // dwarf2reader::LineInfo and populates a Module and a line vector
 // with the results.
@@ -233,27 +337,90 @@ class DumpSymbols::DumperLineToModule:
       public DwarfCUToModule::LineToModuleHandler {
  public:
   // Create a line-to-module converter using BYTE_READER.
-  DumperLineToModule(dwarf2reader::ByteReader *byte_reader)
+  DumperLineToModule(dwarf2reader::ByteReader* byte_reader)
       : byte_reader_(byte_reader) { }
 
   void StartCompilationUnit(const string& compilation_dir) {
     compilation_dir_ = compilation_dir;
   }
 
-  void ReadProgram(const char *program, uint64 length,
-                   Module *module, vector<Module::Line> *lines) {
+  void ReadProgram(const uint8_t* program, uint64_t length,
+                   const uint8_t* string_section,
+                   uint64_t string_section_length,
+                   const uint8_t* line_string_section,
+                   uint64_t line_string_section_length,
+                   Module* module, vector<Module::Line>* lines) {
     DwarfLineToModule handler(module, compilation_dir_, lines);
-    dwarf2reader::LineInfo parser(program, length, byte_reader_, &handler);
+    dwarf2reader::LineInfo parser(program, length, byte_reader_,
+                                  nullptr, 0, nullptr, 0, &handler);
     parser.Start();
   }
  private:
   string compilation_dir_;
-  dwarf2reader::ByteReader *byte_reader_;  // WEAK
+  dwarf2reader::ByteReader* byte_reader_;  // WEAK
 };
 
-bool DumpSymbols::ReadDwarf(google_breakpad::Module *module,
-                            const mach_o::Reader &macho_reader,
-                            const mach_o::SectionMap &dwarf_sections,
+bool DumpSymbols::CreateEmptyModule(scoped_ptr<Module>& module) {
+  // Select an object file, if SetArchitecture hasn't been called to set one
+  // explicitly.
+  if (!selected_object_file_) {
+    // If there's only one architecture, that's the one.
+    if (object_files_.size() == 1)
+      selected_object_file_ = &object_files_[0];
+    else {
+      // Look for an object file whose architecture matches our own.
+      const NXArchInfo* local_arch = NXGetLocalArchInfo();
+      if (!SetArchitecture(local_arch->cputype, local_arch->cpusubtype)) {
+        fprintf(stderr, "%s: object file contains more than one"
+                " architecture, none of which match the current"
+                " architecture; specify an architecture explicitly"
+                " with '-a ARCH' to resolve the ambiguity\n",
+                object_filename_.c_str());
+        return false;
+      }
+    }
+  }
+
+  assert(selected_object_file_);
+
+  // Find the name of the selected file's architecture, to appear in
+  // the MODULE record and in error messages.
+  const NXArchInfo* selected_arch_info =
+      google_breakpad::BreakpadGetArchInfoFromCpuType(
+          selected_object_file_->cputype, selected_object_file_->cpusubtype);
+
+  const char* selected_arch_name = selected_arch_info->name;
+  if (strcmp(selected_arch_name, "i386") == 0)
+    selected_arch_name = "x86";
+
+  // Produce a name to use in error messages that includes the
+  // filename, and the architecture, if there is more than one.
+  selected_object_name_ = object_filename_;
+  if (object_files_.size() > 1) {
+    selected_object_name_ += ", architecture ";
+    selected_object_name_ + selected_arch_name;
+  }
+
+  // Compute a module name, to appear in the MODULE record.
+  string module_name = google_breakpad::BaseName(object_filename_);
+
+  // Choose an identifier string, to appear in the MODULE record.
+  string identifier = Identifier();
+  if (identifier.empty())
+    return false;
+  identifier += "0";
+
+  // Create a module to hold the debugging information.
+  module.reset(new Module(module_name,
+                          "mac",
+                          selected_arch_name,
+                          identifier));
+  return true;
+}
+
+void DumpSymbols::ReadDwarf(google_breakpad::Module* module,
+                            const mach_o::Reader& macho_reader,
+                            const mach_o::SectionMap& dwarf_sections,
                             bool handle_inter_cu_refs) const {
   // Build a byte reader of the appropriate endianness.
   ByteReader byte_reader(macho_reader.big_endian()
@@ -270,51 +437,62 @@ bool DumpSymbols::ReadDwarf(google_breakpad::Module *module,
        it != dwarf_sections.end(); ++it) {
     file_context.AddSectionToSectionMap(
         it->first,
-        reinterpret_cast<const char *>(it->second.contents.start),
+        it->second.contents.start,
         it->second.contents.Size());
   }
 
   // Find the __debug_info section.
   dwarf2reader::SectionMap::const_iterator debug_info_entry =
       file_context.section_map().find("__debug_info");
-  assert(debug_info_entry != file_context.section_map().end());
-  const std::pair<const char*, uint64>& debug_info_section =
-      debug_info_entry->second;
   // There had better be a __debug_info section!
-  if (!debug_info_section.first) {
+  if (debug_info_entry == file_context.section_map().end()) {
     fprintf(stderr, "%s: __DWARF segment of file has no __debug_info section\n",
             selected_object_name_.c_str());
-    return false;
+    return;
   }
+  const std::pair<const uint8_t*, uint64_t>& debug_info_section =
+      debug_info_entry->second;
 
   // Build a line-to-module loader for the root handler to use.
   DumperLineToModule line_to_module(&byte_reader);
 
+  // Optional .debug_ranges reader
+  scoped_ptr<DumperRangesHandler> ranges_handler;
+  dwarf2reader::SectionMap::const_iterator ranges_entry =
+      file_context.section_map().find("__debug_ranges");
+  if (ranges_entry != file_context.section_map().end()) {
+    const std::pair<const uint8_t*, uint64_t>& ranges_section =
+      ranges_entry->second;
+    ranges_handler.reset(
+      new DumperRangesHandler(ranges_section.first, ranges_section.second,
+                              &byte_reader));
+  }
+
   // Walk the __debug_info section, one compilation unit at a time.
-  uint64 debug_info_length = debug_info_section.second;
-  for (uint64 offset = 0; offset < debug_info_length;) {
+  uint64_t debug_info_length = debug_info_section.second;
+  for (uint64_t offset = 0; offset < debug_info_length;) {
     // Make a handler for the root DIE that populates MODULE with the
     // debug info.
     DwarfCUToModule::WarningReporter reporter(selected_object_name_,
                                               offset);
-    DwarfCUToModule root_handler(&file_context, &line_to_module, &reporter);
+    DwarfCUToModule root_handler(&file_context, &line_to_module,
+                                 ranges_handler.get(), &reporter);
     // Make a Dwarf2Handler that drives our DIEHandler.
     dwarf2reader::DIEDispatcher die_dispatcher(&root_handler);
     // Make a DWARF parser for the compilation unit at OFFSET.
-    dwarf2reader::CompilationUnit dwarf_reader(file_context.section_map(),
+    dwarf2reader::CompilationUnit dwarf_reader(selected_object_name_,
+                                               file_context.section_map(),
                                                offset,
                                                &byte_reader,
                                                &die_dispatcher);
     // Process the entire compilation unit; get the offset of the next.
     offset += dwarf_reader.Start();
   }
-
-  return true;
 }
 
-bool DumpSymbols::ReadCFI(google_breakpad::Module *module,
-                          const mach_o::Reader &macho_reader,
-                          const mach_o::Section &section,
+bool DumpSymbols::ReadCFI(google_breakpad::Module* module,
+                          const mach_o::Reader& macho_reader,
+                          const mach_o::Section& section,
                           bool eh_frame) const {
   // Find the appropriate set of register names for this file's
   // architecture.
@@ -329,8 +507,11 @@ bool DumpSymbols::ReadCFI(google_breakpad::Module *module,
     case CPU_TYPE_ARM:
       register_names = DwarfCFIToModule::RegisterNames::ARM();
       break;
+    case CPU_TYPE_ARM64:
+      register_names = DwarfCFIToModule::RegisterNames::ARM64();
+      break;
     default: {
-      const NXArchInfo *arch = google_breakpad::BreakpadGetArchInfoFromCpuType(
+      const NXArchInfo* arch = google_breakpad::BreakpadGetArchInfoFromCpuType(
           macho_reader.cpu_type(), macho_reader.cpu_subtype());
       fprintf(stderr, "%s: cannot convert DWARF call frame information for ",
               selected_object_name_.c_str());
@@ -345,7 +526,7 @@ bool DumpSymbols::ReadCFI(google_breakpad::Module *module,
   }
 
   // Find the call frame information and its size.
-  const char *cfi = reinterpret_cast<const char *>(section.contents.start);
+  const uint8_t* cfi = section.contents.start;
   size_t cfi_size = section.contents.Size();
 
   // Plug together the parser, handler, and their entourages.
@@ -377,9 +558,9 @@ class DumpSymbols::LoadCommandDumper:
  public:
   // Create a load command dumper handling load commands from READER's
   // file, and adding data to MODULE.
-  LoadCommandDumper(const DumpSymbols &dumper,
-                    google_breakpad::Module *module,
-                    const mach_o::Reader &reader,
+  LoadCommandDumper(const DumpSymbols& dumper,
+                    google_breakpad::Module* module,
+                    const mach_o::Reader& reader,
                     SymbolData symbol_data,
                     bool handle_inter_cu_refs)
       : dumper_(dumper),
@@ -388,18 +569,18 @@ class DumpSymbols::LoadCommandDumper:
         symbol_data_(symbol_data),
         handle_inter_cu_refs_(handle_inter_cu_refs) { }
 
-  bool SegmentCommand(const mach_o::Segment &segment);
-  bool SymtabCommand(const ByteBuffer &entries, const ByteBuffer &strings);
+  bool SegmentCommand(const mach_o::Segment& segment);
+  bool SymtabCommand(const ByteBuffer& entries, const ByteBuffer& strings);
 
  private:
-  const DumpSymbols &dumper_;
-  google_breakpad::Module *module_;  // WEAK
-  const mach_o::Reader &reader_;
+  const DumpSymbols& dumper_;
+  google_breakpad::Module* module_;  // WEAK
+  const mach_o::Reader& reader_;
   const SymbolData symbol_data_;
   const bool handle_inter_cu_refs_;
 };
 
-bool DumpSymbols::LoadCommandDumper::SegmentCommand(const Segment &segment) {
+bool DumpSymbols::LoadCommandDumper::SegmentCommand(const Segment& segment) {
   mach_o::SectionMap section_map;
   if (!reader_.MapSegmentSections(segment, &section_map))
     return false;
@@ -419,10 +600,7 @@ bool DumpSymbols::LoadCommandDumper::SegmentCommand(const Segment &segment) {
 
   if (segment.name == "__DWARF") {
     if (symbol_data_ != ONLY_CFI) {
-      if (!dumper_.ReadDwarf(module_, reader_, section_map,
-                             handle_inter_cu_refs_)) {
-        return false;
-      }
+      dumper_.ReadDwarf(module_, reader_, section_map, handle_inter_cu_refs_);
     }
     if (symbol_data_ != NO_CFI) {
       mach_o::SectionMap::const_iterator debug_frame
@@ -437,8 +615,8 @@ bool DumpSymbols::LoadCommandDumper::SegmentCommand(const Segment &segment) {
   return true;
 }
 
-bool DumpSymbols::LoadCommandDumper::SymtabCommand(const ByteBuffer &entries,
-                                                   const ByteBuffer &strings) {
+bool DumpSymbols::LoadCommandDumper::SymtabCommand(const ByteBuffer& entries,
+                                                   const ByteBuffer& strings) {
   StabsToModule stabs_to_module(module_);
   // Mac OS X STABS are never "unitized", and the size of the 'value' field
   // matches the address size of the executable.
@@ -455,65 +633,14 @@ bool DumpSymbols::LoadCommandDumper::SymtabCommand(const ByteBuffer &entries,
 }
 
 bool DumpSymbols::ReadSymbolData(Module** out_module) {
-  // Select an object file, if SetArchitecture hasn't been called to set one
-  // explicitly.
-  if (!selected_object_file_) {
-    // If there's only one architecture, that's the one.
-    if (object_files_.size() == 1)
-      selected_object_file_ = &object_files_[0];
-    else {
-      // Look for an object file whose architecture matches our own.
-      const NXArchInfo *local_arch = NXGetLocalArchInfo();
-      if (!SetArchitecture(local_arch->cputype, local_arch->cpusubtype)) {
-        fprintf(stderr, "%s: object file contains more than one"
-                " architecture, none of which match the current"
-                " architecture; specify an architecture explicitly"
-                " with '-a ARCH' to resolve the ambiguity\n",
-                [object_filename_ fileSystemRepresentation]);
-        return false;
-      }
-    }
-  }
-
-  assert(selected_object_file_);
-
-  // Find the name of the selected file's architecture, to appear in
-  // the MODULE record and in error messages.
-  const NXArchInfo *selected_arch_info =
-      google_breakpad::BreakpadGetArchInfoFromCpuType(
-          selected_object_file_->cputype, selected_object_file_->cpusubtype);
-
-  const char *selected_arch_name = selected_arch_info->name;
-  if (strcmp(selected_arch_name, "i386") == 0)
-    selected_arch_name = "x86";
-
-  // Produce a name to use in error messages that includes the
-  // filename, and the architecture, if there is more than one.
-  selected_object_name_ = [object_filename_ UTF8String];
-  if (object_files_.size() > 1) {
-    selected_object_name_ += ", architecture ";
-    selected_object_name_ + selected_arch_name;
-  }
-
-  // Compute a module name, to appear in the MODULE record.
-  NSString *module_name = [object_filename_ lastPathComponent];
-
-  // Choose an identifier string, to appear in the MODULE record.
-  string identifier = Identifier();
-  if (identifier.empty())
+  scoped_ptr<Module> module;
+  if (!CreateEmptyModule(module))
     return false;
-  identifier += "0";
-
-  // Create a module to hold the debugging information.
-  scoped_ptr<Module> module(new Module([module_name UTF8String],
-                                       "mac",
-                                       selected_arch_name,
-                                       identifier));
 
   // Parse the selected object file.
   mach_o::Reader::Reporter reporter(selected_object_name_);
   mach_o::Reader reader(&reporter);
-  if (!reader.Read(reinterpret_cast<const uint8_t *>([contents_ bytes])
+  if (!reader.Read(&contents_[0]
                    + selected_object_file_->offset,
                    selected_object_file_->size,
                    selected_object_file_->cputype,
@@ -531,7 +658,7 @@ bool DumpSymbols::ReadSymbolData(Module** out_module) {
   return true;
 }
 
-bool DumpSymbols::WriteSymbolFile(std::ostream &stream) {
+bool DumpSymbols::WriteSymbolFile(std::ostream& stream) {
   Module* module = NULL;
 
   if (ReadSymbolData(&module) && module) {
@@ -543,4 +670,15 @@ bool DumpSymbols::WriteSymbolFile(std::ostream &stream) {
   return false;
 }
 
+// Read the selected object file's debugging information, and write out the
+// header only to |stream|. Return true on success; if an error occurs, report
+// it and return false.
+bool DumpSymbols::WriteSymbolFileHeader(std::ostream& stream) {
+  scoped_ptr<Module> module;
+  if (!CreateEmptyModule(module))
+    return false;
+
+  return module->Write(stream, symbol_data_);
+}
+
 }  // namespace google_breakpad
diff --git a/src/MEGASync/google_breakpad/common/mac/dump_syms.h b/src/MEGASync/google_breakpad/common/mac/dump_syms.h
index 34e83976..daebf876 100644
--- a/src/MEGASync/google_breakpad/common/mac/dump_syms.h
+++ b/src/MEGASync/google_breakpad/common/mac/dump_syms.h
@@ -35,7 +35,6 @@
 // reading debugging information from Mach-O files and writing it out as a
 // Breakpad symbol file.
 
-#include <Foundation/Foundation.h>
 #include <mach-o/loader.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -46,7 +45,9 @@
 
 #include "common/byte_cursor.h"
 #include "common/mac/macho_reader.h"
+#include "common/mac/super_fat_arch.h"
 #include "common/module.h"
+#include "common/scoped_ptr.h"
 #include "common/symbol_data.h"
 
 namespace google_breakpad {
@@ -59,23 +60,17 @@ class DumpSymbols {
         input_pathname_(),
         object_filename_(),
         contents_(),
+        object_files_(),
         selected_object_file_(),
         selected_object_name_() { }
   ~DumpSymbols() {
-    [input_pathname_ release];
-    [object_filename_ release];
-    [contents_ release];
   }
 
   // Prepare to read debugging information from |filename|. |filename| may be
   // the name of a universal binary, a Mach-O file, or a dSYM bundle
   // containing either of the above. On success, return true; if there is a
   // problem reading |filename|, report it and return false.
-  //
-  // (This class uses NSString for filenames and related values,
-  // because the Mac Foundation framework seems to support
-  // filename-related operations more fully on NSString values.)
-  bool Read(NSString *filename);
+  bool Read(const std::string& filename);
 
   // If this dumper's file includes an object file for |cpu_type| and
   // |cpu_subtype|, then select that object file for dumping, and return
@@ -96,16 +91,16 @@ class DumpSymbols {
   // the dumper will dump those symbols; and if it contains more than one
   // object file, then the dumper will dump the object file whose
   // architecture matches that of this dumper program.
-  bool SetArchitecture(const std::string &arch_name);
+  bool SetArchitecture(const std::string& arch_name);
 
-  // Return a pointer to an array of 'struct fat_arch' structures,
-  // describing the object files contained in this dumper's file. Set
-  // *|count| to the number of elements in the array. The returned array is
-  // owned by this DumpSymbols instance.
+  // Return a pointer to an array of SuperFatArch structures describing the
+  // object files contained in this dumper's file. Set *|count| to the number
+  // of elements in the array. The returned array is owned by this DumpSymbols
+  // instance.
   //
   // If there are no available architectures, this function
   // may return NULL.
-  const struct fat_arch *AvailableArchitectures(size_t *count) {
+  const SuperFatArch* AvailableArchitectures(size_t* count) {
     *count = object_files_.size();
     if (object_files_.size() > 0)
       return &object_files_[0];
@@ -115,7 +110,12 @@ class DumpSymbols {
   // Read the selected object file's debugging information, and write it out to
   // |stream|. Return true on success; if an error occurs, report it and
   // return false.
-  bool WriteSymbolFile(std::ostream &stream);
+  bool WriteSymbolFile(std::ostream& stream);
+
+  // Read the selected object file's debugging information, and write out the
+  // header only to |stream|. Return true on success; if an error occurs, report
+  // it and return false.
+  bool WriteSymbolFileHeader(std::ostream& stream);
 
   // As above, but simply return the debugging information in module
   // instead of writing it to a stream. The caller owns the resulting
@@ -125,17 +125,26 @@ class DumpSymbols {
  private:
   // Used internally.
   class DumperLineToModule;
+  class DumperRangesHandler;
   class LoadCommandDumper;
 
+  // This method behaves similarly to NXFindBestFatArch, but it supports
+  // SuperFatArch.
+  SuperFatArch* FindBestMatchForArchitecture(
+      cpu_type_t cpu_type, cpu_subtype_t cpu_subtype);
+
   // Return an identifier string for the file this DumpSymbols is dumping.
   std::string Identifier();
 
+
+  // Creates an empty module object.
+  bool CreateEmptyModule(scoped_ptr<Module>& module);
+
   // Read debugging information from |dwarf_sections|, which was taken from
-  // |macho_reader|, and add it to |module|. On success, return true;
-  // on failure, report the problem and return false.
-  bool ReadDwarf(google_breakpad::Module *module,
-                 const mach_o::Reader &macho_reader,
-                 const mach_o::SectionMap &dwarf_sections,
+  // |macho_reader|, and add it to |module|.
+  void ReadDwarf(google_breakpad::Module* module,
+                 const mach_o::Reader& macho_reader,
+                 const mach_o::SectionMap& dwarf_sections,
                  bool handle_inter_cu_refs) const;
 
   // Read DWARF CFI or .eh_frame data from |section|, belonging to
@@ -143,9 +152,9 @@ class DumpSymbols {
   // then the data is .eh_frame-format data; otherwise, it is standard DWARF
   // .debug_frame data. On success, return true; on failure, report
   // the problem and return false.
-  bool ReadCFI(google_breakpad::Module *module,
-               const mach_o::Reader &macho_reader,
-               const mach_o::Section &section,
+  bool ReadCFI(google_breakpad::Module* module,
+               const mach_o::Reader& macho_reader,
+               const mach_o::Section& section,
                bool eh_frame) const;
 
   // The selection of what type of symbol data to read/write.
@@ -156,26 +165,26 @@ class DumpSymbols {
 
   // The name of the file or bundle whose symbols this will dump.
   // This is the path given to Read, for use in error messages.
-  NSString *input_pathname_;
+  std::string input_pathname_;
 
   // The name of the file this DumpSymbols will actually read debugging
   // information from. Normally, this is the same as input_pathname_, but if
   // filename refers to a dSYM bundle, then this is the resource file
   // within that bundle.
-  NSString *object_filename_;
+  std::string object_filename_;
 
   // The complete contents of object_filename_, mapped into memory.
-  NSData *contents_;
+  scoped_array<uint8_t> contents_;
 
-  // A vector of fat_arch structures describing the object files
+  // A vector of SuperFatArch structures describing the object files
   // object_filename_ contains. If object_filename_ refers to a fat binary,
   // this may have more than one element; if it refers to a Mach-O file, this
   // has exactly one element.
-  vector<struct fat_arch> object_files_;
+  vector<SuperFatArch> object_files_;
 
   // The object file in object_files_ selected to dump, or NULL if
   // SetArchitecture hasn't been called yet.
-  const struct fat_arch *selected_object_file_;
+  const SuperFatArch* selected_object_file_;
 
   // A string that identifies the selected object file, for use in error
   // messages.  This is usually object_filename_, but if that refers to a
diff --git a/src/MEGASync/google_breakpad/common/mac/encoding_util.h b/src/MEGASync/google_breakpad/common/mac/encoding_util.h
new file mode 100644
index 00000000..6495a742
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/mac/encoding_util.h
@@ -0,0 +1,41 @@
+// Copyright (c) 2020, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef GOOGLE_BREAKPAD_COMMON_MAC_ENCODING_UTIL_H
+#define GOOGLE_BREAKPAD_COMMON_MAC_ENCODING_UTIL_H
+
+#import <Foundation/Foundation.h>
+
+// As -[NSString stringByAddingPercentEscapesUsingEncoding:] has been
+// deprecated with iOS 9.0 / OS X 10.11 SDKs, this function re-implements it
+// using -[NSString stringByAddingPercentEncodingWithAllowedCharacters:] when
+// using those SDKs.
+NSString* PercentEncodeNSString(NSString* key);
+
+#endif  // GOOGLE_BREAKPAD_COMMON_MAC_ENCODING_UTIL_H
diff --git a/src/MEGASync/google_breakpad/common/mac/encoding_util.m b/src/MEGASync/google_breakpad/common/mac/encoding_util.m
new file mode 100644
index 00000000..86d70fb6
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/mac/encoding_util.m
@@ -0,0 +1,47 @@
+// Copyright (c) 2020, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "encoding_util.h"
+
+#include <Availability.h>
+#include <AvailabilityMacros.h>
+#import <Foundation/Foundation.h>
+
+NSString* PercentEncodeNSString(NSString* key) {
+#if (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && defined(__IPHONE_9_0) && \
+     __IPHONE_OS_VERSION_MIN_REQUIRED >= __IPHONE_9_0) ||                  \
+    (defined(MAC_OS_X_VERSION_MIN_REQUIRED) &&                             \
+     defined(MAC_OS_X_VERSION_10_11) &&                                    \
+     MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_11)
+  return [key stringByAddingPercentEncodingWithAllowedCharacters:
+                  [NSCharacterSet URLQueryAllowedCharacterSet]];
+#else
+  return [key stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
+#endif
+}
diff --git a/src/MEGASync/google_breakpad/common/mac/file_id.cc b/src/MEGASync/google_breakpad/common/mac/file_id.cc
index a2ee320b..4661d5d6 100644
--- a/src/MEGASync/google_breakpad/common/mac/file_id.cc
+++ b/src/MEGASync/google_breakpad/common/mac/file_id.cc
@@ -34,6 +34,7 @@
 // Author: Dan Waylonis
 
 #include <fcntl.h>
+#include <stdio.h>
 #include <string.h>
 #include <unistd.h>
 
@@ -45,7 +46,7 @@ using MacFileUtilities::MachoID;
 namespace google_breakpad {
 
 FileID::FileID(const char *path) {
-  strlcpy(path_, path, sizeof(path_));
+  snprintf(path_, sizeof(path_), "%s", path);
 }
 
 bool FileID::FileIdentifier(unsigned char identifier[16]) {
@@ -61,7 +62,7 @@ bool FileID::FileIdentifier(unsigned char identifier[16]) {
   unsigned char buffer[4096 * 2];
   size_t buffer_size = sizeof(buffer);
   while ((buffer_size = read(fd, buffer, buffer_size) > 0)) {
-    MD5Update(&md5, buffer, buffer_size);
+    MD5Update(&md5, buffer, static_cast<unsigned>(buffer_size));
   }
 
   close(fd);
diff --git a/src/MEGASync/google_breakpad/common/mac/file_id.h b/src/MEGASync/google_breakpad/common/mac/file_id.h
index 1d6dfde1..5d60e84c 100644
--- a/src/MEGASync/google_breakpad/common/mac/file_id.h
+++ b/src/MEGASync/google_breakpad/common/mac/file_id.h
@@ -42,7 +42,7 @@ namespace google_breakpad {
 class FileID {
  public:
   FileID(const char *path);
-  ~FileID() {};
+  ~FileID() {}
 
   // Load the identifier for the file path specified in the constructor into
   // |identifier|.  Return false if the identifier could not be created for the
diff --git a/src/MEGASync/google_breakpad/common/mac/launch_reporter.cc b/src/MEGASync/google_breakpad/common/mac/launch_reporter.cc
new file mode 100644
index 00000000..245be826
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/mac/launch_reporter.cc
@@ -0,0 +1,84 @@
+// Copyright (c) 2014, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include <stdio.h>
+#include <sys/wait.h>
+#include <unistd.h>
+
+namespace google_breakpad {
+
+void LaunchReporter(const char *reporter_executable_path,
+                    const char *config_file_path) {
+  const char* argv[] = { reporter_executable_path, config_file_path, NULL };
+
+  // Launch the reporter
+  pid_t pid = fork();
+
+  if (pid == -1) {
+    perror("fork");
+    fprintf(stderr, "Failed to fork reporter process\n");
+    return;
+  }
+
+  // If we're in the child, load in our new executable and run.
+  // The parent will not wait for the child to complete.
+  if (pid == 0) {
+    execv(argv[0], (char* const*)argv);
+    perror("exec");
+    fprintf(stderr,
+            "Failed to launch reporter process from path %s\n",
+            reporter_executable_path);
+    unlink(config_file_path);  // launch failed - get rid of config file
+    _exit(1);
+  }
+
+  // Wait until the Reporter child process exits.
+  //
+
+  // We'll use a timeout of one minute.
+  int timeout_count = 60;   // 60 seconds
+
+  while (timeout_count-- > 0) {
+    int status;
+    pid_t result = waitpid(pid, &status, WNOHANG);
+
+    if (result == 0) {
+      // The child has not yet finished.
+      sleep(1);
+    } else if (result == -1) {
+      // error occurred.
+      break;
+    } else {
+      // child has finished
+      break;
+    }
+  }
+}
+
+}  // namespace google_breakpad
diff --git a/src/MEGASync/google_breakpad/common/mac/launch_reporter.h b/src/MEGASync/google_breakpad/common/mac/launch_reporter.h
new file mode 100644
index 00000000..4531123c
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/mac/launch_reporter.h
@@ -0,0 +1,43 @@
+// Copyright (c) 2014, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef COMMON_MAC_LAUNCH_REPORTER_H__
+#define COMMON_MAC_LAUNCH_REPORTER_H__
+
+namespace google_breakpad {
+
+// Launch the crash dump sender app.
+// |reporter_executable_path| is the path to the sender executable.
+// |config_file_path| is the path to the config file.
+void LaunchReporter(const char *reporter_executable_path,
+                    const char *config_file_path);
+
+}  // namespace google_breakpad
+
+#endif  // COMMON_MAC_LAUNCH_REPORTER_H__
diff --git a/src/MEGASync/google_breakpad/common/mac/macho_id.cc b/src/MEGASync/google_breakpad/common/mac/macho_id.cc
index aa2cfc83..3cf1d4b5 100644
--- a/src/MEGASync/google_breakpad/common/mac/macho_id.cc
+++ b/src/MEGASync/google_breakpad/common/mac/macho_id.cc
@@ -33,17 +33,15 @@
 //
 // Author: Dan Waylonis
 
-extern "C" {  // necessary for Leopard
-  #include <fcntl.h>
-  #include <mach-o/loader.h>
-  #include <mach-o/swap.h>
-  #include <stdio.h>
-  #include <stdlib.h>
-  #include <string.h>
-  #include <sys/time.h>
-  #include <sys/types.h>
-  #include <unistd.h>
-}
+
+#include <fcntl.h>
+#include <mach-o/loader.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <unistd.h>
 
 #include "common/mac/macho_id.h"
 #include "common/mac/macho_walker.h"
@@ -55,22 +53,22 @@ using google_breakpad::MD5Init;
 using google_breakpad::MD5Update;
 using google_breakpad::MD5Final;
 
-MachoID::MachoID(const char *path)
+MachoID::MachoID(const char* path)
    : memory_(0),
      memory_size_(0),
      crc_(0), 
      md5_context_(), 
      update_function_(NULL) {
-  strlcpy(path_, path, sizeof(path_));
+  snprintf(path_, sizeof(path_), "%s", path);
 }
 
-MachoID::MachoID(const char *path, void *memory, size_t size)
+MachoID::MachoID(const char* path, void* memory, size_t size)
    : memory_(memory),
      memory_size_(size),
      crc_(0), 
      md5_context_(), 
      update_function_(NULL) {
-  strlcpy(path_, path, sizeof(path_));
+  snprintf(path_, sizeof(path_), "%s", path);
 }
 
 MachoID::~MachoID() {
@@ -84,7 +82,7 @@ MachoID::~MachoID() {
 // MAX_BLOCK is the largest n such that 255n(n+1)/2 + (n+1)(MAX_BLOCK-1) <= 2^32-1
 #define MAX_BLOCK 5552
 
-void MachoID::UpdateCRC(unsigned char *bytes, size_t size) {
+void MachoID::UpdateCRC(unsigned char* bytes, size_t size) {
 // Unrolled loops for summing
 #define DO1(buf,i)  {sum1 += (buf)[i]; sum2 += sum1;}
 #define DO2(buf,i)  DO1(buf,i); DO1(buf,i+1);
@@ -124,11 +122,11 @@ void MachoID::UpdateCRC(unsigned char *bytes, size_t size) {
   }
 }
 
-void MachoID::UpdateMD5(unsigned char *bytes, size_t size) {
-  MD5Update(&md5_context_, bytes, size);
+void MachoID::UpdateMD5(unsigned char* bytes, size_t size) {
+  MD5Update(&md5_context_, bytes, static_cast<unsigned>(size));
 }
 
-void MachoID::Update(MachoWalker *walker, off_t offset, size_t size) {
+void MachoID::Update(MachoWalker* walker, off_t offset, size_t size) {
   if (!update_function_ || !size)
     return;
 
@@ -239,7 +237,7 @@ bool MachoID::MD5(cpu_type_t cpu_type, cpu_subtype_t cpu_subtype, unsigned char
 bool MachoID::WalkHeader(cpu_type_t cpu_type,
                          cpu_subtype_t cpu_subtype,
                          MachoWalker::LoadCommandCallback callback,
-                         void *context) {
+                         void* context) {
   if (memory_) {
     MachoWalker walker(memory_, memory_size_, callback, context);
     return walker.WalkHeader(cpu_type, cpu_subtype);
@@ -250,9 +248,9 @@ bool MachoID::WalkHeader(cpu_type_t cpu_type,
 }
 
 // static
-bool MachoID::WalkerCB(MachoWalker *walker, load_command *cmd, off_t offset,
-                       bool swap, void *context) {
-  MachoID *macho_id = (MachoID *)context;
+bool MachoID::WalkerCB(MachoWalker* walker, load_command* cmd, off_t offset,
+                       bool swap, void* context) {
+  MachoID* macho_id = (MachoID*)context;
 
   if (cmd->cmd == LC_SEGMENT) {
     struct segment_command seg;
@@ -261,7 +259,7 @@ bool MachoID::WalkerCB(MachoWalker *walker, load_command *cmd, off_t offset,
       return false;
 
     if (swap)
-      swap_segment_command(&seg, NXHostByteOrder());
+      breakpad_swap_segment_command(&seg);
 
     struct mach_header_64 header;
     off_t header_offset;
@@ -278,7 +276,7 @@ bool MachoID::WalkerCB(MachoWalker *walker, load_command *cmd, off_t offset,
         return false;
 
       if (swap)
-        swap_section(&sec, 1, NXHostByteOrder());
+        breakpad_swap_section(&sec, 1);
 
       // sections of type S_ZEROFILL are "virtual" and contain no data
       // in the file itself
@@ -294,7 +292,7 @@ bool MachoID::WalkerCB(MachoWalker *walker, load_command *cmd, off_t offset,
       return false;
 
     if (swap)
-      breakpad_swap_segment_command_64(&seg64, NXHostByteOrder());
+      breakpad_swap_segment_command_64(&seg64);
 
     struct mach_header_64 header;
     off_t header_offset;
@@ -311,7 +309,7 @@ bool MachoID::WalkerCB(MachoWalker *walker, load_command *cmd, off_t offset,
         return false;
 
       if (swap)
-        breakpad_swap_section_64(&sec64, 1, NXHostByteOrder());
+        breakpad_swap_section_64(&sec64, 1);
 
       // sections of type S_ZEROFILL are "virtual" and contain no data
       // in the file itself
@@ -329,18 +327,18 @@ bool MachoID::WalkerCB(MachoWalker *walker, load_command *cmd, off_t offset,
 }
 
 // static
-bool MachoID::UUIDWalkerCB(MachoWalker *walker, load_command *cmd, off_t offset,
-                           bool swap, void *context) {
+bool MachoID::UUIDWalkerCB(MachoWalker* walker, load_command* cmd, off_t offset,
+                           bool swap, void* context) {
   if (cmd->cmd == LC_UUID) {
-    struct breakpad_uuid_command *uuid_cmd =
-      (struct breakpad_uuid_command *)context;
+    struct breakpad_uuid_command* uuid_cmd =
+      (struct breakpad_uuid_command*)context;
 
     if (!walker->ReadBytes(uuid_cmd, sizeof(struct breakpad_uuid_command),
                            offset))
       return false;
 
     if (swap)
-      breakpad_swap_uuid_command(uuid_cmd, NXHostByteOrder());
+      breakpad_swap_uuid_command(uuid_cmd);
 
     return false;
   }
@@ -350,16 +348,16 @@ bool MachoID::UUIDWalkerCB(MachoWalker *walker, load_command *cmd, off_t offset,
 }
 
 // static
-bool MachoID::IDWalkerCB(MachoWalker *walker, load_command *cmd, off_t offset,
-                         bool swap, void *context) {
+bool MachoID::IDWalkerCB(MachoWalker* walker, load_command* cmd, off_t offset,
+                         bool swap, void* context) {
   if (cmd->cmd == LC_ID_DYLIB) {
-    struct dylib_command *dylib_cmd = (struct dylib_command *)context;
+    struct dylib_command* dylib_cmd = (struct dylib_command*)context;
 
     if (!walker->ReadBytes(dylib_cmd, sizeof(struct dylib_command), offset))
       return false;
 
     if (swap)
-      swap_dylib_command(dylib_cmd, NXHostByteOrder());
+      breakpad_swap_dylib_command(dylib_cmd);
 
     return false;
   }
diff --git a/src/MEGASync/google_breakpad/common/mac/macho_id.h b/src/MEGASync/google_breakpad/common/mac/macho_id.h
index 10375491..e8874c37 100644
--- a/src/MEGASync/google_breakpad/common/mac/macho_id.h
+++ b/src/MEGASync/google_breakpad/common/mac/macho_id.h
@@ -45,8 +45,8 @@ namespace MacFileUtilities {
 
 class MachoID {
  public:
-  MachoID(const char *path);
-  MachoID(const char *path, void *memory, size_t size);
+  MachoID(const char* path);
+  MachoID(const char* path, void* memory, size_t size);
   ~MachoID();
 
   // For the given |cpu_type| and |cpu_subtype|, return a UUID from the LC_UUID
@@ -78,40 +78,40 @@ class MachoID {
 
  private:
   // Signature of class member function to be called with data read from file
-  typedef void (MachoID::*UpdateFunction)(unsigned char *bytes, size_t size);
+  typedef void (MachoID::*UpdateFunction)(unsigned char* bytes, size_t size);
 
   // Update the CRC value by examining |size| |bytes| and applying the algorithm
   // to each byte.
-  void UpdateCRC(unsigned char *bytes, size_t size);
+  void UpdateCRC(unsigned char* bytes, size_t size);
 
   // Update the MD5 value by examining |size| |bytes| and applying the algorithm
   // to each byte.
-  void UpdateMD5(unsigned char *bytes, size_t size);
+  void UpdateMD5(unsigned char* bytes, size_t size);
 
   // Bottleneck for update routines
-  void Update(MachoWalker *walker, off_t offset, size_t size);
+  void Update(MachoWalker* walker, off_t offset, size_t size);
 
   // Factory for the MachoWalker
   bool WalkHeader(cpu_type_t cpu_type, cpu_subtype_t cpu_subtype,
-                  MachoWalker::LoadCommandCallback callback, void *context);
+                  MachoWalker::LoadCommandCallback callback, void* context);
 
   // The callback from the MachoWalker for CRC and MD5
-  static bool WalkerCB(MachoWalker *walker, load_command *cmd, off_t offset,
-                       bool swap, void *context);
+  static bool WalkerCB(MachoWalker* walker, load_command* cmd, off_t offset,
+                       bool swap, void* context);
 
   // The callback from the MachoWalker for LC_UUID
-  static bool UUIDWalkerCB(MachoWalker *walker, load_command *cmd, off_t offset,
-                           bool swap, void *context);
+  static bool UUIDWalkerCB(MachoWalker* walker, load_command* cmd, off_t offset,
+                           bool swap, void* context);
 
   // The callback from the MachoWalker for LC_ID_DYLIB
-  static bool IDWalkerCB(MachoWalker *walker, load_command *cmd, off_t offset,
-                         bool swap, void *context);
+  static bool IDWalkerCB(MachoWalker* walker, load_command* cmd, off_t offset,
+                         bool swap, void* context);
 
   // File path
   char path_[PATH_MAX];
 
   // Memory region to read from
-  void *memory_;
+  void* memory_;
 
   // Size of the memory region
   size_t memory_size_;
diff --git a/src/MEGASync/google_breakpad/common/mac/macho_reader.cc b/src/MEGASync/google_breakpad/common/mac/macho_reader.cc
index 84b595a3..b42506cc 100644
--- a/src/MEGASync/google_breakpad/common/mac/macho_reader.cc
+++ b/src/MEGASync/google_breakpad/common/mac/macho_reader.cc
@@ -38,6 +38,8 @@
 #include <stdio.h>
 #include <stdlib.h>
 
+#include <limits>
+
 // Unfortunately, CPU_TYPE_ARM is not define for 10.4.
 #if !defined(CPU_TYPE_ARM)
 #define CPU_TYPE_ARM 12
@@ -79,7 +81,7 @@ void FatReader::Reporter::MisplacedObjectFile() {
           " to contain\n", filename_.c_str());
 }
 
-bool FatReader::Read(const uint8_t *buffer, size_t size) {
+bool FatReader::Read(const uint8_t* buffer, size_t size) {
   buffer_.start = buffer;
   buffer_.end = buffer + size;
   ByteCursor cursor(&buffer_);
@@ -101,22 +103,26 @@ bool FatReader::Read(const uint8_t *buffer, size_t size) {
       // Read the list of object files.
       object_files_.resize(object_files_count);
       for (size_t i = 0; i < object_files_count; i++) {
-        struct fat_arch *objfile = &object_files_[i];
+        struct fat_arch objfile;
 
         // Read this object file entry, byte-swapping as appropriate.
-        cursor >> objfile->cputype
-               >> objfile->cpusubtype
-               >> objfile->offset
-               >> objfile->size
-               >> objfile->align;
+        cursor >> objfile.cputype
+               >> objfile.cpusubtype
+               >> objfile.offset
+               >> objfile.size
+               >> objfile.align;
+
+        SuperFatArch super_fat_arch(objfile);
+        object_files_[i] = super_fat_arch;
+
         if (!cursor) {
           reporter_->TooShort();
           return false;
         }
         // Does the file actually have the bytes this entry refers to?
         size_t fat_size = buffer_.Size();
-        if (objfile->offset > fat_size ||
-            objfile->size > fat_size - objfile->offset) {
+        if (objfile.offset > fat_size ||
+            objfile.size > fat_size - objfile.offset) {
           reporter_->MisplacedObjectFile();
           return false;
         }
@@ -139,16 +145,14 @@ bool FatReader::Read(const uint8_t *buffer, size_t size) {
       }
 
       object_files_[0].offset = 0;
-      object_files_[0].size = static_cast<uint32_t>(buffer_.Size());
+      object_files_[0].size = static_cast<uint64_t>(buffer_.Size());
       // This alignment is correct for 32 and 64-bit x86 and ppc.
       // See get_align in the lipo source for other architectures:
       // http://www.opensource.apple.com/source/cctools/cctools-773/misc/lipo.c
       object_files_[0].align = 12;  // 2^12 == 4096
-      
       return true;
     }
   }
-  
   reporter_->BadHeader();
   return false;
 }
@@ -179,32 +183,32 @@ void Reader::Reporter::LoadCommandRegionTruncated() {
 
 void Reader::Reporter::LoadCommandsOverrun(size_t claimed, size_t i,
                                            LoadCommandType type) {
-  fprintf(stderr, "%s: file's header claims there are %ld"
-          " load commands, but load command #%ld",
+  fprintf(stderr, "%s: file's header claims there are %zu"
+          " load commands, but load command #%zu",
           filename_.c_str(), claimed, i);
   if (type) fprintf(stderr, ", of type %d,", type);
   fprintf(stderr, " extends beyond the end of the load command region\n");
 }
 
 void Reader::Reporter::LoadCommandTooShort(size_t i, LoadCommandType type) {
-  fprintf(stderr, "%s: the contents of load command #%ld, of type %d,"
+  fprintf(stderr, "%s: the contents of load command #%zu, of type %d,"
           " extend beyond the size given in the load command's header\n",
           filename_.c_str(), i, type);
 }
 
-void Reader::Reporter::SectionsMissing(const string &name) {
+void Reader::Reporter::SectionsMissing(const string& name) {
   fprintf(stderr, "%s: the load command for segment '%s'"
           " is too short to hold the section headers it claims to have\n",
           filename_.c_str(), name.c_str());
 }
 
-void Reader::Reporter::MisplacedSegmentData(const string &name) {
+void Reader::Reporter::MisplacedSegmentData(const string& name) {
   fprintf(stderr, "%s: the segment '%s' claims its contents lie beyond"
           " the end of the file\n", filename_.c_str(), name.c_str());
 }
 
-void Reader::Reporter::MisplacedSectionData(const string &section,
-                                            const string &segment) {
+void Reader::Reporter::MisplacedSectionData(const string& section,
+                                            const string& segment) {
   fprintf(stderr, "%s: the section '%s' in segment '%s'"
           " claims its contents lie outside the segment's contents\n",
           filename_.c_str(), section.c_str(), segment.c_str());
@@ -221,7 +225,7 @@ void Reader::Reporter::UnsupportedCPUType(cpu_type_t cpu_type) {
           filename_.c_str(), cpu_type);
 }
 
-bool Reader::Read(const uint8_t *buffer,
+bool Reader::Read(const uint8_t* buffer,
                   size_t size,
                   cpu_type_t expected_cpu_type,
                   cpu_subtype_t expected_cpu_subtype) {
@@ -305,7 +309,7 @@ bool Reader::Read(const uint8_t *buffer,
   return true;
 }
 
-bool Reader::WalkLoadCommands(Reader::LoadCommandHandler *handler) const {
+bool Reader::WalkLoadCommands(Reader::LoadCommandHandler* handler) const {
   ByteCursor list_cursor(&load_commands_, big_endian_);
 
   for (size_t index = 0; index < load_command_count_; ++index) {
@@ -315,7 +319,7 @@ bool Reader::WalkLoadCommands(Reader::LoadCommandHandler *handler) const {
     // remainder of the load command series.
     ByteBuffer command(list_cursor.here(), list_cursor.Available());
     ByteCursor cursor(&command, big_endian_);
-    
+
     // Read the command type and size --- fields common to all commands.
     uint32_t type, size;
     if (!(cursor >> type)) {
@@ -338,12 +342,11 @@ bool Reader::WalkLoadCommands(Reader::LoadCommandHandler *handler) const {
         segment.bits_64 = (type == LC_SEGMENT_64);
         size_t word_size = segment.bits_64 ? 8 : 4;
         cursor.CString(&segment.name, 16);
-        size_t file_offset, file_size;
         cursor
             .Read(word_size, false, &segment.vmaddr)
             .Read(word_size, false, &segment.vmsize)
-            .Read(word_size, false, &file_offset)
-            .Read(word_size, false, &file_size);
+            .Read(word_size, false, &segment.fileoff)
+            .Read(word_size, false, &segment.filesize);
         cursor >> segment.maxprot
                >> segment.initprot
                >> segment.nsects
@@ -352,8 +355,8 @@ bool Reader::WalkLoadCommands(Reader::LoadCommandHandler *handler) const {
           reporter_->LoadCommandTooShort(index, type);
           return false;
         }
-        if (file_offset > buffer_.Size() ||
-            file_size > buffer_.Size() - file_offset) {
+        if (segment.fileoff > buffer_.Size() ||
+            segment.filesize > buffer_.Size() - segment.fileoff) {
           reporter_->MisplacedSegmentData(segment.name);
           return false;
         }
@@ -361,11 +364,11 @@ bool Reader::WalkLoadCommands(Reader::LoadCommandHandler *handler) const {
         // segments removed, and their file offsets and file sizes zeroed
         // out. To help us handle this special case properly, give such
         // segments' contents NULL starting and ending pointers.
-        if (file_offset == 0 && file_size == 0) {
+        if (segment.fileoff == 0 && segment.filesize == 0) {
           segment.contents.start = segment.contents.end = NULL;
         } else {
-          segment.contents.start = buffer_.start + file_offset;
-          segment.contents.end = segment.contents.start + file_size;
+          segment.contents.start = buffer_.start + segment.fileoff;
+          segment.contents.end = segment.contents.start + segment.filesize;
         }
         // The section list occupies the remainder of this load command's space.
         segment.section_list.start = cursor.here();
@@ -400,7 +403,7 @@ bool Reader::WalkLoadCommands(Reader::LoadCommandHandler *handler) const {
           return false;
         break;
       }
-      
+
       default: {
         if (!handler->UnknownCommand(type, command))
           return false;
@@ -419,13 +422,13 @@ class Reader::SegmentFinder : public LoadCommandHandler {
  public:
   // Create a load command handler that looks for a segment named NAME,
   // and sets SEGMENT to describe it if found.
-  SegmentFinder(const string &name, Segment *segment) 
+  SegmentFinder(const string& name, Segment* segment)
       : name_(name), segment_(segment), found_() { }
 
   // Return true if the traversal found the segment, false otherwise.
   bool found() const { return found_; }
 
-  bool SegmentCommand(const Segment &segment) {
+  bool SegmentCommand(const Segment& segment) {
     if (segment.name == name_) {
       *segment_ = segment;
       found_ = true;
@@ -436,37 +439,37 @@ class Reader::SegmentFinder : public LoadCommandHandler {
 
  private:
   // The name of the segment our creator is looking for.
-  const string &name_;
+  const string& name_;
 
   // Where we should store the segment if found. (WEAK)
-  Segment *segment_;
+  Segment* segment_;
 
   // True if we found the segment.
   bool found_;
 };
 
-bool Reader::FindSegment(const string &name, Segment *segment) const {
+bool Reader::FindSegment(const string& name, Segment* segment) const {
   SegmentFinder finder(name, segment);
   WalkLoadCommands(&finder);
   return finder.found();
 }
 
-bool Reader::WalkSegmentSections(const Segment &segment,
-                                 SectionHandler *handler) const {
+bool Reader::WalkSegmentSections(const Segment& segment,
+                                 SectionHandler* handler) const {
   size_t word_size = segment.bits_64 ? 8 : 4;
   ByteCursor cursor(&segment.section_list, big_endian_);
 
   for (size_t i = 0; i < segment.nsects; i++) {
     Section section;
     section.bits_64 = segment.bits_64;
-    uint64_t size;
-    uint32_t offset, dummy32;
+    uint64_t size, offset;
+    uint32_t dummy32;
     cursor
         .CString(&section.section_name, 16)
         .CString(&section.segment_name, 16)
         .Read(word_size, false, &section.address)
         .Read(word_size, false, &size)
-        >> offset
+        .Read(sizeof(uint32_t), false, &offset)  // clears high bits of |offset|
         >> section.align
         >> dummy32
         >> dummy32
@@ -479,10 +482,30 @@ bool Reader::WalkSegmentSections(const Segment &segment,
       reporter_->SectionsMissing(segment.name);
       return false;
     }
-    if ((section.flags & SECTION_TYPE) == S_ZEROFILL) {
+
+    // Even 64-bit Mach-O isnt a true 64-bit format in that it doesnt handle
+    // 64-bit file offsets gracefully. Segment load commands do contain 64-bit
+    // file offsets, but sections within do not. Because segments load
+    // contiguously, recompute each sections file offset on the basis of its
+    // containing segments file offset and the difference between the sections
+    // and segments load addresses. If truncation is detected, honor the
+    // recomputed offset.
+    if (segment.bits_64 &&
+        segment.fileoff + segment.filesize >
+            std::numeric_limits<uint32_t>::max()) {
+      const uint64_t section_offset_recomputed =
+          segment.fileoff + section.address - segment.vmaddr;
+      if (offset == static_cast<uint32_t>(section_offset_recomputed)) {
+        offset = section_offset_recomputed;
+      }
+    }
+
+    const uint32_t section_type = section.flags & SECTION_TYPE;
+    if (section_type == S_ZEROFILL || section_type == S_THREAD_LOCAL_ZEROFILL ||
+            section_type == S_GB_ZEROFILL) {
       // Zero-fill sections have a size, but no contents.
       section.contents.start = section.contents.end = NULL;
-    } else if (segment.contents.start == NULL && 
+    } else if (segment.contents.start == NULL &&
                segment.contents.end == NULL) {
       // Mach-O files in .dSYM bundles have the contents of the loaded
       // segments removed, and their file offsets and file sizes zeroed
@@ -514,18 +537,18 @@ class Reader::SectionMapper: public SectionHandler {
  public:
   // Create a SectionHandler that populates MAP with an entry for
   // each section it is given.
-  SectionMapper(SectionMap *map) : map_(map) { }
-  bool HandleSection(const Section &section) {
+  SectionMapper(SectionMap* map) : map_(map) { }
+  bool HandleSection(const Section& section) {
     (*map_)[section.section_name] = section;
     return true;
   }
  private:
   // The map under construction. (WEAK)
-  SectionMap *map_;
+  SectionMap* map_;
 };
 
-bool Reader::MapSegmentSections(const Segment &segment,
-                                SectionMap *section_map) const {
+bool Reader::MapSegmentSections(const Segment& segment,
+                                SectionMap* section_map) const {
   section_map->clear();
   SectionMapper mapper(section_map);
   return WalkSegmentSections(segment, &mapper);
diff --git a/src/MEGASync/google_breakpad/common/mac/macho_reader.h b/src/MEGASync/google_breakpad/common/mac/macho_reader.h
index 75376482..02762c55 100644
--- a/src/MEGASync/google_breakpad/common/mac/macho_reader.h
+++ b/src/MEGASync/google_breakpad/common/mac/macho_reader.h
@@ -47,6 +47,7 @@
 #include <vector>
 
 #include "common/byte_cursor.h"
+#include "common/mac/super_fat_arch.h"
 
 namespace google_breakpad {
 namespace mach_o {
@@ -77,7 +78,7 @@ class FatReader {
   class Reporter {
    public:
     // Create a reporter that attributes problems to |filename|.
-    explicit Reporter(const string &filename) : filename_(filename) { }
+    explicit Reporter(const string& filename) : filename_(filename) { }
 
     virtual ~Reporter() { }
 
@@ -93,15 +94,15 @@ class FatReader {
     // complete header, or the header implies that contents are present
     // beyond the actual end of the file.
     virtual void TooShort();
-  
+
    private:
     // The filename to which the reader should attribute problems.
     string filename_;
   };
 
   // Create a fat binary file reader that uses |reporter| to report problems.
-  explicit FatReader(Reporter *reporter) : reporter_(reporter) { }
-  
+  explicit FatReader(Reporter* reporter) : reporter_(reporter) { }
+
   // Read the |size| bytes at |buffer| as a fat binary file. On success,
   // return true; on failure, report the problem to reporter_ and return
   // false.
@@ -109,15 +110,15 @@ class FatReader {
   // If the data is a plain Mach-O file, rather than a fat binary file,
   // then the reader behaves as if it had found a fat binary file whose
   // single object file is the Mach-O file.
-  bool Read(const uint8_t *buffer, size_t size);
+  bool Read(const uint8_t* buffer, size_t size);
 
-  // Return an array of 'struct fat_arch' structures describing the
+  // Return an array of 'SuperFatArch' structures describing the
   // object files present in this fat binary file. Set |size| to the
   // number of elements in the array.
   //
-  // Assuming Read returned true, the entries are validated: it is
-  // safe to assume that the offsets and sizes in each 'struct
-  // fat_arch' refer to subranges of the bytes passed to Read.
+  // Assuming Read returned true, the entries are validated: it is safe to
+  // assume that the offsets and sizes in each SuperFatArch refer to subranges
+  // of the bytes passed to Read.
   //
   // If there are no object files in this fat binary, then this
   // function can return NULL.
@@ -129,7 +130,7 @@ class FatReader {
   // possible to use the result with OS X functions like NXFindBestFatArch,
   // so that the symbol dumper will behave consistently with other OS X
   // utilities that work with fat binaries.
-  const struct fat_arch *object_files(size_t *count) const { 
+  const SuperFatArch* object_files(size_t* count) const {
     *count = object_files_.size();
     if (object_files_.size() > 0)
       return &object_files_[0];
@@ -138,7 +139,7 @@ class FatReader {
 
  private:
   // We use this to report problems parsing the file's contents. (WEAK)
-  Reporter *reporter_;
+  Reporter* reporter_;
 
   // The contents of the fat binary or Mach-O file we're parsing. We do not
   // own the storage it refers to.
@@ -149,7 +150,7 @@ class FatReader {
 
   // The list of object files in this binary.
   // object_files_.size() == fat_header.nfat_arch
-  vector<struct fat_arch> object_files_;
+  vector<SuperFatArch> object_files_;
 };
 
 // A segment in a Mach-O file. All these fields have been byte-swapped as
@@ -174,10 +175,14 @@ struct Segment {
   // of this value are valid.
   uint64_t vmsize;
 
+  // The file offset and size of the segment in the Mach-O image.
+  uint64_t fileoff;
+  uint64_t filesize;
+
   // The maximum and initial VM protection of this segment's contents.
   uint32_t maxprot;
   uint32_t initprot;
-  
+
   // The number of sections in section_list.
   uint32_t nsects;
 
@@ -235,7 +240,7 @@ class Reader {
   class Reporter {
    public:
     // Create a reporter that attributes problems to |filename|.
-    explicit Reporter(const string &filename) : filename_(filename) { }
+    explicit Reporter(const string& filename) : filename_(filename) { }
     virtual ~Reporter() { }
 
     // Reporter functions for fatal errors return void; the reader will
@@ -277,16 +282,16 @@ class Reader {
     // The LC_SEGMENT or LC_SEGMENT_64 load command for the segment named
     // |name| is too short to hold the sections that its header says it does.
     // (This more specific than LoadCommandTooShort.)
-    virtual void SectionsMissing(const string &name);
+    virtual void SectionsMissing(const string& name);
 
     // The segment named |name| claims that its contents lie beyond the end
     // of the file.
-    virtual void MisplacedSegmentData(const string &name);
+    virtual void MisplacedSegmentData(const string& name);
 
     // The section named |section| in the segment named |segment| claims that
     // its contents do not lie entirely within the segment.
-    virtual void MisplacedSectionData(const string &section,
-                                      const string &segment);
+    virtual void MisplacedSectionData(const string& section,
+                                      const string& segment);
 
     // The LC_SYMTAB command claims that symbol table contents are located
     // beyond the end of the file.
@@ -310,7 +315,7 @@ class Reader {
     // Called to report that the segment's section list contains |section|.
     // This should return true if the iteration should continue, or false
     // if it should stop.
-    virtual bool HandleSection(const Section &section) = 0;
+    virtual bool HandleSection(const Section& section) = 0;
   };
 
   // A handler for the load commands in a Mach-O file.
@@ -336,20 +341,20 @@ class Reader {
     // cannot parse the command type or its size, we call
     // reporter_->IncompleteLoadCommand instead.)
     virtual bool UnknownCommand(LoadCommandType type,
-                                const ByteBuffer &contents) {
+                                const ByteBuffer& contents) {
       return true;
     }
 
     // The load command is LC_SEGMENT or LC_SEGMENT_64, defining a segment
     // with the properties given in |segment|.
-    virtual bool SegmentCommand(const Segment &segment) {
+    virtual bool SegmentCommand(const Segment& segment) {
       return true;
     }
 
     // The load command is LC_SYMTAB. |entries| holds the array of nlist
     // entries, and |names| holds the strings the entries refer to.
-    virtual bool SymtabCommand(const ByteBuffer &entries,
-                               const ByteBuffer &names) {
+    virtual bool SymtabCommand(const ByteBuffer& entries,
+                               const ByteBuffer& names) {
       return true;
     }
 
@@ -357,7 +362,7 @@ class Reader {
   };
 
   // Create a Mach-O file reader that reports problems to |reporter|.
-  explicit Reader(Reporter *reporter)
+  explicit Reader(Reporter* reporter)
       : reporter_(reporter) { }
 
   // Read the given data as a Mach-O file. The reader retains pointers
@@ -366,17 +371,17 @@ class Reader {
   //
   // At most one of these functions should be invoked once on each Reader
   // instance.
-  bool Read(const uint8_t *buffer,
+  bool Read(const uint8_t* buffer,
             size_t size,
             cpu_type_t expected_cpu_type,
             cpu_subtype_t expected_cpu_subtype);
-  bool Read(const ByteBuffer &buffer,
+  bool Read(const ByteBuffer& buffer,
             cpu_type_t expected_cpu_type,
             cpu_subtype_t expected_cpu_subtype) {
     return Read(buffer.start,
                 buffer.Size(),
                 expected_cpu_type,
-                expected_cpu_subtype); 
+                expected_cpu_subtype);
   }
 
   // Return this file's characteristics, as found in the Mach-O header.
@@ -397,25 +402,25 @@ class Reader {
   // a handler function returns false. If we encounter a malformed load
   // command, report it via reporter_ and return false. Return true if all
   // load commands were parseable and all handlers returned true.
-  bool WalkLoadCommands(LoadCommandHandler *handler) const;
+  bool WalkLoadCommands(LoadCommandHandler* handler) const;
 
   // Set |segment| to describe the segment named |name|, if present. If
   // found, |segment|'s byte buffers refer to a subregion of the bytes
   // passed to Read. If we find the section, return true; otherwise,
   // return false.
-  bool FindSegment(const string &name, Segment *segment) const;
+  bool FindSegment(const string& name, Segment* segment) const;
 
   // Apply |handler| to each section defined in |segment|. If |handler| returns
   // false, stop iterating and return false. If all calls to |handler| return
   // true and we reach the end of the section list, return true.
-  bool WalkSegmentSections(const Segment &segment, SectionHandler *handler)
+  bool WalkSegmentSections(const Segment& segment, SectionHandler* handler)
     const;
 
   // Clear |section_map| and then populate it with a map of the sections
   // in |segment|, from section names to Section structures.
   // Each Section's contents refer to bytes in |segment|'s contents.
   // On success, return true; if a problem occurs, report it and return false.
-  bool MapSegmentSections(const Segment &segment, SectionMap *section_map)
+  bool MapSegmentSections(const Segment& segment, SectionMap* section_map)
     const;
 
  private:
@@ -424,7 +429,7 @@ class Reader {
   class SectionMapper;
 
   // We use this to report problems parsing the file's contents. (WEAK)
-  Reporter *reporter_;
+  Reporter* reporter_;
 
   // The contents of the Mach-O file we're parsing. We do not own the
   // storage it refers to.
diff --git a/src/MEGASync/google_breakpad/common/mac/macho_reader_unittest.cc b/src/MEGASync/google_breakpad/common/mac/macho_reader_unittest.cc
index 9bc6d25a..dccda4e7 100644
--- a/src/MEGASync/google_breakpad/common/mac/macho_reader_unittest.cc
+++ b/src/MEGASync/google_breakpad/common/mac/macho_reader_unittest.cc
@@ -75,7 +75,7 @@ using testing::_;
 
 class MockFatReaderReporter: public FatReader::Reporter {
  public:
-  MockFatReaderReporter(const string &filename)
+  MockFatReaderReporter(const string& filename)
       : FatReader::Reporter(filename) { }
   MOCK_METHOD0(BadHeader, void());
   MOCK_METHOD0(MisplacedObjectFile, void());
@@ -84,7 +84,7 @@ class MockFatReaderReporter: public FatReader::Reporter {
 
 class MockReaderReporter: public Reader::Reporter {
  public:
-  MockReaderReporter(const string &filename) : Reader::Reporter(filename) { }
+  MockReaderReporter(const string& filename) : Reader::Reporter(filename) { }
   MOCK_METHOD0(BadHeader, void());
   MOCK_METHOD4(CPUTypeMismatch, void(cpu_type_t cpu_type,
                                      cpu_subtype_t cpu_subtype,
@@ -95,24 +95,24 @@ class MockReaderReporter: public Reader::Reporter {
   MOCK_METHOD3(LoadCommandsOverrun, void(size_t claimed, size_t i,
                                          LoadCommandType type));
   MOCK_METHOD2(LoadCommandTooShort, void(size_t i, LoadCommandType type));
-  MOCK_METHOD1(SectionsMissing, void(const string &name));
-  MOCK_METHOD1(MisplacedSegmentData, void(const string &name));
-  MOCK_METHOD2(MisplacedSectionData, void(const string &section,
-                                          const string &segment));
+  MOCK_METHOD1(SectionsMissing, void(const string& name));
+  MOCK_METHOD1(MisplacedSegmentData, void(const string& name));
+  MOCK_METHOD2(MisplacedSectionData, void(const string& section,
+                                          const string& segment));
   MOCK_METHOD0(MisplacedSymbolTable, void());
   MOCK_METHOD1(UnsupportedCPUType, void(cpu_type_t cpu_type));
 };
 
 class MockLoadCommandHandler: public Reader::LoadCommandHandler {
  public:
-  MOCK_METHOD2(UnknownCommand, bool(LoadCommandType, const ByteBuffer &));
-  MOCK_METHOD1(SegmentCommand, bool(const Segment &));
-  MOCK_METHOD2(SymtabCommand,  bool(const ByteBuffer &, const ByteBuffer &));
+  MOCK_METHOD2(UnknownCommand, bool(LoadCommandType, const ByteBuffer&));
+  MOCK_METHOD1(SegmentCommand, bool(const Segment&));
+  MOCK_METHOD2(SymtabCommand,  bool(const ByteBuffer&, const ByteBuffer&));
 };
 
 class MockSectionHandler: public Reader::SectionHandler {
  public:
-  MOCK_METHOD1(HandleSection, bool(const Section &section));
+  MOCK_METHOD1(HandleSection, bool(const Section& section));
 };
 
 
@@ -196,7 +196,7 @@ struct FatReaderFixture {
   FatReaderFixture()
       : fat(kBigEndian),
         reporter("reporter filename"),
-        reader(&reporter), object_files(), object_files_size() { 
+        reader(&reporter), object_files() {
     EXPECT_CALL(reporter, BadHeader()).Times(0);
     EXPECT_CALL(reporter, TooShort()).Times(0);
 
@@ -221,10 +221,15 @@ struct FatReaderFixture {
   }
   void ReadFat(bool expect_parse_success = true) {
     ASSERT_TRUE(fat.GetContents(&contents));
-    fat_bytes = reinterpret_cast<const uint8_t *>(contents.data());
+    fat_bytes = reinterpret_cast<const uint8_t*>(contents.data());
     if (expect_parse_success) {
       EXPECT_TRUE(reader.Read(fat_bytes, contents.size()));
-      object_files = reader.object_files(&object_files_size);
+      size_t fat_files_count;
+      const SuperFatArch* fat_files = reader.object_files(&fat_files_count);
+      object_files.resize(fat_files_count);
+      for (size_t i = 0; i < fat_files_count; ++i) {
+        EXPECT_TRUE(fat_files[i].ConvertToFatArch(&object_files[i]));
+      }
     }
     else
       EXPECT_FALSE(reader.Read(fat_bytes, contents.size()));
@@ -233,9 +238,8 @@ struct FatReaderFixture {
   MockFatReaderReporter reporter;
   FatReader reader;
   string contents;
-  const uint8_t *fat_bytes;
-  const struct fat_arch *object_files;
-  size_t object_files_size;
+  const uint8_t* fat_bytes;
+  vector<struct fat_arch> object_files;
 };
 
 class FatReaderTest: public FatReaderFixture, public Test { };
@@ -289,7 +293,7 @@ TEST_F(FatReaderTest, NoObjectFiles) {
       .B32(0xcafebabe)              // magic number
       .B32(0);                      // number of architectures
   ReadFat();
-  EXPECT_EQ(0U, object_files_size);
+  EXPECT_EQ(0U, object_files.size());
 }
 
 TEST_F(FatReaderTest, OneObjectFile) {
@@ -304,7 +308,7 @@ TEST_F(FatReaderTest, OneObjectFile) {
       .Mark(&obj1_offset)           
       .Append(0x42, '*');           // dummy contents
   ReadFat();
-  ASSERT_EQ(1U, object_files_size);
+  ASSERT_EQ(1U, object_files.size());
   EXPECT_EQ(0x5e3a6e91, object_files[0].cputype);
   EXPECT_EQ(0x52ccd852, object_files[0].cpusubtype);
   EXPECT_EQ(obj1_offset.Value(), object_files[0].offset);
@@ -334,7 +338,7 @@ TEST_F(FatReaderTest, ThreeObjectFiles) {
   
   ReadFat();
 
-  ASSERT_EQ(3U, object_files_size);
+  ASSERT_EQ(3U, object_files.size());
 
   // First object file.
   EXPECT_EQ(0x0cb92c30, object_files[0].cputype);
@@ -373,7 +377,7 @@ TEST_F(FatReaderTest, BigEndianMachO32) {
 
   // FatReader should treat a Mach-O file as if it were a fat binary file
   // containing one object file --- the whole thing.
-  ASSERT_EQ(1U, object_files_size);
+  ASSERT_EQ(1U, object_files.size());
   EXPECT_EQ(0x1a9d0518, object_files[0].cputype);
   EXPECT_EQ(0x1b779357, object_files[0].cpusubtype);
   EXPECT_EQ(0U, object_files[0].offset);
@@ -395,7 +399,7 @@ TEST_F(FatReaderTest, BigEndianMachO64) {
 
   // FatReader should treat a Mach-O file as if it were a fat binary file
   // containing one object file --- the whole thing.
-  ASSERT_EQ(1U, object_files_size);
+  ASSERT_EQ(1U, object_files.size());
   EXPECT_EQ(0x5aff8487, object_files[0].cputype);
   EXPECT_EQ(0x4c6a57f7, object_files[0].cpusubtype);
   EXPECT_EQ(0U, object_files[0].offset);
@@ -417,7 +421,7 @@ TEST_F(FatReaderTest, LittleEndianMachO32) {
 
   // FatReader should treat a Mach-O file as if it were a fat binary file
   // containing one object file --- the whole thing.
-  ASSERT_EQ(1U, object_files_size);
+  ASSERT_EQ(1U, object_files.size());
   EXPECT_EQ(0x1a9d0518, object_files[0].cputype);
   EXPECT_EQ(0x1b779357, object_files[0].cpusubtype);
   EXPECT_EQ(0U, object_files[0].offset);
@@ -439,7 +443,7 @@ TEST_F(FatReaderTest, LittleEndianMachO64) {
 
   // FatReader should treat a Mach-O file as if it were a fat binary file
   // containing one object file --- the whole thing.
-  ASSERT_EQ(1U, object_files_size);
+  ASSERT_EQ(1U, object_files.size());
   EXPECT_EQ(0x5aff8487, object_files[0].cputype);
   EXPECT_EQ(0x4c6a57f7, object_files[0].cpusubtype);
   EXPECT_EQ(0U, object_files[0].offset);
@@ -483,16 +487,16 @@ class WithConfiguration {
  private:
   // The innermost WithConfiguration in whose dynamic scope we are
   // currently executing.
-  static WithConfiguration *current_;
+  static WithConfiguration* current_;
 
   // The innermost WithConfiguration whose dynamic scope encloses this
   // WithConfiguration.
   Endianness endianness_;
   size_t word_size_;
-  WithConfiguration *saved_;
+  WithConfiguration* saved_;
 };
 
-WithConfiguration *WithConfiguration::current_ = NULL;
+WithConfiguration* WithConfiguration::current_ = NULL;
 
 // A test_assembler::Section with a size that we can cite. The start(),
 // Here() and Mark() member functions of a SizedSection always represent
@@ -523,7 +527,7 @@ class SizedSection: public test_assembler::Section {
 
   // Append SECTION to the end of this section, and call its Finish member.
   // Return a reference to this section.
-  SizedSection &Place(SizedSection *section) {
+  SizedSection& Place(SizedSection* section) {
     assert(section->endianness() == endianness());
     section->Finish();
     section->start() = Here();
@@ -559,7 +563,7 @@ class LoadedSection: public SizedSection {
 
   // Placing a loaded section within a loaded section sets the relationship
   // between their addresses.
-  LoadedSection &Place(LoadedSection *section) {
+  LoadedSection& Place(LoadedSection* section) {
     section->address() = address() + Size();
     SizedSection::Place(section);
     return *this;
@@ -579,7 +583,7 @@ class SegmentLoadCommand: public SizedSection {
   // The load command will refer to CONTENTS, which must be Placed in the
   // file separately, at the desired position. Return a reference to this
   // section.
-  SegmentLoadCommand &Header(const string &name, const LoadedSection &contents,
+  SegmentLoadCommand& Header(const string& name, const LoadedSection& contents,
                              uint32_t maxprot, uint32_t initprot,
                              uint32_t flags) {
     assert(contents.word_size() == word_size());
@@ -604,16 +608,16 @@ class SegmentLoadCommand: public SizedSection {
   // memory. If this label is still undefined by the time we place this
   // segment, it defaults to the final size of the segment's in-file
   // contents. Return a reference to this load command.
-  Label &vmsize() { return vmsize_; }
+  Label& vmsize() { return vmsize_; }
 
   // Add a section entry with the given characteristics to this segment
   // load command. Return a reference to this. The section entry will refer
   // to CONTENTS, which must be Placed in the segment's contents
   // separately, at the desired position.
-  SegmentLoadCommand &AppendSectionEntry(const string &section_name,
-                                         const string &segment_name,
+  SegmentLoadCommand& AppendSectionEntry(const string& section_name,
+                                         const string& segment_name,
                                          uint32_t alignment, uint32_t flags,
-                                         const LoadedSection &contents) {
+                                         const LoadedSection& contents) {
     AppendCString(section_name, 16);
     AppendCString(segment_name, 16);
     Append(endianness(), word_size() / 8, contents.address());
@@ -667,14 +671,14 @@ class LoadCommands: public SizedSection {
   Label final_command_count() const { return final_command_count_; }
 
   // Increment the command count; return a reference to this section.
-  LoadCommands &CountCommand() {
+  LoadCommands& CountCommand() {
     command_count_++;
     return *this;
   }
 
   // Place COMMAND, containing a load command, at the end of this section.
   // Return a reference to this section.
-  LoadCommands &Place(SizedSection *section) {
+  LoadCommands& Place(SizedSection* section) {
     SizedSection::Place(section);
     CountCommand();
     return *this;
@@ -706,7 +710,7 @@ class MachOFile: public SizedSection {
   // Create a Mach-O file header using the given characteristics and load
   // command list. This Places COMMANDS immediately after the header.
   // Return a reference to this section.
-  MachOFile &Header(LoadCommands *commands,
+  MachOFile& Header(LoadCommands* commands,
                     cpu_type_t cpu_type = CPU_TYPE_X86,
                     cpu_subtype_t cpu_subtype = CPU_SUBTYPE_I386_ALL,
                     FileType file_type = MH_EXECUTE,
@@ -748,12 +752,12 @@ struct ReaderFixture {
     EXPECT_CALL(load_command_handler, SegmentCommand(_)).Times(0);
   }
 
-  void ReadFile(MachOFile *file,
+  void ReadFile(MachOFile* file,
                 bool expect_parse_success,
                 cpu_type_t expected_cpu_type,
                 cpu_subtype_t expected_cpu_subtype) {
     ASSERT_TRUE(file->GetContents(&file_contents));
-    file_bytes = reinterpret_cast<const uint8_t *>(file_contents.data());
+    file_bytes = reinterpret_cast<const uint8_t*>(file_contents.data());
     if (expect_parse_success) {
       EXPECT_TRUE(reader.Read(file_bytes,
                               file_contents.size(),
@@ -768,7 +772,7 @@ struct ReaderFixture {
   }
 
   string file_contents;
-  const uint8_t *file_bytes;
+  const uint8_t* file_bytes;
   MockReaderReporter reporter;
   Reader reader;
   MockLoadCommandHandler load_command_handler;
@@ -1110,7 +1114,7 @@ TEST_F(LoadCommand, SegmentBE32) {
                     Return(true)));
   EXPECT_TRUE(reader.WalkLoadCommands(&load_command_handler));
 
-  EXPECT_EQ(false,                        actual_segment.bits_64);
+  EXPECT_FALSE(actual_segment.bits_64);
   EXPECT_EQ("froon",                      actual_segment.name);
   EXPECT_EQ(0x1891139cU,                  actual_segment.vmaddr);
   EXPECT_EQ(0xcb76584fU,                  actual_segment.vmsize);
@@ -1147,7 +1151,7 @@ TEST_F(LoadCommand, SegmentLE32) {
                     Return(true)));
   EXPECT_TRUE(reader.WalkLoadCommands(&load_command_handler));
 
-  EXPECT_EQ(false,                        actual_segment.bits_64);
+  EXPECT_FALSE(actual_segment.bits_64);
   EXPECT_EQ("sixteenprecisely",           actual_segment.name);
   EXPECT_EQ(0x4b877866U,                  actual_segment.vmaddr);
   EXPECT_EQ(0xcb76584fU,                  actual_segment.vmsize);
@@ -1339,14 +1343,14 @@ TEST_F(LoadCommand, ThreeLoadCommands) {
   EXPECT_TRUE(reader.WalkLoadCommands(&load_command_handler));
 }
 
-static inline Matcher<const Section &> MatchSection(
+static inline Matcher<const Section&> MatchSection(
     Matcher<bool> bits_64,
-    Matcher<const string &> section_name,
-    Matcher<const string &> segment_name,
+    Matcher<const string&> section_name,
+    Matcher<const string&> segment_name,
     Matcher<uint64_t> address,
     Matcher<uint32_t> alignment,
     Matcher<uint32_t> flags,
-    Matcher<const ByteBuffer &> contents) {
+    Matcher<const ByteBuffer&> contents) {
   return AllOf(AllOf(Field(&Section::bits_64, bits_64),
                      Field(&Section::section_name, section_name),
                      Field(&Section::segment_name, segment_name),
@@ -1356,10 +1360,10 @@ static inline Matcher<const Section &> MatchSection(
                      Field(&Section::contents, contents)));
 }
 
-static inline Matcher<const Section &> MatchSection(
+static inline Matcher<const Section&> MatchSection(
     Matcher<bool> bits_64,
-    Matcher<const string &> section_name,
-    Matcher<const string &> segment_name,
+    Matcher<const string&> section_name,
+    Matcher<const string&> segment_name,
     Matcher<uint64_t> address) {
   return AllOf(Field(&Section::bits_64, bits_64),
                Field(&Section::section_name, section_name),
@@ -1406,7 +1410,7 @@ TEST_F(LoadCommand, OneSegmentTwoSections) {
     contents1.start = file_bytes + section1.start().Value();
     contents1.end = contents1.start + section1.final_size().Value();
     EXPECT_EQ("buddha's hand",
-              string(reinterpret_cast<const char *>(contents1.start),
+              string(reinterpret_cast<const char*>(contents1.start),
                      contents1.Size()));
     EXPECT_CALL(section_handler,
                 HandleSection(MatchSection(true, "mandarin", "kishu",
@@ -1418,7 +1422,7 @@ TEST_F(LoadCommand, OneSegmentTwoSections) {
     contents2.start = file_bytes + section2.start().Value();
     contents2.end = contents2.start + section2.final_size().Value();
     EXPECT_EQ("kumquat",
-              string(reinterpret_cast<const char *>(contents2.start),
+              string(reinterpret_cast<const char*>(contents2.start),
                      contents2.Size()));
     EXPECT_CALL(section_handler,
                 HandleSection(MatchSection(true, "bergamot", "cara cara",
@@ -1712,7 +1716,7 @@ class StringAssembler: public SizedSection {
  public:
   // Add the string S to this StringAssembler, and return the string's
   // offset within this compilation unit's strings.
-  size_t Add(const string &s) {
+  size_t Add(const string& s) {
     size_t offset = Size();
     AppendCString(s);
     return offset;
@@ -1724,7 +1728,7 @@ class StringAssembler: public SizedSection {
 class SymbolAssembler: public SizedSection {
  public:
   // Create a SymbolAssembler that uses StringAssembler for its strings.
-  explicit SymbolAssembler(StringAssembler *string_assembler) 
+  explicit SymbolAssembler(StringAssembler* string_assembler)
       : string_assembler_(string_assembler),
         entry_count_(0) { }
 
@@ -1733,7 +1737,7 @@ class SymbolAssembler: public SizedSection {
   // its compilation unit's portion of the .stabstr section; this can be a
   // value generated by a StringAssembler. Return a reference to this
   // SymbolAssembler.
-  SymbolAssembler &Symbol(uint8_t type, uint8_t other, Label descriptor,
+  SymbolAssembler& Symbol(uint8_t type, uint8_t other, Label descriptor,
                           Label value, Label name) {
     D32(name);
     D8(type);
@@ -1745,14 +1749,14 @@ class SymbolAssembler: public SizedSection {
   }
 
   // As above, but automatically add NAME to our StringAssembler.
-  SymbolAssembler &Symbol(uint8_t type, uint8_t other, Label descriptor,
-                       Label value, const string &name) {
+  SymbolAssembler& Symbol(uint8_t type, uint8_t other, Label descriptor,
+                          Label value, const string& name) {
     return Symbol(type, other, descriptor, value, string_assembler_->Add(name));
   }
 
  private:
   // The strings for our STABS entries.
-  StringAssembler *string_assembler_;
+  StringAssembler* string_assembler_;
 
   // The number of entries in this compilation unit so far.
   size_t entry_count_;
diff --git a/src/MEGASync/google_breakpad/common/mac/macho_utilities.cc b/src/MEGASync/google_breakpad/common/mac/macho_utilities.cc
index 89f9e775..f56fe768 100644
--- a/src/MEGASync/google_breakpad/common/mac/macho_utilities.cc
+++ b/src/MEGASync/google_breakpad/common/mac/macho_utilities.cc
@@ -34,16 +34,44 @@
 #include "common/mac/byteswap.h"
 #include "common/mac/macho_utilities.h"
 
-void breakpad_swap_uuid_command(struct breakpad_uuid_command *uc,
-                                enum NXByteOrder target_byte_order)
-{
+#include <mach-o/fat.h>
+#include <mach-o/loader.h>
+
+void breakpad_swap_uuid_command(struct breakpad_uuid_command *uc) {
   uc->cmd = ByteSwap(uc->cmd);
   uc->cmdsize = ByteSwap(uc->cmdsize);
 }
 
-void breakpad_swap_segment_command_64(struct segment_command_64 *sg,
-                                      enum NXByteOrder target_byte_order)
-{
+void breakpad_swap_load_command(struct load_command *lc) {
+  lc->cmd = ByteSwap(lc->cmd);
+  lc->cmdsize = ByteSwap(lc->cmdsize);
+}
+
+void breakpad_swap_dylib_command(struct dylib_command *dc) {
+  dc->cmd = ByteSwap(dc->cmd);
+  dc->cmdsize = ByteSwap(dc->cmdsize);
+
+  dc->dylib.name.offset = ByteSwap(dc->dylib.name.offset);
+  dc->dylib.timestamp = ByteSwap(dc->dylib.timestamp);
+  dc->dylib.current_version = ByteSwap(dc->dylib.current_version);
+  dc->dylib.compatibility_version = ByteSwap(dc->dylib.compatibility_version);
+}
+
+void breakpad_swap_segment_command(struct segment_command *sc) {
+  sc->cmd = ByteSwap(sc->cmd);
+  sc->cmdsize = ByteSwap(sc->cmdsize);
+
+  sc->vmaddr = ByteSwap(sc->vmaddr);
+  sc->vmsize = ByteSwap(sc->vmsize);
+  sc->fileoff = ByteSwap(sc->fileoff);
+  sc->filesize = ByteSwap(sc->filesize);
+  sc->maxprot = ByteSwap(sc->maxprot);
+  sc->initprot = ByteSwap(sc->initprot);
+  sc->nsects = ByteSwap(sc->nsects);
+  sc->flags = ByteSwap(sc->flags);
+}
+
+void breakpad_swap_segment_command_64(struct segment_command_64 *sg) {
   sg->cmd = ByteSwap(sg->cmd);
   sg->cmdsize = ByteSwap(sg->cmdsize);
 
@@ -58,9 +86,32 @@ void breakpad_swap_segment_command_64(struct segment_command_64 *sg,
   sg->flags = ByteSwap(sg->flags);
 }
 
-void breakpad_swap_mach_header_64(struct mach_header_64 *mh,
-                                  enum NXByteOrder target_byte_order)
-{
+void breakpad_swap_fat_header(struct fat_header *fh) {
+  fh->magic = ByteSwap(fh->magic);
+  fh->nfat_arch = ByteSwap(fh->nfat_arch);
+}
+
+void breakpad_swap_fat_arch(struct fat_arch *fa, uint32_t narchs) {
+  for (uint32_t i = 0; i < narchs; ++i) {
+    fa[i].cputype = ByteSwap(fa[i].cputype);
+    fa[i].cpusubtype = ByteSwap(fa[i].cpusubtype);
+    fa[i].offset = ByteSwap(fa[i].offset);
+    fa[i].size = ByteSwap(fa[i].size);
+    fa[i].align = ByteSwap(fa[i].align);
+  }
+}
+
+void breakpad_swap_mach_header(struct mach_header *mh) {
+  mh->magic = ByteSwap(mh->magic);
+  mh->cputype = ByteSwap(mh->cputype);
+  mh->cpusubtype = ByteSwap(mh->cpusubtype);
+  mh->filetype = ByteSwap(mh->filetype);
+  mh->ncmds = ByteSwap(mh->ncmds);
+  mh->sizeofcmds = ByteSwap(mh->sizeofcmds);
+  mh->flags = ByteSwap(mh->flags);
+}
+
+void breakpad_swap_mach_header_64(struct mach_header_64 *mh) {
   mh->magic = ByteSwap(mh->magic);
   mh->cputype = ByteSwap(mh->cputype);
   mh->cpusubtype = ByteSwap(mh->cpusubtype);
@@ -71,10 +122,24 @@ void breakpad_swap_mach_header_64(struct mach_header_64 *mh,
   mh->reserved = ByteSwap(mh->reserved);
 }
 
+void breakpad_swap_section(struct section *s,
+                           uint32_t nsects) {
+  for (uint32_t i = 0; i < nsects; i++) {
+    s[i].addr = ByteSwap(s[i].addr);
+    s[i].size = ByteSwap(s[i].size);
+
+    s[i].offset = ByteSwap(s[i].offset);
+    s[i].align = ByteSwap(s[i].align);
+    s[i].reloff = ByteSwap(s[i].reloff);
+    s[i].nreloc = ByteSwap(s[i].nreloc);
+    s[i].flags = ByteSwap(s[i].flags);
+    s[i].reserved1 = ByteSwap(s[i].reserved1);
+    s[i].reserved2 = ByteSwap(s[i].reserved2);
+  }
+}
+
 void breakpad_swap_section_64(struct section_64 *s,
-                              uint32_t nsects,
-                              enum NXByteOrder target_byte_order)
-{
+                              uint32_t nsects) {
   for (uint32_t i = 0; i < nsects; i++) {
     s[i].addr = ByteSwap(s[i].addr);
     s[i].size = ByteSwap(s[i].size);
diff --git a/src/MEGASync/google_breakpad/common/mac/macho_utilities.h b/src/MEGASync/google_breakpad/common/mac/macho_utilities.h
index a200c0f7..00563a77 100644
--- a/src/MEGASync/google_breakpad/common/mac/macho_utilities.h
+++ b/src/MEGASync/google_breakpad/common/mac/macho_utilities.h
@@ -62,23 +62,34 @@ struct breakpad_uuid_command {
   uint8_t     uuid[16];       /* the 128-bit uuid */
 };
 
-void breakpad_swap_uuid_command(struct breakpad_uuid_command *uc,
-                                enum NXByteOrder target_byte_order);
+void breakpad_swap_uuid_command(struct breakpad_uuid_command *uc);
+
+void breakpad_swap_load_command(struct load_command *lc);
+
+void breakpad_swap_dylib_command(struct dylib_command *dc);
 
 // Older SDKs defines thread_state_data_t as an int[] instead
 // of the natural_t[] it should be.
 typedef natural_t breakpad_thread_state_data_t[THREAD_STATE_MAX];
 
+void breakpad_swap_segment_command(struct segment_command *sc);
+
 // The 64-bit swap routines were added during the 10.4 series, their
 // presence isn't guaranteed.
-void breakpad_swap_segment_command_64(struct segment_command_64 *sg,
-                                      enum NXByteOrder target_byte_order);
+void breakpad_swap_segment_command_64(struct segment_command_64 *sg);
+
+void breakpad_swap_fat_header(struct fat_header *fh);
+
+void breakpad_swap_fat_arch(struct fat_arch *fa, uint32_t narchs);
+
+void breakpad_swap_mach_header(struct mach_header *mh);
+
+void breakpad_swap_mach_header_64(struct mach_header_64 *mh);
 
-void breakpad_swap_mach_header_64(struct mach_header_64 *mh,
-                                  enum NXByteOrder target_byte_order);
+void breakpad_swap_section(struct section *s,
+                           uint32_t nsects);
 
 void breakpad_swap_section_64(struct section_64 *s,
-                              uint32_t nsects,
-                              enum NXByteOrder target_byte_order);
+                              uint32_t nsects);
 
 #endif
diff --git a/src/MEGASync/google_breakpad/common/mac/macho_walker.cc b/src/MEGASync/google_breakpad/common/mac/macho_walker.cc
index b2948b71..a42128b8 100644
--- a/src/MEGASync/google_breakpad/common/mac/macho_walker.cc
+++ b/src/MEGASync/google_breakpad/common/mac/macho_walker.cc
@@ -33,15 +33,13 @@
 //
 // Author: Dan Waylonis
 
-extern "C" {  // necessary for Leopard
-  #include <assert.h>
-  #include <fcntl.h>
-  #include <mach-o/arch.h>
-  #include <mach-o/loader.h>
-  #include <mach-o/swap.h>
-  #include <string.h>
-  #include <unistd.h>
-}
+#include <assert.h>
+#include <fcntl.h>
+#include <mach-o/arch.h>
+#include <mach-o/fat.h>
+#include <mach-o/loader.h>
+#include <string.h>
+#include <unistd.h>
 
 #include "common/mac/byteswap.h"
 #include "common/mac/macho_walker.h"
@@ -49,9 +47,9 @@ extern "C" {  // necessary for Leopard
 
 namespace MacFileUtilities {
 
-MachoWalker::MachoWalker(const char *path, LoadCommandCallback callback,
-                         void *context)
-    : file_(0),
+MachoWalker::MachoWalker(const char* path, LoadCommandCallback callback,
+                         void* context)
+    : file_(-1),
       memory_(NULL),
       memory_size_(0),
       callback_(callback),
@@ -62,9 +60,9 @@ MachoWalker::MachoWalker(const char *path, LoadCommandCallback callback,
   file_ = open(path, O_RDONLY);
 }
 
-MachoWalker::MachoWalker(void *memory, size_t size,
-                         LoadCommandCallback callback, void *context)
-    : file_(0),
+MachoWalker::MachoWalker(void* memory, size_t size,
+                         LoadCommandCallback callback, void* context)
+    : file_(-1),
       memory_(memory),
       memory_size_(size),
       callback_(callback),
@@ -84,7 +82,7 @@ bool MachoWalker::WalkHeader(cpu_type_t cpu_type, cpu_subtype_t cpu_subtype) {
   cpu_subtype_t valid_cpu_subtype = cpu_subtype;
   // if |cpu_type| is 0, use the native cpu type.
   if (cpu_type == 0) {
-    const NXArchInfo *arch = NXGetLocalArchInfo();
+    const NXArchInfo* arch = NXGetLocalArchInfo();
     assert(arch);
     valid_cpu_type = arch->cputype;
     valid_cpu_subtype = CPU_SUBTYPE_MULTIPLE;
@@ -100,7 +98,7 @@ bool MachoWalker::WalkHeader(cpu_type_t cpu_type, cpu_subtype_t cpu_subtype) {
   return false;
 }
 
-bool MachoWalker::ReadBytes(void *buffer, size_t size, off_t offset) {
+bool MachoWalker::ReadBytes(void* buffer, size_t size, off_t offset) {
   if (memory_) {
     if (offset < 0)
       return false;
@@ -111,14 +109,14 @@ bool MachoWalker::ReadBytes(void *buffer, size_t size, off_t offset) {
       size = memory_size_ - static_cast<size_t>(offset);
       result = false;
     }
-    memcpy(buffer, static_cast<char *>(memory_) + offset, size);
+    memcpy(buffer, static_cast<char*>(memory_) + offset, size);
     return result;
   } else {
     return pread(file_, buffer, size, offset) == (ssize_t)size;
   }
 }
 
-bool MachoWalker::CurrentHeader(struct mach_header_64 *header, off_t *offset) {
+bool MachoWalker::CurrentHeader(struct mach_header_64* header, off_t* offset) {
   if (current_header_) {
     memcpy(header, current_header_, sizeof(mach_header_64));
     *offset = current_header_offset_;
@@ -130,7 +128,7 @@ bool MachoWalker::CurrentHeader(struct mach_header_64 *header, off_t *offset) {
 
 bool MachoWalker::FindHeader(cpu_type_t cpu_type,
                              cpu_subtype_t cpu_subtype,
-                             off_t &offset) {
+                             off_t& offset) {
   // Read the magic bytes that's common amongst all mach-o files
   uint32_t magic;
   if (!ReadBytes(&magic, sizeof(magic), 0))
@@ -156,7 +154,7 @@ bool MachoWalker::FindHeader(cpu_type_t cpu_type,
       return false;
 
     if (magic == MH_CIGAM || magic == MH_CIGAM_64)
-      swap_mach_header(&header, NXHostByteOrder());
+      breakpad_swap_mach_header(&header);
 
     if (cpu_type != header.cputype ||
         (cpu_subtype != CPU_SUBTYPE_MULTIPLE &&
@@ -174,7 +172,7 @@ bool MachoWalker::FindHeader(cpu_type_t cpu_type,
       return false;
 
     if (NXHostByteOrder() != NX_BigEndian)
-      swap_fat_header(&fat, NXHostByteOrder());
+      breakpad_swap_fat_header(&fat);
 
     offset += sizeof(fat);
 
@@ -185,7 +183,7 @@ bool MachoWalker::FindHeader(cpu_type_t cpu_type,
         return false;
 
       if (NXHostByteOrder() != NX_BigEndian)
-        swap_fat_arch(&arch, 1, NXHostByteOrder());
+        breakpad_swap_fat_arch(&arch, 1);
 
       if (arch.cputype == cpu_type &&
           (cpu_subtype == CPU_SUBTYPE_MULTIPLE ||
@@ -208,12 +206,12 @@ bool MachoWalker::WalkHeaderAtOffset(off_t offset) {
 
   bool swap = (header.magic == MH_CIGAM);
   if (swap)
-    swap_mach_header(&header, NXHostByteOrder());
+    breakpad_swap_mach_header(&header);
 
   // Copy the data into the mach_header_64 structure.  Since the 32-bit and
   // 64-bit only differ in the last field (reserved), this is safe to do.
   struct mach_header_64 header64;
-  memcpy((void *)&header64, (const void *)&header, sizeof(header));
+  memcpy((void*)&header64, (const void*)&header, sizeof(header));
   header64.reserved = 0;
 
   current_header_ = &header64;
@@ -234,7 +232,7 @@ bool MachoWalker::WalkHeader64AtOffset(off_t offset) {
 
   bool swap = (header.magic == MH_CIGAM_64);
   if (swap)
-    breakpad_swap_mach_header_64(&header, NXHostByteOrder());
+    breakpad_swap_mach_header_64(&header);
 
   current_header_ = &header;
   current_header_size_ = sizeof(header);
@@ -255,7 +253,7 @@ bool MachoWalker::WalkHeaderCore(off_t offset, uint32_t number_of_commands,
       return false;
 
     if (swap)
-      swap_load_command(&cmd, NXHostByteOrder());
+      breakpad_swap_load_command(&cmd);
 
     // Call the user callback
     if (callback_ && !callback_(this, &cmd, offset, swap, callback_context_))
diff --git a/src/MEGASync/google_breakpad/common/mac/macho_walker.h b/src/MEGASync/google_breakpad/common/mac/macho_walker.h
index dd535814..168f30e6 100644
--- a/src/MEGASync/google_breakpad/common/mac/macho_walker.h
+++ b/src/MEGASync/google_breakpad/common/mac/macho_walker.h
@@ -49,12 +49,12 @@ class MachoWalker {
   // beginning of the file (not header) where the command was read.  If |swap|
   // is set, then any command data (other than the returned load_command) should
   // be swapped when read
-  typedef bool (*LoadCommandCallback)(MachoWalker *walker, load_command *cmd,
-                                      off_t offset, bool swap, void *context);
+  typedef bool (*LoadCommandCallback)(MachoWalker* walker, load_command* cmd,
+                                      off_t offset, bool swap, void* context);
 
-  MachoWalker(const char *path, LoadCommandCallback callback, void *context);
-  MachoWalker(void *memory, size_t size, LoadCommandCallback callback,
-              void *context);
+  MachoWalker(const char* path, LoadCommandCallback callback, void* context);
+  MachoWalker(void* memory, size_t size, LoadCommandCallback callback,
+              void* context);
   ~MachoWalker();
 
   // Begin walking the header for |cpu_type| and |cpu_subtype|.  If |cpu_type|
@@ -67,17 +67,17 @@ class MachoWalker {
   bool WalkHeader(cpu_type_t cpu_type, cpu_subtype_t cpu_subtype);
 
   // Read |size| bytes from the opened file at |offset| into |buffer|
-  bool ReadBytes(void *buffer, size_t size, off_t offset);
+  bool ReadBytes(void* buffer, size_t size, off_t offset);
 
   // Return the current header and header offset
-  bool CurrentHeader(struct mach_header_64 *header, off_t *offset);
+  bool CurrentHeader(struct mach_header_64* header, off_t* offset);
 
  private:
   // Locate (if any) the header offset for |cpu_type| and return in |offset|.
   // Return true if found, false otherwise.
   bool FindHeader(cpu_type_t cpu_type,
                   cpu_subtype_t cpu_subtype,
-                  off_t &offset);
+                  off_t& offset);
 
   // Process an individual header starting at |offset| from the start of the
   // file.  Return true if successful, false otherwise.
@@ -91,27 +91,27 @@ class MachoWalker {
   int file_;
 
   // Memory location to read from.
-  void *memory_;
+  void* memory_;
 
   // Size of the memory segment we can read from.
   size_t memory_size_;
 
   // User specified callback & context
   LoadCommandCallback callback_;
-  void *callback_context_;
+  void* callback_context_;
 
   // Current header, size, and offset.  The mach_header_64 is used for both
   // 32-bit and 64-bit headers because they only differ in their last field
   // (reserved).  By adding the |current_header_size_| and the
   // |current_header_offset_|, you can determine the offset in the file just
   // after the header.
-  struct mach_header_64 *current_header_;
+  struct mach_header_64* current_header_;
   unsigned long current_header_size_;
   off_t current_header_offset_;
 
  private:
-  MachoWalker(const MachoWalker &);
-  MachoWalker &operator=(const MachoWalker &);
+  MachoWalker(const MachoWalker&);
+  MachoWalker& operator=(const MachoWalker&);
 };
 
 }  // namespace MacFileUtilities
diff --git a/src/MEGASync/google_breakpad/common/mac/minidump_upload.m b/src/MEGASync/google_breakpad/common/mac/minidump_upload.m
new file mode 100644
index 00000000..1fe4f213
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/mac/minidump_upload.m
@@ -0,0 +1,135 @@
+// Copyright (c) 2006, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// minidump_upload.m: Upload a minidump to a HTTP server.  The upload is sent as
+// a multipart/form-data POST request with the following parameters:
+//  prod: the product name
+//  ver: the product version
+//  symbol_file: the breakpad format symbol file
+
+#import <unistd.h>
+
+#import <Foundation/Foundation.h>
+
+#import "common/mac/HTTPMultipartUpload.h"
+
+typedef struct {
+  NSString* minidumpPath;
+  NSString* uploadURLStr;
+  NSString* product;
+  NSString* version;
+  BOOL success;
+} Options;
+
+//=============================================================================
+static void Start(Options* options) {
+  NSURL* url = [NSURL URLWithString:options->uploadURLStr];
+  HTTPMultipartUpload* ul = [[HTTPMultipartUpload alloc] initWithURL:url];
+  NSMutableDictionary* parameters = [NSMutableDictionary dictionary];
+
+  // Add parameters
+  [parameters setObject:options->product forKey:@"prod"];
+  [parameters setObject:options->version forKey:@"ver"];
+  [ul setParameters:parameters];
+
+  // Add file
+  [ul addFileAtPath:options->minidumpPath name:@"upload_file_minidump"];
+
+  // Send it
+  NSError* error = nil;
+  NSData* data = [ul send:&error];
+  NSString* result = [[NSString alloc] initWithData:data
+                                           encoding:NSUTF8StringEncoding];
+
+  NSLog(@"Send: %@", error ? [error description] : @"No Error");
+  NSLog(@"Response: %ld", (long)[[ul response] statusCode]);
+  NSLog(@"Result: %lu bytes\n%@", (unsigned long)[data length], result);
+
+  [result release];
+  [ul release];
+  options->success = !error;
+}
+
+//=============================================================================
+static void Usage(int argc, const char* argv[]) {
+  fprintf(stderr, "Submit minidump information.\n");
+  fprintf(stderr,
+          "Usage: %s -p <product> -v <version> <minidump> "
+          "<upload-URL>\n",
+          argv[0]);
+  fprintf(stderr, "<minidump> should be a minidump.\n");
+  fprintf(stderr, "<upload-URL> is the destination for the upload\n");
+
+  fprintf(stderr, "\t-h: Usage\n");
+  fprintf(stderr, "\t-?: Usage\n");
+}
+
+//=============================================================================
+static void SetupOptions(int argc, const char* argv[], Options* options) {
+  extern int optind;
+  char ch;
+
+  while ((ch = getopt(argc, (char* const*)argv, "p:v:h?")) != -1) {
+    switch (ch) {
+      case 'p':
+        options->product = [NSString stringWithUTF8String:optarg];
+        break;
+      case 'v':
+        options->version = [NSString stringWithUTF8String:optarg];
+        break;
+
+      default:
+        Usage(argc, argv);
+        exit(0);
+        break;
+    }
+  }
+
+  if ((argc - optind) != 2) {
+    fprintf(stderr, "%s: Missing symbols file and/or upload-URL\n", argv[0]);
+    Usage(argc, argv);
+    exit(1);
+  }
+
+  options->minidumpPath = [NSString stringWithUTF8String:argv[optind]];
+  options->uploadURLStr = [NSString stringWithUTF8String:argv[optind + 1]];
+}
+
+//=============================================================================
+int main(int argc, const char* argv[]) {
+  NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];
+  Options options;
+
+  bzero(&options, sizeof(Options));
+  SetupOptions(argc, argv, &options);
+  Start(&options);
+
+  [pool release];
+  return options.success ? 0 : 1;
+}
diff --git a/src/MEGASync/google_breakpad/common/mac/string_utilities.cc b/src/MEGASync/google_breakpad/common/mac/string_utilities.cc
index 07c0f426..cb155403 100644
--- a/src/MEGASync/google_breakpad/common/mac/string_utilities.cc
+++ b/src/MEGASync/google_breakpad/common/mac/string_utilities.cc
@@ -48,12 +48,12 @@ std::string ConvertToString(CFStringRef str) {
   CFStringGetBytes(str, CFRangeMake(0, length), kCFStringEncodingUTF8, 0,
                    false, buffer.get(), maxUTF8Length, &actualUTF8Length);
   buffer[actualUTF8Length] = 0;
-  result.assign((const char *)buffer.get());
+  result.assign((const char*)buffer.get());
 
   return result;
 }
 
-unsigned int IntegerValueAtIndex(string &str, unsigned int idx) {
+unsigned int IntegerValueAtIndex(string& str, unsigned int idx) {
   string digits("0123456789"), temp;
   size_t start = 0;
   size_t end;
diff --git a/src/MEGASync/google_breakpad/common/mac/string_utilities.h b/src/MEGASync/google_breakpad/common/mac/string_utilities.h
index 6d89c834..e87304c1 100644
--- a/src/MEGASync/google_breakpad/common/mac/string_utilities.h
+++ b/src/MEGASync/google_breakpad/common/mac/string_utilities.h
@@ -45,7 +45,7 @@ string ConvertToString(CFStringRef str);
 
 // Return the idx'th decimal integer in str, separated by non-decimal-digits
 // E.g., str = 10.4.8, idx = 1 -> 4
-unsigned int IntegerValueAtIndex(string &str, unsigned int idx);
+unsigned int IntegerValueAtIndex(string& str, unsigned int idx);
 
 }  // namespace MacStringUtils
 
diff --git a/src/MEGASync/google_breakpad/common/mac/super_fat_arch.h b/src/MEGASync/google_breakpad/common/mac/super_fat_arch.h
new file mode 100644
index 00000000..d7fa018a
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/mac/super_fat_arch.h
@@ -0,0 +1,88 @@
+// Copyright (c) 2015, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// Original author: Erik Chen <erikchen@chromium.org>
+
+// super_fat_arch.h: A class to handle 64-bit object files. Has conversions to
+// and from struct fat_arch.
+
+#ifndef BREAKPAD_COMMON_MAC_SUPER_FAT_ARCH_H_
+#define BREAKPAD_COMMON_MAC_SUPER_FAT_ARCH_H_
+
+#include <limits>
+#include <mach-o/fat.h>
+#include <stdint.h>
+
+// Similar to struct fat_arch, except size-related parameters support
+// 64-bits.
+class SuperFatArch {
+ public:
+  uint32_t cputype;
+  uint32_t cpusubtype;
+  uint64_t offset;
+  uint64_t size;
+  uint64_t align;
+
+  SuperFatArch() :
+      cputype(0),
+      cpusubtype(0),
+      offset(0),
+      size(0),
+      align(0) {
+  }
+
+  explicit SuperFatArch(const struct fat_arch& arch) :
+      cputype(arch.cputype),
+      cpusubtype(arch.cpusubtype),
+      offset(arch.offset),
+      size(arch.size),
+      align(arch.align) {
+  }
+
+  // Returns false if the conversion cannot be made.
+  // If the conversion succeeds, the result is placed in |output_arch|.
+  bool ConvertToFatArch(struct fat_arch* output_arch) const {
+    if (offset > std::numeric_limits<uint32_t>::max())
+      return false;
+    if (size > std::numeric_limits<uint32_t>::max())
+      return false;
+    if (align > std::numeric_limits<uint32_t>::max())
+      return false;
+    struct fat_arch arch;
+    arch.cputype = cputype;
+    arch.cpusubtype = cpusubtype;
+    arch.offset = offset;
+    arch.size = size;
+    arch.align = align;
+    *output_arch = arch;
+    return true;
+  }
+};
+
+#endif  // BREAKPAD_COMMON_MAC_SUPER_FAT_ARCH_H_
diff --git a/src/MEGASync/google_breakpad/common/mac/testing/GTMSenTestCase.m b/src/MEGASync/google_breakpad/common/mac/testing/GTMSenTestCase.m
index 5607c316..162f01e9 100644
--- a/src/MEGASync/google_breakpad/common/mac/testing/GTMSenTestCase.m
+++ b/src/MEGASync/google_breakpad/common/mac/testing/GTMSenTestCase.m
@@ -26,10 +26,6 @@
 #import "GTMObjC2Runtime.h"
 #import "GTMUnitTestDevLog.h"
 
-#if !GTM_IPHONE_SDK
-#import "GTMGarbageCollection.h"
-#endif  // !GTM_IPHONE_SDK
-
 #if GTM_IPHONE_SDK && !GTM_IPHONE_USE_SENTEST
 #import <stdarg.h>
 
@@ -430,71 +426,3 @@ static int MethodSort(id a, id b, void *context) {
 }
 
 @end
-
-// Leak detection
-#if !GTM_IPHONE_DEVICE && !GTM_SUPPRESS_RUN_LEAKS_HOOK
-// Don't want to get leaks on the iPhone Device as the device doesn't
-// have 'leaks'. The simulator does though.
-
-// COV_NF_START
-// We don't have leak checking on by default, so this won't be hit.
-static void _GTMRunLeaks(void) {
-  // This is an atexit handler. It runs leaks for us to check if we are
-  // leaking anything in our tests.
-  const char* cExclusionsEnv = getenv("GTM_LEAKS_SYMBOLS_TO_IGNORE");
-  NSMutableString *exclusions = [NSMutableString string];
-  if (cExclusionsEnv) {
-    NSString *exclusionsEnv = [NSString stringWithUTF8String:cExclusionsEnv];
-    NSArray *exclusionsArray = [exclusionsEnv componentsSeparatedByString:@","];
-    NSString *exclusion;
-    NSCharacterSet *wcSet = [NSCharacterSet whitespaceCharacterSet];
-    GTM_FOREACH_OBJECT(exclusion, exclusionsArray) {
-      exclusion = [exclusion stringByTrimmingCharactersInSet:wcSet];
-      [exclusions appendFormat:@"-exclude \"%@\" ", exclusion];
-    }
-  }
-  // Clearing out DYLD_ROOT_PATH because iPhone Simulator framework libraries
-  // are different from regular OS X libraries and leaks will fail to run
-  // because of missing symbols. Also capturing the output of leaks and then
-  // pipe rather than a direct pipe, because otherwise if leaks failed,
-  // the system() call will still be successful. Bug:
-  // http://code.google.com/p/google-toolbox-for-mac/issues/detail?id=56
-  NSString *string
-    = [NSString stringWithFormat:
-       @"LeakOut=`DYLD_ROOT_PATH='' /usr/bin/leaks %@%d` &&"
-       @"echo \"$LeakOut\"|/usr/bin/sed -e 's/Leak: /Leaks:0: warning: Leak /'",
-       exclusions, getpid()];
-  int ret = system([string UTF8String]);
-  if (ret) {
-    fprintf(stderr,
-            "%s:%d: Error: Unable to run leaks. 'system' returned: %d\n",
-            __FILE__, __LINE__, ret);
-    fflush(stderr);
-  }
-}
-// COV_NF_END
-
-static __attribute__((constructor)) void _GTMInstallLeaks(void) {
-  BOOL checkLeaks = YES;
-#if !GTM_IPHONE_SDK
-  checkLeaks = GTMIsGarbageCollectionEnabled() ? NO : YES;
-#endif  // !GTM_IPHONE_SDK
-  if (checkLeaks) {
-    checkLeaks = getenv("GTM_ENABLE_LEAKS") ? YES : NO;
-    if (checkLeaks) {
-      // COV_NF_START
-      // We don't have leak checking on by default, so this won't be hit.
-      fprintf(stderr, "Leak Checking Enabled\n");
-      fflush(stderr);
-      int ret = atexit(&_GTMRunLeaks);
-      // To avoid unused variable warning when _GTMDevAssert is stripped.
-      (void)ret;
-      _GTMDevAssert(ret == 0,
-                    @"Unable to install _GTMRunLeaks as an atexit handler (%d)",
-                    errno);
-      // COV_NF_END
-    }
-  }
-}
-
-#endif   // !GTM_IPHONE_DEVICE && !GTM_SUPPRESS_RUN_LEAKS_HOOK
diff --git a/src/MEGASync/google_breakpad/common/macros.h b/src/MEGASync/google_breakpad/common/macros.h
new file mode 100644
index 00000000..14bb3f7b
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/macros.h
@@ -0,0 +1,45 @@
+// Copyright (c) 2019, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef BREAKPAD_COMMON_MACROS_H_
+#define BREAKPAD_COMMON_MACROS_H_
+
+// Ensure that this macro definition stays in a private header file: clang
+// suggests the first macro expanding to [[clang::fallthrough]] in its
+// diagnostics, so if BP_FALLTHROUGH is visible in code depending on breakpad,
+// clang would suggest BP_FALLTHROUGH for code depending on breakpad, instead of
+// the client code's own fallthrough macro.
+// TODO(thakis): Once everyone uses C++17, use its [[fallthrough]] instead.
+#if defined(__clang__)
+#define BP_FALLTHROUGH [[clang::fallthrough]]
+#else
+#define BP_FALLTHROUGH
+#endif
+
+#endif // BREAKPAD_COMMON_MACROS_H_
diff --git a/src/MEGASync/google_breakpad/common/md5.cc b/src/MEGASync/google_breakpad/common/md5.cc
index bccf61c6..b6e710da 100644
--- a/src/MEGASync/google_breakpad/common/md5.cc
+++ b/src/MEGASync/google_breakpad/common/md5.cc
@@ -31,7 +31,7 @@ static void byteReverse(unsigned char *buf, unsigned longs)
   do {
     t = (u32) ((unsigned) buf[3] << 8 | buf[2]) << 16 |
       ((unsigned) buf[1] << 8 | buf[0]);
-    *(u32 *) buf = t;
+    *(u32*) buf = t;
     buf += 4;
   } while (--longs);
 }
@@ -58,7 +58,7 @@ void MD5Init(struct MD5Context *ctx)
  * Update context to reflect the concatenation of another buffer full
  * of bytes.
  */
-void MD5Update(struct MD5Context *ctx, unsigned char const *buf, unsigned len)
+void MD5Update(struct MD5Context *ctx, unsigned char const *buf, size_t len)
 {
   u32 t;
 
@@ -74,7 +74,7 @@ void MD5Update(struct MD5Context *ctx, unsigned char const *buf, unsigned len)
   /* Handle any leading odd-sized chunks */
 
   if (t) {
-    unsigned char *p = (unsigned char *) ctx->in + t;
+    unsigned char *p = (unsigned char*) ctx->in + t;
 
     t = 64 - t;
     if (len < t) {
@@ -83,7 +83,7 @@ void MD5Update(struct MD5Context *ctx, unsigned char const *buf, unsigned len)
     }
     memcpy(p, buf, t);
     byteReverse(ctx->in, 16);
-    MD5Transform(ctx->buf, (u32 *) ctx->in);
+    MD5Transform(ctx->buf, (u32*) ctx->in);
     buf += t;
     len -= t;
   }
@@ -92,7 +92,7 @@ void MD5Update(struct MD5Context *ctx, unsigned char const *buf, unsigned len)
   while (len >= 64) {
     memcpy(ctx->in, buf, 64);
     byteReverse(ctx->in, 16);
-    MD5Transform(ctx->buf, (u32 *) ctx->in);
+    MD5Transform(ctx->buf, (u32*) ctx->in);
     buf += 64;
     len -= 64;
   }
@@ -127,7 +127,7 @@ void MD5Final(unsigned char digest[16], struct MD5Context *ctx)
     /* Two lots of padding:  Pad the first block to 64 bytes */
     memset(p, 0, count);
     byteReverse(ctx->in, 16);
-    MD5Transform(ctx->buf, (u32 *) ctx->in);
+    MD5Transform(ctx->buf, (u32*) ctx->in);
 
     /* Now fill the next block with 56 bytes */
     memset(ctx->in, 0, 56);
@@ -138,11 +138,11 @@ void MD5Final(unsigned char digest[16], struct MD5Context *ctx)
   byteReverse(ctx->in, 14);
 
   /* Append length in bits and transform */
-  ((u32 *) ctx->in)[14] = ctx->bits[0];
-  ((u32 *) ctx->in)[15] = ctx->bits[1];
+  memcpy(&ctx->in[14], &ctx->bits[0], sizeof(u32));
+  memcpy(&ctx->in[15], &ctx->bits[1], sizeof(u32));
 
-  MD5Transform(ctx->buf, (u32 *) ctx->in);
-  byteReverse((unsigned char *) ctx->buf, 4);
+  MD5Transform(ctx->buf, (u32*) ctx->in);
+  byteReverse((unsigned char*) ctx->buf, 4);
   memcpy(digest, ctx->buf, 16);
   memset(ctx, 0, sizeof(*ctx));        /* In case it's sensitive */
 }
@@ -166,7 +166,7 @@ void MD5Final(unsigned char digest[16], struct MD5Context *ctx)
  */
 static void MD5Transform(u32 buf[4], u32 const in[16])
 {
-  register u32 a, b, c, d;
+  u32 a, b, c, d;
 
   a = buf[0];
   b = buf[1];
diff --git a/src/MEGASync/google_breakpad/common/md5.h b/src/MEGASync/google_breakpad/common/md5.h
index e96521ee..2ab0ab95 100644
--- a/src/MEGASync/google_breakpad/common/md5.h
+++ b/src/MEGASync/google_breakpad/common/md5.h
@@ -18,7 +18,7 @@ struct MD5Context {
 
 void MD5Init(struct MD5Context *ctx);
 
-void MD5Update(struct MD5Context *ctx, unsigned char const *buf, unsigned len);
+void MD5Update(struct MD5Context *ctx, unsigned char const *buf, size_t len);
 
 void MD5Final(unsigned char digest[16], struct MD5Context *ctx);
 
diff --git a/src/MEGASync/google_breakpad/common/memory.h b/src/MEGASync/google_breakpad/common/memory_allocator.h
similarity index 65%
rename from src/MEGASync/google_breakpad/common/memory.h
rename to src/MEGASync/google_breakpad/common/memory_allocator.h
index 5f944452..69055a15 100644
--- a/src/MEGASync/google_breakpad/common/memory.h
+++ b/src/MEGASync/google_breakpad/common/memory_allocator.h
@@ -27,8 +27,8 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-#ifndef GOOGLE_BREAKPAD_COMMON_MEMORY_H_
-#define GOOGLE_BREAKPAD_COMMON_MEMORY_H_
+#ifndef GOOGLE_BREAKPAD_COMMON_MEMORY_ALLOCATOR_H_
+#define GOOGLE_BREAKPAD_COMMON_MEMORY_ALLOCATOR_H_
 
 #include <stdint.h>
 #include <stdlib.h>
@@ -38,9 +38,12 @@
 #include <memory>
 #include <vector>
 
+#if defined(MEMORY_SANITIZER)
+#include <sanitizer/msan_interface.h>
+#endif
+
 #ifdef __APPLE__
 #define sys_mmap mmap
-#define sys_mmap2 mmap
 #define sys_munmap munmap
 #define MAP_ANONYMOUS MAP_ANON
 #else
@@ -60,19 +63,20 @@ class PageAllocator {
       : page_size_(getpagesize()),
         last_(NULL),
         current_page_(NULL),
-        page_offset_(0) {
+        page_offset_(0),
+        pages_allocated_(0) {
   }
 
   ~PageAllocator() {
     FreeAll();
   }
 
-  void *Alloc(unsigned bytes) {
+  void* Alloc(size_t bytes) {
     if (!bytes)
       return NULL;
 
     if (current_page_ && page_size_ - page_offset_ >= bytes) {
-      uint8_t *const ret = current_page_ + page_offset_;
+      uint8_t* const ret = current_page_ + page_offset_;
       page_offset_ += bytes;
       if (page_offset_ == page_size_) {
         page_offset_ = 0;
@@ -82,9 +86,9 @@ class PageAllocator {
       return ret;
     }
 
-    const unsigned pages =
+    const size_t pages =
         (bytes + sizeof(PageHeader) + page_size_ - 1) / page_size_;
-    uint8_t *const ret = GetNPages(pages);
+    uint8_t* const ret = GetNPages(pages);
     if (!ret)
       return NULL;
 
@@ -108,44 +112,50 @@ class PageAllocator {
     return false;
   }
 
+  unsigned long pages_allocated() { return pages_allocated_; }
+
  private:
-  uint8_t *GetNPages(unsigned num_pages) {
-#ifdef __x86_64
-    void *a = sys_mmap(NULL, page_size_ * num_pages, PROT_READ | PROT_WRITE,
+  uint8_t* GetNPages(size_t num_pages) {
+    void* a = sys_mmap(NULL, page_size_ * num_pages, PROT_READ | PROT_WRITE,
                        MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
-#else
-    void *a = sys_mmap2(NULL, page_size_ * num_pages, PROT_READ | PROT_WRITE,
-                        MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
-#endif
     if (a == MAP_FAILED)
       return NULL;
 
-    struct PageHeader *header = reinterpret_cast<PageHeader*>(a);
+#if defined(MEMORY_SANITIZER)
+    // We need to indicate to MSan that memory allocated through sys_mmap is
+    // initialized, since linux_syscall_support.h doesn't have MSan hooks.
+    __msan_unpoison(a, page_size_ * num_pages);
+#endif
+
+    struct PageHeader* header = reinterpret_cast<PageHeader*>(a);
     header->next = last_;
     header->num_pages = num_pages;
     last_ = header;
 
+    pages_allocated_ += num_pages;
+
     return reinterpret_cast<uint8_t*>(a);
   }
 
   void FreeAll() {
-    PageHeader *next;
+    PageHeader* next;
 
-    for (PageHeader *cur = last_; cur; cur = next) {
+    for (PageHeader* cur = last_; cur; cur = next) {
       next = cur->next;
       sys_munmap(cur, cur->num_pages * page_size_);
     }
   }
 
   struct PageHeader {
-    PageHeader *next;  // pointer to the start of the next set of pages.
-    unsigned num_pages;  // the number of pages in this set.
+    PageHeader* next;  // pointer to the start of the next set of pages.
+    size_t num_pages;  // the number of pages in this set.
   };
 
-  const unsigned page_size_;
-  PageHeader *last_;
-  uint8_t *current_page_;
-  unsigned page_offset_;
+  const size_t page_size_;
+  PageHeader* last_;
+  uint8_t* current_page_;
+  size_t page_offset_;
+  unsigned long pages_allocated_;
 };
 
 // Wrapper to use with STL containers
@@ -154,12 +164,30 @@ struct PageStdAllocator : public std::allocator<T> {
   typedef typename std::allocator<T>::pointer pointer;
   typedef typename std::allocator<T>::size_type size_type;
 
-  explicit PageStdAllocator(PageAllocator& allocator): allocator_(allocator) {}
+  explicit PageStdAllocator(PageAllocator& allocator) : allocator_(allocator),
+                                                        stackdata_(NULL),
+                                                        stackdata_size_(0)
+  {}
+
   template <class Other> PageStdAllocator(const PageStdAllocator<Other>& other)
-      : allocator_(other.allocator_) {}
+      : allocator_(other.allocator_),
+        stackdata_(nullptr),
+        stackdata_size_(0)
+  {}
+
+  explicit PageStdAllocator(PageAllocator& allocator,
+                            pointer stackdata,
+                            size_type stackdata_size) : allocator_(allocator),
+      stackdata_(stackdata),
+      stackdata_size_(stackdata_size)
+  {}
 
   inline pointer allocate(size_type n, const void* = 0) {
-    return static_cast<pointer>(allocator_.Alloc(sizeof(T) * n));
+    const size_type size = sizeof(T) * n;
+    if (size <= stackdata_size_) {
+      return stackdata_;
+    }
+    return static_cast<pointer>(allocator_.Alloc(size));
   }
 
   inline void deallocate(pointer, size_type) {
@@ -177,6 +205,8 @@ struct PageStdAllocator : public std::allocator<T> {
   template<typename Other> friend struct PageStdAllocator;
 
   PageAllocator& allocator_;
+  pointer stackdata_;
+  size_type stackdata_size_;
 };
 
 // A wasteful vector is a std::vector, except that it allocates memory from a
@@ -189,6 +219,24 @@ class wasteful_vector : public std::vector<T, PageStdAllocator<T> > {
       : std::vector<T, PageStdAllocator<T> >(PageStdAllocator<T>(*allocator)) {
     std::vector<T, PageStdAllocator<T> >::reserve(size_hint);
   }
+ protected:
+  wasteful_vector(PageStdAllocator<T> allocator)
+      : std::vector<T, PageStdAllocator<T> >(allocator) {}
+};
+
+// auto_wasteful_vector allocates space on the stack for N entries to avoid
+// using the PageAllocator for small data, while still allowing for larger data.
+template<class T, unsigned int N>
+class auto_wasteful_vector : public wasteful_vector<T> {
+ T stackdata_[N];
+ public:
+  auto_wasteful_vector(PageAllocator* allocator)
+      : wasteful_vector<T>(
+            PageStdAllocator<T>(*allocator,
+                                &stackdata_[0],
+                                sizeof(stackdata_))) {
+    std::vector<T, PageStdAllocator<T> >::reserve(N);
+  }
 };
 
 }  // namespace google_breakpad
@@ -198,4 +246,4 @@ inline void* operator new(size_t nbytes,
   return allocator.Alloc(nbytes);
 }
 
-#endif  // GOOGLE_BREAKPAD_COMMON_MEMORY_H_
+#endif  // GOOGLE_BREAKPAD_COMMON_MEMORY_ALLOCATOR_H_
diff --git a/src/MEGASync/google_breakpad/common/memory_unittest.cc b/src/MEGASync/google_breakpad/common/memory_allocator_unittest.cc
similarity index 72%
rename from src/MEGASync/google_breakpad/common/memory_unittest.cc
rename to src/MEGASync/google_breakpad/common/memory_allocator_unittest.cc
index 1e511ca5..5803b90d 100644
--- a/src/MEGASync/google_breakpad/common/memory_unittest.cc
+++ b/src/MEGASync/google_breakpad/common/memory_allocator_unittest.cc
@@ -28,7 +28,7 @@
 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #include "breakpad_googletest_includes.h"
-#include "common/memory.h"
+#include "common/memory_allocator.h"
 
 using namespace google_breakpad;
 
@@ -38,13 +38,15 @@ typedef testing::Test PageAllocatorTest;
 
 TEST(PageAllocatorTest, Setup) {
   PageAllocator allocator;
+  EXPECT_EQ(0U, allocator.pages_allocated());
 }
 
 TEST(PageAllocatorTest, SmallObjects) {
   PageAllocator allocator;
 
+  EXPECT_EQ(0U, allocator.pages_allocated());
   for (unsigned i = 1; i < 1024; ++i) {
-    uint8_t *p = reinterpret_cast<uint8_t*>(allocator.Alloc(i));
+    uint8_t* p = reinterpret_cast<uint8_t*>(allocator.Alloc(i));
     ASSERT_FALSE(p == NULL);
     memset(p, 0, i);
   }
@@ -53,10 +55,12 @@ TEST(PageAllocatorTest, SmallObjects) {
 TEST(PageAllocatorTest, LargeObject) {
   PageAllocator allocator;
 
-  uint8_t *p = reinterpret_cast<uint8_t*>(allocator.Alloc(10000));
+  EXPECT_EQ(0U, allocator.pages_allocated());
+  uint8_t* p = reinterpret_cast<uint8_t*>(allocator.Alloc(10000));
   ASSERT_FALSE(p == NULL);
+  EXPECT_EQ(3U, allocator.pages_allocated());
   for (unsigned i = 1; i < 10; ++i) {
-    uint8_t *p = reinterpret_cast<uint8_t*>(allocator.Alloc(i));
+    uint8_t* p = reinterpret_cast<uint8_t*>(allocator.Alloc(i));
     ASSERT_FALSE(p == NULL);
     memset(p, 0, i);
   }
@@ -75,6 +79,7 @@ TEST(WastefulVectorTest, Setup) {
 
 TEST(WastefulVectorTest, Simple) {
   PageAllocator allocator_;
+  EXPECT_EQ(0U, allocator_.pages_allocated());
   wasteful_vector<unsigned> v(&allocator_);
 
   for (unsigned i = 0; i < 256; ++i) {
@@ -84,6 +89,7 @@ TEST(WastefulVectorTest, Simple) {
   }
   ASSERT_FALSE(v.empty());
   ASSERT_EQ(v.size(), 256u);
+  EXPECT_EQ(1U, allocator_.pages_allocated());
   for (unsigned i = 0; i < 256; ++i)
     ASSERT_EQ(v[i], i);
 }
@@ -91,7 +97,28 @@ TEST(WastefulVectorTest, Simple) {
 TEST(WastefulVectorTest, UsesPageAllocator) {
   PageAllocator allocator_;
   wasteful_vector<unsigned> v(&allocator_);
+  EXPECT_EQ(1U, allocator_.pages_allocated());
 
   v.push_back(1);
   ASSERT_TRUE(allocator_.OwnsPointer(&v[0]));
 }
+
+TEST(WastefulVectorTest, AutoWastefulVector) {
+  PageAllocator allocator_;
+  EXPECT_EQ(0U, allocator_.pages_allocated());
+
+  auto_wasteful_vector<unsigned, 4> v(&allocator_);
+  EXPECT_EQ(0U, allocator_.pages_allocated());
+
+  v.push_back(1);
+  EXPECT_EQ(0U, allocator_.pages_allocated());
+  EXPECT_FALSE(allocator_.OwnsPointer(&v[0]));
+
+  v.resize(4);
+  EXPECT_EQ(0U, allocator_.pages_allocated());
+  EXPECT_FALSE(allocator_.OwnsPointer(&v[0]));
+
+  v.resize(10);
+  EXPECT_EQ(1U, allocator_.pages_allocated());
+  EXPECT_TRUE(allocator_.OwnsPointer(&v[0]));
+}
diff --git a/src/MEGASync/google_breakpad/common/minidump_type_helper.h b/src/MEGASync/google_breakpad/common/minidump_type_helper.h
new file mode 100644
index 00000000..5a7d5a6a
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/minidump_type_helper.h
@@ -0,0 +1,56 @@
+// Copyright (c) 2014, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef GOOGLE_BREAKPAD_COMMON_MINIDUMP_TYPE_HELPER_H_
+#define GOOGLE_BREAKPAD_COMMON_MINIDUMP_TYPE_HELPER_H_
+
+#include <stdint.h>
+
+#include "google_breakpad/common/minidump_format.h"
+
+namespace google_breakpad {
+
+template <size_t>
+struct MDTypeHelper;
+
+template <>
+struct MDTypeHelper<sizeof(uint32_t)> {
+  typedef MDRawDebug32 MDRawDebug;
+  typedef MDRawLinkMap32 MDRawLinkMap;
+};
+
+template <>
+struct MDTypeHelper<sizeof(uint64_t)> {
+  typedef MDRawDebug64 MDRawDebug;
+  typedef MDRawLinkMap64 MDRawLinkMap;
+};
+
+}  // namespace google_breakpad
+
+#endif  // GOOGLE_BREAKPAD_COMMON_MINIDUMP_TYPE_HELPER_H_
diff --git a/src/MEGASync/google_breakpad/common/module.cc b/src/MEGASync/google_breakpad/common/module.cc
index 2d2e4efc..f70ae203 100644
--- a/src/MEGASync/google_breakpad/common/module.cc
+++ b/src/MEGASync/google_breakpad/common/module.cc
@@ -44,16 +44,17 @@
 namespace google_breakpad {
 
 using std::dec;
-using std::endl;
 using std::hex;
 
 
-Module::Module(const string &name, const string &os,
-               const string &architecture, const string &id) :
+Module::Module(const string& name, const string& os,
+               const string& architecture, const string& id,
+               const string& code_id /* = "" */) :
     name_(name),
     os_(os),
     architecture_(architecture),
     id_(id),
+    code_id_(code_id),
     load_address_(0) { }
 
 Module::~Module() {
@@ -63,7 +64,7 @@ Module::~Module() {
        it != functions_.end(); ++it) {
     delete *it;
   }
-  for (vector<StackFrameEntry *>::iterator it = stack_frame_entries_.begin();
+  for (vector<StackFrameEntry*>::iterator it = stack_frame_entries_.begin();
        it != stack_frame_entries_.end(); ++it) {
     delete *it;
   }
@@ -75,29 +76,73 @@ void Module::SetLoadAddress(Address address) {
   load_address_ = address;
 }
 
-void Module::AddFunction(Function *function) {
+void Module::SetAddressRanges(const vector<Range>& ranges) {
+  address_ranges_ = ranges;
+}
+
+void Module::AddFunction(Function* function) {
   // FUNC lines must not hold an empty name, so catch the problem early if
   // callers try to add one.
   assert(!function->name.empty());
+
+  if (!AddressIsInModule(function->address)) {
+    return;
+  }
+
+  // FUNCs are better than PUBLICs as they come with sizes, so remove an extern
+  // with the same address if present.
+  Extern ext(function->address);
+  ExternSet::iterator it_ext = externs_.find(&ext);
+  if (it_ext == externs_.end() &&
+      architecture_ == "arm" &&
+      (function->address & 0x1) == 0) {
+    // ARM THUMB functions have bit 0 set. ARM64 does not have THUMB.
+    Extern arm_thumb_ext(function->address | 0x1);
+    it_ext = externs_.find(&arm_thumb_ext);
+  }
+  if (it_ext != externs_.end()) {
+    delete *it_ext;
+    externs_.erase(it_ext);
+  }
+#if _DEBUG
+  {
+    // There should be no other PUBLIC symbols that overlap with the function.
+    for (const Range& range : function->ranges) {
+      Extern debug_ext(range.address);
+      ExternSet::iterator it_debug = externs_.lower_bound(&ext);
+      assert(it_debug == externs_.end() ||
+             (*it_debug)->address >= range.address + range.size);
+    }
+  }
+#endif
+
   std::pair<FunctionSet::iterator,bool> ret = functions_.insert(function);
-  if (!ret.second) {
+  if (!ret.second && (*ret.first != function)) {
     // Free the duplicate that was not inserted because this Module
     // now owns it.
     delete function;
   }
 }
 
-void Module::AddFunctions(vector<Function *>::iterator begin,
-                          vector<Function *>::iterator end) {
-  for (vector<Function *>::iterator it = begin; it != end; ++it)
+void Module::AddFunctions(vector<Function*>::iterator begin,
+                          vector<Function*>::iterator end) {
+  for (vector<Function*>::iterator it = begin; it != end; ++it)
     AddFunction(*it);
 }
 
-void Module::AddStackFrameEntry(StackFrameEntry *stack_frame_entry) {
+void Module::AddStackFrameEntry(StackFrameEntry* stack_frame_entry) {
+  if (!AddressIsInModule(stack_frame_entry->address)) {
+    return;
+  }
+
   stack_frame_entries_.push_back(stack_frame_entry);
 }
 
-void Module::AddExtern(Extern *ext) {
+void Module::AddExtern(Extern* ext) {
+  if (!AddressIsInModule(ext->address)) {
+    return;
+  }
+
   std::pair<ExternSet::iterator,bool> ret = externs_.insert(ext);
   if (!ret.second) {
     // Free the duplicate that was not inserted because this Module
@@ -106,17 +151,17 @@ void Module::AddExtern(Extern *ext) {
   }
 }
 
-void Module::GetFunctions(vector<Function *> *vec,
-                          vector<Function *>::iterator i) {
+void Module::GetFunctions(vector<Function*>* vec,
+                          vector<Function*>::iterator i) {
   vec->insert(i, functions_.begin(), functions_.end());
 }
 
-void Module::GetExterns(vector<Extern *> *vec,
-                        vector<Extern *>::iterator i) {
+void Module::GetExterns(vector<Extern*>* vec,
+                        vector<Extern*>::iterator i) {
   vec->insert(i, externs_.begin(), externs_.end());
 }
 
-Module::File *Module::FindFile(const string &name) {
+Module::File* Module::FindFile(const string& name) {
   // A tricky bit here.  The key of each map entry needs to be a
   // pointer to the entry's File's name string.  This means that we
   // can't do the initial lookup with any operation that would create
@@ -130,8 +175,7 @@ Module::File *Module::FindFile(const string &name) {
   FileByNameMap::iterator destiny = files_.lower_bound(&name);
   if (destiny == files_.end()
       || *destiny->first != name) {  // Repeated string comparison, boo hoo.
-    File *file = new File;
-    file->name = name;
+    File* file = new File(name);
     file->source_id = -1;
     destiny = files_.insert(destiny,
                             FileByNameMap::value_type(&file->name, file));
@@ -139,23 +183,23 @@ Module::File *Module::FindFile(const string &name) {
   return destiny->second;
 }
 
-Module::File *Module::FindFile(const char *name) {
+Module::File* Module::FindFile(const char* name) {
   string name_string = name;
   return FindFile(name_string);
 }
 
-Module::File *Module::FindExistingFile(const string &name) {
+Module::File* Module::FindExistingFile(const string& name) {
   FileByNameMap::iterator it = files_.find(&name);
   return (it == files_.end()) ? NULL : it->second;
 }
 
-void Module::GetFiles(vector<File *> *vec) {
+void Module::GetFiles(vector<File*>* vec) {
   vec->clear();
   for (FileByNameMap::iterator it = files_.begin(); it != files_.end(); ++it)
     vec->push_back(it->second);
 }
 
-void Module::GetStackFrameEntries(vector<StackFrameEntry *> *vec) {
+void Module::GetStackFrameEntries(vector<StackFrameEntry*>* vec) const {
   *vec = stack_frame_entries_;
 }
 
@@ -170,7 +214,7 @@ void Module::AssignSourceIds() {
   // info, by setting each one's source id to zero.
   for (FunctionSet::const_iterator func_it = functions_.begin();
        func_it != functions_.end(); ++func_it) {
-    Function *func = *func_it;
+    Function* func = *func_it;
     for (vector<Line>::iterator line_it = func->lines.begin();
          line_it != func->lines.end(); ++line_it)
       line_it->file->source_id = 0;
@@ -194,7 +238,7 @@ bool Module::ReportError() {
   return false;
 }
 
-bool Module::WriteRuleMap(const RuleMap &rule_map, std::ostream &stream) {
+bool Module::WriteRuleMap(const RuleMap& rule_map, std::ostream& stream) {
   for (RuleMap::const_iterator it = rule_map.begin();
        it != rule_map.end(); ++it) {
     if (it != rule_map.begin())
@@ -204,21 +248,38 @@ bool Module::WriteRuleMap(const RuleMap &rule_map, std::ostream &stream) {
   return stream.good();
 }
 
-bool Module::Write(std::ostream &stream, SymbolData symbol_data) {
+bool Module::AddressIsInModule(Address address) const {
+  if (address_ranges_.empty()) {
+    return true;
+  }
+  for (const auto& segment : address_ranges_) {
+    if (address >= segment.address &&
+        address < segment.address + segment.size) {
+      return true;
+    }
+  }
+  return false;
+}
+
+bool Module::Write(std::ostream& stream, SymbolData symbol_data) {
   stream << "MODULE " << os_ << " " << architecture_ << " "
-         << id_ << " " << name_ << endl;
+         << id_ << " " << name_ << "\n";
   if (!stream.good())
     return ReportError();
 
+  if (!code_id_.empty()) {
+    stream << "INFO CODE_ID " << code_id_ << "\n";
+  }
+
   if (symbol_data != ONLY_CFI) {
     AssignSourceIds();
 
     // Write out files.
     for (FileByNameMap::iterator file_it = files_.begin();
          file_it != files_.end(); ++file_it) {
-      File *file = file_it->second;
+      File* file = file_it->second;
       if (file->source_id >= 0) {
-        stream << "FILE " << file->source_id << " " <<  file->name << endl;
+        stream << "FILE " << file->source_id << " " <<  file->name << "\n";
         if (!stream.good())
           return ReportError();
       }
@@ -227,44 +288,53 @@ bool Module::Write(std::ostream &stream, SymbolData symbol_data) {
     // Write out functions and their lines.
     for (FunctionSet::const_iterator func_it = functions_.begin();
          func_it != functions_.end(); ++func_it) {
-      Function *func = *func_it;
-      stream << "FUNC " << hex
-             << (func->address - load_address_) << " "
-             << func->size << " "
-             << func->parameter_size << " "
-             << func->name << dec << endl;
-      if (!stream.good())
-        return ReportError();
+      Function* func = *func_it;
+      vector<Line>::iterator line_it = func->lines.begin();
+      for (auto range_it = func->ranges.cbegin();
+           range_it != func->ranges.cend(); ++range_it) {
+        stream << "FUNC " << hex
+               << (range_it->address - load_address_) << " "
+               << range_it->size << " "
+               << func->parameter_size << " "
+               << func->name << dec << "\n";
 
-      for (vector<Line>::iterator line_it = func->lines.begin();
-           line_it != func->lines.end(); ++line_it) {
-        stream << hex
-               << (line_it->address - load_address_) << " "
-               << line_it->size << " "
-               << dec
-               << line_it->number << " "
-               << line_it->file->source_id << endl;
         if (!stream.good())
           return ReportError();
+
+        while ((line_it != func->lines.end()) &&
+               (line_it->address >= range_it->address) &&
+               (line_it->address < (range_it->address + range_it->size))) {
+          stream << hex
+                 << (line_it->address - load_address_) << " "
+                 << line_it->size << " "
+                 << dec
+                 << line_it->number << " "
+                 << line_it->file->source_id << "\n";
+
+          if (!stream.good())
+            return ReportError();
+
+          ++line_it;
+        }
       }
     }
 
     // Write out 'PUBLIC' records.
     for (ExternSet::const_iterator extern_it = externs_.begin();
          extern_it != externs_.end(); ++extern_it) {
-      Extern *ext = *extern_it;
+      Extern* ext = *extern_it;
       stream << "PUBLIC " << hex
              << (ext->address - load_address_) << " 0 "
-             << ext->name << dec << endl;
+             << ext->name << dec << "\n";
     }
   }
 
   if (symbol_data != NO_CFI) {
     // Write out 'STACK CFI INIT' and 'STACK CFI' records.
-    vector<StackFrameEntry *>::const_iterator frame_it;
+    vector<StackFrameEntry*>::const_iterator frame_it;
     for (frame_it = stack_frame_entries_.begin();
          frame_it != stack_frame_entries_.end(); ++frame_it) {
-      StackFrameEntry *entry = *frame_it;
+      StackFrameEntry* entry = *frame_it;
       stream << "STACK CFI INIT " << hex
              << (entry->address - load_address_) << " "
              << entry->size << " " << dec;
@@ -272,7 +342,7 @@ bool Module::Write(std::ostream &stream, SymbolData symbol_data) {
           || !WriteRuleMap(entry->initial_rules, stream))
         return ReportError();
 
-      stream << endl;
+      stream << "\n";
 
       // Write out this entry's delta rules as 'STACK CFI' records.
       for (RuleChangeMap::const_iterator delta_it = entry->rule_changes.begin();
@@ -283,7 +353,7 @@ bool Module::Write(std::ostream &stream, SymbolData symbol_data) {
             || !WriteRuleMap(delta_it->second, stream))
           return ReportError();
 
-        stream << endl;
+        stream << "\n";
       }
     }
   }
diff --git a/src/MEGASync/google_breakpad/common/module.h b/src/MEGASync/google_breakpad/common/module.h
index 398bc315..408e620b 100644
--- a/src/MEGASync/google_breakpad/common/module.h
+++ b/src/MEGASync/google_breakpad/common/module.h
@@ -39,6 +39,7 @@
 #define COMMON_LINUX_MODULE_H__
 
 #include <iostream>
+#include <limits>
 #include <map>
 #include <set>
 #include <string>
@@ -62,6 +63,7 @@ class Module {
  public:
   // The type of addresses and sizes in a symbol table.
   typedef uint64_t Address;
+  static constexpr uint64_t kMaxAddress = std::numeric_limits<Address>::max();
   struct File;
   struct Function;
   struct Line;
@@ -74,8 +76,10 @@ class Module {
 
   // A source file.
   struct File {
+    explicit File(const string& name_input) : name(name_input), source_id(0) {}
+
     // The name of the source file.
-    string name;
+    const string name;
 
     // The file's source id.  The Write member function clears this
     // field and assigns source ids a fresh, so any value placed here
@@ -83,19 +87,32 @@ class Module {
     int source_id;
   };
 
+  // An address range.
+  struct Range {
+    Range(const Address address_input, const Address size_input) :
+        address(address_input), size(size_input) { }
+
+    Address address;
+    Address size;
+  };
+
   // A function.
   struct Function {
+    Function(const string& name_input, const Address& address_input) :
+        name(name_input), address(address_input), parameter_size(0) {}
+
     // For sorting by address.  (Not style-guide compliant, but it's
     // stupid not to put this in the struct.)
-    static bool CompareByAddress(const Function *x, const Function *y) {
+    static bool CompareByAddress(const Function* x, const Function* y) {
       return x->address < y->address;
     }
 
     // The function's name.
     string name;
 
-    // The start address and length of the function's code.
-    Address address, size;
+    // The start address and the address ranges covered by the function.
+    const Address address;
+    vector<Range> ranges;
 
     // The function's parameter size.
     Address parameter_size;
@@ -109,18 +126,19 @@ class Module {
   struct Line {
     // For sorting by address.  (Not style-guide compliant, but it's
     // stupid not to put this in the struct.)
-    static bool CompareByAddress(const Module::Line &x, const Module::Line &y) {
+    static bool CompareByAddress(const Module::Line& x, const Module::Line& y) {
       return x.address < y.address;
     }
 
     Address address, size;    // The address and size of the line's code.
-    File *file;                // The source file.
+    File* file;                // The source file.
     int number;                // The source line number.
   };
 
   // An exported symbol.
   struct Extern {
-    Address address;
+    explicit Extern(const Address& address_input) : address(address_input) {}
+    const Address address;
     string name;
   };
 
@@ -154,8 +172,7 @@ class Module {
   };
 
   struct FunctionCompare {
-    bool operator() (const Function *lhs,
-                     const Function *rhs) const {
+    bool operator() (const Function* lhs, const Function* rhs) const {
       if (lhs->address == rhs->address)
         return lhs->name < rhs->name;
       return lhs->address < rhs->address;
@@ -163,16 +180,15 @@ class Module {
   };
 
   struct ExternCompare {
-    bool operator() (const Extern *lhs,
-                     const Extern *rhs) const {
+    bool operator() (const Extern* lhs, const Extern* rhs) const {
       return lhs->address < rhs->address;
     }
   };
 
   // Create a new module with the given name, operating system,
   // architecture, and ID string.
-  Module(const string &name, const string &os, const string &architecture,
-         const string &id);
+  Module(const string& name, const string& os, const string& architecture,
+         const string& id, const string& code_id = "");
   ~Module();
 
   // Set the module's load address to LOAD_ADDRESS; addresses given
@@ -189,65 +205,73 @@ class Module {
   // Write is used.
   void SetLoadAddress(Address load_address);
 
+  // Sets address filtering on elements added to the module.  This allows
+  // libraries with extraneous debug symbols to generate symbol files containing
+  // only relevant symbols.  For example, an LLD-generated partition library may
+  // contain debug information pertaining to all partitions derived from a
+  // single "combined" library.  Filtering applies only to elements added after
+  // this method is called.
+  void SetAddressRanges(const vector<Range>& ranges);
+
   // Add FUNCTION to the module. FUNCTION's name must not be empty.
   // This module owns all Function objects added with this function:
   // destroying the module destroys them as well.
-  void AddFunction(Function *function);
+  void AddFunction(Function* function);
 
   // Add all the functions in [BEGIN,END) to the module.
   // This module owns all Function objects added with this function:
   // destroying the module destroys them as well.
-  void AddFunctions(vector<Function *>::iterator begin,
-                    vector<Function *>::iterator end);
+  void AddFunctions(vector<Function*>::iterator begin,
+                    vector<Function*>::iterator end);
 
   // Add STACK_FRAME_ENTRY to the module.
   // This module owns all StackFrameEntry objects added with this
   // function: destroying the module destroys them as well.
-  void AddStackFrameEntry(StackFrameEntry *stack_frame_entry);
+  void AddStackFrameEntry(StackFrameEntry* stack_frame_entry);
 
   // Add PUBLIC to the module.
   // This module owns all Extern objects added with this function:
   // destroying the module destroys them as well.
-  void AddExtern(Extern *ext);
+  void AddExtern(Extern* ext);
 
   // If this module has a file named NAME, return a pointer to it. If
   // it has none, then create one and return a pointer to the new
   // file. This module owns all File objects created using these
   // functions; destroying the module destroys them as well.
-  File *FindFile(const string &name);
-  File *FindFile(const char *name);
+  File* FindFile(const string& name);
+  File* FindFile(const char* name);
 
   // If this module has a file named NAME, return a pointer to it.
   // Otherwise, return NULL.
-  File *FindExistingFile(const string &name);
+  File* FindExistingFile(const string& name);
 
   // Insert pointers to the functions added to this module at I in
   // VEC. The pointed-to Functions are still owned by this module.
   // (Since this is effectively a copy of the function list, this is
   // mostly useful for testing; other uses should probably get a more
   // appropriate interface.)
-  void GetFunctions(vector<Function *> *vec, vector<Function *>::iterator i);
+  void GetFunctions(vector<Function*>* vec, vector<Function*>::iterator i);
 
   // Insert pointers to the externs added to this module at I in
   // VEC. The pointed-to Externs are still owned by this module.
   // (Since this is effectively a copy of the extern list, this is
   // mostly useful for testing; other uses should probably get a more
   // appropriate interface.)
-  void GetExterns(vector<Extern *> *vec, vector<Extern *>::iterator i);
+  void GetExterns(vector<Extern*>* vec, vector<Extern*>::iterator i);
 
   // Clear VEC and fill it with pointers to the Files added to this
   // module, sorted by name. The pointed-to Files are still owned by
   // this module. (Since this is effectively a copy of the file list,
   // this is mostly useful for testing; other uses should probably get
   // a more appropriate interface.)
-  void GetFiles(vector<File *> *vec);
+  void GetFiles(vector<File*>* vec);
 
   // Clear VEC and fill it with pointers to the StackFrameEntry
   // objects that have been added to this module. (Since this is
   // effectively a copy of the stack frame entry list, this is mostly
   // useful for testing; other uses should probably get
   // a more appropriate interface.)
-  void GetStackFrameEntries(vector<StackFrameEntry *> *vec);
+  void GetStackFrameEntries(vector<StackFrameEntry*>* vec) const;
 
   // Find those files in this module that are actually referred to by
   // functions' line number data, and assign them source id numbers.
@@ -268,7 +292,13 @@ class Module {
   // - all CFI records.
   // Addresses in the output are all relative to the load address
   // established by SetLoadAddress.
-  bool Write(std::ostream &stream, SymbolData symbol_data);
+  bool Write(std::ostream& stream, SymbolData symbol_data);
+
+  string name() const { return name_; }
+  string os() const { return os_; }
+  string architecture() const { return architecture_; }
+  string identifier() const { return id_; }
+  string code_identifier() const { return code_id_; }
 
  private:
   // Report an error that has occurred writing the symbol file, using
@@ -278,31 +308,39 @@ class Module {
   // Write RULE_MAP to STREAM, in the form appropriate for 'STACK CFI'
   // records, without a final newline. Return true if all goes well;
   // if an error occurs, return false, and leave errno set.
-  static bool WriteRuleMap(const RuleMap &rule_map, std::ostream &stream);
+  static bool WriteRuleMap(const RuleMap& rule_map, std::ostream& stream);
+
+  // Returns true of the specified address resides with an specified address
+  // range, or if no ranges have been specified.
+  bool AddressIsInModule(Address address) const;
 
   // Module header entries.
-  string name_, os_, architecture_, id_;
+  string name_, os_, architecture_, id_, code_id_;
 
   // The module's nominal load address.  Addresses for functions and
   // lines are absolute, assuming the module is loaded at this
   // address.
   Address load_address_;
 
+  // The set of valid address ranges of the module.  If specified, attempts to
+  // add elements residing outside these ranges will be silently filtered.
+  vector<Range> address_ranges_;
+
   // Relation for maps whose keys are strings shared with some other
   // structure.
   struct CompareStringPtrs {
-    bool operator()(const string *x, const string *y) const { return *x < *y; }
+    bool operator()(const string* x, const string* y) const { return *x < *y; }
   };
 
   // A map from filenames to File structures.  The map's keys are
   // pointers to the Files' names.
-  typedef map<const string *, File *, CompareStringPtrs> FileByNameMap;
+  typedef map<const string*, File*, CompareStringPtrs> FileByNameMap;
 
   // A set containing Function structures, sorted by address.
-  typedef set<Function *, FunctionCompare> FunctionSet;
+  typedef set<Function*, FunctionCompare> FunctionSet;
 
   // A set containing Extern structures, sorted by address.
-  typedef set<Extern *, ExternCompare> ExternSet;
+  typedef set<Extern*, ExternCompare> ExternSet;
 
   // The module owns all the files and functions that have been added
   // to it; destroying the module frees the Files and Functions these
@@ -312,7 +350,7 @@ class Module {
 
   // The module owns all the call frame info entries that have been
   // added to it.
-  vector<StackFrameEntry *> stack_frame_entries_;
+  vector<StackFrameEntry*> stack_frame_entries_;
 
   // The module owns all the externs that have been added to it;
   // destroying the module frees the Externs these point to.
diff --git a/src/MEGASync/google_breakpad/common/module_unittest.cc b/src/MEGASync/google_breakpad/common/module_unittest.cc
index 5c0c6975..cede09c3 100644
--- a/src/MEGASync/google_breakpad/common/module_unittest.cc
+++ b/src/MEGASync/google_breakpad/common/module_unittest.cc
@@ -49,15 +49,14 @@ using std::stringstream;
 using std::vector;
 using testing::ContainerEq;
 
-static Module::Function *generate_duplicate_function(const string &name) {
-  const Module::Address DUP_ADDRESS = 0xd35402aac7a7ad5cLL;
-  const Module::Address DUP_SIZE = 0x200b26e605f99071LL;
-  const Module::Address DUP_PARAMETER_SIZE = 0xf14ac4fed48c4a99LL;
-
-  Module::Function *function = new(Module::Function);
-  function->name = name;
-  function->address = DUP_ADDRESS;
-  function->size = DUP_SIZE;
+static Module::Function* generate_duplicate_function(const string& name) {
+  const Module::Address DUP_ADDRESS = 0xd35402aac7a7ad5cULL;
+  const Module::Address DUP_SIZE = 0x200b26e605f99071ULL;
+  const Module::Address DUP_PARAMETER_SIZE = 0xf14ac4fed48c4a99ULL;
+
+  Module::Function* function = new Module::Function(name, DUP_ADDRESS);
+  Module::Range range(DUP_ADDRESS, DUP_SIZE);
+  function->ranges.push_back(range);
   function->parameter_size = DUP_PARAMETER_SIZE;
   return function;
 }
@@ -66,6 +65,7 @@ static Module::Function *generate_duplicate_function(const string &name) {
 #define MODULE_OS "os-name"
 #define MODULE_ARCH "architecture"
 #define MODULE_ID "id-string"
+#define MODULE_CODE_ID "code-id-string"
 
 TEST(Write, Header) {
   stringstream s;
@@ -76,17 +76,27 @@ TEST(Write, Header) {
                contents.c_str());
 }
 
+TEST(Write, HeaderCodeId) {
+  stringstream s;
+  Module m(MODULE_NAME, MODULE_OS, MODULE_ARCH, MODULE_ID, MODULE_CODE_ID);
+  m.Write(s, ALL_SYMBOL_DATA);
+  string contents = s.str();
+  EXPECT_STREQ("MODULE os-name architecture id-string name with spaces\n"
+               "INFO CODE_ID code-id-string\n",
+               contents.c_str());
+}
+
 TEST(Write, OneLineFunc) {
   stringstream s;
   Module m(MODULE_NAME, MODULE_OS, MODULE_ARCH, MODULE_ID);
 
-  Module::File *file = m.FindFile("file_name.cc");
-  Module::Function *function = new(Module::Function);
-  function->name = "function_name";
-  function->address = 0xe165bf8023b9d9abLL;
-  function->size = 0x1e4bb0eb1cbf5b09LL;
-  function->parameter_size = 0x772beee89114358aLL;
-  Module::Line line = { 0xe165bf8023b9d9abLL, 0x1e4bb0eb1cbf5b09LL,
+  Module::File* file = m.FindFile("file_name.cc");
+  Module::Function* function = new Module::Function(
+      "function_name", 0xe165bf8023b9d9abULL);
+  Module::Range range(0xe165bf8023b9d9abULL, 0x1e4bb0eb1cbf5b09ULL);
+  function->ranges.push_back(range);
+  function->parameter_size = 0x772beee89114358aULL;
+  Module::Line line = { 0xe165bf8023b9d9abULL, 0x1e4bb0eb1cbf5b09ULL,
                         file, 67519080 };
   function->lines.push_back(line);
   m.AddFunction(function);
@@ -106,20 +116,20 @@ TEST(Write, RelativeLoadAddress) {
   Module m(MODULE_NAME, MODULE_OS, MODULE_ARCH, MODULE_ID);
 
   // Some source files.  We will expect to see them in lexicographic order.
-  Module::File *file1 = m.FindFile("filename-b.cc");
-  Module::File *file2 = m.FindFile("filename-a.cc");
+  Module::File* file1 = m.FindFile("filename-b.cc");
+  Module::File* file2 = m.FindFile("filename-a.cc");
 
   // A function.
-  Module::Function *function = new(Module::Function);
-  function->name = "A_FLIBBERTIJIBBET::a_will_o_the_wisp(a clown)";
-  function->address = 0xbec774ea5dd935f3LL;
-  function->size = 0x2922088f98d3f6fcLL;
-  function->parameter_size = 0xe5e9aa008bd5f0d0LL;
+  Module::Function* function = new Module::Function(
+      "A_FLIBBERTIJIBBET::a_will_o_the_wisp(a clown)", 0xbec774ea5dd935f3ULL);
+  Module::Range range(0xbec774ea5dd935f3ULL, 0x2922088f98d3f6fcULL);
+  function->ranges.push_back(range);
+  function->parameter_size = 0xe5e9aa008bd5f0d0ULL;
 
   // Some source lines.  The module should not sort these.
-  Module::Line line1 = { 0xbec774ea5dd935f3LL, 0x1c2be6d6c5af2611LL,
+  Module::Line line1 = { 0xbec774ea5dd935f3ULL, 0x1c2be6d6c5af2611ULL,
                          file1, 41676901 };
-  Module::Line line2 = { 0xdaf35bc123885c04LL, 0xcf621b8d324d0ebLL,
+  Module::Line line2 = { 0xdaf35bc123885c04ULL, 0xcf621b8d324d0ebULL,
                          file2, 67519080 };
   function->lines.push_back(line2);
   function->lines.push_back(line1);
@@ -127,7 +137,7 @@ TEST(Write, RelativeLoadAddress) {
   m.AddFunction(function);
 
   // Some stack information.
-  Module::StackFrameEntry *entry = new Module::StackFrameEntry();
+  Module::StackFrameEntry* entry = new Module::StackFrameEntry();
   entry->address = 0x30f9e5c83323973dULL;
   entry->size = 0x49fc9ca7c7c13dc2ULL;
   entry->initial_rules[".cfa"] = "he was a handsome man";
@@ -139,7 +149,7 @@ TEST(Write, RelativeLoadAddress) {
 
   // Set the load address.  Doing this after adding all the data to
   // the module must work fine.
-  m.SetLoadAddress(0x2ab698b0b6407073LL);
+  m.SetLoadAddress(0x2ab698b0b6407073ULL);
 
   m.Write(s, ALL_SYMBOL_DATA);
   string contents = s.str();
@@ -163,21 +173,21 @@ TEST(Write, OmitUnusedFiles) {
   Module m(MODULE_NAME, MODULE_OS, MODULE_ARCH, MODULE_ID);
 
   // Create some source files.
-  Module::File *file1 = m.FindFile("filename1");
+  Module::File* file1 = m.FindFile("filename1");
   m.FindFile("filename2");  // not used by any line
-  Module::File *file3 = m.FindFile("filename3");
+  Module::File* file3 = m.FindFile("filename3");
 
   // Create a function.
-  Module::Function *function = new(Module::Function);
-  function->name = "function_name";
-  function->address = 0x9b926d464f0b9384LL;
-  function->size = 0x4f524a4ba795e6a6LL;
-  function->parameter_size = 0xbbe8133a6641c9b7LL;
+  Module::Function* function = new Module::Function(
+      "function_name", 0x9b926d464f0b9384ULL);
+  Module::Range range(0x9b926d464f0b9384ULL, 0x4f524a4ba795e6a6ULL);
+  function->ranges.push_back(range);
+  function->parameter_size = 0xbbe8133a6641c9b7ULL;
 
   // Source files that refer to some files, but not others.
-  Module::Line line1 = { 0x595fa44ebacc1086LL, 0x1e1e0191b066c5b3LL,
+  Module::Line line1 = { 0xab415089485e1a20ULL, 0x126e3124979291f2ULL,
                          file1, 137850127 };
-  Module::Line line2 = { 0x401ce8c8a12d25e3LL, 0x895751c41b8d2ce2LL,
+  Module::Line line2 = { 0xb2675b5c3c2ed33fULL, 0x1df77f5551dbd68cULL,
                          file3, 28113549 };
   function->lines.push_back(line1);
   function->lines.push_back(line2);
@@ -185,7 +195,7 @@ TEST(Write, OmitUnusedFiles) {
 
   m.AssignSourceIds();
 
-  vector<Module::File *> vec;
+  vector<Module::File*> vec;
   m.GetFiles(&vec);
   EXPECT_EQ((size_t) 3, vec.size());
   EXPECT_STREQ("filename1", vec[0]->name.c_str());
@@ -204,8 +214,8 @@ TEST(Write, OmitUnusedFiles) {
                "FILE 1 filename3\n"
                "FUNC 9b926d464f0b9384 4f524a4ba795e6a6 bbe8133a6641c9b7"
                " function_name\n"
-               "595fa44ebacc1086 1e1e0191b066c5b3 137850127 0\n"
-               "401ce8c8a12d25e3 895751c41b8d2ce2 28113549 1\n",
+               "ab415089485e1a20 126e3124979291f2 137850127 0\n"
+               "b2675b5c3c2ed33f 1df77f5551dbd68c 28113549 1\n",
                contents.c_str());
 }
 
@@ -214,24 +224,24 @@ TEST(Write, NoCFI) {
   Module m(MODULE_NAME, MODULE_OS, MODULE_ARCH, MODULE_ID);
 
   // Some source files.  We will expect to see them in lexicographic order.
-  Module::File *file1 = m.FindFile("filename.cc");
+  Module::File* file1 = m.FindFile("filename.cc");
 
   // A function.
-  Module::Function *function = new(Module::Function);
-  function->name = "A_FLIBBERTIJIBBET::a_will_o_the_wisp(a clown)";
-  function->address = 0xbec774ea5dd935f3LL;
-  function->size = 0x2922088f98d3f6fcLL;
-  function->parameter_size = 0xe5e9aa008bd5f0d0LL;
+  Module::Function* function = new Module::Function(
+      "A_FLIBBERTIJIBBET::a_will_o_the_wisp(a clown)", 0xbec774ea5dd935f3ULL);
+  Module::Range range(0xbec774ea5dd935f3ULL, 0x2922088f98d3f6fcULL);
+  function->ranges.push_back(range);
+  function->parameter_size = 0xe5e9aa008bd5f0d0ULL;
 
   // Some source lines.  The module should not sort these.
-  Module::Line line1 = { 0xbec774ea5dd935f3LL, 0x1c2be6d6c5af2611LL,
+  Module::Line line1 = { 0xbec774ea5dd935f3ULL, 0x1c2be6d6c5af2611ULL,
                          file1, 41676901 };
   function->lines.push_back(line1);
 
   m.AddFunction(function);
 
   // Some stack information.
-  Module::StackFrameEntry *entry = new Module::StackFrameEntry();
+  Module::StackFrameEntry* entry = new Module::StackFrameEntry();
   entry->address = 0x30f9e5c83323973dULL;
   entry->size = 0x49fc9ca7c7c13dc2ULL;
   entry->initial_rules[".cfa"] = "he was a handsome man";
@@ -243,7 +253,7 @@ TEST(Write, NoCFI) {
 
   // Set the load address.  Doing this after adding all the data to
   // the module must work fine.
-  m.SetLoadAddress(0x2ab698b0b6407073LL);
+  m.SetLoadAddress(0x2ab698b0b6407073ULL);
 
   m.Write(s, NO_CFI);
   string contents = s.str();
@@ -260,20 +270,20 @@ TEST(Construct, AddFunctions) {
   Module m(MODULE_NAME, MODULE_OS, MODULE_ARCH, MODULE_ID);
 
   // Two functions.
-  Module::Function *function1 = new(Module::Function);
-  function1->name = "_without_form";
-  function1->address = 0xd35024aa7ca7da5cLL;
-  function1->size = 0x200b26e605f99071LL;
-  function1->parameter_size = 0xf14ac4fed48c4a99LL;
-
-  Module::Function *function2 = new(Module::Function);
-  function2->name = "_and_void";
-  function2->address = 0x2987743d0b35b13fLL;
-  function2->size = 0xb369db048deb3010LL;
-  function2->parameter_size = 0x938e556cb5a79988LL;
+  Module::Function* function1 = new Module::Function(
+      "_without_form", 0xd35024aa7ca7da5cULL);
+  Module::Range r1(0xd35024aa7ca7da5cULL, 0x200b26e605f99071ULL);
+  function1->ranges.push_back(r1);
+  function1->parameter_size = 0xf14ac4fed48c4a99ULL;
+
+  Module::Function* function2 = new Module::Function(
+      "_and_void", 0x2987743d0b35b13fULL);
+  Module::Range r2(0x2987743d0b35b13fULL, 0xb369db048deb3010ULL);
+  function2->ranges.push_back(r2);
+  function2->parameter_size = 0x938e556cb5a79988ULL;
 
   // Put them in a vector.
-  vector<Module::Function *> vec;
+  vector<Module::Function*> vec;
   vec.push_back(function1);
   vec.push_back(function2);
 
@@ -301,13 +311,13 @@ TEST(Construct, AddFrames) {
   Module m(MODULE_NAME, MODULE_OS, MODULE_ARCH, MODULE_ID);
 
   // First STACK CFI entry, with no initial rules or deltas.
-  Module::StackFrameEntry *entry1 = new Module::StackFrameEntry();
+  Module::StackFrameEntry* entry1 = new Module::StackFrameEntry();
   entry1->address = 0xddb5f41285aa7757ULL;
   entry1->size = 0x1486493370dc5073ULL;
   m.AddStackFrameEntry(entry1);
 
   // Second STACK CFI entry, with initial rules but no deltas.
-  Module::StackFrameEntry *entry2 = new Module::StackFrameEntry();
+  Module::StackFrameEntry* entry2 = new Module::StackFrameEntry();
   entry2->address = 0x8064f3af5e067e38ULL;
   entry2->size = 0x0de2a5ee55509407ULL;
   entry2->initial_rules[".cfa"] = "I think that I shall never see";
@@ -316,7 +326,7 @@ TEST(Construct, AddFrames) {
   m.AddStackFrameEntry(entry2);
 
   // Third STACK CFI entry, with initial rules and deltas.
-  Module::StackFrameEntry *entry3 = new Module::StackFrameEntry();
+  Module::StackFrameEntry* entry3 = new Module::StackFrameEntry();
   entry3->address = 0x5e8d0db0a7075c6cULL;
   entry3->size = 0x1c7edb12a7aea229ULL;
   entry3->initial_rules[".cfa"] = "Whose woods are these";
@@ -350,7 +360,7 @@ TEST(Construct, AddFrames) {
                contents.c_str());
 
   // Check that GetStackFrameEntries works.
-  vector<Module::StackFrameEntry *> entries;
+  vector<Module::StackFrameEntry*> entries;
   m.GetStackFrameEntries(&entries);
   ASSERT_EQ(3U, entries.size());
   // Check first entry.
@@ -385,10 +395,10 @@ TEST(Construct, AddFrames) {
 
 TEST(Construct, UniqueFiles) {
   Module m(MODULE_NAME, MODULE_OS, MODULE_ARCH, MODULE_ID);
-  Module::File *file1 = m.FindFile("foo");
-  Module::File *file2 = m.FindFile(string("bar"));
-  Module::File *file3 = m.FindFile(string("foo"));
-  Module::File *file4 = m.FindFile("bar");
+  Module::File* file1 = m.FindFile("foo");
+  Module::File* file2 = m.FindFile(string("bar"));
+  Module::File* file3 = m.FindFile(string("foo"));
+  Module::File* file4 = m.FindFile("bar");
   EXPECT_NE(file1, file2);
   EXPECT_EQ(file1, file3);
   EXPECT_EQ(file2, file4);
@@ -401,8 +411,8 @@ TEST(Construct, DuplicateFunctions) {
   Module m(MODULE_NAME, MODULE_OS, MODULE_ARCH, MODULE_ID);
 
   // Two functions.
-  Module::Function *function1 = generate_duplicate_function("_without_form");
-  Module::Function *function2 = generate_duplicate_function("_without_form");
+  Module::Function* function1 = generate_duplicate_function("_without_form");
+  Module::Function* function2 = generate_duplicate_function("_without_form");
 
   m.AddFunction(function1);
   m.AddFunction(function2);
@@ -420,8 +430,8 @@ TEST(Construct, FunctionsWithSameAddress) {
   Module m(MODULE_NAME, MODULE_OS, MODULE_ARCH, MODULE_ID);
 
   // Two functions.
-  Module::Function *function1 = generate_duplicate_function("_without_form");
-  Module::Function *function2 = generate_duplicate_function("_and_void");
+  Module::Function* function1 = generate_duplicate_function("_without_form");
+  Module::Function* function2 = generate_duplicate_function("_and_void");
 
   m.AddFunction(function1);
   m.AddFunction(function2);
@@ -443,11 +453,9 @@ TEST(Construct, Externs) {
   Module m(MODULE_NAME, MODULE_OS, MODULE_ARCH, MODULE_ID);
 
   // Two externs.
-  Module::Extern *extern1 = new(Module::Extern);
-  extern1->address = 0xffff;
+  Module::Extern* extern1 = new Module::Extern(0xffff);
   extern1->name = "_abc";
-  Module::Extern *extern2 = new(Module::Extern);
-  extern2->address = 0xaaaa;
+  Module::Extern* extern2 = new Module::Extern(0xaaaa);
   extern2->name = "_xyz";
 
   m.AddExtern(extern1);
@@ -470,11 +478,9 @@ TEST(Construct, DuplicateExterns) {
   Module m(MODULE_NAME, MODULE_OS, MODULE_ARCH, MODULE_ID);
 
   // Two externs.
-  Module::Extern *extern1 = new(Module::Extern);
-  extern1->address = 0xffff;
+  Module::Extern* extern1 = new Module::Extern(0xffff);
   extern1->name = "_xyz";
-  Module::Extern *extern2 = new(Module::Extern);
-  extern2->address = 0xffff;
+  Module::Extern* extern2 = new Module::Extern(0xffff);
   extern2->name = "_abc";
 
   m.AddExtern(extern1);
@@ -488,3 +494,123 @@ TEST(Construct, DuplicateExterns) {
                "PUBLIC ffff 0 _xyz\n",
                contents.c_str());
 }
+
+// If there exists an extern and a function at the same address, only write
+// out the FUNC entry.
+TEST(Construct, FunctionsAndExternsWithSameAddress) {
+  stringstream s;
+  Module m(MODULE_NAME, MODULE_OS, MODULE_ARCH, MODULE_ID);
+
+  // Two externs.
+  Module::Extern* extern1 = new Module::Extern(0xabc0);
+  extern1->name = "abc";
+  Module::Extern* extern2 = new Module::Extern(0xfff0);
+  extern2->name = "xyz";
+
+  m.AddExtern(extern1);
+  m.AddExtern(extern2);
+
+  Module::Function* function = new Module::Function("_xyz", 0xfff0);
+  Module::Range range(0xfff0, 0x10);
+  function->ranges.push_back(range);
+  function->parameter_size = 0;
+  m.AddFunction(function);
+
+  m.Write(s, ALL_SYMBOL_DATA);
+  string contents = s.str();
+
+  EXPECT_STREQ("MODULE " MODULE_OS " " MODULE_ARCH " "
+               MODULE_ID " " MODULE_NAME "\n"
+               "FUNC fff0 10 0 _xyz\n"
+               "PUBLIC abc0 0 abc\n",
+               contents.c_str());
+}
+
+// If there exists an extern and a function at the same address, only write
+// out the FUNC entry. For ARM THUMB, the extern that comes from the ELF
+// symbol section has bit 0 set.
+TEST(Construct, FunctionsAndThumbExternsWithSameAddress) {
+  stringstream s;
+  Module m(MODULE_NAME, MODULE_OS, "arm", MODULE_ID);
+
+  // Two THUMB externs.
+  Module::Extern* thumb_extern1 = new Module::Extern(0xabc1);
+  thumb_extern1->name = "thumb_abc";
+  Module::Extern* thumb_extern2 = new Module::Extern(0xfff1);
+  thumb_extern2->name = "thumb_xyz";
+
+  Module::Extern* arm_extern1 = new Module::Extern(0xcc00);
+  arm_extern1->name = "arm_func";
+
+  m.AddExtern(thumb_extern1);
+  m.AddExtern(thumb_extern2);
+  m.AddExtern(arm_extern1);
+
+  // The corresponding function from the DWARF debug data have the actual
+  // address.
+  Module::Function* function = new Module::Function("_thumb_xyz", 0xfff0);
+  Module::Range range(0xfff0, 0x10);
+  function->ranges.push_back(range);
+  function->parameter_size = 0;
+  m.AddFunction(function);
+
+  m.Write(s, ALL_SYMBOL_DATA);
+  string contents = s.str();
+
+  EXPECT_STREQ("MODULE " MODULE_OS " arm "
+               MODULE_ID " " MODULE_NAME "\n"
+               "FUNC fff0 10 0 _thumb_xyz\n"
+               "PUBLIC abc1 0 thumb_abc\n"
+               "PUBLIC cc00 0 arm_func\n",
+               contents.c_str());
+}
+
+TEST(Write, OutOfRangeAddresses) {
+  stringstream s;
+  Module m(MODULE_NAME, MODULE_OS, MODULE_ARCH, MODULE_ID);
+
+  // Specify an allowed address range, representing a PT_LOAD segment in a
+  // module.
+  vector<Module::Range> address_ranges = {
+    Module::Range(0x2000ULL, 0x1000ULL),
+  };
+  m.SetAddressRanges(address_ranges);
+
+  // Add three stack frames (one lower, one in, and one higher than the allowed
+  // address range).  Only the middle frame should be captured.
+  Module::StackFrameEntry* entry1 = new Module::StackFrameEntry();
+  entry1->address = 0x1000ULL;
+  entry1->size = 0x100ULL;
+  m.AddStackFrameEntry(entry1);
+  Module::StackFrameEntry* entry2 = new Module::StackFrameEntry();
+  entry2->address = 0x2000ULL;
+  entry2->size = 0x100ULL;
+  m.AddStackFrameEntry(entry2);
+  Module::StackFrameEntry* entry3 = new Module::StackFrameEntry();
+  entry3->address = 0x3000ULL;
+  entry3->size = 0x100ULL;
+  m.AddStackFrameEntry(entry3);
+
+  // Add a function outside the allowed range.
+  Module::File* file = m.FindFile("file_name.cc");
+  Module::Function* function = new Module::Function(
+      "function_name", 0x4000ULL);
+  Module::Range range(0x4000ULL, 0x1000ULL);
+  function->ranges.push_back(range);
+  function->parameter_size = 0x100ULL;
+  Module::Line line = { 0x4000ULL, 0x100ULL, file, 67519080 };
+  function->lines.push_back(line);
+  m.AddFunction(function);
+
+  // Add an extern outside the allowed range.
+  Module::Extern* extern1 = new Module::Extern(0x5000ULL);
+  extern1->name = "_xyz";
+  m.AddExtern(extern1);
+
+  m.Write(s, ALL_SYMBOL_DATA);
+
+  EXPECT_STREQ("MODULE os-name architecture id-string name with spaces\n"
+               "STACK CFI INIT 2000 100 \n",
+               s.str().c_str());
+
+}
diff --git a/src/MEGASync/google_breakpad/common/path_helper.cc b/src/MEGASync/google_breakpad/common/path_helper.cc
new file mode 100644
index 00000000..61a6e318
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/path_helper.cc
@@ -0,0 +1,55 @@
+// Copyright 2017, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "common/path_helper.h"
+
+#include <assert.h>
+#include <libgen.h>
+#include <stdlib.h>
+#include <string.h>
+
+namespace google_breakpad {
+
+string BaseName(const string& path) {
+  char* path_tmp = strdup(path.c_str());
+  assert(path_tmp);
+  string result(basename(path_tmp));
+  free(path_tmp);
+  return result;
+}
+
+string DirName(const string& path) {
+  char* path_tmp = strdup(path.c_str());
+  assert(path_tmp);
+  string result(dirname(path_tmp));
+  free(path_tmp);
+  return result;
+}
+
+}  // namespace google_breakpad
diff --git a/src/MEGASync/google_breakpad/common/path_helper.h b/src/MEGASync/google_breakpad/common/path_helper.h
new file mode 100644
index 00000000..2166ba01
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/path_helper.h
@@ -0,0 +1,44 @@
+// Copyright 2017, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef GOOGLE_BREAKPAD_COMMON_PATH_HELPER_H
+#define GOOGLE_BREAKPAD_COMMON_PATH_HELPER_H
+
+#include <string>
+
+#include "common/using_std_string.h"
+
+namespace google_breakpad {
+
+string BaseName(const string& path);
+string DirName(const string& path);
+
+}  // namespace google_breakpad
+
+#endif  // GOOGLE_BREAKPAD_COMMON_PATH_HELPER_H
diff --git a/src/MEGASync/google_breakpad/common/simple_string_dictionary.h b/src/MEGASync/google_breakpad/common/simple_string_dictionary.h
index d2ab17fd..94849205 100644
--- a/src/MEGASync/google_breakpad/common/simple_string_dictionary.h
+++ b/src/MEGASync/google_breakpad/common/simple_string_dictionary.h
@@ -147,39 +147,42 @@ class NonAllocatingMap {
     if (!key)
       return NULL;
 
-    const Entry* entry = GetConstEntryForKey(key);
-    if (!entry)
+    size_t index = GetEntryIndexForKey(key);
+    if (index == num_entries)
       return NULL;
 
-    return entry->value;
+    return entries_[index].value;
   }
 
   // Stores |value| into |key|, replacing the existing value if |key| is
   // already present. |key| must not be NULL. If |value| is NULL, the key is
   // removed from the map. If there is no more space in the map, then the
-  // operation silently fails.
-  void SetKeyValue(const char* key, const char* value) {
+  // operation silently fails. Returns an index into the map that can be used
+  // to quickly access the entry, or |num_entries| on failure or when clearing
+  // a key with a null value.
+  size_t SetKeyValue(const char* key, const char* value) {
     if (!value) {
       RemoveKey(key);
-      return;
+      return num_entries;
     }
 
     assert(key);
     if (!key)
-      return;
+      return num_entries;
 
     // Key must not be an empty string.
     assert(key[0] != '\0');
     if (key[0] == '\0')
-      return;
+      return num_entries;
 
-    Entry* entry = GetEntryForKey(key);
+    size_t entry_index = GetEntryIndexForKey(key);
 
     // If it does not yet exist, attempt to insert it.
-    if (!entry) {
+    if (entry_index == num_entries) {
       for (size_t i = 0; i < num_entries; ++i) {
         if (!entries_[i].is_active()) {
-          entry = &entries_[i];
+          entry_index = i;
+          Entry* entry = &entries_[i];
 
           strncpy(entry->key, key, key_size);
           entry->key[key_size - 1] = '\0';
@@ -190,8 +193,8 @@ class NonAllocatingMap {
     }
 
     // If the map is out of space, entry will be NULL.
-    if (!entry)
-      return;
+    if (entry_index == num_entries)
+      return num_entries;
 
 #ifndef NDEBUG
     // Sanity check that the key only appears once.
@@ -203,26 +206,46 @@ class NonAllocatingMap {
     assert(count == 1);
 #endif
 
+    strncpy(entries_[entry_index].value, value, value_size);
+    entries_[entry_index].value[value_size - 1] = '\0';
+
+    return entry_index;
+  }
+
+  // Sets a value for a key that has already been set with SetKeyValue(), using
+  // the index returned from that function.
+  void SetValueAtIndex(size_t index, const char* value) {
+    assert(index < num_entries);
+    if (index >= num_entries)
+      return;
+
+    Entry* entry = &entries_[index];
+    assert(entry->key[0] != '\0');
+
     strncpy(entry->value, value, value_size);
     entry->value[value_size - 1] = '\0';
   }
 
   // Given |key|, removes any associated value. |key| must not be NULL. If
-  // the key is not found, this is a noop.
-  void RemoveKey(const char* key) {
+  // the key is not found, this is a noop. This invalidates the index
+  // returned by SetKeyValue().
+  bool RemoveKey(const char* key) {
     assert(key);
     if (!key)
-      return;
+      return false;
 
-    Entry* entry = GetEntryForKey(key);
-    if (entry) {
-      entry->key[0] = '\0';
-      entry->value[0] = '\0';
-    }
+    return RemoveAtIndex(GetEntryIndexForKey(key));
+  }
 
-#ifndef NDEBUG
-    assert(GetEntryForKey(key) == NULL);
-#endif
+  // Removes a value and key using an index that was returned from
+  // SetKeyValue(). After a call to this function, the index is invalidated.
+  bool RemoveAtIndex(size_t index) {
+    if (index >= num_entries)
+      return false;
+
+    entries_[index].key[0] = '\0';
+    entries_[index].value[0] = '\0';
+    return true;
   }
 
   // Places a serialized version of the map into |map| and returns the size.
@@ -235,17 +258,13 @@ class NonAllocatingMap {
   }
 
  private:
-  const Entry* GetConstEntryForKey(const char* key) const {
+  size_t GetEntryIndexForKey(const char* key) const {
     for (size_t i = 0; i < num_entries; ++i) {
       if (strncmp(key, entries_[i].key, key_size) == 0) {
-        return &entries_[i];
+        return i;
       }
     }
-    return NULL;
-  }
-
-  Entry* GetEntryForKey(const char* key) {
-    return const_cast<Entry*>(GetConstEntryForKey(key));
+    return num_entries;
   }
 
   Entry entries_[NumEntries];
diff --git a/src/MEGASync/google_breakpad/common/simple_string_dictionary_unittest.cc b/src/MEGASync/google_breakpad/common/simple_string_dictionary_unittest.cc
index 34f4b9ef..e7b8fd76 100644
--- a/src/MEGASync/google_breakpad/common/simple_string_dictionary_unittest.cc
+++ b/src/MEGASync/google_breakpad/common/simple_string_dictionary_unittest.cc
@@ -288,6 +288,37 @@ TEST(NonAllocatingMapTest, OutOfSpace) {
   EXPECT_FALSE(map.GetValueForKey("c"));
 }
 
+TEST(NonAllocatingMapTest, ByIndex) {
+  NonAllocatingMap<10, 10, 3> map;
+
+  size_t index1 = map.SetKeyValue("test", "one");
+  EXPECT_TRUE(index1 >= 0 && index1 <= map.num_entries);
+
+  size_t index2 = map.SetKeyValue("moo", "foo");
+  EXPECT_TRUE(index2 >= 0 && index2 <= map.num_entries);
+  EXPECT_NE(index1, index2);
+
+  size_t index3 = map.SetKeyValue("blob", "kebab");
+  EXPECT_TRUE(index3 >= 0 && index3 <= map.num_entries);
+  EXPECT_NE(index2, index3);
+
+  size_t index4 = map.SetKeyValue("nogo", "full");
+  EXPECT_TRUE(index4 == map.num_entries);
+
+  EXPECT_STREQ("one", map.GetValueForKey("test"));
+  EXPECT_STREQ("foo", map.GetValueForKey("moo"));
+  EXPECT_STREQ("kebab", map.GetValueForKey("blob"));
+
+  map.SetValueAtIndex(index2, "booo");
+  EXPECT_STREQ("booo", map.GetValueForKey("moo"));
+
+  EXPECT_TRUE(map.RemoveAtIndex(index1));
+  EXPECT_FALSE(map.GetValueForKey("test"));
+
+  EXPECT_FALSE(map.RemoveAtIndex(map.num_entries));
+  EXPECT_FALSE(map.RemoveAtIndex(9999));
+}
+
 #ifndef NDEBUG
 
 TEST(NonAllocatingMapTest, NullKey) {
diff --git a/src/MEGASync/google_breakpad/common/solaris/dump_symbols.cc b/src/MEGASync/google_breakpad/common/solaris/dump_symbols.cc
index 168d0b28..9524a18b 100644
--- a/src/MEGASync/google_breakpad/common/solaris/dump_symbols.cc
+++ b/src/MEGASync/google_breakpad/common/solaris/dump_symbols.cc
@@ -97,7 +97,7 @@ struct LineInfo {
 // Information of a function.
 struct FuncInfo {
   // Name of the function.
-  const char *name;
+  const char* name;
   // Offset from the base of the loading address.
   GElf_Off rva_to_base;
   // Virtual address of the function.
@@ -115,7 +115,7 @@ struct FuncInfo {
 // Information of a source file.
 struct SourceFileInfo {
   // Name of the source file.
-  const char *name;
+  const char* name;
   // Starting address of the source file.
   GElf_Addr addr;
   // Id of the source file.
@@ -125,12 +125,12 @@ struct SourceFileInfo {
 };
 
 struct CompareString {
-  bool operator()(const char *s1, const char *s2) const {
+  bool operator()(const char* s1, const char* s2) const {
     return strcmp(s1, s2) < 0;
   }
 };
 
-typedef std::map<const char *, struct SymbolEntry *, CompareString> SymbolMap;
+typedef std::map<const char*, struct SymbolEntry*, CompareString> SymbolMap;
 
 // Information of a symbol table.
 // This is the root of all types of symbol.
@@ -141,16 +141,16 @@ struct SymbolInfo {
 };
 
 // Stab section name.
-const char *kStabName = ".stab";
+const char* kStabName = ".stab";
 
 // Stab str section name.
-const char *kStabStrName = ".stabstr";
+const char* kStabStrName = ".stabstr";
 
 // Symtab section name.
-const char *kSymtabName = ".symtab";
+const char* kSymtabName = ".symtab";
 
 // Strtab section name.
-const char *kStrtabName = ".strtab";
+const char* kStrtabName = ".strtab";
 
 // Default buffer lenght for demangle.
 const int demangleLen = 20000;
@@ -160,11 +160,11 @@ uint64_t stringOffset = 0;
 
 // Update the offset to the start of the string index of the next
 // object module for every N_ENDM stabs.
-inline void RecalculateOffset(struct slist* cur_list, char *stabstr) {
+inline void RecalculateOffset(struct slist* cur_list, char* stabstr) {
   while ((--cur_list)->n_strx == 0) ;
   stringOffset += cur_list->n_strx;
 
-  char *temp = stabstr + stringOffset;
+  char* temp = stabstr + stringOffset;
   while (*temp != '\0') {
     ++stringOffset;
     ++temp;
@@ -174,10 +174,10 @@ inline void RecalculateOffset(struct slist* cur_list, char *stabstr) {
 }
 
 // Demangle using demangle library on Solaris.
-std::string Demangle(const char *mangled) {
+std::string Demangle(const char* mangled) {
   int status = 0;
   std::string str(mangled);
-  char *demangled = (char *)malloc(demangleLen);
+  char* demangled = (char*)malloc(demangleLen);
 
   if (!demangled) {
     fprintf(stderr, "no enough memory.\n");
@@ -197,7 +197,7 @@ out:
   return str; 
 }
 
-bool WriteFormat(int fd, const char *fmt, ...) {
+bool WriteFormat(int fd, const char* fmt, ...) {
   va_list list;
   char buffer[4096];
   ssize_t expected, written;
@@ -209,27 +209,27 @@ bool WriteFormat(int fd, const char *fmt, ...) {
   return expected == written;
 }
 
-bool IsValidElf(const GElf_Ehdr *elf_header) {
+bool IsValidElf(const GElf_Ehdr* elf_header) {
   return memcmp(elf_header, ELFMAG, SELFMAG) == 0;
 }
 
-static bool FindSectionByName(Elf *elf, const char *name,
+static bool FindSectionByName(Elf* elf, const char* name,
                               int shstrndx,
-                              GElf_Shdr *shdr) {
+                              GElf_Shdr* shdr) {
   assert(name != NULL);
 
   if (strlen(name) == 0)
     return false;
 
-  Elf_Scn *scn = NULL;
+  Elf_Scn* scn = NULL;
 
   while ((scn = elf_nextscn(elf, scn)) != NULL) {
-    if (gelf_getshdr(scn, shdr) == (GElf_Shdr *)0) {
+    if (gelf_getshdr(scn, shdr) == (GElf_Shdr*)0) {
       fprintf(stderr, "failed to read section header: %s\n", elf_errmsg(0));
       return false;
     }
 
-    const char *section_name = elf_strptr(elf, shstrndx, shdr->sh_name);
+    const char* section_name = elf_strptr(elf, shstrndx, shdr->sh_name);
     if (!section_name) {
       fprintf(stderr, "Section name error: %s\n", elf_errmsg(-1));
       continue;
@@ -245,10 +245,10 @@ static bool FindSectionByName(Elf *elf, const char *name,
 // The parameter size is used for FPO-optimized code, and
 // this is all tied up with the debugging data for Windows x86.
 // Set it to 0 on Solaris.
-int LoadStackParamSize(struct slist *list,
-                       struct slist *list_end,
-                       struct FuncInfo *func_info) {
-  struct slist *cur_list = list;
+int LoadStackParamSize(struct slist* list,
+                       struct slist* list_end,
+                       struct FuncInfo* func_info) {
+  struct slist* cur_list = list;
   int step = 1;
   while (cur_list < list_end && cur_list->n_type == N_PSYM) {
     ++cur_list;
@@ -259,10 +259,10 @@ int LoadStackParamSize(struct slist *list,
   return step;
 }
 
-int LoadLineInfo(struct slist *list,
-                 struct slist *list_end,
-                 struct FuncInfo *func_info) {
-  struct slist *cur_list = list;
+int LoadLineInfo(struct slist* list,
+                 struct slist* list_end,
+                 struct FuncInfo* func_info) {
+  struct slist* cur_list = list;
   do {
     // Skip non line information.
     while (cur_list < list_end && cur_list->n_type != N_SLINE) {
@@ -288,12 +288,12 @@ int LoadLineInfo(struct slist *list,
   return cur_list - list;
 }
 
-int LoadFuncSymbols(struct slist *list,
-                    struct slist *list_end,
-                    char *stabstr,
+int LoadFuncSymbols(struct slist* list,
+                    struct slist* list_end,
+                    char* stabstr,
                     GElf_Word base,
-                    struct SourceFileInfo *source_file_info) {
-  struct slist *cur_list = list;
+                    struct SourceFileInfo* source_file_info) {
+  struct slist* cur_list = list;
   assert(cur_list->n_type == N_SO);
   ++cur_list;
 
@@ -342,17 +342,17 @@ int LoadFuncSymbols(struct slist *list,
 }
 
 // Compute size and rva information based on symbols loaded from stab section.
-bool ComputeSizeAndRVA(struct SymbolInfo *symbols) {
-  std::vector<struct SourceFileInfo> *sorted_files =
+bool ComputeSizeAndRVA(struct SymbolInfo* symbols) {
+  std::vector<struct SourceFileInfo>* sorted_files =
     &(symbols->source_file_info);
-  SymbolMap *symbol_entries = &(symbols->symbol_entries);
+  SymbolMap* symbol_entries = &(symbols->symbol_entries);
   for (size_t i = 0; i < sorted_files->size(); ++i) {
-    struct SourceFileInfo &source_file = (*sorted_files)[i];
-    std::vector<struct FuncInfo> *sorted_functions = &(source_file.func_info);
+    struct SourceFileInfo& source_file = (*sorted_files)[i];
+    std::vector<struct FuncInfo>* sorted_functions = &(source_file.func_info);
     int func_size = sorted_functions->size();
 
     for (size_t j = 0; j < func_size; ++j) {
-      struct FuncInfo &func_info = (*sorted_functions)[j];
+      struct FuncInfo& func_info = (*sorted_functions)[j];
       int line_count = func_info.line_info.size();
 
       // Discard the ending part of the name.
@@ -373,13 +373,13 @@ bool ComputeSizeAndRVA(struct SymbolInfo *symbols) {
 
       // Compute function and line size.
       for (size_t k = 0; k < line_count; ++k) {
-        struct LineInfo &line_info = func_info.line_info[k];
+        struct LineInfo& line_info = func_info.line_info[k];
 
         line_info.rva_to_base = line_info.rva_to_func + func_info.rva_to_base;
         if (k == line_count - 1) {
           line_info.size = func_info.size - line_info.rva_to_func;
         } else {
-          struct LineInfo &next_line = func_info.line_info[k + 1];
+          struct LineInfo& next_line = func_info.line_info[k + 1];
           line_info.size = next_line.rva_to_func - line_info.rva_to_func;
         }
       }  // for each line.
@@ -392,24 +392,23 @@ bool ComputeSizeAndRVA(struct SymbolInfo *symbols) {
   return true;
 }
 
-bool LoadAllSymbols(const GElf_Shdr *stab_section,
-                    const GElf_Shdr *stabstr_section,
+bool LoadAllSymbols(const GElf_Shdr* stab_section,
+                    const GElf_Shdr* stabstr_section,
                     GElf_Word base,
-                    struct SymbolInfo *symbols) {
+                    struct SymbolInfo* symbols) {
   if (stab_section == NULL || stabstr_section == NULL)
     return false;
 
-  char *stabstr = 
-    reinterpret_cast<char *>(stabstr_section->sh_offset + base);
-  struct slist *lists =
-    reinterpret_cast<struct slist *>(stab_section->sh_offset + base);
+  char* stabstr = reinterpret_cast<char*>(stabstr_section->sh_offset + base);
+  struct slist* lists =
+    reinterpret_cast<struct slist*>(stab_section->sh_offset + base);
   int nstab = stab_section->sh_size / sizeof(struct slist);
   int source_id = 0;
 
   // First pass, load all symbols from the object file.
   for (int i = 0; i < nstab; ) {
     int step = 1;
-    struct slist *cur_list = lists + i;
+    struct slist* cur_list = lists + i;
     if (cur_list->n_type == N_SO) {
       // FUNC <address> <size> <param_stack_size> <function>
       struct SourceFileInfo source_file_info;
@@ -431,12 +430,12 @@ bool LoadAllSymbols(const GElf_Shdr *stab_section,
   return ComputeSizeAndRVA(symbols);
 }
 
-bool LoadSymbols(Elf *elf, GElf_Ehdr *elf_header, struct SymbolInfo *symbols,
-                 void *obj_base) {
+bool LoadSymbols(Elf* elf, GElf_Ehdr* elf_header, struct SymbolInfo* symbols,
+                 void* obj_base) {
   GElf_Word base = reinterpret_cast<GElf_Word>(obj_base);
 
-  const GElf_Shdr *sections =
-    reinterpret_cast<GElf_Shdr *>(elf_header->e_shoff + base);
+  const GElf_Shdr* sections =
+    reinterpret_cast<GElf_Shdr*>(elf_header->e_shoff + base);
   GElf_Shdr stab_section;
   if (!FindSectionByName(elf, kStabName, elf_header->e_shstrndx,
                          &stab_section)) {
@@ -462,11 +461,11 @@ bool LoadSymbols(Elf *elf, GElf_Ehdr *elf_header, struct SymbolInfo *symbols,
     return false;
   }
 
-  Elf_Sym *symbol = (Elf_Sym *)((char *)base + symtab_section.sh_offset);
+  Elf_Sym* symbol = (Elf_Sym*)((char*)base + symtab_section.sh_offset);
   for (int i = 0; i < symtab_section.sh_size/symtab_section.sh_entsize; ++i) {
-    struct SymbolEntry *symbol_entry =
-        (struct SymbolEntry *)malloc(sizeof(struct SymbolEntry));
-    const char *name = reinterpret_cast<char *>(
+    struct SymbolEntry* symbol_entry =
+        (struct SymbolEntry*)malloc(sizeof(struct SymbolEntry));
+    const char* name = reinterpret_cast<char*>(
         strtab_section.sh_offset + (GElf_Word)base + symbol->st_name);
     symbol_entry->offset = symbol->st_value;
     symbol_entry->size = symbol->st_size;
@@ -479,8 +478,8 @@ bool LoadSymbols(Elf *elf, GElf_Ehdr *elf_header, struct SymbolInfo *symbols,
   return LoadAllSymbols(&stab_section, &stabstr_section, base, symbols);
 }
 
-bool WriteModuleInfo(int fd, GElf_Half arch, const std::string &obj_file) {
-  const char *arch_name = NULL;
+bool WriteModuleInfo(int fd, GElf_Half arch, const std::string& obj_file) {
+  const char* arch_name = NULL;
   if (arch == EM_386)
     arch_name = "x86";
   else if (arch == EM_X86_64)
@@ -508,10 +507,10 @@ bool WriteModuleInfo(int fd, GElf_Half arch, const std::string &obj_file) {
   return false;
 }
 
-bool WriteSourceFileInfo(int fd, const struct SymbolInfo &symbols) {
+bool WriteSourceFileInfo(int fd, const struct SymbolInfo& symbols) {
   for (size_t i = 0; i < symbols.source_file_info.size(); ++i) {
     if (symbols.source_file_info[i].source_id != -1) {
-      const char *name = symbols.source_file_info[i].name;
+      const char* name = symbols.source_file_info[i].name;
       if (!WriteFormat(fd, "FILE %d %s\n",
                        symbols.source_file_info[i].source_id, name))
         return false;
@@ -521,7 +520,7 @@ bool WriteSourceFileInfo(int fd, const struct SymbolInfo &symbols) {
 }
 
 bool WriteOneFunction(int fd, int source_id,
-                      const struct FuncInfo &func_info){
+                      const struct FuncInfo& func_info){
   // Discard the ending part of the name.
   std::string func_name(func_info.name);
   std::string::size_type last_colon = func_name.find_last_of(':');
@@ -539,7 +538,7 @@ bool WriteOneFunction(int fd, int source_id,
                   func_info.stack_param_size,
                   func_name.c_str())) {
     for (size_t i = 0; i < func_info.line_info.size(); ++i) {
-      const struct LineInfo &line_info = func_info.line_info[i];
+      const struct LineInfo& line_info = func_info.line_info[i];
       if (line_info.line_num == 0)
         return true;
       if (!WriteFormat(fd, "%llx %x %d %d\n",
@@ -554,11 +553,11 @@ bool WriteOneFunction(int fd, int source_id,
   return false;
 }
 
-bool WriteFunctionInfo(int fd, const struct SymbolInfo &symbols) {
+bool WriteFunctionInfo(int fd, const struct SymbolInfo& symbols) {
   for (size_t i = 0; i < symbols.source_file_info.size(); ++i) {
-    const struct SourceFileInfo &file_info = symbols.source_file_info[i];
+    const struct SourceFileInfo& file_info = symbols.source_file_info[i];
     for (size_t j = 0; j < file_info.func_info.size(); ++j) {
-      const struct FuncInfo &func_info = file_info.func_info[j];
+      const struct FuncInfo& func_info = file_info.func_info[j];
       if (!WriteOneFunction(fd, file_info.source_id, func_info))
         return false;
     }
@@ -566,7 +565,7 @@ bool WriteFunctionInfo(int fd, const struct SymbolInfo &symbols) {
   return true;
 }
 
-bool DumpStabSymbols(int fd, const struct SymbolInfo &symbols) {
+bool DumpStabSymbols(int fd, const struct SymbolInfo& symbols) {
   return WriteSourceFileInfo(fd, symbols) &&
     WriteFunctionInfo(fd, symbols);
 }
@@ -604,13 +603,13 @@ class FDWrapper {
 //
 class MmapWrapper {
  public:
-  MmapWrapper(void *mapped_address, size_t mapped_size) :
+  MmapWrapper(void* mapped_address, size_t mapped_size) :
     base_(mapped_address), size_(mapped_size) {
   }
   ~MmapWrapper() {
     if (base_ != NULL) {
       assert(size_ > 0);
-      munmap((char *)base_, size_);
+      munmap((char*)base_, size_);
     }
   }
   void release() {
@@ -619,7 +618,7 @@ class MmapWrapper {
   }
 
  private:
-  void *base_;
+  void* base_;
   size_t size_;
 };
 
@@ -629,14 +628,14 @@ namespace google_breakpad {
 
 class AutoElfEnder {
  public:
-  AutoElfEnder(Elf *elf) : elf_(elf) {}
+  AutoElfEnder(Elf* elf) : elf_(elf) {}
   ~AutoElfEnder() { if (elf_) elf_end(elf_); }
  private:
-  Elf *elf_;
+  Elf* elf_;
 };
 
 
-bool DumpSymbols::WriteSymbolFile(const std::string &obj_file, int sym_fd) {
+bool DumpSymbols::WriteSymbolFile(const std::string& obj_file, int sym_fd) {
   if (elf_version(EV_CURRENT) == EV_NONE) {
     fprintf(stderr, "elf_version() failed: %s\n", elf_errmsg(0));
     return false;
@@ -649,16 +648,16 @@ bool DumpSymbols::WriteSymbolFile(const std::string &obj_file, int sym_fd) {
   struct stat st;
   if (fstat(obj_fd, &st) != 0 && st.st_size <= 0)
     return false;
-  void *obj_base = mmap(NULL, st.st_size,
+  void* obj_base = mmap(NULL, st.st_size,
                         PROT_READ, MAP_PRIVATE, obj_fd, 0);
   if (obj_base == MAP_FAILED)
     return false;
   MmapWrapper map_wrapper(obj_base, st.st_size);
   GElf_Ehdr elf_header;
-  Elf *elf = elf_begin(obj_fd, ELF_C_READ, NULL);
+  Elf* elf = elf_begin(obj_fd, ELF_C_READ, NULL);
   AutoElfEnder elfEnder(elf);
 
-  if (gelf_getehdr(elf, &elf_header) == (GElf_Ehdr *)NULL) {
+  if (gelf_getehdr(elf, &elf_header) == (GElf_Ehdr*)NULL) {
     fprintf(stderr, "failed to read elf header: %s\n", elf_errmsg(-1));
     return false;
   }
diff --git a/src/MEGASync/google_breakpad/common/solaris/dump_symbols.h b/src/MEGASync/google_breakpad/common/solaris/dump_symbols.h
index 7f4baadc..3bca8a23 100644
--- a/src/MEGASync/google_breakpad/common/solaris/dump_symbols.h
+++ b/src/MEGASync/google_breakpad/common/solaris/dump_symbols.h
@@ -40,7 +40,7 @@ namespace google_breakpad {
 
 class DumpSymbols {
  public:
-  bool WriteSymbolFile(const std::string &obj_file,
+  bool WriteSymbolFile(const std::string& obj_file,
                        int sym_fd);
 };
 
diff --git a/src/MEGASync/google_breakpad/common/solaris/file_id.cc b/src/MEGASync/google_breakpad/common/solaris/file_id.cc
index 643a1462..c32c73bb 100644
--- a/src/MEGASync/google_breakpad/common/solaris/file_id.cc
+++ b/src/MEGASync/google_breakpad/common/solaris/file_id.cc
@@ -54,17 +54,17 @@ namespace google_breakpad {
 
 class AutoElfEnder {
  public:
-  AutoElfEnder(Elf *elf) : elf_(elf) {}
+  AutoElfEnder(Elf* elf) : elf_(elf) {}
   ~AutoElfEnder() { if (elf_) elf_end(elf_); }
  private:
-  Elf *elf_;
+  Elf* elf_;
 };
 
 // Find the text section in elf object file.
 // Return the section start address and the size.
-static bool FindElfTextSection(int fd, const void *elf_base,
-                               const void **text_start,
-                               int *text_size) {
+static bool FindElfTextSection(int fd, const void* elf_base,
+                               const void** text_start,
+                               int* text_size) {
   assert(text_start);
   assert(text_size);
 
@@ -78,10 +78,10 @@ static bool FindElfTextSection(int fd, const void *elf_base,
 
   GElf_Ehdr elf_header;
   lseek(fd, 0L, 0);
-  Elf *elf = elf_begin(fd, ELF_C_READ, NULL);
+  Elf* elf = elf_begin(fd, ELF_C_READ, NULL);
   AutoElfEnder elfEnder(elf);
 
-  if (gelf_getehdr(elf, &elf_header) == (GElf_Ehdr *)NULL) {
+  if (gelf_getehdr(elf, &elf_header) == (GElf_Ehdr*)NULL) {
     print_message2(2, "failed to read elf header: %s\n", elf_errmsg(-1));
     return false;
   }
@@ -95,18 +95,18 @@ static bool FindElfTextSection(int fd, const void *elf_base,
   }
 
   static const char kTextSectionName[] = ".text";
-  const GElf_Shdr *text_section = NULL;
-  Elf_Scn *scn = NULL;
+  const GElf_Shdr* text_section = NULL;
+  Elf_Scn* scn = NULL;
   GElf_Shdr shdr;
 
   while ((scn = elf_nextscn(elf, scn)) != NULL) {
-    if (gelf_getshdr(scn, &shdr) == (GElf_Shdr *)0) {
+    if (gelf_getshdr(scn, &shdr) == (GElf_Shdr*)0) {
       print_message2(2, "failed to read section header: %s\n", elf_errmsg(0));
       return false;
     }
 
     if (shdr.sh_type == SHT_PROGBITS) {
-      const char *section_name = elf_strptr(elf, elf_header.e_shstrndx,
+      const char* section_name = elf_strptr(elf, elf_header.e_shstrndx,
                                             shdr.sh_name);
       if (!section_name) {
         print_message2(2, "Section name error: %s\n", elf_errmsg(-1));
@@ -120,7 +120,7 @@ static bool FindElfTextSection(int fd, const void *elf_base,
     }
   }
   if (text_section != NULL && text_section->sh_size > 0) {
-    *text_start = (char *)elf_base + text_section->sh_offset;
+    *text_start = (char*)elf_base + text_section->sh_offset;
     *text_size = text_section->sh_size;
     return true;
   }
@@ -128,7 +128,7 @@ static bool FindElfTextSection(int fd, const void *elf_base,
   return false;
 }
 
-FileID::FileID(const char *path) {
+FileID::FileID(const char* path) {
   strcpy(path_, path);
 }
 
@@ -150,29 +150,29 @@ bool FileID::ElfFileIdentifier(unsigned char identifier[16]) {
   if (fstat(fd, &st) != 0 || st.st_size <= 0)
     return false;
 
-  void *base = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
+  void* base = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
   if (base == MAP_FAILED)
     return false;
 
   bool success = false;
-  const void *text_section = NULL;
+  const void* text_section = NULL;
   int text_size = 0;
 
   if (FindElfTextSection(fd, base, &text_section, &text_size)) {
     MD5Context md5;
     MD5Init(&md5);
-    MD5Update(&md5, (const unsigned char *)text_section, text_size);
+    MD5Update(&md5, (const unsigned char*)text_section, text_size);
     MD5Final(identifier, &md5);
     success = true;
   }
 
-  munmap((char *)base, st.st_size);
+  munmap((char*)base, st.st_size);
   return success;
 }
 
 // static
 bool FileID::ConvertIdentifierToString(const unsigned char identifier[16],
-                                       char *buffer, int buffer_length) {
+                                       char* buffer, int buffer_length) {
   if (buffer_length < 34)
     return false;
 
diff --git a/src/MEGASync/google_breakpad/common/solaris/guid_creator.cc b/src/MEGASync/google_breakpad/common/solaris/guid_creator.cc
index c4d58e0a..17d773e7 100644
--- a/src/MEGASync/google_breakpad/common/solaris/guid_creator.cc
+++ b/src/MEGASync/google_breakpad/common/solaris/guid_creator.cc
@@ -66,7 +66,7 @@ const GUIDGenerator kGuidGenerator;
 
 bool CreateGUID(GUID *guid) {
   return kGuidGenerator.CreateGUID(guid);
-};
+}
 
 // Parse guid to string.
 bool GUIDToString(const GUID *guid, char *buf, int buf_len) {
@@ -74,8 +74,8 @@ bool GUIDToString(const GUID *guid, char *buf, int buf_len) {
   assert(buf_len > kGUIDStringLength);
   int num = snprintf(buf, buf_len, kGUIDFormatString,
                      guid->data1, guid->data2, guid->data3,
-                     *reinterpret_cast<const uint32_t *>(&(guid->data4[0])),
-                     *reinterpret_cast<const uint32_t *>(&(guid->data4[4])));
+                     *reinterpret_cast<const uint32_t*>(&(guid->data4[0])),
+                     *reinterpret_cast<const uint32_t*>(&(guid->data4[4])));
   if (num != kGUIDStringLength)
     return false;
 
diff --git a/src/MEGASync/google_breakpad/common/stabs_reader.cc b/src/MEGASync/google_breakpad/common/stabs_reader.cc
index 6019fc7e..43c40402 100644
--- a/src/MEGASync/google_breakpad/common/stabs_reader.cc
+++ b/src/MEGASync/google_breakpad/common/stabs_reader.cc
@@ -45,7 +45,7 @@ using std::vector;
 
 namespace google_breakpad {
 
-StabsReader::EntryIterator::EntryIterator(const ByteBuffer *buffer,
+StabsReader::EntryIterator::EntryIterator(const ByteBuffer* buffer,
                                           bool big_endian, size_t value_size)
     : value_size_(value_size), cursor_(buffer, big_endian) {
   // Actually, we could handle weird sizes just fine, but they're
@@ -65,10 +65,10 @@ void StabsReader::EntryIterator::Fetch() {
   entry_.at_end = !cursor_;
 }
 
-StabsReader::StabsReader(const uint8_t *stab,    size_t stab_size,
-                         const uint8_t *stabstr, size_t stabstr_size,
+StabsReader::StabsReader(const uint8_t* stab,    size_t stab_size,
+                         const uint8_t* stabstr, size_t stabstr_size,
                          bool big_endian, size_t value_size, bool unitized,
-                         StabsHandler *handler)
+                         StabsHandler* handler)
     : entries_(stab, stab_size),
       strings_(stabstr, stabstr_size),
       iterator_(&entries_, big_endian, value_size),
@@ -78,7 +78,7 @@ StabsReader::StabsReader(const uint8_t *stab,    size_t stab_size,
       next_cu_string_offset_(0),
       current_source_file_(NULL) { }
 
-const char *StabsReader::SymbolString() {
+const char* StabsReader::SymbolString() {
   ptrdiff_t offset = string_offset_ + iterator_->name_offset;
   if (offset < 0 || (size_t) offset >= strings_.Size()) {
     handler_->Warning("symbol %d: name offset outside the string section\n",
@@ -87,7 +87,7 @@ const char *StabsReader::SymbolString() {
     // taken from the string section.
     offset = 0;
   }
-  return reinterpret_cast<const char *>(strings_.start + offset);
+  return reinterpret_cast<const char*>(strings_.start + offset);
 }
 
 bool StabsReader::Process() {
@@ -134,9 +134,9 @@ bool StabsReader::ProcessCompilationUnit() {
   // There may be an N_SO entry whose name ends with a slash,
   // indicating the directory in which the compilation occurred.
   // The build directory defaults to NULL.
-  const char *build_directory = NULL;
+  const char* build_directory = NULL;
   {
-    const char *name = SymbolString();
+    const char* name = SymbolString();
     if (name[0] && name[strlen(name) - 1] == '/') {
       build_directory = name;
       ++iterator_;
@@ -148,7 +148,7 @@ bool StabsReader::ProcessCompilationUnit() {
   {
     if (iterator_->at_end || iterator_->type != N_SO)
       return true;
-    const char *name = SymbolString();
+    const char* name = SymbolString();
     if (name[0] == '\0') {
       // This seems to be a stray end-of-compilation-unit marker;
       // consume it, but don't report the end, since we didn't see a
@@ -203,7 +203,7 @@ bool StabsReader::ProcessCompilationUnit() {
   uint64_t ending_address = 0;
   if (!iterator_->at_end) {
     assert(iterator_->type == N_SO);
-    const char *name = SymbolString();
+    const char* name = SymbolString();
     if (name[0] == '\0') {
       ending_address = iterator_->value;
       ++iterator_;
@@ -225,8 +225,8 @@ bool StabsReader::ProcessFunction() {
   // The STABS string for an N_FUN entry is the name of the function,
   // followed by a colon, followed by type information for the
   // function.  We want to pass the name alone to StartFunction.
-  const char *stab_string = SymbolString();
-  const char *name_end = strchr(stab_string, ':');
+  const char* stab_string = SymbolString();
+  const char* name_end = strchr(stab_string, ':');
   if (! name_end)
     name_end = stab_string + strlen(stab_string);
   string name(stab_string, name_end - stab_string);
@@ -270,7 +270,7 @@ bool StabsReader::ProcessFunction() {
   if (!iterator_->at_end) {
     assert(iterator_->type == N_SO || iterator_->type == N_FUN);
     if (iterator_->type == N_FUN) {
-      const char *symbol_name = SymbolString();
+      const char* symbol_name = SymbolString();
       if (symbol_name[0] == '\0') {
         // An N_FUN entry with no name is a terminator for this function;
         // its value is the function's size.
diff --git a/src/MEGASync/google_breakpad/common/stabs_reader.h b/src/MEGASync/google_breakpad/common/stabs_reader.h
index d89afc00..1e773f45 100644
--- a/src/MEGASync/google_breakpad/common/stabs_reader.h
+++ b/src/MEGASync/google_breakpad/common/stabs_reader.h
@@ -53,11 +53,10 @@
 #include <config.h>
 #endif
 
-#ifdef HAVE_A_OUT_H
-#include <a.out.h>
-#endif
 #ifdef HAVE_MACH_O_NLIST_H
 #include <mach-o/nlist.h>
+#elif defined(HAVE_A_OUT_H)
+#include <a.out.h>
 #endif
 
 #include <string>
@@ -93,10 +92,10 @@ class StabsReader {
   // 
   // Note that, in ELF, the .stabstr section should be found using the
   // 'sh_link' field of the .stab section header, not by name.
-  StabsReader(const uint8_t *stab,    size_t stab_size,
-              const uint8_t *stabstr, size_t stabstr_size,
+  StabsReader(const uint8_t* stab,    size_t stab_size,
+              const uint8_t* stabstr, size_t stabstr_size,
               bool big_endian, size_t value_size, bool unitized,
-              StabsHandler *handler);
+              StabsHandler* handler);
 
   // Process the STABS data, calling the handler's member functions to
   // report what we find.  While the handler functions return true,
@@ -150,17 +149,17 @@ class StabsReader {
     // Mac, they are 32 or 64 bits long. Oddly, the section header's entry
     // size for a Linux ELF .stab section varies according to the ELF class
     // from 12 to 20 even as the actual entries remain unchanged.
-    EntryIterator(const ByteBuffer *buffer, bool big_endian, size_t value_size);
+    EntryIterator(const ByteBuffer* buffer, bool big_endian, size_t value_size);
 
     // Move to the next entry. This function's behavior is undefined if
     // at_end() is true when it is called.
-    EntryIterator &operator++() { Fetch(); entry_.index++; return *this; }
+    EntryIterator& operator++() { Fetch(); entry_.index++; return *this; }
 
     // Dereferencing this iterator produces a reference to an Entry structure
     // that holds the current entry's values. The entry is owned by this
     // EntryIterator, and will be invalidated at the next call to operator++.
-    const Entry &operator*() const { return entry_; }
-    const Entry *operator->() const { return &entry_; }
+    const Entry& operator*() const { return entry_; }
+    const Entry* operator->() const { return &entry_; }
 
    private:
     // Read the STABS entry at cursor_, and set entry_ appropriately.
@@ -179,12 +178,12 @@ class StabsReader {
   // A source line, saved to be reported later.
   struct Line {
     uint64_t address;
-    const char *filename;
+    const char* filename;
     int number;
   };
 
   // Return the name of the current symbol.
-  const char *SymbolString();
+  const char* SymbolString();
 
   // Process a compilation unit starting at symbol_.  Return true
   // to continue processing, or false to abort.
@@ -211,7 +210,7 @@ class StabsReader {
   // StabsReader::StabsReader.
   bool unitized_;
 
-  StabsHandler *handler_;
+  StabsHandler* handler_;
 
   // The offset of the current compilation unit's strings within stabstr_.
   size_t string_offset_;
@@ -221,7 +220,7 @@ class StabsReader {
   size_t next_cu_string_offset_;
 
   // The current source file name.
-  const char *current_source_file_;
+  const char* current_source_file_;
 
   // Mac OS X STABS place SLINE records before functions; we accumulate a
   // vector of these until we see the FUN record, and then report them
@@ -262,7 +261,7 @@ class StabsHandler {
   // FILENAME values are different addresses, they represent different
   // file names.
   //
-  // Thus, it's safe to use (say) std::map<char *, ...>, which does
+  // Thus, it's safe to use (say) std::map<char*, ...>, which does
   // string address comparisons, not string content comparisons.
   // Since all the strings are in same array of characters --- the
   // .stabstr section --- comparing their addresses produces
@@ -272,8 +271,8 @@ class StabsHandler {
   // named FILENAME, and whose base address is ADDRESS.  If
   // BUILD_DIRECTORY is non-NULL, it is the name of the build
   // directory in which the compilation occurred.
-  virtual bool StartCompilationUnit(const char *filename, uint64_t address,
-                                    const char *build_directory) {
+  virtual bool StartCompilationUnit(const char* filename, uint64_t address,
+                                    const char* build_directory) {
     return true;
   }
 
@@ -293,7 +292,7 @@ class StabsHandler {
   // StartFunction is the function name alone.
   //
   // In languages that use name mangling, like C++, NAME is mangled.
-  virtual bool StartFunction(const string &name, uint64_t address) {
+  virtual bool StartFunction(const string& name, uint64_t address) {
     return true;
   }
 
@@ -306,19 +305,19 @@ class StabsHandler {
   // Report that the code at ADDRESS is attributable to line NUMBER of
   // the source file named FILENAME.  The caller must infer the ending
   // address of the line.
-  virtual bool Line(uint64_t address, const char *filename, int number) {
+  virtual bool Line(uint64_t address, const char* filename, int number) {
     return true;
   }
 
   // Report that an exported function NAME is present at ADDRESS.
   // The size of the function is unknown.
-  virtual bool Extern(const string &name, uint64_t address) {
+  virtual bool Extern(const string& name, uint64_t address) {
     return true;
   }
 
   // Report a warning.  FORMAT is a printf-like format string,
   // specifying how to format the subsequent arguments.
-  virtual void Warning(const char *format, ...) = 0;
+  virtual void Warning(const char* format, ...) = 0;
 };
 
 } // namespace google_breakpad
diff --git a/src/MEGASync/google_breakpad/common/stabs_reader_unittest.cc b/src/MEGASync/google_breakpad/common/stabs_reader_unittest.cc
index a84da1c4..24f3e1a5 100644
--- a/src/MEGASync/google_breakpad/common/stabs_reader_unittest.cc
+++ b/src/MEGASync/google_breakpad/common/stabs_reader_unittest.cc
@@ -75,7 +75,7 @@ class StringAssembler: public Section {
   // Add the string S to this StringAssembler, and return the string's
   // offset within this compilation unit's strings. If S has been added
   // already, this returns the offset of its first instance.
-  size_t Add(const string &s) {
+  size_t Add(const string& s) {
     map<string, size_t>::iterator it = added_.find(s);
     if (it != added_.end())
       return it->second;
@@ -127,7 +127,7 @@ class StringAssembler: public Section {
 class StabsAssembler: public Section {
  public:
   // Create a StabsAssembler that uses StringAssembler for its strings.
-  StabsAssembler(StringAssembler *string_assembler)
+  StabsAssembler(StringAssembler* string_assembler)
       : Section(string_assembler->endianness()),
         string_assembler_(string_assembler),
         value_size_(0),
@@ -137,7 +137,7 @@ class StabsAssembler: public Section {
 
   // Accessor and setter for value_size_.
   size_t value_size() const { return value_size_; }
-  StabsAssembler &set_value_size(size_t value_size) {
+  StabsAssembler& set_value_size(size_t value_size) {
     value_size_ = value_size;
     return *this;
   }
@@ -147,7 +147,7 @@ class StabsAssembler: public Section {
   // its compilation unit's portion of the .stabstr section; this can be a
   // value generated by a StringAssembler. Return a reference to this
   // StabsAssembler.
-  StabsAssembler &Stab(uint8_t type, uint8_t other, Label descriptor,
+  StabsAssembler& Stab(uint8_t type, uint8_t other, Label descriptor,
                        Label value, Label name) {
     D32(name);
     D8(type);
@@ -159,15 +159,15 @@ class StabsAssembler: public Section {
   }
 
   // As above, but automatically add NAME to our StringAssembler.
-  StabsAssembler &Stab(uint8_t type, uint8_t other, Label descriptor,
-                       Label value, const string &name) {
+  StabsAssembler& Stab(uint8_t type, uint8_t other, Label descriptor,
+                       Label value, const string& name) {
     return Stab(type, other, descriptor, value, string_assembler_->Add(name));
   }
 
   // Start a compilation unit named NAME, with an N_UNDF symbol to start
   // it, and its own portion of the string section. Return a reference to
   // this StabsAssembler.
-  StabsAssembler &StartCU(const string &name) {
+  StabsAssembler& StartCU(const string& name) {
     assert(!cu_header_);
     cu_header_ = new CUHeader;
     string_assembler_->StartCU();
@@ -180,7 +180,7 @@ class StabsAssembler: public Section {
 
   // Close off the current compilation unit. Return a reference to this
   // StabsAssembler.
-  StabsAssembler &EndCU() {
+  StabsAssembler& EndCU() {
     assert(cu_header_);
     cu_header_->final_entry_count = entry_count_;
     cu_header_->final_string_size = string_assembler_->EndCU();
@@ -201,7 +201,7 @@ class StabsAssembler: public Section {
   };
 
   // The strings for our STABS entries.
-  StringAssembler *string_assembler_;
+  StringAssembler* string_assembler_;
 
   // The size of the 'value' field of stabs entries in this section.
   size_t value_size_;
@@ -211,20 +211,20 @@ class StabsAssembler: public Section {
 
   // Header labels for this compilation unit, if we've started one but not
   // finished it.
-  CUHeader *cu_header_;
+  CUHeader* cu_header_;
 };
 
 class MockStabsReaderHandler: public StabsHandler {
  public:
   MOCK_METHOD3(StartCompilationUnit,
-               bool(const char *, uint64_t, const char *));
+               bool(const char*, uint64_t, const char*));
   MOCK_METHOD1(EndCompilationUnit, bool(uint64_t));
-  MOCK_METHOD2(StartFunction, bool(const string &, uint64_t));
+  MOCK_METHOD2(StartFunction, bool(const string&, uint64_t));
   MOCK_METHOD1(EndFunction, bool(uint64_t));
-  MOCK_METHOD3(Line, bool(uint64_t, const char *, int));
-  MOCK_METHOD2(Extern, bool(const string &, uint64_t));
-  void Warning(const char *format, ...) { MockWarning(format); }
-  MOCK_METHOD1(MockWarning, void(const char *));
+  MOCK_METHOD3(Line, bool(uint64_t, const char*, int));
+  MOCK_METHOD2(Extern, bool(const string&, uint64_t));
+  void Warning(const char* format, ...) { MockWarning(format); }
+  MOCK_METHOD1(MockWarning, void(const char*));
 };
 
 struct StabsFixture {
@@ -243,9 +243,9 @@ struct StabsFixture {
 
     // Run the parser on the test input, passing whatever we find to HANDLER.
     StabsReader reader(
-        reinterpret_cast<const uint8_t *>(stabs_contents.data()),
+        reinterpret_cast<const uint8_t*>(stabs_contents.data()),
         stabs_contents.size(),
-        reinterpret_cast<const uint8_t *>(stabstr_contents.data()),
+        reinterpret_cast<const uint8_t*>(stabstr_contents.data()),
         stabstr_contents.size(),
         stabs.endianness() == kBigEndian, stabs.value_size(), unitized,
         &mock_handler);
diff --git a/src/MEGASync/google_breakpad/common/stabs_to_module.cc b/src/MEGASync/google_breakpad/common/stabs_to_module.cc
index e59aebdb..05b25a74 100644
--- a/src/MEGASync/google_breakpad/common/stabs_to_module.cc
+++ b/src/MEGASync/google_breakpad/common/stabs_to_module.cc
@@ -45,7 +45,7 @@ namespace google_breakpad {
 
 // Demangle using abi call.
 // Older GCC may not support it.
-static string Demangle(const string &mangled) {
+static string Demangle(const string& mangled) {
   int status = 0;
   char *demangled = abi::__cxa_demangle(mangled.c_str(), NULL, NULL, &status);
   if (status == 0 && demangled != NULL) {
@@ -58,7 +58,7 @@ static string Demangle(const string &mangled) {
 
 StabsToModule::~StabsToModule() {
   // Free any functions we've accumulated but not added to the module.
-  for (vector<Module::Function *>::const_iterator func_it = functions_.begin();
+  for (vector<Module::Function*>::const_iterator func_it = functions_.begin();
        func_it != functions_.end(); func_it++)
     delete *func_it;
   // Free any function that we're currently within.
@@ -87,13 +87,12 @@ bool StabsToModule::EndCompilationUnit(uint64_t address) {
   return true;
 }
 
-bool StabsToModule::StartFunction(const string &name,
+bool StabsToModule::StartFunction(const string& name,
                                   uint64_t address) {
   assert(!current_function_);
-  Module::Function *f = new Module::Function;
-  f->name = Demangle(name);
-  f->address = address;
-  f->size = 0;           // We compute this in StabsToModule::Finalize().
+  Module::Function *f = new Module::Function(Demangle(name), address);
+  Module::Range r(address, 0); // We compute this in StabsToModule::Finalize().
+  f->ranges.push_back(r);
   f->parameter_size = 0; // We don't provide this information.
   current_function_ = f;
   boundaries_.push_back(static_cast<Module::Address>(address));
@@ -132,8 +131,8 @@ bool StabsToModule::Line(uint64_t address, const char *name, int number) {
   return true;
 }
 
-bool StabsToModule::Extern(const string &name, uint64_t address) {
-  Module::Extern *ext = new Module::Extern;
+bool StabsToModule::Extern(const string& name, uint64_t address) {
+  Module::Extern *ext = new Module::Extern(address);
   // Older libstdc++ demangle implementations can crash on unexpected
   // input, so be careful about what gets passed in.
   if (name.compare(0, 3, "__Z") == 0) {
@@ -143,7 +142,6 @@ bool StabsToModule::Extern(const string &name, uint64_t address) {
   } else {
     ext->name = name;
   }
-  ext->address = address;
   module_->AddExtern(ext);
   return true;
 }
@@ -162,7 +160,7 @@ void StabsToModule::Finalize() {
   sort(functions_.begin(), functions_.end(),
        Module::Function::CompareByAddress);
 
-  for (vector<Module::Function *>::const_iterator func_it = functions_.begin();
+  for (vector<Module::Function*>::const_iterator func_it = functions_.begin();
        func_it != functions_.end();
        func_it++) {
     Module::Function *f = *func_it;
@@ -170,14 +168,14 @@ void StabsToModule::Finalize() {
     vector<Module::Address>::const_iterator boundary
         = std::upper_bound(boundaries_.begin(), boundaries_.end(), f->address);
     if (boundary != boundaries_.end())
-      f->size = *boundary - f->address;
+      f->ranges[0].size = *boundary - f->address;
     else
       // If this is the last function in the module, and the STABS
       // reader was unable to give us its ending address, then assign
       // it a bogus, very large value.  This will happen at most once
       // per module: since we've added all functions' addresses to the
       // boundary table, only one can be the last.
-      f->size = kFallbackSize;
+      f->ranges[0].size = kFallbackSize;
 
     // Compute sizes for each of the function f's lines --- if it has any.
     if (!f->lines.empty()) {
@@ -188,7 +186,8 @@ void StabsToModule::Finalize() {
            line_it != last_line; line_it++)
         line_it[0].size = line_it[1].address - line_it[0].address;
       // Compute the size of the last line from f's end address.
-      last_line->size = (f->address + f->size) - last_line->address;
+      last_line->size =
+        (f->ranges[0].address + f->ranges[0].size) - last_line->address;
     }
   }
   // Now that everything has a size, add our functions to the module, and
diff --git a/src/MEGASync/google_breakpad/common/stabs_to_module.h b/src/MEGASync/google_breakpad/common/stabs_to_module.h
index 5e04fa79..6f6e0ed7 100644
--- a/src/MEGASync/google_breakpad/common/stabs_to_module.h
+++ b/src/MEGASync/google_breakpad/common/stabs_to_module.h
@@ -76,10 +76,10 @@ class StabsToModule: public google_breakpad::StabsHandler {
   bool StartCompilationUnit(const char *name, uint64_t address,
                             const char *build_directory);
   bool EndCompilationUnit(uint64_t address);
-  bool StartFunction(const string &name, uint64_t address);
+  bool StartFunction(const string& name, uint64_t address);
   bool EndFunction(uint64_t address);
   bool Line(uint64_t address, const char *name, int number);
-  bool Extern(const string &name, uint64_t address);
+  bool Extern(const string& name, uint64_t address);
   void Warning(const char *format, ...);
 
   // Do any final processing necessary to make module_ contain all the
@@ -107,7 +107,7 @@ class StabsToModule: public google_breakpad::StabsHandler {
   // We could just stick them in module_ from the outset, but if
   // module_ already contains data gathered from other debugging
   // formats, that would complicate the size computation.
-  vector<Module::Function *> functions_;
+  vector<Module::Function*> functions_;
 
   // Boundary addresses.  STABS doesn't necessarily supply sizes for
   // functions and lines, so we need to compute them ourselves by
diff --git a/src/MEGASync/google_breakpad/common/stabs_to_module_unittest.cc b/src/MEGASync/google_breakpad/common/stabs_to_module_unittest.cc
index d445d1d6..9c134e73 100644
--- a/src/MEGASync/google_breakpad/common/stabs_to_module_unittest.cc
+++ b/src/MEGASync/google_breakpad/common/stabs_to_module_unittest.cc
@@ -58,13 +58,13 @@ TEST(StabsToModule, SimpleCU) {
   Module::File *file = m.FindExistingFile("source-file-name");
   ASSERT_TRUE(file != NULL);
 
-  vector<Module::Function *> functions;
+  vector<Module::Function*> functions;
   m.GetFunctions(&functions, functions.end());
   ASSERT_EQ((size_t) 1, functions.size());
   Module::Function *function = functions[0];
   EXPECT_STREQ("function", function->name.c_str());
   EXPECT_EQ(0xfde4abbed390c394LL, function->address);
-  EXPECT_EQ(0x10U, function->size);
+  EXPECT_EQ(0x10U, function->ranges[0].size);
   EXPECT_EQ(0U, function->parameter_size);
   ASSERT_EQ((size_t) 1, function->lines.size());
   Module::Line *line = &function->lines[0];
@@ -88,7 +88,7 @@ TEST(StabsToModule, Externs) {
   h.Finalize();
 
   // Now check to see what has been added to the Module.
-  vector<Module::Extern *> externs;
+  vector<Module::Extern*> externs;
   m.GetExterns(&externs, externs.end());
   ASSERT_EQ((size_t) 3, externs.size());
   Module::Extern *extern1 = externs[0];
@@ -124,13 +124,13 @@ TEST(StabsToModule, DuplicateFunctionNames) {
   Module::File *file = m.FindExistingFile("compilation-unit");
   ASSERT_TRUE(file != NULL);
 
-  vector<Module::Function *> functions;
+  vector<Module::Function*> functions;
   m.GetFunctions(&functions, functions.end());
   ASSERT_EQ(1U, functions.size());
 
   Module::Function *function = functions[0];
   EXPECT_EQ(0xf2cfda36ecf7f46dLL, function->address);
-  EXPECT_LT(0U, function->size);  // should have used dummy size
+  EXPECT_LT(0U, function->ranges[0].size); // should have used dummy size
   EXPECT_EQ(0U, function->parameter_size);
   ASSERT_EQ(0U, function->lines.size());
 }
@@ -159,14 +159,14 @@ TEST(InferSizes, LineSize) {
   Module::File *file2 = m.FindExistingFile("source-file-name-2");
   ASSERT_TRUE(file2 != NULL);
 
-  vector<Module::Function *> functions;
+  vector<Module::Function*> functions;
   m.GetFunctions(&functions, functions.end());
   ASSERT_EQ((size_t) 1, functions.size());
 
   Module::Function *function = functions[0];
   EXPECT_STREQ("function", function->name.c_str());
   EXPECT_EQ(0xb4513962eff94e92LL, function->address);
-  EXPECT_EQ(0x1000100000000ULL, function->size); // inferred from CU end
+  EXPECT_EQ(0x1000100000000ULL, function->ranges[0].size); // inferred from CU end
   EXPECT_EQ(0U, function->parameter_size);
   ASSERT_EQ((size_t) 2, function->lines.size());
 
@@ -204,7 +204,7 @@ TEST(FunctionNames, Mangled) {
   Module::File *file = m.FindExistingFile("compilation-unit");
   ASSERT_TRUE(file != NULL);
 
-  vector<Module::Function *> functions;
+  vector<Module::Function*> functions;
   m.GetFunctions(&functions, functions.end());
   ASSERT_EQ(1U, functions.size());
 
@@ -216,7 +216,7 @@ TEST(FunctionNames, Mangled) {
                "push_back(unsigned long long const&)",
                function->name.c_str());
   EXPECT_EQ(0xf2cfda63cef7f46dLL, function->address);
-  EXPECT_LT(0U, function->size); // should have used dummy size
+  EXPECT_LT(0U, function->ranges[0].size); // should have used dummy size
   EXPECT_EQ(0U, function->parameter_size);
   ASSERT_EQ(0U, function->lines.size());
 }
diff --git a/src/MEGASync/google_breakpad/common/android/include/sgidefs.h b/src/MEGASync/google_breakpad/common/stdio_wrapper.h
similarity index 73%
rename from src/MEGASync/google_breakpad/common/android/include/sgidefs.h
rename to src/MEGASync/google_breakpad/common/stdio_wrapper.h
index cc8ef5d0..a3dd50aa 100644
--- a/src/MEGASync/google_breakpad/common/android/include/sgidefs.h
+++ b/src/MEGASync/google_breakpad/common/stdio_wrapper.h
@@ -1,4 +1,4 @@
-// Copyright (c) 2013, Google Inc.
+// Copyright (c) 2016, Google Inc.
 // All rights reserved.
 //
 // Redistribution and use in source and binary forms, with or without
@@ -27,25 +27,17 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-#ifndef GOOGLE_BREAKPAD_ANDROID_INCLUDE_SGIDEFS_H
-#define GOOGLE_BREAKPAD_ANDROID_INCLUDE_SGIDEFS_H
+#ifndef GOOGLE_BREAKPAD_COMMON_STDIO_WRAPPER_H
+#define GOOGLE_BREAKPAD_COMMON_STDIO_WRAPPER_H
 
-#ifdef __mips__
+#include <stdio.h>
 
-#define _MIPS_SIM_ABI32  1
-#define _MIPS_SIM_NABI32 2
-#define _MIPS_SIM_ABI64  3
+#if defined(_MSC_VER) && MSC_VER < 1900
+#include <basetsd.h>
 
-// The following should always be defined by the compiler,
-// Verified for Android with GCC 4.6 and Clang 3.1.
-#ifndef _MIPS_SIM
-#error "Toolchain should define _MIPS_SIM"
+#define snprintf _snprintf
+typedef SSIZE_T ssize_t;
 #endif
 
-#ifndef _MIPS_SZPTR
-#error "Toolchain should define _MIPS_PTR"
-#endif
-
-#endif  // __mips__
 
-#endif  // GOOGLE_BREAKPAD_ANDROID_INCLUDE_SGIDEFS_H
+#endif  // GOOGLE_BREAKPAD_COMMON_STDIO_WRAPPER_H
diff --git a/src/MEGASync/google_breakpad/common/string_conversion.cc b/src/MEGASync/google_breakpad/common/string_conversion.cc
index 9c0d623f..6a78ed7e 100644
--- a/src/MEGASync/google_breakpad/common/string_conversion.cc
+++ b/src/MEGASync/google_breakpad/common/string_conversion.cc
@@ -38,15 +38,15 @@ namespace google_breakpad {
 
 using std::vector;
 
-void UTF8ToUTF16(const char *in, vector<uint16_t> *out) {
+void UTF8ToUTF16(const char* in, vector<uint16_t>* out) {
   size_t source_length = strlen(in);
-  const UTF8 *source_ptr = reinterpret_cast<const UTF8 *>(in);
-  const UTF8 *source_end_ptr = source_ptr + source_length;
+  const UTF8* source_ptr = reinterpret_cast<const UTF8*>(in);
+  const UTF8* source_end_ptr = source_ptr + source_length;
   // Erase the contents and zero fill to the expected size
   out->clear();
   out->insert(out->begin(), source_length, 0);
-  uint16_t *target_ptr = &(*out)[0];
-  uint16_t *target_end_ptr = target_ptr + out->capacity() * sizeof(uint16_t);
+  uint16_t* target_ptr = &(*out)[0];
+  uint16_t* target_end_ptr = target_ptr + out->capacity();
   ConversionResult result = ConvertUTF8toUTF16(&source_ptr, source_end_ptr,
                                                &target_ptr, target_end_ptr,
                                                strictConversion);
@@ -55,11 +55,11 @@ void UTF8ToUTF16(const char *in, vector<uint16_t> *out) {
   out->resize(result == conversionOK ? target_ptr - &(*out)[0] + 1: 0);
 }
 
-int UTF8ToUTF16Char(const char *in, int in_length, uint16_t out[2]) {
-  const UTF8 *source_ptr = reinterpret_cast<const UTF8 *>(in);
-  const UTF8 *source_end_ptr = source_ptr + sizeof(char);
-  uint16_t *target_ptr = out;
-  uint16_t *target_end_ptr = target_ptr + 2 * sizeof(uint16_t);
+int UTF8ToUTF16Char(const char* in, int in_length, uint16_t out[2]) {
+  const UTF8* source_ptr = reinterpret_cast<const UTF8*>(in);
+  const UTF8* source_end_ptr = source_ptr + 1;
+  uint16_t* target_ptr = out;
+  uint16_t* target_end_ptr = target_ptr + 2;
   out[0] = out[1] = 0;
 
   // Process one character at a time
@@ -69,28 +69,28 @@ int UTF8ToUTF16Char(const char *in, int in_length, uint16_t out[2]) {
                                                  strictConversion);
 
     if (result == conversionOK)
-      return static_cast<int>(source_ptr - reinterpret_cast<const UTF8 *>(in));
+      return static_cast<int>(source_ptr - reinterpret_cast<const UTF8*>(in));
 
     // Add another character to the input stream and try again
-    source_ptr = reinterpret_cast<const UTF8 *>(in);
+    source_ptr = reinterpret_cast<const UTF8*>(in);
     ++source_end_ptr;
 
-    if (source_end_ptr > reinterpret_cast<const UTF8 *>(in) + in_length)
+    if (source_end_ptr > reinterpret_cast<const UTF8*>(in) + in_length)
       break;
   }
 
   return 0;
 }
 
-void UTF32ToUTF16(const wchar_t *in, vector<uint16_t> *out) {
+void UTF32ToUTF16(const wchar_t* in, vector<uint16_t>* out) {
   size_t source_length = wcslen(in);
-  const UTF32 *source_ptr = reinterpret_cast<const UTF32 *>(in);
-  const UTF32 *source_end_ptr = source_ptr + source_length;
+  const UTF32* source_ptr = reinterpret_cast<const UTF32*>(in);
+  const UTF32* source_end_ptr = source_ptr + source_length;
   // Erase the contents and zero fill to the expected size
   out->clear();
   out->insert(out->begin(), source_length, 0);
-  uint16_t *target_ptr = &(*out)[0];
-  uint16_t *target_end_ptr = target_ptr + out->capacity() * sizeof(uint16_t);
+  uint16_t* target_ptr = &(*out)[0];
+  uint16_t* target_end_ptr = target_ptr + out->capacity();
   ConversionResult result = ConvertUTF32toUTF16(&source_ptr, source_end_ptr,
                                                 &target_ptr, target_end_ptr,
                                                 strictConversion);
@@ -100,10 +100,10 @@ void UTF32ToUTF16(const wchar_t *in, vector<uint16_t> *out) {
 }
 
 void UTF32ToUTF16Char(wchar_t in, uint16_t out[2]) {
-  const UTF32 *source_ptr = reinterpret_cast<const UTF32 *>(&in);
-  const UTF32 *source_end_ptr = source_ptr + 1;
-  uint16_t *target_ptr = out;
-  uint16_t *target_end_ptr = target_ptr + 2 * sizeof(uint16_t);
+  const UTF32* source_ptr = reinterpret_cast<const UTF32*>(&in);
+  const UTF32* source_end_ptr = source_ptr + 1;
+  uint16_t* target_ptr = out;
+  uint16_t* target_end_ptr = target_ptr + 2;
   out[0] = out[1] = 0;
   ConversionResult result = ConvertUTF32toUTF16(&source_ptr, source_end_ptr,
                                                 &target_ptr, target_end_ptr,
@@ -118,15 +118,15 @@ static inline uint16_t Swap(uint16_t value) {
   return (value >> 8) | static_cast<uint16_t>(value << 8);
 }
 
-string UTF16ToUTF8(const vector<uint16_t> &in, bool swap) {
-  const UTF16 *source_ptr = &in[0];
+string UTF16ToUTF8(const vector<uint16_t>& in, bool swap) {
+  const UTF16* source_ptr = &in[0];
   scoped_array<uint16_t> source_buffer;
 
   // If we're to swap, we need to make a local copy and swap each byte pair
   if (swap) {
     int idx = 0;
     source_buffer.reset(new uint16_t[in.size()]);
-    UTF16 *source_buffer_ptr = source_buffer.get();
+    UTF16* source_buffer_ptr = source_buffer.get();
     for (vector<uint16_t>::const_iterator it = in.begin();
          it != in.end(); ++it, ++idx)
       source_buffer_ptr[idx] = Swap(*it);
@@ -135,17 +135,17 @@ string UTF16ToUTF8(const vector<uint16_t> &in, bool swap) {
   }
 
   // The maximum expansion would be 4x the size of the input string.
-  const UTF16 *source_end_ptr = source_ptr + in.size();
+  const UTF16* source_end_ptr = source_ptr + in.size();
   size_t target_capacity = in.size() * 4;
   scoped_array<UTF8> target_buffer(new UTF8[target_capacity]);
-  UTF8 *target_ptr = target_buffer.get();
-  UTF8 *target_end_ptr = target_ptr + target_capacity;
+  UTF8* target_ptr = target_buffer.get();
+  UTF8* target_end_ptr = target_ptr + target_capacity;
   ConversionResult result = ConvertUTF16toUTF8(&source_ptr, source_end_ptr,
                                                &target_ptr, target_end_ptr,
                                                strictConversion);
 
   if (result == conversionOK) {
-    const char *targetPtr = reinterpret_cast<const char *>(target_buffer.get());
+    const char* targetPtr = reinterpret_cast<const char*>(target_buffer.get());
     return targetPtr;
   }
 
diff --git a/src/MEGASync/google_breakpad/common/string_conversion.h b/src/MEGASync/google_breakpad/common/string_conversion.h
index b9ba96a2..02d1486a 100644
--- a/src/MEGASync/google_breakpad/common/string_conversion.h
+++ b/src/MEGASync/google_breakpad/common/string_conversion.h
@@ -44,24 +44,24 @@ using std::vector;
 
 // Convert |in| to UTF-16 into |out|.  Use platform byte ordering.  If the
 // conversion failed, |out| will be zero length.
-void UTF8ToUTF16(const char *in, vector<uint16_t> *out);
+void UTF8ToUTF16(const char* in, vector<uint16_t>* out);
 
 // Convert at least one character (up to a maximum of |in_length|) from |in|
 // to UTF-16 into |out|.  Return the number of characters consumed from |in|.
 // Any unused characters in |out| will be initialized to 0.  No memory will
 // be allocated by this routine.
-int UTF8ToUTF16Char(const char *in, int in_length, uint16_t out[2]);
+int UTF8ToUTF16Char(const char* in, int in_length, uint16_t out[2]);
 
 // Convert |in| to UTF-16 into |out|.  Use platform byte ordering.  If the
 // conversion failed, |out| will be zero length.
-void UTF32ToUTF16(const wchar_t *in, vector<uint16_t> *out);
+void UTF32ToUTF16(const wchar_t* in, vector<uint16_t>* out);
 
 // Convert |in| to UTF-16 into |out|.  Any unused characters in |out| will be
 // initialized to 0.  No memory will be allocated by this routine.
 void UTF32ToUTF16Char(wchar_t in, uint16_t out[2]);
 
 // Convert |in| to UTF-8.  If |swap| is true, swap bytes before converting.
-string UTF16ToUTF8(const vector<uint16_t> &in, bool swap);
+string UTF16ToUTF8(const vector<uint16_t>& in, bool swap);
 
 }  // namespace google_breakpad
 
diff --git a/src/MEGASync/google_breakpad/common/string_conversion_unittest.cc b/src/MEGASync/google_breakpad/common/string_conversion_unittest.cc
new file mode 100644
index 00000000..e9f9b55d
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/string_conversion_unittest.cc
@@ -0,0 +1,64 @@
+// Copyright (c) 2019, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// string_conversion_unittest.cc: Unit tests for google_breakpad::UTF* helpers.
+
+#include <string>
+#include <vector>
+
+#include "breakpad_googletest_includes.h"
+#include "common/string_conversion.h"
+
+using google_breakpad::UTF8ToUTF16;
+using google_breakpad::UTF8ToUTF16Char;
+using google_breakpad::UTF16ToUTF8;
+using std::vector;
+
+TEST(StringConversionTest, UTF8ToUTF16) {
+  const char in[] = "ac";
+  vector<uint16_t> out;
+  vector<uint16_t> exp{'a', 0xdf, 'c', 0};
+  UTF8ToUTF16(in, &out);
+  EXPECT_EQ(4u, out.size());
+  EXPECT_EQ(exp, out);
+}
+
+TEST(StringConversionTest, UTF8ToUTF16Char) {
+  const char in[] = "a";
+  uint16_t out[3] = {0xff, 0xff, 0xff};
+  EXPECT_EQ(1, UTF8ToUTF16Char(in, 1, out));
+  EXPECT_EQ('a', out[0]);
+  EXPECT_EQ(0, out[1]);
+  EXPECT_EQ(0xff, out[2]);
+}
+
+TEST(StringConversionTest, UTF16ToUTF8) {
+  vector<uint16_t> in{'a', 0xdf, 'c', 0};
+  EXPECT_EQ("ac", UTF16ToUTF8(in, false));
+}
diff --git a/src/MEGASync/google_breakpad/common/test_assembler.cc b/src/MEGASync/google_breakpad/common/test_assembler.cc
index 1e783b45..8a48bfb0 100644
--- a/src/MEGASync/google_breakpad/common/test_assembler.cc
+++ b/src/MEGASync/google_breakpad/common/test_assembler.cc
@@ -46,7 +46,7 @@ using std::back_insert_iterator;
 
 Label::Label() : value_(new Binding()) { }
 Label::Label(uint64_t value) : value_(new Binding(value)) { }
-Label::Label(const Label &label) {
+Label::Label(const Label& label) {
   value_ = label.value_;
   value_->Acquire();
 }
@@ -54,12 +54,12 @@ Label::~Label() {
   if (value_->Release()) delete value_;
 }
 
-Label &Label::operator=(uint64_t value) {
+Label& Label::operator=(uint64_t value) {
   value_->Set(NULL, value);
   return *this;
 }
 
-Label &Label::operator=(const Label &label) {
+Label& Label::operator=(const Label& label) {
   value_->Set(label.value_, 0);
   return *this;
 }
@@ -89,7 +89,7 @@ Label Label::operator-(uint64_t subtrahend) const {
 #define ALWAYS_EVALUATE_AND_ASSERT(x) assert(x)
 #endif
 
-uint64_t Label::operator-(const Label &label) const {
+uint64_t Label::operator-(const Label& label) const {
   uint64_t offset;
   ALWAYS_EVALUATE_AND_ASSERT(IsKnownOffsetFrom(label, &offset));
   return offset;
@@ -101,8 +101,8 @@ uint64_t Label::Value() const {
   return v;
 };
 
-bool Label::IsKnownConstant(uint64_t *value_p) const {
-  Binding *base;
+bool Label::IsKnownConstant(uint64_t* value_p) const {
+  Binding* base;
   uint64_t addend;
   value_->Get(&base, &addend);
   if (base != NULL) return false;
@@ -110,9 +110,9 @@ bool Label::IsKnownConstant(uint64_t *value_p) const {
   return true;
 }
 
-bool Label::IsKnownOffsetFrom(const Label &label, uint64_t *offset_p) const
+bool Label::IsKnownOffsetFrom(const Label& label, uint64_t* offset_p) const
 {
-  Binding *label_base, *this_base;
+  Binding* label_base, *this_base;
   uint64_t label_addend, this_addend;
   label.value_->Get(&label_base, &label_addend);
   value_->Get(&this_base, &this_addend);
@@ -135,7 +135,7 @@ Label::Binding::~Binding() {
     delete base_;
 }
 
-void Label::Binding::Set(Binding *binding, uint64_t addend) {
+void Label::Binding::Set(Binding* binding, uint64_t addend) {
   if (!base_ && !binding) {
     // We're equating two constants. This could be okay.
     assert(addend_ == addend);
@@ -183,13 +183,13 @@ void Label::Binding::Set(Binding *binding, uint64_t addend) {
   }
 }
 
-void Label::Binding::Get(Binding **base, uint64_t *addend) {
+void Label::Binding::Get(Binding** base, uint64_t* addend) {
   if (base_ && base_ != this) {
     // Recurse to find the end of our reference chain (the root of our
     // tree), and then rewrite every binding along the chain to refer
     // to it directly, adjusting addends appropriately. (This is why
     // this member function isn't this-const.)
-    Binding *final_base;
+    Binding* final_base;
     uint64_t final_addend;
     base_->Get(&final_base, &final_addend);
     if (final_base) final_base->Acquire();
@@ -218,14 +218,14 @@ static inline void InsertEndian(test_assembler::Endianness endianness,
   }
 }
 
-Section &Section::Append(Endianness endianness, size_t size, uint64_t number) {
+Section& Section::Append(Endianness endianness, size_t size, uint64_t number) {
   InsertEndian(endianness, size, number,
                back_insert_iterator<string>(contents_));
   return *this;
 }
 
-Section &Section::Append(Endianness endianness, size_t size,
-                         const Label &label) {
+Section& Section::Append(Endianness endianness, size_t size,
+                         const Label& label) {
   // If this label's value is known, there's no reason to waste an
   // entry in references_ on it.
   uint64_t value;
@@ -246,14 +246,14 @@ Section &Section::Append(Endianness endianness, size_t size,
 #define ENDIANNESS(e) ENDIANNESS_ ## e
 
 #define DEFINE_SHORT_APPEND_NUMBER_ENDIAN(e, bits)                      \
-  Section &Section::e ## bits(uint ## bits ## _t v) {                  \
+  Section& Section::e ## bits(uint ## bits ## _t v) {                   \
     InsertEndian(ENDIANNESS(e), bits / 8, v,                            \
                  back_insert_iterator<string>(contents_));              \
     return *this;                                                       \
   }
 
 #define DEFINE_SHORT_APPEND_LABEL_ENDIAN(e, bits)                       \
-  Section &Section::e ## bits(const Label &v) {                         \
+  Section& Section::e ## bits(const Label& v) {                         \
     return Append(ENDIANNESS(e), bits / 8, v);                          \
   }
 
@@ -272,13 +272,13 @@ DEFINE_SHORT_APPEND_ENDIAN(B, 32);
 DEFINE_SHORT_APPEND_ENDIAN(B, 64);
 
 #define DEFINE_SHORT_APPEND_NUMBER_DEFAULT(bits)                        \
-  Section &Section::D ## bits(uint ## bits ## _t v) {                  \
+  Section& Section::D ## bits(uint ## bits ## _t v) {                   \
     InsertEndian(endianness_, bits / 8, v,                              \
                  back_insert_iterator<string>(contents_));              \
     return *this;                                                       \
   }
 #define DEFINE_SHORT_APPEND_LABEL_DEFAULT(bits)                         \
-  Section &Section::D ## bits(const Label &v) {                         \
+  Section& Section::D ## bits(const Label& v) {                         \
     return Append(endianness_, bits / 8, v);                            \
   }
 #define DEFINE_SHORT_APPEND_DEFAULT(bits)                               \
@@ -290,7 +290,7 @@ DEFINE_SHORT_APPEND_DEFAULT(16);
 DEFINE_SHORT_APPEND_DEFAULT(32);
 DEFINE_SHORT_APPEND_DEFAULT(64);
 
-Section &Section::Append(const Section &section) {
+Section& Section::Append(const Section& section) {
   size_t base = contents_.size();
   contents_.append(section.contents_);
   for (vector<Reference>::const_iterator it = section.references_.begin();
@@ -300,7 +300,7 @@ Section &Section::Append(const Section &section) {
   return *this;
 }
 
-Section &Section::LEB128(long long value) {
+Section& Section::LEB128(long long value) {
   while (value < -0x40 || 0x3f < value) {
     contents_ += (value & 0x7f) | 0x80;
     if (value < 0)
@@ -312,7 +312,7 @@ Section &Section::LEB128(long long value) {
   return *this;
 }
 
-Section &Section::ULEB128(uint64_t value) {
+Section& Section::ULEB128(uint64_t value) {
   while (value > 0x7f) {
     contents_ += (value & 0x7f) | 0x80;
     value = (value >> 7);
@@ -321,7 +321,7 @@ Section &Section::ULEB128(uint64_t value) {
   return *this;
 }
 
-Section &Section::Align(size_t alignment, uint8_t pad_byte) {
+Section& Section::Align(size_t alignment, uint8_t pad_byte) {
   // ALIGNMENT must be a power of two.
   assert(((alignment - 1) & alignment) == 0);
   size_t new_size = (contents_.size() + alignment - 1) & ~(alignment - 1);
@@ -335,11 +335,11 @@ void Section::Clear() {
   references_.clear();
 }
 
-bool Section::GetContents(string *contents) {
+bool Section::GetContents(string* contents) {
   // For each label reference, find the label's value, and patch it into
   // the section's contents.
   for (size_t i = 0; i < references_.size(); i++) {
-    Reference &r = references_[i];
+    Reference& r = references_[i];
     uint64_t value;
     if (!r.label.IsKnownConstant(&value)) {
       fprintf(stderr, "Undefined label #%zu at offset 0x%zx\n", i, r.offset);
diff --git a/src/MEGASync/google_breakpad/common/test_assembler.h b/src/MEGASync/google_breakpad/common/test_assembler.h
index 373dbeba..125ef450 100644
--- a/src/MEGASync/google_breakpad/common/test_assembler.h
+++ b/src/MEGASync/google_breakpad/common/test_assembler.h
@@ -111,7 +111,7 @@ class Label {
  public:
   Label();                      // An undefined label.
   Label(uint64_t value);       // A label with a fixed value
-  Label(const Label &value);    // A label equal to another.
+  Label(const Label& value);    // A label equal to another.
   ~Label();
 
   // Return this label's value; it must be known.
@@ -124,18 +124,18 @@ class Label {
   // former could fail if the label is not yet defined and the latter won't.
   uint64_t Value() const;
 
-  Label &operator=(uint64_t value);
-  Label &operator=(const Label &value);
+  Label& operator=(uint64_t value);
+  Label& operator=(const Label& value);
   Label operator+(uint64_t addend) const;
   Label operator-(uint64_t subtrahend) const;
-  uint64_t operator-(const Label &subtrahend) const;
+  uint64_t operator-(const Label& subtrahend) const;
 
   // We could also provide == and != that work on undefined, but
   // related, labels.
 
   // Return true if this label's value is known. If VALUE_P is given,
   // set *VALUE_P to the known value if returning true.
-  bool IsKnownConstant(uint64_t *value_p = NULL) const;
+  bool IsKnownConstant(uint64_t* value_p = NULL) const;
 
   // Return true if the offset from LABEL to this label is known. If
   // OFFSET_P is given, set *OFFSET_P to the offset when returning true.
@@ -155,7 +155,7 @@ class Label {
   //   l-m                              // -10
   //   m-l                              // 10
   //   m.Value()                        // error: m's value is not known
-  bool IsKnownOffsetFrom(const Label &label, uint64_t *offset_p = NULL) const;
+  bool IsKnownOffsetFrom(const Label& label, uint64_t* offset_p = NULL) const;
 
  private:
   // A label's value, or if that is not yet known, how the value is
@@ -186,7 +186,7 @@ class Label {
     // Update every binding on this binding's chain to point directly
     // to BINDING, or to be a constant, with addends adjusted
     // appropriately.
-    void Set(Binding *binding, uint64_t value);
+    void Set(Binding* binding, uint64_t value);
 
     // Return what we know about the value of this binding.
     // - If this binding's value is a known constant, set BASE to
@@ -198,7 +198,7 @@ class Label {
     //   value.
     // - If this binding is unconstrained, set BASE to this, and leave
     //   ADDEND unchanged.
-    void Get(Binding **base, uint64_t *addend);
+    void Get(Binding** base, uint64_t* addend);
 
    private:
     // There are three cases:
@@ -220,7 +220,7 @@ class Label {
     // operations on bindings do path compression: they change every
     // binding on the chain to point directly to the final value,
     // adjusting addends as appropriate.
-    Binding *base_;
+    Binding* base_;
     uint64_t addend_;
 
     // The number of Labels and Bindings pointing to this binding.
@@ -230,10 +230,10 @@ class Label {
   };
 
   // This label's value.
-  Binding *value_;
+  Binding* value_;
 };
 
-inline Label operator+(uint64_t a, const Label &l) { return l + a; }
+inline Label operator+(uint64_t a, const Label& l) { return l + a; }
 // Note that int-Label isn't defined, as negating a Label is not an
 // operation we support.
 
@@ -288,18 +288,18 @@ class Section {
 
   // Append the SIZE bytes at DATA or the contents of STRING to the
   // end of this section. Return a reference to this section.
-  Section &Append(const uint8_t *data, size_t size) {
-    contents_.append(reinterpret_cast<const char *>(data), size);
+  Section& Append(const uint8_t* data, size_t size) {
+    contents_.append(reinterpret_cast<const char*>(data), size);
     return *this;
   };
-  Section &Append(const string &data) {
+  Section& Append(const string& data) {
     contents_.append(data);
     return *this;
   };
 
   // Append SIZE copies of BYTE to the end of this section. Return a
   // reference to this section.
-  Section &Append(size_t size, uint8_t byte) {
+  Section& Append(size_t size, uint8_t byte) {
     contents_.append(size, (char) byte);
     return *this;
   }
@@ -307,8 +307,8 @@ class Section {
   // Append NUMBER to this section. ENDIANNESS is the endianness to
   // use to write the number. SIZE is the length of the number in
   // bytes. Return a reference to this section.
-  Section &Append(Endianness endianness, size_t size, uint64_t number);
-  Section &Append(Endianness endianness, size_t size, const Label &label);
+  Section& Append(Endianness endianness, size_t size, uint64_t number);
+  Section& Append(Endianness endianness, size_t size, const Label& label);
 
   // Append SECTION to the end of this section. The labels SECTION
   // refers to need not be defined yet.
@@ -317,11 +317,11 @@ class Section {
   // SECTION. If placing SECTION within 'this' provides new
   // constraints on existing labels' values, then it's up to the
   // caller to fiddle with those labels as needed.
-  Section &Append(const Section &section);
+  Section& Append(const Section& section);
 
   // Append the contents of DATA as a series of bytes terminated by
   // a NULL character.
-  Section &AppendCString(const string &data) {
+  Section& AppendCString(const string& data) {
     Append(data);
     contents_ += '\0';
     return *this;
@@ -329,7 +329,7 @@ class Section {
 
   // Append at most SIZE bytes from DATA; if DATA is less than SIZE bytes
   // long, pad with '\0' characters.
-  Section &AppendCString(const string &data, size_t size) {
+  Section& AppendCString(const string& data, size_t size) {
     contents_.append(data, 0, size);
     if (data.size() < size)
       Append(size - data.size(), 0);
@@ -352,18 +352,18 @@ class Section {
   // the compiler will properly sign-extend a signed value before
   // passing it to the function, at which point the function's
   // behavior is the same either way.
-  Section &L8(uint8_t value) { contents_ += value; return *this; }
-  Section &B8(uint8_t value) { contents_ += value; return *this; }
-  Section &D8(uint8_t value) { contents_ += value; return *this; }
+  Section& L8(uint8_t value) { contents_ += value; return *this; }
+  Section& B8(uint8_t value) { contents_ += value; return *this; }
+  Section& D8(uint8_t value) { contents_ += value; return *this; }
   Section &L16(uint16_t), &L32(uint32_t), &L64(uint64_t),
           &B16(uint16_t), &B32(uint32_t), &B64(uint64_t),
           &D16(uint16_t), &D32(uint32_t), &D64(uint64_t);
-  Section &L8(const Label &label),  &L16(const Label &label),
-          &L32(const Label &label), &L64(const Label &label),
-          &B8(const Label &label),  &B16(const Label &label),
-          &B32(const Label &label), &B64(const Label &label),
-          &D8(const Label &label),  &D16(const Label &label),
-          &D32(const Label &label), &D64(const Label &label);
+  Section &L8(const Label& label),  &L16(const Label& label),
+          &L32(const Label& label), &L64(const Label& label),
+          &B8(const Label& label),  &B16(const Label& label),
+          &B32(const Label& label), &B64(const Label& label),
+          &D8(const Label& label),  &D16(const Label& label),
+          &D32(const Label& label), &D64(const Label& label);
 
   // Append VALUE in a signed LEB128 (Little-Endian Base 128) form.
   // 
@@ -383,7 +383,7 @@ class Section {
   //
   // Note that VALUE cannot be a Label (we would have to implement
   // relaxation).
-  Section &LEB128(long long value);
+  Section& LEB128(long long value);
 
   // Append VALUE in unsigned LEB128 (Little-Endian Base 128) form.
   // 
@@ -399,13 +399,13 @@ class Section {
   //
   // Note that VALUE cannot be a Label (we would have to implement
   // relaxation).
-  Section &ULEB128(uint64_t value);
+  Section& ULEB128(uint64_t value);
 
   // Jump to the next location aligned on an ALIGNMENT-byte boundary,
   // relative to the start of the section. Fill the gap with PAD_BYTE.
   // ALIGNMENT must be a power of two. Return a reference to this
   // section.
-  Section &Align(size_t alignment, uint8_t pad_byte = 0);
+  Section& Align(size_t alignment, uint8_t pad_byte = 0);
 
   // Clear the contents of this section.
   void Clear();
@@ -436,19 +436,19 @@ class Section {
   Label Here() const { return start_ + Size(); }
 
   // Set *LABEL to Here, and return a reference to this section.
-  Section &Mark(Label *label) { *label = Here(); return *this; }
+  Section& Mark(Label* label) { *label = Here(); return *this; }
 
   // If there are no undefined label references left in this
   // section, set CONTENTS to the contents of this section, as a
   // string, and clear this section. Return true on success, or false
   // if there were still undefined labels.
-  bool GetContents(string *contents);
+  bool GetContents(string* contents);
 
  private:
   // Used internally. A reference to a label's value.
   struct Reference {
     Reference(size_t set_offset, Endianness set_endianness,  size_t set_size,
-              const Label &set_label)
+              const Label& set_label)
         : offset(set_offset), endianness(set_endianness), size(set_size),
           label(set_label) { }
       
diff --git a/src/MEGASync/google_breakpad/common/test_assembler_unittest.cc b/src/MEGASync/google_breakpad/common/test_assembler_unittest.cc
index 94b5a5ce..bda25ebf 100644
--- a/src/MEGASync/google_breakpad/common/test_assembler_unittest.cc
+++ b/src/MEGASync/google_breakpad/common/test_assembler_unittest.cc
@@ -755,7 +755,7 @@ const uint8_t SectionFixture::data[] = {
     {                                                                   \
       static const uint8_t expected_bytes[] = b;                       \
       ASSERT_EQ(sizeof(expected_bytes), s.size());                      \
-      ASSERT_TRUE(memcmp(s.data(), (const char *) expected_bytes,       \
+      ASSERT_TRUE(memcmp(s.data(), (const char*) expected_bytes,       \
                          sizeof(expected_bytes)) == 0);                 \
     }                                                                   \
   while(0)
@@ -766,7 +766,7 @@ TEST_F(Append, Bytes) {
   section.Append(data, sizeof(data));
   ASSERT_TRUE(section.GetContents(&contents));
   ASSERT_EQ(sizeof(data), contents.size());
-  EXPECT_TRUE(0 == memcmp(contents.data(), (const char *) data, sizeof(data)));
+  EXPECT_TRUE(0 == memcmp(contents.data(), (const char*) data, sizeof(data)));
 }
 
 TEST_F(Append, BytesTwice) {
@@ -774,9 +774,9 @@ TEST_F(Append, BytesTwice) {
   section.Append(data, sizeof(data));
   ASSERT_TRUE(section.GetContents(&contents));
   ASSERT_EQ(2 * sizeof(data), contents.size());
-  ASSERT_TRUE(0 == memcmp(contents.data(), (const char *) data, sizeof(data)));
+  ASSERT_TRUE(0 == memcmp(contents.data(), (const char*) data, sizeof(data)));
   ASSERT_TRUE(0 == memcmp(contents.data() + sizeof(data),
-                          (const char *) data, sizeof(data)));
+                          (const char*) data, sizeof(data)));
 }
 
 TEST_F(Append, String) {
diff --git a/src/MEGASync/google_breakpad/common/tests/file_utils.cc b/src/MEGASync/google_breakpad/common/tests/file_utils.cc
index 1c041777..c1cbb39c 100644
--- a/src/MEGASync/google_breakpad/common/tests/file_utils.cc
+++ b/src/MEGASync/google_breakpad/common/tests/file_utils.cc
@@ -96,6 +96,10 @@ bool CopyFile(const char* from_path, const char* to_path) {
   return result;
 }
 
+bool CopyFile(const std::string& from_path, const std::string& to_path) {
+  return CopyFile(from_path.c_str(), to_path.c_str());
+}
+
 bool ReadFile(const char* path, void* buffer, ssize_t* buffer_size) {
   int fd = HANDLE_EINTR(open(path, O_RDONLY));
   if (fd == -1) {
diff --git a/src/MEGASync/google_breakpad/common/tests/file_utils.h b/src/MEGASync/google_breakpad/common/tests/file_utils.h
index c98a9bfa..3d1a9c6f 100644
--- a/src/MEGASync/google_breakpad/common/tests/file_utils.h
+++ b/src/MEGASync/google_breakpad/common/tests/file_utils.h
@@ -33,9 +33,12 @@
 #ifndef COMMON_TESTS_FILE_UTILS_H_
 #define COMMON_TESTS_FILE_UTILS_H_
 
+#include <string>
+
 namespace google_breakpad {
 
 // Copies a file from |from_path| to |to_path|. Returns true on success.
+bool CopyFile(const std::string& from_path, const std::string& to_path);
 bool CopyFile(const char* from_path, const char* to_path);
 
 // Reads the content of a file at |path| into |buffer|. |buffer_size| specifies
diff --git a/src/MEGASync/google_breakpad/common/unordered.h b/src/MEGASync/google_breakpad/common/unordered.h
new file mode 100644
index 00000000..c9cbd585
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/unordered.h
@@ -0,0 +1,62 @@
+// Copyright (c) 2010 Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// Include this file to use unordered_map and unordered_set.  If tr1
+// or C++11 is not available, you can switch to using hash_set and
+// hash_map by defining BP_USE_HASH_SET.
+
+#ifndef COMMON_UNORDERED_H_
+#define COMMON_UNORDERED_H_
+
+#if defined(BP_USE_HASH_SET)
+#include <hash_map>
+#include <hash_set>
+
+// For hash<string>.
+#include "util/hash/hash.h"
+
+template <class T, class U, class H = __gnu_cxx::hash<T> >
+struct unordered_map : public __gnu_cxx::hash_map<T, U, H> {};
+template <class T, class H = __gnu_cxx::hash<T> >
+struct unordered_set : public __gnu_cxx::hash_set<T, H> {};
+
+#elif defined(_LIBCPP_VERSION)  // c++11
+#include <unordered_map>
+#include <unordered_set>
+using std::unordered_map;
+using std::unordered_set;
+
+#else  // Fallback to tr1::unordered
+#include <tr1/unordered_map>
+#include <tr1/unordered_set>
+using std::tr1::unordered_map;
+using std::tr1::unordered_set;
+#endif
+
+#endif  // COMMON_UNORDERED_H_
diff --git a/src/MEGASync/google_breakpad/common/windows/common_windows.gyp b/src/MEGASync/google_breakpad/common/windows/common_windows.gyp
index 6b877759..5f7594b1 100644
--- a/src/MEGASync/google_breakpad/common/windows/common_windows.gyp
+++ b/src/MEGASync/google_breakpad/common/windows/common_windows.gyp
@@ -28,7 +28,7 @@
 
 {
   'includes': [
-    '../../client/windows/build/common.gypi',
+    '../../build/common.gypi',
   ],
   'targets': [
     {
@@ -37,16 +37,34 @@
       'all_dependent_settings': {
         'include_dirs': [
           '<(DEPTH)',
-          '$(VSInstallDir)\DIA SDK\include',
+          '$(VSInstallDir)/DIA SDK/include',
         ],
         'msvs_settings': {
           'VCLinkerTool': {
             'AdditionalDependencies': [
-              '$(VSInstallDir)\DIA SDK\lib\diaguids.lib',
+              'diaguids.lib',
               'imagehlp.lib',
             ],
           },
         },
+        'configurations': {
+          'x86_Base': {
+            'msvs_settings': {
+              'VCLinkerTool': {
+                'AdditionalLibraryDirectories':
+                  ['$(VSInstallDir)/DIA SDK/lib'],
+              },
+            },
+          },
+          'x64_Base': {
+            'msvs_settings': {
+              'VCLinkerTool': {
+                'AdditionalLibraryDirectories':
+                  ['$(VSInstallDir)/DIA SDK/lib/amd64'],
+              },
+            },
+          },
+        },
       },
     },
     {
@@ -59,13 +77,20 @@
         'guid_string.h',
         'http_upload.cc',
         'http_upload.h',
+        'module_info.h',
         'omap.cc',
         'omap.h',
         'omap_internal.h',
         'pdb_source_line_writer.cc',
         'pdb_source_line_writer.h',
+        'pe_source_line_writer.cc',
+        'pe_source_line_writer.h',
+        'pe_util.h',
+        'pe_util.cc',
         'string_utils.cc',
         'string_utils-inl.h',
+        'symbol_collector_client.cc',
+        'symbol_collector_client.h',
       ],
       'dependencies': [
         'dia_sdk',
diff --git a/src/MEGASync/google_breakpad/common/windows/dia_util.cc b/src/MEGASync/google_breakpad/common/windows/dia_util.cc
index 5322997d..f4cfa1d9 100644
--- a/src/MEGASync/google_breakpad/common/windows/dia_util.cc
+++ b/src/MEGASync/google_breakpad/common/windows/dia_util.cc
@@ -89,4 +89,4 @@ bool FindTable(REFIID iid, IDiaSession* session, void** table) {
   return false;
 }
 
-}  // namespace google_breakpad
+}  // namespace google_breakpad
\ No newline at end of file
diff --git a/src/MEGASync/google_breakpad/common/windows/dia_util.h b/src/MEGASync/google_breakpad/common/windows/dia_util.h
index 3c092609..b9e0df2d 100644
--- a/src/MEGASync/google_breakpad/common/windows/dia_util.h
+++ b/src/MEGASync/google_breakpad/common/windows/dia_util.h
@@ -28,6 +28,9 @@
 
 // Utilities for loading debug streams and tables from a PDB file.
 
+#ifndef COMMON_WINDOWS_DIA_UTIL_H_
+#define COMMON_WINDOWS_DIA_UTIL_H_
+
 #include <Windows.h>
 #include <dia2.h>
 
@@ -57,3 +60,5 @@ bool FindTable(IDiaSession* session, InterfaceType** table) {
 }
 
 }  // namespace google_breakpad
+
+#endif  // COMMON_WINDOWS_DIA_UTIL_H_
diff --git a/src/MEGASync/google_breakpad/common/windows/guid_string.h b/src/MEGASync/google_breakpad/common/windows/guid_string.h
index f8aa8a23..48a5c1d3 100644
--- a/src/MEGASync/google_breakpad/common/windows/guid_string.h
+++ b/src/MEGASync/google_breakpad/common/windows/guid_string.h
@@ -29,10 +29,10 @@
 
 // guid_string.cc: Convert GUIDs to strings.
 
-#ifndef COMMON_WINDOWS_GUID_STRING_H__
-#define COMMON_WINDOWS_GUID_STRING_H__
+#ifndef COMMON_WINDOWS_GUID_STRING_H_
+#define COMMON_WINDOWS_GUID_STRING_H_
 
-#include <Guiddef.h>
+#include <guiddef.h>
 
 #include <string>
 
@@ -55,4 +55,4 @@ class GUIDString {
 
 }  // namespace google_breakpad
 
-#endif  // COMMON_WINDOWS_GUID_STRING_H__
+#endif  // COMMON_WINDOWS_GUID_STRING_H_
diff --git a/src/MEGASync/google_breakpad/common/windows/http_upload.cc b/src/MEGASync/google_breakpad/common/windows/http_upload.cc
index 838185b7..efee0d58 100644
--- a/src/MEGASync/google_breakpad/common/windows/http_upload.cc
+++ b/src/MEGASync/google_breakpad/common/windows/http_upload.cc
@@ -33,386 +33,478 @@
 #pragma warning(disable:4530)
 
 #include <fstream>
+#include <vector>
 
 #include "common/windows/string_utils-inl.h"
 
 #include "common/windows/http_upload.h"
 
-namespace google_breakpad {
+namespace {
+  using std::string;
+  using std::wstring;
+  using std::map;
+  using std::vector;
+  using std::ifstream;
+  using std::ios;
+
+  const wchar_t kUserAgent[] = L"Breakpad/1.0 (Windows)";
+
+  // Helper class which closes an internet handle when it goes away
+  class AutoInternetHandle {
+  public:
+    explicit AutoInternetHandle(HINTERNET handle) : handle_(handle) {}
+    ~AutoInternetHandle() {
+      if (handle_) {
+        InternetCloseHandle(handle_);
+      }
+    }
 
-using std::ifstream;
-using std::ios;
+    HINTERNET get() { return handle_; }
 
-static const wchar_t kUserAgent[] = L"Breakpad/1.0 (Windows)";
+  private:
+    HINTERNET handle_;
+  };
 
-// Helper class which closes an internet handle when it goes away
-class HTTPUpload::AutoInternetHandle {
- public:
-  explicit AutoInternetHandle(HINTERNET handle) : handle_(handle) {}
-  ~AutoInternetHandle() {
-    if (handle_) {
-      InternetCloseHandle(handle_);
+  wstring UTF8ToWide(const string& utf8) {
+    if (utf8.length() == 0) {
+      return wstring();
     }
-  }
 
-  HINTERNET get() { return handle_; }
-
- private:
-  HINTERNET handle_;
-};
-
-// static
-bool HTTPUpload::SendRequest(const wstring &url,
-                             const map<wstring, wstring> &parameters,
-                             const wstring &upload_file,
-                             const wstring &file_part_name,
-                             int *timeout,
-                             wstring *response_body,
-                             int *response_code) {
-  if (response_code) {
-    *response_code = 0;
-  }
+    // compute the length of the buffer we'll need
+    int charcount = MultiByteToWideChar(CP_UTF8, 0, utf8.c_str(), -1, NULL, 0);
 
-  // TODO(bryner): support non-ASCII parameter names
-  if (!CheckParameters(parameters)) {
-    return false;
-  }
+    if (charcount == 0) {
+      return wstring();
+    }
 
-  // Break up the URL and make sure we can handle it
-  wchar_t scheme[16], host[256], path[256];
-  URL_COMPONENTS components;
-  memset(&components, 0, sizeof(components));
-  components.dwStructSize = sizeof(components);
-  components.lpszScheme = scheme;
-  components.dwSchemeLength = sizeof(scheme) / sizeof(scheme[0]);
-  components.lpszHostName = host;
-  components.dwHostNameLength = sizeof(host) / sizeof(host[0]);
-  components.lpszUrlPath = path;
-  components.dwUrlPathLength = sizeof(path) / sizeof(path[0]);
-  if (!InternetCrackUrl(url.c_str(), static_cast<DWORD>(url.size()),
-                        0, &components)) {
-    return false;
-  }
-  bool secure = false;
-  if (wcscmp(scheme, L"https") == 0) {
-    secure = true;
-  } else if (wcscmp(scheme, L"http") != 0) {
-    return false;
+    // convert
+    wchar_t* buf = new wchar_t[charcount];
+    MultiByteToWideChar(CP_UTF8, 0, utf8.c_str(), -1, buf, charcount);
+    wstring result(buf);
+    delete[] buf;
+    return result;
   }
 
-  AutoInternetHandle internet(InternetOpen(kUserAgent,
-                                           INTERNET_OPEN_TYPE_PRECONFIG,
-                                           NULL,  // proxy name
-                                           NULL,  // proxy bypass
-                                           0));   // flags
-  if (!internet.get()) {
-    return false;
-  }
+  string WideToMBCP(const wstring& wide, unsigned int cp) {
+    if (wide.length() == 0) {
+      return string();
+    }
 
-  AutoInternetHandle connection(InternetConnect(internet.get(),
-                                                host,
-                                                components.nPort,
-                                                NULL,    // user name
-                                                NULL,    // password
-                                                INTERNET_SERVICE_HTTP,
-                                                0,       // flags
-                                                NULL));  // context
-  if (!connection.get()) {
-    return false;
-  }
+    // compute the length of the buffer we'll need
+    int charcount = WideCharToMultiByte(cp, 0, wide.c_str(), -1,
+        NULL, 0, NULL, NULL);
+    if (charcount == 0) {
+      return string();
+    }
 
-  DWORD http_open_flags = secure ? INTERNET_FLAG_SECURE : 0;
-  http_open_flags |= INTERNET_FLAG_NO_COOKIES;
-  AutoInternetHandle request(HttpOpenRequest(connection.get(),
-                                             L"POST",
-                                             path,
-                                             NULL,    // version
-                                             NULL,    // referer
-                                             NULL,    // agent type
-                                             http_open_flags,
-                                             NULL));  // context
-  if (!request.get()) {
-    return false;
-  }
+    // convert
+    char *buf = new char[charcount];
+    WideCharToMultiByte(cp, 0, wide.c_str(), -1, buf, charcount,
+        NULL, NULL);
 
-  wstring boundary = GenerateMultipartBoundary();
-  wstring content_type_header = GenerateRequestHeader(boundary);
-  HttpAddRequestHeaders(request.get(),
-                        content_type_header.c_str(),
-                        static_cast<DWORD>(-1),
-                        HTTP_ADDREQ_FLAG_ADD);
-
-  string request_body;
-  if (!GenerateRequestBody(parameters, upload_file,
-                           file_part_name, boundary, &request_body)) {
-    return false;
+    string result(buf);
+    delete[] buf;
+    return result;
   }
 
-  if (timeout) {
-    if (!InternetSetOption(request.get(),
-                           INTERNET_OPTION_SEND_TIMEOUT,
-                           timeout,
-                           sizeof(*timeout))) {
-      fwprintf(stderr, L"Could not unset send timeout, continuing...\n");
+  bool GetFileContents(const wstring& filename, vector<char>* contents) {
+    bool rv = false;
+    // The "open" method on pre-MSVC8 ifstream implementations doesn't accept a
+    // wchar_t* filename, so use _wfopen directly in that case.  For VC8 and
+    // later, _wfopen has been deprecated in favor of _wfopen_s, which does
+    // not exist in earlier versions, so let the ifstream open the file itself.
+    // GCC doesn't support wide file name and opening on FILE* requires ugly
+    // hacks, so fallback to multi byte file.
+#ifdef _MSC_VER
+    ifstream file;
+    file.open(filename.c_str(), ios::binary);
+#else // GCC
+    ifstream file(WideToMBCP(filename, CP_ACP).c_str(), ios::binary);
+#endif  // _MSC_VER >= 1400
+    if (file.is_open()) {
+      file.seekg(0, ios::end);
+      std::streamoff length = file.tellg();
+      // Check for loss of data when converting lenght from std::streamoff into
+      // std::vector<char>::size_type
+      std::vector<char>::size_type vector_size =
+        static_cast<std::vector<char>::size_type>(length);
+      if (static_cast<std::streamoff>(vector_size) == length) {
+        contents->resize(vector_size);
+        if (length != 0) {
+          file.seekg(0, ios::beg);
+          file.read(&((*contents)[0]), length);
+        }
+        rv = true;
+      }
+      file.close();
     }
+    return rv;
+  }
 
-    if (!InternetSetOption(request.get(),
-                           INTERNET_OPTION_RECEIVE_TIMEOUT,
-                           timeout,
-                           sizeof(*timeout))) {
-      fwprintf(stderr, L"Could not unset receive timeout, continuing...\n");
+  bool CheckParameters(const map<wstring, wstring>& parameters) {
+    for (map<wstring, wstring>::const_iterator pos = parameters.begin();
+          pos != parameters.end(); ++pos) {
+      const wstring& str = pos->first;
+      if (str.size() == 0) {
+        return false;  // disallow empty parameter names
+      }
+      for (unsigned int i = 0; i < str.size(); ++i) {
+        wchar_t c = str[i];
+        if (c < 32 || c == '"' || c > 127) {
+          return false;
+        }
+      }
     }
+    return true;
   }
 
-  if (!HttpSendRequest(request.get(), NULL, 0,
-                       const_cast<char *>(request_body.data()),
-                       static_cast<DWORD>(request_body.size()))) {
-    return false;
+  // Converts a UTF16 string to UTF8.
+  string WideToUTF8(const wstring& wide) {
+    return WideToMBCP(wide, CP_UTF8);
   }
 
-  // The server indicates a successful upload with HTTP status 200.
-  wchar_t http_status[4];
-  DWORD http_status_size = sizeof(http_status);
-  if (!HttpQueryInfo(request.get(), HTTP_QUERY_STATUS_CODE,
-                     static_cast<LPVOID>(&http_status), &http_status_size,
-                     0)) {
-    return false;
-  }
+  bool ReadResponse(HINTERNET request, wstring *response) {
+    bool has_content_length_header = false;
+    wchar_t content_length[32];
+    DWORD content_length_size = sizeof(content_length);
+    DWORD claimed_size = 0;
+    string response_body;
+
+    if (HttpQueryInfo(request, HTTP_QUERY_CONTENT_LENGTH,
+        static_cast<LPVOID>(&content_length),
+        &content_length_size, 0)) {
+      has_content_length_header = true;
+      claimed_size = wcstol(content_length, NULL, 10);
+      response_body.reserve(claimed_size);
+    }
 
-  int http_response = wcstol(http_status, NULL, 10);
-  if (response_code) {
-    *response_code = http_response;
-  }
+    DWORD bytes_available;
+    DWORD total_read = 0;
+    BOOL return_code;
 
-  bool result = (http_response == 200);
+    while (((return_code = InternetQueryDataAvailable(request, &bytes_available,
+        0, 0)) != 0) && bytes_available > 0) {
+      vector<char> response_buffer(bytes_available);
+      DWORD size_read;
 
-  if (result) {
-    result = ReadResponse(request.get(), response_body);
-  }
+      return_code = InternetReadFile(request,
+          &response_buffer[0],
+          bytes_available, &size_read);
 
-  return result;
-}
+      if (return_code && size_read > 0) {
+        total_read += size_read;
+        response_body.append(&response_buffer[0], size_read);
+      }
+      else {
+        break;
+      }
+    }
+
+    bool succeeded = return_code && (!has_content_length_header ||
+        (total_read == claimed_size));
+    if (succeeded && response) {
+      *response = UTF8ToWide(response_body);
+    }
 
-// static
-bool HTTPUpload::ReadResponse(HINTERNET request, wstring *response) {
-  bool has_content_length_header = false;
-  wchar_t content_length[32];
-  DWORD content_length_size = sizeof(content_length);
-  DWORD claimed_size = 0;
-  string response_body;
-
-  if (HttpQueryInfo(request, HTTP_QUERY_CONTENT_LENGTH,
-                    static_cast<LPVOID>(&content_length),
-                    &content_length_size, 0)) {
-    has_content_length_header = true;
-    claimed_size = wcstol(content_length, NULL, 10);
-    response_body.reserve(claimed_size);
+    return succeeded;
   }
 
+  bool SendRequestInner(
+      const wstring& url,
+      const wstring& http_method,
+      const wstring& content_type_header,
+      const string& request_body,
+      int* timeout_ms,
+      wstring* response_body,
+      int* response_code) {
+    if (response_code) {
+      *response_code = 0;
+    }
 
-  DWORD bytes_available;
-  DWORD total_read = 0;
-  BOOL return_code;
+    // Break up the URL and make sure we can handle it
+    wchar_t scheme[16], host[256], path[1024];
+    URL_COMPONENTS components;
+    memset(&components, 0, sizeof(components));
+    components.dwStructSize = sizeof(components);
+    components.lpszScheme = scheme;
+    components.dwSchemeLength = sizeof(scheme) / sizeof(scheme[0]);
+    components.lpszHostName = host;
+    components.dwHostNameLength = sizeof(host) / sizeof(host[0]);
+    components.lpszUrlPath = path;
+    components.dwUrlPathLength = sizeof(path) / sizeof(path[0]);
+    if (!InternetCrackUrl(url.c_str(), static_cast<DWORD>(url.size()),
+        0, &components)) {
+      DWORD err = GetLastError();
+      wprintf(L"%d\n", err);
+      return false;
+    }
+    bool secure = false;
+    if (wcscmp(scheme, L"https") == 0) {
+      secure = true;
+    }
+    else if (wcscmp(scheme, L"http") != 0) {
+      return false;
+    }
 
-  while (((return_code = InternetQueryDataAvailable(request, &bytes_available,
-      0, 0)) != 0) && bytes_available > 0) {
-    vector<char> response_buffer(bytes_available);
-    DWORD size_read;
+    AutoInternetHandle internet(InternetOpen(kUserAgent,
+        INTERNET_OPEN_TYPE_PRECONFIG,
+        NULL,  // proxy name
+        NULL,  // proxy bypass
+        0));   // flags
+    if (!internet.get()) {
+      return false;
+    }
 
-    return_code = InternetReadFile(request,
-                                   &response_buffer[0],
-                                   bytes_available, &size_read);
+    AutoInternetHandle connection(InternetConnect(internet.get(),
+        host,
+        components.nPort,
+        NULL,    // user name
+        NULL,    // password
+        INTERNET_SERVICE_HTTP,
+        0,       // flags
+        NULL));  // context
+    if (!connection.get()) {
+      return false;
+    }
 
-    if (return_code && size_read > 0) {
-      total_read += size_read;
-      response_body.append(&response_buffer[0], size_read);
-    } else {
-      break;
+    DWORD http_open_flags = secure ? INTERNET_FLAG_SECURE : 0;
+    http_open_flags |= INTERNET_FLAG_NO_COOKIES;
+    AutoInternetHandle request(HttpOpenRequest(connection.get(),
+        http_method.c_str(),
+        path,
+        NULL,    // version
+        NULL,    // referer
+        NULL,    // agent type
+        http_open_flags,
+        NULL));  // context
+    if (!request.get()) {
+      return false;
     }
-  }
 
-  bool succeeded = return_code && (!has_content_length_header ||
-                                   (total_read == claimed_size));
-  if (succeeded && response) {
-    *response = UTF8ToWide(response_body);
-  }
+    if (!content_type_header.empty()) {
+      HttpAddRequestHeaders(request.get(),
+          content_type_header.c_str(),
+          static_cast<DWORD>(-1),
+          HTTP_ADDREQ_FLAG_ADD);
+    }
 
-  return succeeded;
-}
+    if (timeout_ms) {
+      if (!InternetSetOption(request.get(),
+          INTERNET_OPTION_SEND_TIMEOUT,
+          timeout_ms,
+          sizeof(*timeout_ms))) {
+        fwprintf(stderr, L"Could not unset send timeout, continuing...\n");
+      }
 
-// static
-wstring HTTPUpload::GenerateMultipartBoundary() {
-  // The boundary has 27 '-' characters followed by 16 hex digits
-  static const wchar_t kBoundaryPrefix[] = L"---------------------------";
-  static const int kBoundaryLength = 27 + 16 + 1;
+      if (!InternetSetOption(request.get(),
+          INTERNET_OPTION_RECEIVE_TIMEOUT,
+          timeout_ms,
+          sizeof(*timeout_ms))) {
+        fwprintf(stderr, L"Could not unset receive timeout, continuing...\n");
+      }
+    }
 
-  // Generate some random numbers to fill out the boundary
-  int r0 = rand();
-  int r1 = rand();
+    if (!HttpSendRequest(request.get(), NULL, 0,
+        const_cast<char*>(request_body.data()),
+        static_cast<DWORD>(request_body.size()))) {
+      return false;
+    }
 
-  wchar_t temp[kBoundaryLength];
-  swprintf(temp, kBoundaryLength, L"%s%08X%08X", kBoundaryPrefix, r0, r1);
+    // The server indicates a successful upload with HTTP status 200.
+    wchar_t http_status[4];
+    DWORD http_status_size = sizeof(http_status);
+    if (!HttpQueryInfo(request.get(), HTTP_QUERY_STATUS_CODE,
+        static_cast<LPVOID>(&http_status), &http_status_size,
+        0)) {
+      return false;
+    }
 
-  // remove when VC++7.1 is no longer supported
-  temp[kBoundaryLength - 1] = L'\0';
+    int http_response = wcstol(http_status, NULL, 10);
+    if (response_code) {
+      *response_code = http_response;
+    }
 
-  return wstring(temp);
-}
+    bool result = (http_response == 200);
 
-// static
-wstring HTTPUpload::GenerateRequestHeader(const wstring &boundary) {
-  wstring header = L"Content-Type: multipart/form-data; boundary=";
-  header += boundary;
-  return header;
-}
+    if (result) {
+      result = ReadResponse(request.get(), response_body);
+    }
 
-// static
-bool HTTPUpload::GenerateRequestBody(const map<wstring, wstring> &parameters,
-                                     const wstring &upload_file,
-                                     const wstring &file_part_name,
-                                     const wstring &boundary,
-                                     string *request_body) {
-  vector<char> contents;
-  if (!GetFileContents(upload_file, &contents)) {
-    return false;
+    return result;
   }
 
-  string boundary_str = WideToUTF8(boundary);
-  if (boundary_str.empty()) {
-    return false;
-  }
+  wstring GenerateMultipartBoundary() {
+    // The boundary has 27 '-' characters followed by 16 hex digits
+    static const wchar_t kBoundaryPrefix[] = L"---------------------------";
+    static const int kBoundaryLength = 27 + 16 + 1;
 
-  request_body->clear();
+    // Generate some random numbers to fill out the boundary
+    int r0 = rand();
+    int r1 = rand();
 
-  // Append each of the parameter pairs as a form-data part
-  for (map<wstring, wstring>::const_iterator pos = parameters.begin();
-       pos != parameters.end(); ++pos) {
-    request_body->append("--" + boundary_str + "\r\n");
-    request_body->append("Content-Disposition: form-data; name=\"" +
-                         WideToUTF8(pos->first) + "\"\r\n\r\n" +
-                         WideToUTF8(pos->second) + "\r\n");
-  }
+    wchar_t temp[kBoundaryLength];
+    swprintf(temp, kBoundaryLength, L"%s%08X%08X", kBoundaryPrefix, r0, r1);
 
-  // Now append the upload file as a binary (octet-stream) part
-  string filename_utf8 = WideToUTF8(upload_file);
-  if (filename_utf8.empty()) {
-    return false;
+    // remove when VC++7.1 is no longer supported
+    temp[kBoundaryLength - 1] = L'\0';
+
+    return wstring(temp);
   }
 
-  string file_part_name_utf8 = WideToUTF8(file_part_name);
-  if (file_part_name_utf8.empty()) {
-    return false;
+  wstring GenerateMultipartPostRequestHeader(const wstring& boundary) {
+    wstring header = L"Content-Type: multipart/form-data; boundary=";
+    header += boundary;
+    return header;
   }
 
-  request_body->append("--" + boundary_str + "\r\n");
-  request_body->append("Content-Disposition: form-data; "
-                       "name=\"" + file_part_name_utf8 + "\"; "
-                       "filename=\"" + filename_utf8 + "\"\r\n");
-  request_body->append("Content-Type: application/octet-stream\r\n");
-  request_body->append("\r\n");
+  bool AppendFileToRequestBody(
+      const wstring& file_part_name,
+      const wstring& filename,
+      string* request_body) {
+    string file_part_name_utf8 = WideToUTF8(file_part_name);
+    if (file_part_name_utf8.empty()) {
+      return false;
+    }
 
-  if (!contents.empty()) {
+    string filename_utf8 = WideToUTF8(filename);
+    if (filename_utf8.empty()) {
+      return false;
+    }
+
+    request_body->append("Content-Disposition: form-data; "
+        "name=\"" + file_part_name_utf8 + "\"; "
+        "filename=\"" + filename_utf8 + "\"\r\n");
+    request_body->append("Content-Type: application/octet-stream\r\n");
+    request_body->append("\r\n");
+
+    vector<char> contents;
+    if (!GetFileContents(filename, &contents)) {
+      return false;
+    }
+
+    if (!contents.empty()) {
       request_body->append(&(contents[0]), contents.size());
+    }
+    request_body->append("\r\n");
+
+    return true;
   }
-  request_body->append("\r\n");
-  request_body->append("--" + boundary_str + "--\r\n");
-  return true;
-}
 
-// static
-bool HTTPUpload::GetFileContents(const wstring &filename,
-                                 vector<char> *contents) {
-  bool rv = false;
-  // The "open" method on pre-MSVC8 ifstream implementations doesn't accept a
-  // wchar_t* filename, so use _wfopen directly in that case.  For VC8 and
-  // later, _wfopen has been deprecated in favor of _wfopen_s, which does
-  // not exist in earlier versions, so let the ifstream open the file itself.
-#if _MSC_VER >= 1400  // MSVC 2005/8
-  ifstream file;
-  file.open(filename.c_str(), ios::binary);
-#else  // _MSC_VER >= 1400
-  ifstream file(_wfopen(filename.c_str(), L"rb"));
-#endif  // _MSC_VER >= 1400
-  if (file.is_open()) {
-    file.seekg(0, ios::end);
-    std::streamoff length = file.tellg();
-    // Check for loss of data when converting lenght from std::streamoff into
-    // std::vector<char>::size_type
-    std::vector<char>::size_type vector_size =
-        static_cast<std::vector<char>::size_type>(length);
-    if (static_cast<std::streamoff>(vector_size) == length) {
-      contents->resize(vector_size);
-      if (length != 0) {
-        file.seekg(0, ios::beg);
-        file.read(&((*contents)[0]), length);
-      }
-      rv = true;
+  bool GenerateRequestBody(const map<wstring, wstring>& parameters,
+      const map<wstring, wstring>& files,
+      const wstring& boundary,
+      string *request_body) {
+    string boundary_str = WideToUTF8(boundary);
+    if (boundary_str.empty()) {
+      return false;
     }
-    file.close();
-  }
-  return rv;
-}
 
-// static
-wstring HTTPUpload::UTF8ToWide(const string &utf8) {
-  if (utf8.length() == 0) {
-    return wstring();
-  }
+    request_body->clear();
+
+    // Append each of the parameter pairs as a form-data part
+    for (map<wstring, wstring>::const_iterator pos = parameters.begin();
+        pos != parameters.end(); ++pos) {
+      request_body->append("--" + boundary_str + "\r\n");
+      request_body->append("Content-Disposition: form-data; name=\"" +
+          WideToUTF8(pos->first) + "\"\r\n\r\n" +
+          WideToUTF8(pos->second) + "\r\n");
+    }
 
-  // compute the length of the buffer we'll need
-  int charcount = MultiByteToWideChar(CP_UTF8, 0, utf8.c_str(), -1, NULL, 0);
+    // Now append each upload file as a binary (octet-stream) part
+    for (map<wstring, wstring>::const_iterator pos = files.begin();
+        pos != files.end(); ++pos) {
+      request_body->append("--" + boundary_str + "\r\n");
 
-  if (charcount == 0) {
-    return wstring();
+      if (!AppendFileToRequestBody(pos->first, pos->second, request_body)) {
+        return false;
+      }
+    }
+    request_body->append("--" + boundary_str + "--\r\n");
+    return true;
   }
-
-  // convert
-  wchar_t* buf = new wchar_t[charcount];
-  MultiByteToWideChar(CP_UTF8, 0, utf8.c_str(), -1, buf, charcount);
-  wstring result(buf);
-  delete[] buf;
-  return result;
 }
 
-// static
-string HTTPUpload::WideToUTF8(const wstring &wide) {
-  if (wide.length() == 0) {
-    return string();
+namespace google_breakpad {
+  bool HTTPUpload::SendPutRequest(
+      const wstring& url,
+      const wstring& path,
+      int* timeout_ms,
+      wstring* response_body,
+      int* response_code) {
+    string request_body;
+    if (!AppendFileToRequestBody(L"symbol_file", path, &request_body)) {
+      return false;
+    }
+
+    return SendRequestInner(
+        url,
+        L"PUT",
+        L"",
+        request_body,
+        timeout_ms,
+        response_body,
+        response_code);
   }
 
-  // compute the length of the buffer we'll need
-  int charcount = WideCharToMultiByte(CP_UTF8, 0, wide.c_str(), -1,
-                                      NULL, 0, NULL, NULL);
-  if (charcount == 0) {
-    return string();
+  bool HTTPUpload::SendGetRequest(
+      const wstring& url,
+      int* timeout_ms,
+      wstring* response_body,
+      int* response_code) {
+    return SendRequestInner(
+        url,
+        L"GET",
+        L"",
+        "",
+        timeout_ms,
+        response_body,
+        response_code);
   }
 
-  // convert
-  char *buf = new char[charcount];
-  WideCharToMultiByte(CP_UTF8, 0, wide.c_str(), -1, buf, charcount,
-                      NULL, NULL);
+  bool HTTPUpload::SendMultipartPostRequest(
+      const wstring& url,
+      const map<wstring, wstring>& parameters,
+      const map<wstring, wstring>& files,
+      int* timeout_ms,
+      wstring* response_body,
+      int* response_code) {
+    // TODO(bryner): support non-ASCII parameter names
+    if (!CheckParameters(parameters)) {
+      return false;
+    }
 
-  string result(buf);
-  delete[] buf;
-  return result;
-}
+    wstring boundary = GenerateMultipartBoundary();
+    wstring content_type_header = GenerateMultipartPostRequestHeader(boundary);
 
-// static
-bool HTTPUpload::CheckParameters(const map<wstring, wstring> &parameters) {
-  for (map<wstring, wstring>::const_iterator pos = parameters.begin();
-       pos != parameters.end(); ++pos) {
-    const wstring &str = pos->first;
-    if (str.size() == 0) {
-      return false;  // disallow empty parameter names
-    }
-    for (unsigned int i = 0; i < str.size(); ++i) {
-      wchar_t c = str[i];
-      if (c < 32 || c == '"' || c > 127) {
-        return false;
-      }
+    string request_body;
+    if (!GenerateRequestBody(parameters, files, boundary, &request_body)) {
+      return false;
     }
+
+    return SendRequestInner(
+        url,
+        L"POST",
+        content_type_header,
+        request_body,
+        timeout_ms,
+        response_body,
+        response_code);
   }
-  return true;
-}
 
+  bool HTTPUpload::SendSimplePostRequest(
+      const wstring& url,
+      const wstring& body,
+      const wstring& content_type,
+      int *timeout_ms,
+      wstring *response_body,
+      int *response_code) {
+    return SendRequestInner(
+        url,
+        L"POST",
+        content_type,
+        WideToUTF8(body),
+        timeout_ms,
+        response_body,
+        response_code);
+  }
 }  // namespace google_breakpad
diff --git a/src/MEGASync/google_breakpad/common/windows/http_upload.h b/src/MEGASync/google_breakpad/common/windows/http_upload.h
index 8a17aab1..c7d8c6fe 100644
--- a/src/MEGASync/google_breakpad/common/windows/http_upload.h
+++ b/src/MEGASync/google_breakpad/common/windows/http_upload.h
@@ -31,32 +31,55 @@
 // request using wininet.  It currently supports requests that contain
 // a set of string parameters (key/value pairs), and a file to upload.
 
-#ifndef COMMON_WINDOWS_HTTP_UPLOAD_H__
-#define COMMON_WINDOWS_HTTP_UPLOAD_H__
+#ifndef COMMON_WINDOWS_HTTP_UPLOAD_H_
+#define COMMON_WINDOWS_HTTP_UPLOAD_H_
 
-#pragma warning( push )
+#pragma warning(push)
 // Disable exception handler warnings.
-#pragma warning( disable : 4530 ) 
+#pragma warning(disable : 4530)
 
-#include <Windows.h>
-#include <WinInet.h>
+#include <windows.h>
+#include <wininet.h>
 
 #include <map>
-#include <string>
-#include <vector>
 
 namespace google_breakpad {
 
 using std::string;
 using std::wstring;
 using std::map;
-using std::vector;
 
 class HTTPUpload {
  public:
-  // Sends the given set of parameters, along with the contents of
-  // upload_file, as a multipart POST request to the given URL.
-  // file_part_name contains the name of the file part of the request
+  // Sends a PUT request containing the data in |path| to the given
+  // URL.
+  // Only HTTP(S) URLs are currently supported.  Returns true on success.
+  // If the request is successful and response_body is non-NULL,
+  // the response body will be returned in response_body.
+  // If response_code is non-NULL, it will be set to the HTTP response code
+  // received (or 0 if the request failed before getting an HTTP response).
+  static bool SendPutRequest(
+      const wstring& url,
+      const wstring& path,
+      int* timeout_ms,
+      wstring* response_body,
+      int* response_code);
+
+  // Sends a GET request to the given URL.
+  // Only HTTP(S) URLs are currently supported.  Returns true on success.
+  // If the request is successful and response_body is non-NULL,
+  // the response body will be returned in response_body.
+  // If response_code is non-NULL, it will be set to the HTTP response code
+  // received (or 0 if the request failed before getting an HTTP response).
+  static bool SendGetRequest(
+      const wstring& url,
+      int* timeout_ms,
+      wstring* response_body,
+      int* response_code);
+
+  // Sends the given sets of parameters and files as a multipart POST
+  // request to the given URL.
+  // Each key in |files| is the name of the file part of the request
   // (i.e. it corresponds to the name= attribute on an <input type="file">.
   // Parameter names must contain only printable ASCII characters,
   // and may not contain a quote (") character.
@@ -65,62 +88,39 @@ class HTTPUpload {
   // the response body will be returned in response_body.
   // If response_code is non-NULL, it will be set to the HTTP response code
   // received (or 0 if the request failed before getting an HTTP response).
-  static bool SendRequest(const wstring &url,
-                          const map<wstring, wstring> &parameters,
-                          const wstring &upload_file,
-                          const wstring &file_part_name,
-                          int *timeout,
-                          wstring *response_body,
-                          int *response_code);
+  static bool SendMultipartPostRequest(
+      const wstring& url,
+      const map<wstring, wstring>& parameters,
+      const map<wstring, wstring>& files,
+      int *timeout_ms,
+      wstring *response_body,
+      int *response_code);
+
+  // Sends a POST request, with the body set to |body|, to the given URL.
+  // Only HTTP(S) URLs are currently supported.  Returns true on success.
+  // If the request is successful and response_body is non-NULL,
+  // the response body will be returned in response_body.
+  // If response_code is non-NULL, it will be set to the HTTP response code
+  // received (or 0 if the request failed before getting an HTTP response).
+  static bool SendSimplePostRequest(
+      const wstring& url,
+      const wstring& body,
+      const wstring& content_type,
+      int *timeout_ms,
+      wstring *response_body,
+      int *response_code);
 
  private:
-  class AutoInternetHandle;
-
-  // Retrieves the HTTP response.  If NULL is passed in for response,
-  // this merely checks (via the return value) that we were successfully
-  // able to retrieve exactly as many bytes of content in the response as
-  // were specified in the Content-Length header.
-  static bool HTTPUpload::ReadResponse(HINTERNET request, wstring* response);
-
-  // Generates a new multipart boundary for a POST request
-  static wstring GenerateMultipartBoundary();
-
-  // Generates a HTTP request header for a multipart form submit.
-  static wstring GenerateRequestHeader(const wstring &boundary);
-
-  // Given a set of parameters, an upload filename, and a file part name,
-  // generates a multipart request body string with these parameters
-  // and minidump contents.  Returns true on success.
-  static bool GenerateRequestBody(const map<wstring, wstring> &parameters,
-                                  const wstring &upload_file,
-                                  const wstring &file_part_name,
-                                  const wstring &boundary,
-                                  string *request_body);
-
-  // Fills the supplied vector with the contents of filename.
-  static bool GetFileContents(const wstring &filename, vector<char> *contents);
-
-  // Converts a UTF8 string to UTF16.
-  static wstring UTF8ToWide(const string &utf8);
-
-  // Converts a UTF16 string to UTF8.
-  static string WideToUTF8(const wstring &wide);
-
-  // Checks that the given list of parameters has only printable
-  // ASCII characters in the parameter name, and does not contain
-  // any quote (") characters.  Returns true if so.
-  static bool CheckParameters(const map<wstring, wstring> &parameters);
-
   // No instances of this class should be created.
   // Disallow all constructors, destructors, and operator=.
   HTTPUpload();
-  explicit HTTPUpload(const HTTPUpload &);
-  void operator=(const HTTPUpload &);
+  explicit HTTPUpload(const HTTPUpload&);
+  void operator=(const HTTPUpload&);
   ~HTTPUpload();
 };
 
 }  // namespace google_breakpad
 
-#pragma warning( pop )
+#pragma warning(pop)
 
-#endif  // COMMON_WINDOWS_HTTP_UPLOAD_H__
+#endif  // COMMON_WINDOWS_HTTP_UPLOAD_H_
diff --git a/src/MEGASync/google_breakpad/common/windows/module_info.h b/src/MEGASync/google_breakpad/common/windows/module_info.h
new file mode 100644
index 00000000..c543822f
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/windows/module_info.h
@@ -0,0 +1,75 @@
+// Copyright (c) 2019, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef COMMON_WINDOWS_MODULE_INFO_H_
+#define COMMON_WINDOWS_MODULE_INFO_H_
+
+#include <string>
+
+namespace google_breakpad {
+
+using std::wstring;
+// A structure that carries information that identifies a module.
+struct PDBModuleInfo {
+public:
+  // The basename of the pe/pdb file from which information was loaded.
+  wstring debug_file;
+
+  // The module's identifier.  For recent pe/pdb files, the identifier consists
+  // of the pe/pdb's guid, in uppercase hexadecimal form without any dashes
+  // or separators, followed immediately by the pe/pdb's age, also in
+  // uppercase hexadecimal form.  For older pe/pdb files which have no guid,
+  // the identifier is the pe/pdb's 32-bit signature value, in zero-padded
+  // hexadecimal form, followed immediately by the pe/pdb's age, in lowercase
+  // hexadecimal form.
+  wstring debug_identifier;
+
+  // A string identifying the cpu that the pe/pdb is associated with.
+  // Currently, this may be "x86" or "unknown".
+  wstring cpu;
+};
+
+// A structure that carries information that identifies a PE file,
+// either an EXE or a DLL.
+struct PEModuleInfo {
+  // The basename of the PE file.
+  wstring code_file;
+
+  // The PE file's code identifier, which consists of its timestamp
+  // and file size concatenated together into a single hex string.
+  // (The fields IMAGE_OPTIONAL_HEADER::SizeOfImage and
+  // IMAGE_FILE_HEADER::TimeDateStamp, as defined in the ImageHlp
+  // documentation.) This is not well documented, if it's documented
+  // at all, but it's what symstore does and what DbgHelp supports.
+  wstring code_identifier;
+};
+
+}  // namespace google_breakpad
+
+#endif  // COMMON_WINDOWS_MODULE_INFO_H_
diff --git a/src/MEGASync/google_breakpad/common/windows/omap.cc b/src/MEGASync/google_breakpad/common/windows/omap.cc
index 39e4722b..5a821b64 100644
--- a/src/MEGASync/google_breakpad/common/windows/omap.cc
+++ b/src/MEGASync/google_breakpad/common/windows/omap.cc
@@ -210,7 +210,7 @@ bool FindAndLoadOmapTable(const wchar_t* name,
                           reinterpret_cast<BYTE*>(&table->at(0)),
                           &count_read))) {
     fprintf(stderr, "IDiaEnumDebugStreamData::Next failed while reading "
-                    "data from stream \"%ws\"\n");
+                    "data from stream \"%ws\"\n", name);
     return false;
   }
 
@@ -449,6 +449,27 @@ void BuildEndpointIndexMap(ImageMap* image_map) {
   }
 }
 
+void BuildSubsequentRVAMap(const OmapData& omap_data,
+                           std::map<DWORD, DWORD>* subsequent) {
+  assert(subsequent->empty());
+  const OmapFromTable& orig2tran =
+      reinterpret_cast<const OmapFromTable&>(omap_data.omap_from);
+
+  if (orig2tran.empty())
+    return;
+
+  for (size_t i = 0; i < orig2tran.size() - 1; ++i) {
+    // Expect that orig2tran is sorted.
+    if (orig2tran[i].rva_original >= orig2tran[i + 1].rva_original) {
+      fprintf(stderr, "OMAP 'from' table unexpectedly unsorted\n");
+      subsequent->clear();
+      return;
+    }
+    subsequent->insert(std::make_pair(orig2tran[i].rva_original,
+                                      orig2tran[i + 1].rva_original));
+  }
+}
+
 // Clips the given mapped range.
 void ClipMappedRangeOriginal(const AddressRange& clip_range,
                              MappedRange* mapped_range) {
@@ -576,6 +597,7 @@ void BuildImageMap(const OmapData& omap_data, ImageMap* image_map) {
 
   BuildMapping(omap_data, &image_map->mapping);
   BuildEndpointIndexMap(image_map);
+  BuildSubsequentRVAMap(omap_data, &image_map->subsequent_rva_block);
 }
 
 void MapAddressRange(const ImageMap& image_map,
diff --git a/src/MEGASync/google_breakpad/common/windows/omap.h b/src/MEGASync/google_breakpad/common/windows/omap.h
index 1e023d11..bc293afb 100644
--- a/src/MEGASync/google_breakpad/common/windows/omap.h
+++ b/src/MEGASync/google_breakpad/common/windows/omap.h
@@ -32,8 +32,8 @@
 // transforming addresses prior to querying symbols (the way it is typically
 // done by Windows-native tools, including the DIA).
 
-#ifndef COMMON_WINDOWS_OMAP_H__
-#define COMMON_WINDOWS_OMAP_H__
+#ifndef COMMON_WINDOWS_OMAP_H_
+#define COMMON_WINDOWS_OMAP_H_
 
 #include "common/windows/omap_internal.h"
 
@@ -69,4 +69,4 @@ void MapAddressRange(const ImageMap& image_map,
 
 }  // namespace google_breakpad
 
-#endif  // COMMON_WINDOWS_OMAP_H__
+#endif  // COMMON_WINDOWS_OMAP_H_
diff --git a/src/MEGASync/google_breakpad/common/windows/omap_internal.h b/src/MEGASync/google_breakpad/common/windows/omap_internal.h
index 6c37d7f8..2a4713d9 100644
--- a/src/MEGASync/google_breakpad/common/windows/omap_internal.h
+++ b/src/MEGASync/google_breakpad/common/windows/omap_internal.h
@@ -29,12 +29,13 @@
 // Declares internal implementation details for functionality in omap.h and
 // omap.cc.
 
-#ifndef COMMON_WINDOWS_OMAP_INTERNAL_H__
-#define COMMON_WINDOWS_OMAP_INTERNAL_H__
+#ifndef COMMON_WINDOWS_OMAP_INTERNAL_H_
+#define COMMON_WINDOWS_OMAP_INTERNAL_H_
 
 #include <windows.h>
 #include <dia2.h>
 
+#include <map>
 #include <vector>
 
 namespace google_breakpad {
@@ -130,8 +131,10 @@ struct ImageMap {
   // an interval in |mapping| that contains the endpoint. Useful for doing
   // interval intersection queries.
   EndpointIndexMap endpoint_index_map;
+
+  std::map<DWORD, DWORD> subsequent_rva_block;
 };
 
 }  // namespace google_breakpad
 
-#endif  // COMMON_WINDOWS_OMAP_INTERNAL_H__
+#endif  // COMMON_WINDOWS_OMAP_INTERNAL_H_
diff --git a/src/MEGASync/google_breakpad/common/windows/omap_unittest.cc b/src/MEGASync/google_breakpad/common/windows/omap_unittest.cc
index c1a2c512..b2443341 100644
--- a/src/MEGASync/google_breakpad/common/windows/omap_unittest.cc
+++ b/src/MEGASync/google_breakpad/common/windows/omap_unittest.cc
@@ -30,8 +30,7 @@
 
 #include "common/windows/omap.h"
 
-#include "gmock/gmock.h"
-#include "gtest/gtest.h"
+#include "breakpad_googletest_includes.h"
 
 namespace google_breakpad {
 
diff --git a/src/MEGASync/google_breakpad/common/windows/pdb_source_line_writer.cc b/src/MEGASync/google_breakpad/common/windows/pdb_source_line_writer.cc
index 1f24f70a..0eeb30cc 100644
--- a/src/MEGASync/google_breakpad/common/windows/pdb_source_line_writer.cc
+++ b/src/MEGASync/google_breakpad/common/windows/pdb_source_line_writer.cc
@@ -33,13 +33,19 @@
 #include <winnt.h>
 #include <atlbase.h>
 #include <dia2.h>
+#include <diacreate.h>
 #include <ImageHlp.h>
 #include <stdio.h>
 
+#include <algorithm>
 #include <limits>
+#include <map>
+#include <set>
+#include <utility>
 
 #include "common/windows/dia_util.h"
 #include "common/windows/guid_string.h"
+#include "common/windows/pe_util.h"
 #include "common/windows/string_utils-inl.h"
 
 // This constant may be missing from DbgHelp.h.  See the documentation for
@@ -54,21 +60,99 @@ namespace {
 
 using std::vector;
 
-// A helper class to scope a PLOADED_IMAGE.
-class AutoImage {
- public:
-  explicit AutoImage(PLOADED_IMAGE img) : img_(img) {}
-  ~AutoImage() {
-    if (img_)
-      ImageUnload(img_);
+// The symbol (among possibly many) selected to represent an rva.
+struct SelectedSymbol {
+  SelectedSymbol(const CComPtr<IDiaSymbol>& symbol, bool is_public)
+      : symbol(symbol), is_public(is_public), is_multiple(false) {}
+
+  // The symbol to use for an rva.
+  CComPtr<IDiaSymbol> symbol;
+  // Whether this is a public or function symbol.
+  bool is_public;
+  // Whether the rva has multiple associated symbols. An rva will correspond to
+  // multiple symbols in the case of linker identical symbol folding.
+  bool is_multiple;
+};
+
+// Maps rva to the symbol to use for that address.
+typedef std::map<DWORD, SelectedSymbol> SymbolMap;
+
+// Record this in the map as the selected symbol for the rva if it satisfies the
+// necessary conditions.
+void MaybeRecordSymbol(DWORD rva,
+                       const CComPtr<IDiaSymbol> symbol,
+                       bool is_public,
+                       SymbolMap* map) {
+  SymbolMap::iterator loc = map->find(rva);
+  if (loc == map->end()) {
+    map->insert(std::make_pair(rva, SelectedSymbol(symbol, is_public)));
+    return;
   }
 
-  operator PLOADED_IMAGE() { return img_; }
-  PLOADED_IMAGE operator->() { return img_; }
+  // Prefer function symbols to public symbols.
+  if (is_public && !loc->second.is_public) {
+    return;
+  }
 
- private:
-  PLOADED_IMAGE img_;
-};
+  loc->second.is_multiple = true;
+
+  // Take the 'least' symbol by lexicographical order of the decorated name. We
+  // use the decorated rather than undecorated name because computing the latter
+  // is expensive.
+  BSTR current_name, new_name;
+  loc->second.symbol->get_name(&current_name);
+  symbol->get_name(&new_name);
+  if (wcscmp(new_name, current_name) < 0) {
+    loc->second.symbol = symbol;
+    loc->second.is_public = is_public;
+  }
+}
+
+
+
+bool SymbolsMatch(IDiaSymbol* a, IDiaSymbol* b) {
+  DWORD a_section, a_offset, b_section, b_offset;
+  if (FAILED(a->get_addressSection(&a_section)) ||
+      FAILED(a->get_addressOffset(&a_offset)) ||
+      FAILED(b->get_addressSection(&b_section)) ||
+      FAILED(b->get_addressOffset(&b_offset)))
+    return false;
+  return a_section == b_section && a_offset == b_offset;
+}
+
+bool CreateDiaDataSourceInstance(CComPtr<IDiaDataSource>& data_source) {
+  if (SUCCEEDED(data_source.CoCreateInstance(CLSID_DiaSource))) {
+    return true;
+  }
+
+  class DECLSPEC_UUID("B86AE24D-BF2F-4ac9-B5A2-34B14E4CE11D") DiaSource100;
+  class DECLSPEC_UUID("761D3BCD-1304-41D5-94E8-EAC54E4AC172") DiaSource110;
+  class DECLSPEC_UUID("3BFCEA48-620F-4B6B-81F7-B9AF75454C7D") DiaSource120;
+  class DECLSPEC_UUID("E6756135-1E65-4D17-8576-610761398C3C") DiaSource140;
+
+  // If the CoCreateInstance call above failed, msdia*.dll is not registered.
+  // We can try loading the DLL corresponding to the #included DIA SDK, but
+  // the DIA headers don't provide a version. Lets try to figure out which DIA
+  // version we're compiling against by comparing CLSIDs.
+  const wchar_t* msdia_dll = nullptr;
+  if (CLSID_DiaSource == _uuidof(DiaSource100)) {
+    msdia_dll = L"msdia100.dll";
+  } else if (CLSID_DiaSource == _uuidof(DiaSource110)) {
+    msdia_dll = L"msdia110.dll";
+  } else if (CLSID_DiaSource == _uuidof(DiaSource120)) {
+    msdia_dll = L"msdia120.dll";
+  } else if (CLSID_DiaSource == _uuidof(DiaSource140)) {
+    msdia_dll = L"msdia140.dll";
+  }
+
+  if (msdia_dll &&
+      SUCCEEDED(NoRegCoCreate(msdia_dll, CLSID_DiaSource, IID_IDiaDataSource,
+                              reinterpret_cast<void**>(&data_source)))) {
+    return true;
+  }
+
+  return false;
+}
 
 }  // namespace
 
@@ -76,10 +160,22 @@ PDBSourceLineWriter::PDBSourceLineWriter() : output_(NULL) {
 }
 
 PDBSourceLineWriter::~PDBSourceLineWriter() {
+  Close();
+}
+
+bool PDBSourceLineWriter::SetCodeFile(const wstring& exe_file) {
+  if (code_file_.empty()) {
+    code_file_ = exe_file;
+    return true;
+  }
+  // Setting a different code file path is an error.  It is success only if the
+  // file paths are the same.
+  return exe_file == code_file_;
 }
 
-bool PDBSourceLineWriter::Open(const wstring &file, FileFormat format) {
+bool PDBSourceLineWriter::Open(const wstring& file, FileFormat format) {
   Close();
+  code_file_.clear();
 
   if (FAILED(CoInitialize(NULL))) {
     fprintf(stderr, "CoInitialize failed\n");
@@ -87,12 +183,10 @@ bool PDBSourceLineWriter::Open(const wstring &file, FileFormat format) {
   }
 
   CComPtr<IDiaDataSource> data_source;
-  if (FAILED(data_source.CoCreateInstance(CLSID_DiaSource))) {
+  if (!CreateDiaDataSourceInstance(data_source)) {
     const int kGuidSize = 64;
     wchar_t classid[kGuidSize] = {0};
     StringFromGUID2(CLSID_DiaSource, classid, kGuidSize);
-    // vc80 uses bce36434-2c24-499e-bf49-8bd99b0eeb68.
-    // vc90 uses 4C41678E-887B-4365-A09E-925D28DB33C2.
     fprintf(stderr, "CoCreateInstance CLSID_DiaSource %S failed "
             "(msdia*.dll unregistered?)\n", classid);
     return false;
@@ -115,7 +209,8 @@ bool PDBSourceLineWriter::Open(const wstring &file, FileFormat format) {
     case ANY_FILE:
       if (FAILED(data_source->loadDataFromPdb(file.c_str()))) {
         if (FAILED(data_source->loadDataForExe(file.c_str(), NULL, NULL))) {
-          fprintf(stderr, "loadDataForPdb and loadDataFromExe failed for %ws\n", file.c_str());
+          fprintf(stderr, "loadDataForPdb and loadDataFromExe failed for %ws\n",
+                  file.c_str());
           return false;
         }
         code_file_ = file;
@@ -133,7 +228,7 @@ bool PDBSourceLineWriter::Open(const wstring &file, FileFormat format) {
   return true;
 }
 
-bool PDBSourceLineWriter::PrintLines(IDiaEnumLineNumbers *lines) {
+bool PDBSourceLineWriter::PrintLines(IDiaEnumLineNumbers* lines) {
   // The line number format is:
   // <rva> <line number> <source file id>
   CComPtr<IDiaLineNumber> line;
@@ -169,7 +264,7 @@ bool PDBSourceLineWriter::PrintLines(IDiaEnumLineNumbers *lines) {
     AddressRangeVector ranges;
     MapAddressRange(image_map_, AddressRange(rva, length), &ranges);
     for (size_t i = 0; i < ranges.size(); ++i) {
-      fprintf(output_, "%x %x %d %d\n", ranges[i].rva, ranges[i].length,
+      fprintf(output_, "%lx %lx %lu %lu\n", ranges[i].rva, ranges[i].length,
               line_num, source_id);
     }
     line.Release();
@@ -177,8 +272,9 @@ bool PDBSourceLineWriter::PrintLines(IDiaEnumLineNumbers *lines) {
   return true;
 }
 
-bool PDBSourceLineWriter::PrintFunction(IDiaSymbol *function,
-                                        IDiaSymbol *block) {
+bool PDBSourceLineWriter::PrintFunction(IDiaSymbol* function,
+                                        IDiaSymbol* block,
+                                        bool has_multiple_symbols) {
   // The function format is:
   // FUNC <address> <length> <param_stack_size> <function>
   DWORD rva;
@@ -214,8 +310,9 @@ bool PDBSourceLineWriter::PrintFunction(IDiaSymbol *function,
   MapAddressRange(image_map_, AddressRange(rva, static_cast<DWORD>(length)),
                   &ranges);
   for (size_t i = 0; i < ranges.size(); ++i) {
-    fprintf(output_, "FUNC %x %x %x %ws\n",
-            ranges[i].rva, ranges[i].length, stack_param_size, name);
+    const char* optional_multiple_field = has_multiple_symbols ? "m " : "";
+    fprintf(output_, "FUNC %s%lx %lx %x %ws\n", optional_multiple_field,
+            ranges[i].rva, ranges[i].length, stack_param_size, name.m_str);
   }
 
   CComPtr<IDiaEnumLineNumbers> lines;
@@ -266,7 +363,7 @@ bool PDBSourceLineWriter::PrintSourceFiles() {
       if (!FileIDIsCached(file_name_string)) {
         // this is a new file name, cache it and output a FILE line.
         CacheFileID(file_name_string, file_id);
-        fwprintf(output_, L"FILE %d %s\n", file_id, file_name);
+        fwprintf(output_, L"FILE %d %ws\n", file_id, file_name_string.c_str());
       } else {
         // this file name has already been seen, just save this
         // ID for later lookup.
@@ -280,47 +377,75 @@ bool PDBSourceLineWriter::PrintSourceFiles() {
 }
 
 bool PDBSourceLineWriter::PrintFunctions() {
-  CComPtr<IDiaEnumSymbolsByAddr> symbols;
-  if (FAILED(session_->getSymbolsByAddr(&symbols))) {
-    fprintf(stderr, "failed to get symbol enumerator\n");
-    return false;
-  }
+  ULONG count = 0;
+  DWORD rva = 0;
+  CComPtr<IDiaSymbol> global;
+  HRESULT hr;
 
-  CComPtr<IDiaSymbol> symbol;
-  if (FAILED(symbols->symbolByAddr(1, 0, &symbol))) {
-    fprintf(stderr, "failed to enumerate symbols\n");
+  if (FAILED(session_->get_globalScope(&global))) {
+    fprintf(stderr, "get_globalScope failed\n");
     return false;
   }
 
-  DWORD rva_last = 0;
-  if (FAILED(symbol->get_relativeVirtualAddress(&rva_last))) {
-    fprintf(stderr, "failed to get symbol rva\n");
-    return false;
-  }
+  CComPtr<IDiaEnumSymbols> symbols = NULL;
 
-  ULONG count;
-  do {
-    DWORD tag;
-    if (FAILED(symbol->get_symTag(&tag))) {
-      fprintf(stderr, "failed to get symbol tag\n");
-      return false;
-    }
+  // Find all function symbols first.
+  SymbolMap rva_symbol;
+  hr = global->findChildren(SymTagFunction, NULL, nsNone, &symbols);
 
-    // For a given function, DIA seems to give either a symbol with
-    // SymTagFunction or SymTagPublicSymbol, but not both.  This means
-    // that PDBSourceLineWriter will output either a FUNC or PUBLIC line,
-    // but not both.
-    if (tag == SymTagFunction) {
-      if (!PrintFunction(symbol, symbol)) {
+  if (SUCCEEDED(hr)) {
+    CComPtr<IDiaSymbol> symbol = NULL;
+
+    while (SUCCEEDED(symbols->Next(1, &symbol, &count)) && count == 1) {
+      if (SUCCEEDED(symbol->get_relativeVirtualAddress(&rva))) {
+        // Potentially record this as the canonical symbol for this rva.
+        MaybeRecordSymbol(rva, symbol, false, &rva_symbol);
+      } else {
+        fprintf(stderr, "get_relativeVirtualAddress failed on the symbol\n");
         return false;
       }
-    } else if (tag == SymTagPublicSymbol) {
-      if (!PrintCodePublicSymbol(symbol)) {
+
+      symbol.Release();
+    }
+
+    symbols.Release();
+  }
+
+  // Find all public symbols and record public symbols that are not also private
+  // symbols.
+  hr = global->findChildren(SymTagPublicSymbol, NULL, nsNone, &symbols);
+
+  if (SUCCEEDED(hr)) {
+    CComPtr<IDiaSymbol> symbol = NULL;
+
+    while (SUCCEEDED(symbols->Next(1, &symbol, &count)) && count == 1) {
+      if (SUCCEEDED(symbol->get_relativeVirtualAddress(&rva))) {
+        // Potentially record this as the canonical symbol for this rva.
+        MaybeRecordSymbol(rva, symbol, true, &rva_symbol);
+      } else {
+        fprintf(stderr, "get_relativeVirtualAddress failed on the symbol\n");
         return false;
       }
+
+      symbol.Release();
     }
-    symbol.Release();
-  } while (SUCCEEDED(symbols->Next(1, &symbol, &count)) && count == 1);
+
+    symbols.Release();
+  }
+
+  // For each rva, dump the selected symbol at the address.
+  SymbolMap::iterator it;
+  for (it = rva_symbol.begin(); it != rva_symbol.end(); ++it) {
+    CComPtr<IDiaSymbol> symbol = it->second.symbol;
+    // Only print public symbols if there is no function symbol for the address.
+    if (!it->second.is_public) {
+      if (!PrintFunction(symbol, symbol, it->second.is_multiple))
+        return false;
+    } else {
+      if (!PrintCodePublicSymbol(symbol, it->second.is_multiple))
+        return false;
+    }
+  }
 
   // When building with PGO, the compiler can split functions into
   // "hot" and "cold" blocks, and move the "cold" blocks out to separate
@@ -329,12 +454,6 @@ bool PDBSourceLineWriter::PrintFunctions() {
   // that are children of them. We can then find the lexical parents
   // of those blocks and print out an extra FUNC line for blocks
   // that are not contained in their parent functions.
-  CComPtr<IDiaSymbol> global;
-  if (FAILED(session_->get_globalScope(&global))) {
-    fprintf(stderr, "get_globalScope failed\n");
-    return false;
-  }
-
   CComPtr<IDiaEnumSymbols> compilands;
   if (FAILED(global->findChildren(SymTagCompiland, NULL,
                                   nsNone, &compilands))) {
@@ -367,7 +486,7 @@ bool PDBSourceLineWriter::PrintFunctions() {
             SUCCEEDED(parent->get_relativeVirtualAddress(&func_rva)) &&
             SUCCEEDED(parent->get_length(&func_length))) {
           if (block_rva < func_rva || block_rva > (func_rva + func_length)) {
-            if (!PrintFunction(parent, block)) {
+            if (!PrintFunction(parent, block, false)) {
               return false;
             }
           }
@@ -380,10 +499,13 @@ bool PDBSourceLineWriter::PrintFunctions() {
     compiland.Release();
   }
 
+  global.Release();
   return true;
 }
 
-bool PDBSourceLineWriter::PrintFrameData() {
+#undef max
+
+bool PDBSourceLineWriter::PrintFrameDataUsingPDB() {
   // It would be nice if it were possible to output frame data alongside the
   // associated function, as is done with line numbers, but the DIA API
   // doesn't make it possible to get the frame data in that way.
@@ -392,10 +514,10 @@ bool PDBSourceLineWriter::PrintFrameData() {
   if (!FindTable(session_, &frame_data_enum))
     return false;
 
-  DWORD last_type = std::numeric_limits<DWORD>::max()
-  DWORD last_rva = std::numeric_limits<DWORD>::max()
+  DWORD last_type = std::numeric_limits<DWORD>::max();
+  DWORD last_rva = std::numeric_limits<DWORD>::max();
   DWORD last_code_size = 0;
-  DWORD last_prolog_size = std::numeric_limits<DWORD>::max()
+  DWORD last_prolog_size = std::numeric_limits<DWORD>::max();
 
   CComPtr<IDiaFrameData> frame_data;
   ULONG count = 0;
@@ -515,12 +637,12 @@ bool PDBSourceLineWriter::PrintFrameData() {
 
       for (size_t i = 0; i < frame_infos.size(); ++i) {
         const FrameInfo& fi(frame_infos[i]);
-        fprintf(output_, "STACK WIN %x %x %x %x %x %x %x %x %x %d ",
+        fprintf(output_, "STACK WIN %lx %lx %lx %lx %x %lx %lx %lx %lx %d ",
                 type, fi.rva, fi.code_size, fi.prolog_size,
                 0 /* epilog_size */, parameter_size, saved_register_size,
                 local_size, max_stack_size, program_string_result == S_OK);
         if (program_string_result == S_OK) {
-          fprintf(output_, "%ws\n", program_string);
+          fprintf(output_, "%ws\n", program_string.m_str);
         } else {
           fprintf(output_, "%d\n", allocates_base_pointer);
         }
@@ -538,7 +660,27 @@ bool PDBSourceLineWriter::PrintFrameData() {
   return true;
 }
 
-bool PDBSourceLineWriter::PrintCodePublicSymbol(IDiaSymbol *symbol) {
+bool PDBSourceLineWriter::PrintFrameDataUsingEXE() {
+  if (code_file_.empty() && !FindPEFile()) {
+    fprintf(stderr, "Couldn't locate EXE or DLL file.\n");
+    return false;
+  }
+
+  return PrintPEFrameData(code_file_, output_);
+}
+
+bool PDBSourceLineWriter::PrintFrameData() {
+  PDBModuleInfo info;
+  if (GetModuleInfo(&info) && info.cpu == L"x86_64") {
+    return PrintFrameDataUsingEXE();
+  } else {
+    return PrintFrameDataUsingPDB();
+  }
+  return false;
+}
+
+bool PDBSourceLineWriter::PrintCodePublicSymbol(IDiaSymbol* symbol,
+                                                bool has_multiple_symbols) {
   BOOL is_code;
   if (FAILED(symbol->get_code(&is_code))) {
     return false;
@@ -561,9 +703,44 @@ bool PDBSourceLineWriter::PrintCodePublicSymbol(IDiaSymbol *symbol) {
   AddressRangeVector ranges;
   MapAddressRange(image_map_, AddressRange(rva, 1), &ranges);
   for (size_t i = 0; i < ranges.size(); ++i) {
-    fprintf(output_, "PUBLIC %x %x %ws\n", ranges[i].rva,
-            stack_param_size > 0 ? stack_param_size : 0, name);
+    const char* optional_multiple_field = has_multiple_symbols ? "m " : "";
+    fprintf(output_, "PUBLIC %s%lx %x %ws\n", optional_multiple_field,
+            ranges[i].rva, stack_param_size > 0 ? stack_param_size : 0,
+            name.m_str);
   }
+
+  // Now walk the function in the original untranslated space, asking DIA
+  // what function is at that location, stepping through OMAP blocks. If
+  // we're still in the same function, emit another entry, because the
+  // symbol could have been split into multiple pieces. If we've gotten to
+  // another symbol in the original address space, then we're done for
+  // this symbol. See https://crbug.com/678874.
+  for (;;) {
+    // This steps to the next block in the original image. Simply doing
+    // rva++ would also be correct, but would emit tons of unnecessary
+    // entries.
+    rva = image_map_.subsequent_rva_block[rva];
+    if (rva == 0)
+      break;
+
+    CComPtr<IDiaSymbol> next_sym = NULL;
+    LONG displacement;
+    if (FAILED(session_->findSymbolByRVAEx(rva, SymTagPublicSymbol, &next_sym,
+                                           &displacement))) {
+      break;
+    }
+
+    if (!SymbolsMatch(symbol, next_sym))
+      break;
+
+    AddressRangeVector next_ranges;
+    MapAddressRange(image_map_, AddressRange(rva, 1), &next_ranges);
+    for (size_t i = 0; i < next_ranges.size(); ++i) {
+      fprintf(output_, "PUBLIC %lx %x %ws\n", next_ranges[i].rva,
+              stack_param_size > 0 ? stack_param_size : 0, name.m_str);
+    }
+  }
+
   return true;
 }
 
@@ -604,9 +781,9 @@ bool PDBSourceLineWriter::PrintPEInfo() {
 // and scanf families, which are not as strict about input and in some cases
 // don't provide a good way for the caller to determine if a conversion was
 // successful.
-static bool wcstol_positive_strict(wchar_t *string, int *result) {
+static bool wcstol_positive_strict(wchar_t* string, int* result) {
   int value = 0;
-  for (wchar_t *c = string; *c != '\0'; ++c) {
+  for (wchar_t* c = string; *c != '\0'; ++c) {
     int last_value = value;
     value *= 10;
     // Detect overflow.
@@ -642,10 +819,10 @@ bool PDBSourceLineWriter::FindPEFile() {
   CComBSTR symbols_file;
   if (SUCCEEDED(global->get_symbolsFileName(&symbols_file))) {
     wstring file(symbols_file);
-    
+
     // Look for an EXE or DLL file.
-    const wchar_t *extensions[] = { L"exe", L"dll" };
-    for (int i = 0; i < sizeof(extensions) / sizeof(extensions[0]); i++) {
+    const wchar_t* extensions[] = { L"exe", L"dll" };
+    for (size_t i = 0; i < sizeof(extensions) / sizeof(extensions[0]); i++) {
       size_t dot_pos = file.find_last_of(L".");
       if (dot_pos != wstring::npos) {
         file.replace(dot_pos + 1, wstring::npos, extensions[i]);
@@ -662,9 +839,9 @@ bool PDBSourceLineWriter::FindPEFile() {
 }
 
 // static
-bool PDBSourceLineWriter::GetSymbolFunctionName(IDiaSymbol *function,
-                                                BSTR *name,
-                                                int *stack_param_size) {
+bool PDBSourceLineWriter::GetSymbolFunctionName(IDiaSymbol* function,
+                                                BSTR* name,
+                                                int* stack_param_size) {
   *stack_param_size = -1;
   const DWORD undecorate_options = UNDNAME_NO_MS_KEYWORDS |
                                    UNDNAME_NO_FUNCTION_RETURNS |
@@ -683,6 +860,16 @@ bool PDBSourceLineWriter::GetSymbolFunctionName(IDiaSymbol *function,
       fprintf(stderr, "failed to get function name\n");
       return false;
     }
+
+    // It's possible for get_name to return an empty string, so
+    // special-case that.
+    if (wcscmp(*name, L"") == 0) {
+      SysFreeString(*name);
+      // dwarf_cu_to_module.cc uses "<name omitted>", so match that.
+      *name = SysAllocString(L"<name omitted>");
+      return true;
+    }
+
     // If a name comes from get_name because no undecorated form existed,
     // it's already formatted properly to be used as output.  Don't do any
     // additional processing.
@@ -695,12 +882,12 @@ bool PDBSourceLineWriter::GetSymbolFunctionName(IDiaSymbol *function,
     // C++ uses a bogus "void" argument for functions and methods that don't
     // take any parameters.  Take it out of the undecorated name because it's
     // ugly and unnecessary.
-    const wchar_t *replace_string = L"(void)";
+    const wchar_t* replace_string = L"(void)";
     const size_t replace_length = wcslen(replace_string);
-    const wchar_t *replacement_string = L"()";
+    const wchar_t* replacement_string = L"()";
     size_t length = wcslen(*name);
     if (length >= replace_length) {
-      wchar_t *name_end = *name + length - replace_length;
+      wchar_t* name_end = *name + length - replace_length;
       if (wcscmp(name_end, replace_string) == 0) {
         WindowsStringUtils::safe_wcscpy(name_end, replace_length,
                                         replacement_string);
@@ -716,7 +903,7 @@ bool PDBSourceLineWriter::GetSymbolFunctionName(IDiaSymbol *function,
     // whether the undecorated name contains any ':' or '(' characters.
     if (!wcschr(*name, ':') && !wcschr(*name, '(') &&
         (*name[0] == '_' || *name[0] == '@')) {
-      wchar_t *last_at = wcsrchr(*name + 1, '@');
+      wchar_t* last_at = wcsrchr(*name + 1, '@');
       if (last_at && wcstol_positive_strict(last_at + 1, stack_param_size)) {
         // If this function adheres to the fastcall convention, it accepts up
         // to the first 8 bytes of parameters in registers (%ecx and %edx).
@@ -748,7 +935,7 @@ bool PDBSourceLineWriter::GetSymbolFunctionName(IDiaSymbol *function,
 }
 
 // static
-int PDBSourceLineWriter::GetFunctionStackParamSize(IDiaSymbol *function) {
+int PDBSourceLineWriter::GetFunctionStackParamSize(IDiaSymbol* function) {
   // This implementation is highly x86-specific.
 
   // Gather the symbols corresponding to data.
@@ -821,12 +1008,15 @@ int PDBSourceLineWriter::GetFunctionStackParamSize(IDiaSymbol *function) {
       goto next_child;
     }
 
-    int child_end = child_register_offset + static_cast<ULONG>(child_length);
-    if (child_register_offset < lowest_base) {
-      lowest_base = child_register_offset;
-    }
-    if (child_end > highest_end) {
-      highest_end = child_end;
+    // Extra scope to avoid goto jumping over variable initialization
+    {
+      int child_end = child_register_offset + static_cast<ULONG>(child_length);
+      if (child_register_offset < lowest_base) {
+        lowest_base = child_register_offset;
+      }
+      if (child_end > highest_end) {
+        highest_end = child_end;
+      }
     }
 
 next_child:
@@ -860,8 +1050,8 @@ next_child:
   return param_size;
 }
 
-bool PDBSourceLineWriter::WriteMap(FILE *map_file) {
-  output_ = map_file;
+bool PDBSourceLineWriter::WriteSymbols(FILE* symbol_file) {
+  output_ = symbol_file;
 
   // Load the OMAP information, and disable auto-translation of addresses in
   // preference of doing it ourselves.
@@ -874,7 +1064,7 @@ bool PDBSourceLineWriter::WriteMap(FILE *map_file) {
   // This is not a critical piece of the symbol file.
   PrintPEInfo();
   ret = ret &&
-      PrintSourceFiles() && 
+      PrintSourceFiles() &&
       PrintFunctions() &&
       PrintFrameData();
 
@@ -883,10 +1073,12 @@ bool PDBSourceLineWriter::WriteMap(FILE *map_file) {
 }
 
 void PDBSourceLineWriter::Close() {
-  session_.Release();
+  if (session_ != nullptr) {
+    session_.Release();
+  }
 }
 
-bool PDBSourceLineWriter::GetModuleInfo(PDBModuleInfo *info) {
+bool PDBSourceLineWriter::GetModuleInfo(PDBModuleInfo* info) {
   if (!info) {
     return false;
   }
@@ -908,17 +1100,7 @@ bool PDBSourceLineWriter::GetModuleInfo(PDBModuleInfo *info) {
     // Instead, it returns one of the IMAGE_FILE_MACHINE values as
     // defined here:
     // http://msdn.microsoft.com/en-us/library/ms680313%28VS.85%29.aspx
-    switch (machine_type) {
-      case IMAGE_FILE_MACHINE_I386:
-        info->cpu = L"x86";
-        break;
-      case IMAGE_FILE_MACHINE_AMD64:
-        info->cpu = L"x86_64";
-        break;
-      default:
-        info->cpu = L"unknown";
-        break;
-    }
+    info->cpu = FileHeaderMachineToCpuString(static_cast<WORD>(machine_type));
   } else {
     // Unexpected, but handle gracefully.
     info->cpu = L"unknown";
@@ -941,35 +1123,14 @@ bool PDBSourceLineWriter::GetModuleInfo(PDBModuleInfo *info) {
       return false;
     }
 
-    // Use the same format that the MS symbol server uses in filesystem
-    // hierarchies.
-    wchar_t age_string[9];
-    swprintf(age_string, sizeof(age_string) / sizeof(age_string[0]),
-             L"%x", age);
-
-    // remove when VC++7.1 is no longer supported
-    age_string[sizeof(age_string) / sizeof(age_string[0]) - 1] = L'\0';
-
-    info->debug_identifier = GUIDString::GUIDToSymbolServerWString(&guid);
-    info->debug_identifier.append(age_string);
+    info->debug_identifier = GenerateDebugIdentifier(age, guid);
   } else {
     DWORD signature;
     if (FAILED(global->get_signature(&signature))) {
       return false;
     }
 
-    // Use the same format that the MS symbol server uses in filesystem
-    // hierarchies.
-    wchar_t identifier_string[17];
-    swprintf(identifier_string,
-             sizeof(identifier_string) / sizeof(identifier_string[0]),
-             L"%08X%x", signature, age);
-
-    // remove when VC++7.1 is no longer supported
-    identifier_string[sizeof(identifier_string) /
-                      sizeof(identifier_string[0]) - 1] = L'\0';
-
-    info->debug_identifier = identifier_string;
+    info->debug_identifier = GenerateDebugIdentifier(age, signature);
   }
 
   CComBSTR debug_file_string;
@@ -982,7 +1143,7 @@ bool PDBSourceLineWriter::GetModuleInfo(PDBModuleInfo *info) {
   return true;
 }
 
-bool PDBSourceLineWriter::GetPEInfo(PEModuleInfo *info) {
+bool PDBSourceLineWriter::GetPEInfo(PEModuleInfo* info) {
   if (!info) {
     return false;
   }
@@ -992,45 +1153,10 @@ bool PDBSourceLineWriter::GetPEInfo(PEModuleInfo *info) {
     return false;
   }
 
-  // Convert wchar to native charset because ImageLoad only takes
-  // a PSTR as input.
-  string code_file;
-  if (!WindowsStringUtils::safe_wcstombs(code_file_, &code_file)) {
-    return false;
-  }
-
-  AutoImage img(ImageLoad((PSTR)code_file.c_str(), NULL));
-  if (!img) {
-    fprintf(stderr, "Failed to open PE file: %s\n", code_file.c_str());
-    return false;
-  }
-
-  info->code_file = WindowsStringUtils::GetBaseName(code_file_);
-
-  // The date and time that the file was created by the linker.
-  DWORD TimeDateStamp = img->FileHeader->FileHeader.TimeDateStamp;
-  // The size of the file in bytes, including all headers.
-  DWORD SizeOfImage = 0;
-  PIMAGE_OPTIONAL_HEADER64 opt =
-    &((PIMAGE_NT_HEADERS64)img->FileHeader)->OptionalHeader;
-  if (opt->Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
-    // 64-bit PE file.
-    SizeOfImage = opt->SizeOfImage;
-  }
-  else {
-    // 32-bit PE file.
-    SizeOfImage = img->FileHeader->OptionalHeader.SizeOfImage;
-  }
-  wchar_t code_identifier[32];
-  swprintf(code_identifier,
-      sizeof(code_identifier) / sizeof(code_identifier[0]),
-      L"%08X%X", TimeDateStamp, SizeOfImage);
-  info->code_identifier = code_identifier;
-
-  return true;
+  return ReadPEInfo(code_file_, info);
 }
 
-bool PDBSourceLineWriter::UsesGUID(bool *uses_guid) {
+bool PDBSourceLineWriter::UsesGUID(bool* uses_guid) {
   if (!uses_guid)
     return false;
 
diff --git a/src/MEGASync/google_breakpad/common/windows/pdb_source_line_writer.h b/src/MEGASync/google_breakpad/common/windows/pdb_source_line_writer.h
index be6121c3..00f6e592 100644
--- a/src/MEGASync/google_breakpad/common/windows/pdb_source_line_writer.h
+++ b/src/MEGASync/google_breakpad/common/windows/pdb_source_line_writer.h
@@ -30,14 +30,15 @@
 // PDBSourceLineWriter uses a pdb file produced by Visual C++ to output
 // a line/address map for use with BasicSourceLineResolver.
 
-#ifndef _PDB_SOURCE_LINE_WRITER_H__
-#define _PDB_SOURCE_LINE_WRITER_H__
+#ifndef COMMON_WINDOWS_PDB_SOURCE_LINE_WRITER_H_
+#define COMMON_WINDOWS_PDB_SOURCE_LINE_WRITER_H_
 
 #include <atlcomcli.h>
 
-#include <hash_map>
 #include <string>
+#include <unordered_map>
 
+#include "common/windows/module_info.h"
 #include "common/windows/omap.h"
 
 struct IDiaEnumLineNumbers;
@@ -47,42 +48,7 @@ struct IDiaSymbol;
 namespace google_breakpad {
 
 using std::wstring;
-using stdext::hash_map;
-
-// A structure that carries information that identifies a pdb file.
-struct PDBModuleInfo {
- public:
-  // The basename of the pdb file from which information was loaded.
-  wstring debug_file;
-
-  // The pdb's identifier.  For recent pdb files, the identifier consists
-  // of the pdb's guid, in uppercase hexadecimal form without any dashes
-  // or separators, followed immediately by the pdb's age, also in
-  // uppercase hexadecimal form.  For older pdb files which have no guid,
-  // the identifier is the pdb's 32-bit signature value, in zero-padded
-  // hexadecimal form, followed immediately by the pdb's age, in lowercase
-  // hexadecimal form.
-  wstring debug_identifier;
-
-  // A string identifying the cpu that the pdb is associated with.
-  // Currently, this may be "x86" or "unknown".
-  wstring cpu;
-};
-
-// A structure that carries information that identifies a PE file,
-// either an EXE or a DLL.
-struct PEModuleInfo {
-  // The basename of the PE file.
-  wstring code_file;
-
-  // The PE file's code identifier, which consists of its timestamp
-  // and file size concatenated together into a single hex string.
-  // (The fields IMAGE_OPTIONAL_HEADER::SizeOfImage and
-  // IMAGE_FILE_HEADER::TimeDateStamp, as defined in the ImageHlp
-  // documentation.) This is not well documented, if it's documented
-  // at all, but it's what symstore does and what DbgHelp supports.
-  wstring code_identifier;
-};
+using std::unordered_map;
 
 class PDBSourceLineWriter {
  public:
@@ -99,20 +65,24 @@ class PDBSourceLineWriter {
   // file must be available; Open will be if it is not.
   // If there is already a pdb file open, it is automatically closed.
   // Returns true on success.
-  bool Open(const wstring &file, FileFormat format);
-
-  // Locates the pdb file for the given executable (exe or dll) file,
-  // and opens it.  If there is already a pdb file open, it is automatically
-  // closed.  Returns true on success.
-  bool OpenExecutable(const wstring &exe_file);
-
-  // Writes a map file from the current pdb file to the given file stream.
-  // Returns true on success.
-  bool WriteMap(FILE *map_file);
+  bool Open(const wstring& file, FileFormat format);
 
   // Closes the current pdb file and its associated resources.
   void Close();
 
+  // Sets the code file full path.  This is optional for 32-bit modules.  It is
+  // also optional for 64-bit modules when there is an executable file stored
+  // in the same directory as the PDB file.  It is only required for 64-bit
+  // modules when the executable file is not in the same location as the PDB
+  // file and it must be called after Open() and before WriteMap().
+  // If Open() was called for an executable file, then it is an error to call
+  // SetCodeFile() with a different file path and it will return false.
+  bool SetCodeFile(const wstring& exe_file);
+
+  // Writes a Breakpad symbol file from the current pdb file to |symbol_file|.
+  // Returns true on success.
+  bool WriteSymbols(FILE *symbol_file);
+
   // Retrieves information about the module's debugging file.  Returns
   // true on success and false on failure.
   bool GetModuleInfo(PDBModuleInfo *info);
@@ -134,11 +104,12 @@ class PDBSourceLineWriter {
   bool PrintLines(IDiaEnumLineNumbers *lines);
 
   // Outputs a function address and name, followed by its source line list.
-  // block can be the same object as function, or it can be a reference
-  // to a code block that is lexically part of this function, but
-  // resides at a separate address.
-  // Returns true on success.
-  bool PrintFunction(IDiaSymbol *function, IDiaSymbol *block);
+  // block can be the same object as function, or it can be a reference to a
+  // code block that is lexically part of this function, but resides at a
+  // separate address. If has_multiple_symbols is true, this function's
+  // instructions correspond to multiple symbols. Returns true on success.
+  bool PrintFunction(IDiaSymbol *function, IDiaSymbol *block,
+                     bool has_multiple_symbols);
 
   // Outputs all functions as described above.  Returns true on success.
   bool PrintFunctions();
@@ -147,14 +118,26 @@ class PDBSourceLineWriter {
   // Returns true on success.
   bool PrintSourceFiles();
 
+  // Outputs all of the frame information necessary to construct stack
+  // backtraces in the absence of frame pointers. For x86 data stored in
+  // .pdb files. Returns true on success.
+  bool PrintFrameDataUsingPDB();
+
+  // Outputs all of the frame information necessary to construct stack
+  // backtraces in the absence of frame pointers. For x64 data stored in
+  // .exe, .dll files. Returns true on success.
+  bool PrintFrameDataUsingEXE();
+
   // Outputs all of the frame information necessary to construct stack
   // backtraces in the absence of frame pointers.  Returns true on success.
   bool PrintFrameData();
 
   // Outputs a single public symbol address and name, if the symbol corresponds
   // to a code address.  Returns true on success.  If symbol is does not
-  // correspond to code, returns true without outputting anything.
-  bool PrintCodePublicSymbol(IDiaSymbol *symbol);
+  // correspond to code, returns true without outputting anything. If
+  // has_multiple_symbols is true, the symbol corresponds to a code address and
+  // the instructions correspond to multiple symbols.
+  bool PrintCodePublicSymbol(IDiaSymbol *symbol, bool has_multiple_symbols);
 
   // Outputs a line identifying the PDB file that is being dumped, along with
   // its uuid and age.
@@ -167,34 +150,34 @@ class PDBSourceLineWriter {
 
   // Returns true if this filename has already been seen,
   // and an ID is stored for it, or false if it has not.
-  bool FileIDIsCached(const wstring &file) {
+  bool FileIDIsCached(const wstring& file) {
     return unique_files_.find(file) != unique_files_.end();
-  };
+  }
 
   // Cache this filename and ID for later reuse.
-  void CacheFileID(const wstring &file, DWORD id) {
+  void CacheFileID(const wstring& file, DWORD id) {
     unique_files_[file] = id;
-  };
+  }
 
   // Store this ID in the cache as a duplicate for this filename.
-  void StoreDuplicateFileID(const wstring &file, DWORD id) {
-    hash_map<wstring, DWORD>::iterator iter = unique_files_.find(file);
+  void StoreDuplicateFileID(const wstring& file, DWORD id) {
+    unordered_map<wstring, DWORD>::iterator iter = unique_files_.find(file);
     if (iter != unique_files_.end()) {
       // map this id to the previously seen one
       file_ids_[id] = iter->second;
     }
-  };
+  }
 
   // Given a file's unique ID, return the ID that should be used to
   // reference it. There may be multiple files with identical filenames
   // but different unique IDs. The cache attempts to coalesce these into
   // one ID per unique filename.
   DWORD GetRealFileID(DWORD id) {
-    hash_map<DWORD, DWORD>::iterator iter = file_ids_.find(id);
+    unordered_map<DWORD, DWORD>::iterator iter = file_ids_.find(id);
     if (iter == file_ids_.end())
       return id;
     return iter->second;
-  };
+  }
 
   // Find the PE file corresponding to the loaded PDB file, and
   // set the code_file_ member. Returns false on failure.
@@ -226,9 +209,9 @@ class PDBSourceLineWriter {
   // There may be many duplicate filenames with different IDs.
   // This maps from the DIA "unique ID" to a single ID per unique
   // filename.
-  hash_map<DWORD, DWORD> file_ids_;
+  unordered_map<DWORD, DWORD> file_ids_;
   // This maps unique filenames to file IDs.
-  hash_map<wstring, DWORD> unique_files_;
+  unordered_map<wstring, DWORD> unique_files_;
 
   // This is used for calculating post-transform symbol addresses and lengths.
   ImageMap image_map_;
@@ -240,4 +223,4 @@ class PDBSourceLineWriter {
 
 }  // namespace google_breakpad
 
-#endif  // _PDB_SOURCE_LINE_WRITER_H__
+#endif  // COMMON_WINDOWS_PDB_SOURCE_LINE_WRITER_H_
diff --git a/src/MEGASync/google_breakpad/common/windows/pe_source_line_writer.cc b/src/MEGASync/google_breakpad/common/windows/pe_source_line_writer.cc
new file mode 100644
index 00000000..09d75ddc
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/windows/pe_source_line_writer.cc
@@ -0,0 +1,77 @@
+// Copyright (c) 2019, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "common/windows/pe_source_line_writer.h"
+
+#include "common/windows/pe_util.h"
+
+namespace google_breakpad {
+PESourceLineWriter::PESourceLineWriter(const wstring& pe_file) :
+  pe_file_(pe_file) {
+}
+
+PESourceLineWriter::~PESourceLineWriter() {
+}
+
+bool PESourceLineWriter::WriteSymbols(FILE* symbol_file) {
+  PDBModuleInfo module_info;
+  if (!GetModuleInfo(&module_info)) {
+    return false;
+  }
+  // Hard-code "windows" for the OS because that's the only thing that makes
+  // sense for PDB files.  (This might not be strictly correct for Windows CE
+  // support, but we don't care about that at the moment.)
+  fprintf(symbol_file, "MODULE windows %ws %ws %ws\n",
+    module_info.cpu.c_str(), module_info.debug_identifier.c_str(),
+    module_info.debug_file.c_str());
+
+  PEModuleInfo pe_info;
+  if (!GetPEInfo(&pe_info)) {
+    return false;
+  }
+  fprintf(symbol_file, "INFO CODE_ID %ws %ws\n",
+    pe_info.code_identifier.c_str(),
+    pe_info.code_file.c_str());
+
+  if (!PrintPEFrameData(pe_file_, symbol_file)) {
+    return false;
+  }
+
+  return true;
+}
+
+bool PESourceLineWriter::GetModuleInfo(PDBModuleInfo* info) {
+  return ReadModuleInfo(pe_file_, info);
+}
+
+bool PESourceLineWriter::GetPEInfo(PEModuleInfo* info) {
+  return ReadPEInfo(pe_file_, info);
+}
+
+}  // namespace google_breakpad
diff --git a/src/MEGASync/google_breakpad/common/windows/pe_source_line_writer.h b/src/MEGASync/google_breakpad/common/windows/pe_source_line_writer.h
new file mode 100644
index 00000000..7e95eb61
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/windows/pe_source_line_writer.h
@@ -0,0 +1,69 @@
+// Copyright (c) 2019, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef COMMON_WINDOWS_PE_SOURCE_LINE_WRITER_H_
+#define COMMON_WINDOWS_PE_SOURCE_LINE_WRITER_H_
+
+#include <string>
+
+#include "common/basictypes.h"
+#include "common/windows/module_info.h"
+
+namespace google_breakpad {
+
+using std::wstring;
+
+// PESourceLineWriter uses a pe file produced by Visual C++ to output
+// a line/address map for use with BasicSourceLineResolver.
+// NOTE: Only supports PE32+ format, ie. a 64bit PE file.
+class PESourceLineWriter {
+public:
+  explicit PESourceLineWriter(const wstring& pe_file);
+  ~PESourceLineWriter();
+
+  // Writes Breakpad symbols from the pe file to |symbol_file|.
+  // Returns true on success.
+  bool WriteSymbols(FILE* symbol_file);
+
+  // Retrieves information about the module. Returns true on success.
+  bool GetModuleInfo(PDBModuleInfo* info);
+
+  // Retrieves information about the module's PE file.  Returns
+  // true on success.
+  bool GetPEInfo(PEModuleInfo* info);
+
+private:
+  const wstring pe_file_;
+
+  DISALLOW_COPY_AND_ASSIGN(PESourceLineWriter);
+};
+
+}  // namespace google_breakpad
+
+#endif  // COMMON_WINDOWS_PE_SOURCE_LINE_WRITER_H_
diff --git a/src/MEGASync/google_breakpad/common/windows/pe_util.cc b/src/MEGASync/google_breakpad/common/windows/pe_util.cc
new file mode 100644
index 00000000..7dcfa7c9
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/windows/pe_util.cc
@@ -0,0 +1,407 @@
+// Copyright (c) 2019, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "pe_util.h"
+
+#include <windows.h>
+#include <winnt.h>
+#include <atlbase.h>
+#include <ImageHlp.h>
+
+#include <functional>
+
+#include "common/windows/string_utils-inl.h"
+#include "common/windows/guid_string.h"
+
+namespace {
+
+/*
+ * Not defined in WinNT.h for some reason. Definitions taken from:
+ * http://uninformed.org/index.cgi?v=4&a=1&p=13
+ *
+ */
+typedef unsigned char UBYTE;
+
+#if !defined(_WIN64)
+#define UNW_FLAG_EHANDLER  0x01
+#define UNW_FLAG_UHANDLER  0x02
+#define UNW_FLAG_CHAININFO 0x04
+#endif
+
+union UnwindCode {
+  struct {
+    UBYTE offset_in_prolog;
+    UBYTE unwind_operation_code : 4;
+    UBYTE operation_info : 4;
+  };
+  USHORT frame_offset;
+};
+
+enum UnwindOperationCodes {
+  UWOP_PUSH_NONVOL = 0, /* info == register number */
+  UWOP_ALLOC_LARGE,     /* no info, alloc size in next 2 slots */
+  UWOP_ALLOC_SMALL,     /* info == size of allocation / 8 - 1 */
+  UWOP_SET_FPREG,       /* no info, FP = RSP + UNWIND_INFO.FPRegOffset*16 */
+  UWOP_SAVE_NONVOL,     /* info == register number, offset in next slot */
+  UWOP_SAVE_NONVOL_FAR, /* info == register number, offset in next 2 slots */
+  // XXX: these are missing from MSDN!
+  // See: http://www.osronline.com/ddkx/kmarch/64bitamd_4rs7.htm
+  UWOP_SAVE_XMM,
+  UWOP_SAVE_XMM_FAR,
+  UWOP_SAVE_XMM128,     /* info == XMM reg number, offset in next slot */
+  UWOP_SAVE_XMM128_FAR, /* info == XMM reg number, offset in next 2 slots */
+  UWOP_PUSH_MACHFRAME   /* info == 0: no error-code, 1: error-code */
+};
+
+// See: http://msdn.microsoft.com/en-us/library/ddssxxy8.aspx
+// Note: some fields removed as we don't use them.
+struct UnwindInfo {
+  UBYTE version : 3;
+  UBYTE flags : 5;
+  UBYTE size_of_prolog;
+  UBYTE count_of_codes;
+  UBYTE frame_register : 4;
+  UBYTE frame_offset : 4;
+  UnwindCode unwind_code[1];
+};
+
+struct CV_INFO_PDB70 {
+  ULONG cv_signature;
+  GUID signature;
+  ULONG age;
+  CHAR pdb_filename[ANYSIZE_ARRAY];
+};
+
+#define CV_SIGNATURE_RSDS 'SDSR'
+
+// A helper class to scope a PLOADED_IMAGE.
+class AutoImage {
+public:
+  explicit AutoImage(PLOADED_IMAGE img) : img_(img) {}
+  ~AutoImage() {
+    if (img_)
+      ImageUnload(img_);
+  }
+
+  operator PLOADED_IMAGE() { return img_; }
+  PLOADED_IMAGE operator->() { return img_; }
+
+private:
+  PLOADED_IMAGE img_;
+};
+}  // namespace
+
+namespace google_breakpad {
+
+using std::unique_ptr;
+using google_breakpad::GUIDString;
+
+bool ReadModuleInfo(const wstring & pe_file, PDBModuleInfo * info) {
+  // Convert wchar to native charset because ImageLoad only takes
+  // a PSTR as input.
+  string img_file;
+  if (!WindowsStringUtils::safe_wcstombs(pe_file, &img_file)) {
+    fprintf(stderr, "Image path '%S' contains unrecognized characters.\n",
+        pe_file.c_str());
+    return false;
+  }
+
+  AutoImage img(ImageLoad((PSTR)img_file.c_str(), NULL));
+  if (!img) {
+    fprintf(stderr, "Failed to load %s\n", img_file.c_str());
+    return false;
+  }
+
+  info->cpu = FileHeaderMachineToCpuString(
+      img->FileHeader->FileHeader.Machine);
+
+  PIMAGE_OPTIONAL_HEADER64 optional_header =
+      &(reinterpret_cast<PIMAGE_NT_HEADERS64>(img->FileHeader))->OptionalHeader;
+
+  // Search debug directories for a guid signature & age
+  DWORD debug_rva = optional_header->
+    DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress;
+  DWORD debug_size = optional_header->
+    DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size;
+  PIMAGE_DEBUG_DIRECTORY debug_directories =
+    static_cast<PIMAGE_DEBUG_DIRECTORY>(
+      ImageRvaToVa(img->FileHeader,
+        img->MappedAddress,
+        debug_rva,
+        &img->LastRvaSection));
+
+  for (DWORD i = 0; i < debug_size / sizeof(*debug_directories); i++) {
+    if (debug_directories[i].Type != IMAGE_DEBUG_TYPE_CODEVIEW ||
+        debug_directories[i].SizeOfData < sizeof(CV_INFO_PDB70)) {
+      continue;
+    }
+
+    struct CV_INFO_PDB70* cv_info = static_cast<CV_INFO_PDB70*>(ImageRvaToVa(
+        img->FileHeader,
+        img->MappedAddress,
+        debug_directories[i].AddressOfRawData,
+        &img->LastRvaSection));
+    if (cv_info->cv_signature != CV_SIGNATURE_RSDS) {
+      continue;
+    }
+
+    info->debug_identifier = GenerateDebugIdentifier(cv_info->age,
+        cv_info->signature);
+
+    // This code assumes that the pdb_filename is stored as ASCII without
+    // multibyte characters, but it's not clear if that's true.
+    size_t debug_file_length = strnlen_s(cv_info->pdb_filename, MAX_PATH);
+    if (debug_file_length < 0 || debug_file_length >= MAX_PATH) {
+      fprintf(stderr, "PE debug directory is corrupt.\n");
+      return false;
+    }
+    std::string debug_file(cv_info->pdb_filename, debug_file_length);
+    if (!WindowsStringUtils::safe_mbstowcs(debug_file, &info->debug_file)) {
+      fprintf(stderr, "PDB filename '%s' contains unrecognized characters.\n",
+          debug_file.c_str());
+      return false;
+    }
+    info->debug_file = WindowsStringUtils::GetBaseName(info->debug_file);
+
+    return true;
+  }
+
+  fprintf(stderr, "Image is missing debug information.\n");
+  return false;
+}
+
+bool ReadPEInfo(const wstring & pe_file, PEModuleInfo * info) {
+  // Convert wchar to native charset because ImageLoad only takes
+  // a PSTR as input.
+  string img_file;
+  if (!WindowsStringUtils::safe_wcstombs(pe_file, &img_file)) {
+    fprintf(stderr, "Image path '%S' contains unrecognized characters.\n",
+        pe_file.c_str());
+    return false;
+  }
+
+  AutoImage img(ImageLoad((PSTR)img_file.c_str(), NULL));
+  if (!img) {
+    fprintf(stderr, "Failed to open PE file: %S\n", pe_file.c_str());
+    return false;
+  }
+
+  info->code_file = WindowsStringUtils::GetBaseName(pe_file);
+
+  // The date and time that the file was created by the linker.
+  DWORD TimeDateStamp = img->FileHeader->FileHeader.TimeDateStamp;
+  // The size of the file in bytes, including all headers.
+  DWORD SizeOfImage = 0;
+  PIMAGE_OPTIONAL_HEADER64 opt =
+    &((PIMAGE_NT_HEADERS64)img->FileHeader)->OptionalHeader;
+  if (opt->Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
+    // 64-bit PE file.
+    SizeOfImage = opt->SizeOfImage;
+  }
+  else {
+    // 32-bit PE file.
+    SizeOfImage = img->FileHeader->OptionalHeader.SizeOfImage;
+  }
+  wchar_t code_identifier[32];
+  swprintf(code_identifier,
+    sizeof(code_identifier) / sizeof(code_identifier[0]),
+    L"%08X%X", TimeDateStamp, SizeOfImage);
+  info->code_identifier = code_identifier;
+
+  return true;
+}
+
+bool PrintPEFrameData(const wstring & pe_file, FILE * out_file)
+{
+  // Convert wchar to native charset because ImageLoad only takes
+  // a PSTR as input.
+  string img_file;
+  if (!WindowsStringUtils::safe_wcstombs(pe_file, &img_file)) {
+    fprintf(stderr, "Image path '%S' contains unrecognized characters.\n",
+        pe_file.c_str());
+    return false;
+  }
+
+  AutoImage img(ImageLoad((PSTR)img_file.c_str(), NULL));
+  if (!img) {
+    fprintf(stderr, "Failed to load %s\n", img_file.c_str());
+    return false;
+  }
+  PIMAGE_OPTIONAL_HEADER64 optional_header =
+    &(reinterpret_cast<PIMAGE_NT_HEADERS64>(img->FileHeader))->OptionalHeader;
+  if (optional_header->Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
+    fprintf(stderr, "Not a PE32+ image\n");
+    return false;
+  }
+
+  // Read Exception Directory
+  DWORD exception_rva = optional_header->
+    DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].VirtualAddress;
+  DWORD exception_size = optional_header->
+    DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].Size;
+  PIMAGE_RUNTIME_FUNCTION_ENTRY funcs =
+    static_cast<PIMAGE_RUNTIME_FUNCTION_ENTRY>(
+      ImageRvaToVa(img->FileHeader,
+        img->MappedAddress,
+        exception_rva,
+        &img->LastRvaSection));
+  for (DWORD i = 0; i < exception_size / sizeof(*funcs); i++) {
+    DWORD unwind_rva = funcs[i].UnwindInfoAddress;
+    // handle chaining
+    while (unwind_rva & 0x1) {
+      unwind_rva ^= 0x1;
+      PIMAGE_RUNTIME_FUNCTION_ENTRY chained_func =
+        static_cast<PIMAGE_RUNTIME_FUNCTION_ENTRY>(
+          ImageRvaToVa(img->FileHeader,
+            img->MappedAddress,
+            unwind_rva,
+            &img->LastRvaSection));
+      unwind_rva = chained_func->UnwindInfoAddress;
+    }
+
+    UnwindInfo *unwind_info = static_cast<UnwindInfo*>(
+      ImageRvaToVa(img->FileHeader,
+        img->MappedAddress,
+        unwind_rva,
+        &img->LastRvaSection));
+
+    DWORD stack_size = 8;  // minimal stack size is 8 for RIP
+    DWORD rip_offset = 8;
+    do {
+      for (UBYTE c = 0; c < unwind_info->count_of_codes; c++) {
+        UnwindCode *unwind_code = &unwind_info->unwind_code[c];
+        switch (unwind_code->unwind_operation_code) {
+        case UWOP_PUSH_NONVOL: {
+          stack_size += 8;
+          break;
+        }
+        case UWOP_ALLOC_LARGE: {
+          if (unwind_code->operation_info == 0) {
+            c++;
+            if (c < unwind_info->count_of_codes)
+              stack_size += (unwind_code + 1)->frame_offset * 8;
+          }
+          else {
+            c += 2;
+            if (c < unwind_info->count_of_codes)
+              stack_size += (unwind_code + 1)->frame_offset |
+              ((unwind_code + 2)->frame_offset << 16);
+          }
+          break;
+        }
+        case UWOP_ALLOC_SMALL: {
+          stack_size += unwind_code->operation_info * 8 + 8;
+          break;
+        }
+        case UWOP_SET_FPREG:
+        case UWOP_SAVE_XMM:
+        case UWOP_SAVE_XMM_FAR:
+          break;
+        case UWOP_SAVE_NONVOL:
+        case UWOP_SAVE_XMM128: {
+          c++;  // skip slot with offset
+          break;
+        }
+        case UWOP_SAVE_NONVOL_FAR:
+        case UWOP_SAVE_XMM128_FAR: {
+          c += 2;  // skip 2 slots with offset
+          break;
+        }
+        case UWOP_PUSH_MACHFRAME: {
+          if (unwind_code->operation_info) {
+            stack_size += 88;
+          }
+          else {
+            stack_size += 80;
+          }
+          rip_offset += 80;
+          break;
+        }
+        }
+      }
+      if (unwind_info->flags & UNW_FLAG_CHAININFO) {
+        PIMAGE_RUNTIME_FUNCTION_ENTRY chained_func =
+          reinterpret_cast<PIMAGE_RUNTIME_FUNCTION_ENTRY>(
+          (unwind_info->unwind_code +
+            ((unwind_info->count_of_codes + 1) & ~1)));
+
+        unwind_info = static_cast<UnwindInfo*>(
+          ImageRvaToVa(img->FileHeader,
+            img->MappedAddress,
+            chained_func->UnwindInfoAddress,
+            &img->LastRvaSection));
+      }
+      else {
+        unwind_info = NULL;
+      }
+    } while (unwind_info);
+    fprintf(out_file, "STACK CFI INIT %lx %lx .cfa: $rsp .ra: .cfa %lu - ^\n",
+      funcs[i].BeginAddress,
+      funcs[i].EndAddress - funcs[i].BeginAddress, rip_offset);
+    fprintf(out_file, "STACK CFI %lx .cfa: $rsp %lu +\n",
+      funcs[i].BeginAddress, stack_size);
+  }
+
+  return true;
+}
+
+wstring GenerateDebugIdentifier(DWORD age, GUID signature)
+{
+  // Use the same format that the MS symbol server uses in filesystem
+  // hierarchies.
+  wchar_t age_string[9];
+  swprintf(age_string, sizeof(age_string) / sizeof(age_string[0]),
+    L"%x", age);
+
+  // remove when VC++7.1 is no longer supported
+  age_string[sizeof(age_string) / sizeof(age_string[0]) - 1] = L'\0';
+
+  wstring debug_identifier = GUIDString::GUIDToSymbolServerWString(&signature);
+  debug_identifier.append(age_string);
+
+  return debug_identifier;
+}
+
+wstring GenerateDebugIdentifier(DWORD age, DWORD signature)
+{
+  // Use the same format that the MS symbol server uses in filesystem
+  // hierarchies.
+  wchar_t identifier_string[17];
+  swprintf(identifier_string,
+    sizeof(identifier_string) / sizeof(identifier_string[0]),
+    L"%08X%x", signature, age);
+
+  // remove when VC++7.1 is no longer supported
+  identifier_string[sizeof(identifier_string) /
+    sizeof(identifier_string[0]) - 1] = L'\0';
+
+  return wstring(identifier_string);
+}
+
+}  // namespace google_breakpad
diff --git a/src/MEGASync/google_breakpad/common/windows/pe_util.h b/src/MEGASync/google_breakpad/common/windows/pe_util.h
new file mode 100644
index 00000000..ec2c6830
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/windows/pe_util.h
@@ -0,0 +1,78 @@
+// Copyright (c) 2019, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef COMMON_WINDOWS_PE_UTIL_H_
+#define COMMON_WINDOWS_PE_UTIL_H_
+
+#include <windows.h>
+
+#include "common/windows/module_info.h"
+
+namespace google_breakpad {
+
+using std::wstring;
+
+// Reads |pe_file| and populates |info|. Returns true on success.
+// Only supports PE32+ format, ie. a 64bit PE file.
+// Will fail if |pe_file| does not contain a valid CodeView record.
+bool ReadModuleInfo(const wstring& pe_file, PDBModuleInfo* info);
+
+// Reads |pe_file| and populates |info|. Returns true on success.
+bool ReadPEInfo(const wstring& pe_file, PEModuleInfo* info);
+
+// Reads |pe_file| and prints frame data (aka. unwind info) to |out_file|.
+// Only supports PE32+ format, ie. a 64bit PE file.
+bool PrintPEFrameData(const wstring& pe_file, FILE* out_file);
+
+// Combines a GUID |signature| and DWORD |age| to create a Breakpad debug
+// identifier.
+wstring GenerateDebugIdentifier(DWORD age, GUID signature);
+
+// Combines a DWORD |signature| and DWORD |age| to create a Breakpad debug
+// identifier.
+wstring GenerateDebugIdentifier(DWORD age, DWORD signature);
+
+// Converts |machine| enum value to the corresponding string used by Breakpad.
+// The enum is IMAGE_FILE_MACHINE_*, contained in winnt.h.
+constexpr const wchar_t* FileHeaderMachineToCpuString(WORD machine) {
+  switch (machine) {
+    case IMAGE_FILE_MACHINE_I386: {
+      return L"x86";
+    }
+    case IMAGE_FILE_MACHINE_IA64:
+    case IMAGE_FILE_MACHINE_AMD64: {
+      return L"x86_64";
+    }
+    default: { return L"unknown"; }
+  }
+}
+
+}  // namespace google_breakpad
+
+#endif  // COMMON_WINDOWS_PE_UTIL_H_
diff --git a/src/MEGASync/google_breakpad/common/windows/string_utils-inl.h b/src/MEGASync/google_breakpad/common/windows/string_utils-inl.h
index d281aaa1..935e19f5 100644
--- a/src/MEGASync/google_breakpad/common/windows/string_utils-inl.h
+++ b/src/MEGASync/google_breakpad/common/windows/string_utils-inl.h
@@ -30,8 +30,8 @@
 // string_utils-inl.h: Safer string manipulation on Windows, supporting
 // pre-MSVC8 environments.
 
-#ifndef COMMON_WINDOWS_STRING_UTILS_INL_H__
-#define COMMON_WINDOWS_STRING_UTILS_INL_H__
+#ifndef COMMON_WINDOWS_STRING_UTILS_INL_H_
+#define COMMON_WINDOWS_STRING_UTILS_INL_H_
 
 #include <stdarg.h>
 #include <wchar.h>
@@ -72,26 +72,26 @@ class WindowsStringUtils {
   // Roughly equivalent to MSVC8's wcscpy_s, except pre-MSVC8, this does
   // not fail if source is longer than destination_size.  The destination
   // buffer is always 0-terminated.
-  static void safe_wcscpy(wchar_t *destination, size_t destination_size,
-                          const wchar_t *source);
+  static void safe_wcscpy(wchar_t* destination, size_t destination_size,
+                          const wchar_t* source);
 
   // Roughly equivalent to MSVC8's wcsncpy_s, except that _TRUNCATE cannot
   // be passed directly, and pre-MSVC8, this will not fail if source or count
   // are longer than destination_size.  The destination buffer is always
   // 0-terminated.
-  static void safe_wcsncpy(wchar_t *destination, size_t destination_size,
-                           const wchar_t *source, size_t count);
+  static void safe_wcsncpy(wchar_t* destination, size_t destination_size,
+                           const wchar_t* source, size_t count);
 
   // Performs multi-byte to wide character conversion on C++ strings, using
   // mbstowcs_s (MSVC8) or mbstowcs (pre-MSVC8).  Returns false on failure,
   // without setting wcs.
-  static bool safe_mbstowcs(const string &mbs, wstring *wcs);
+  static bool safe_mbstowcs(const string& mbs, wstring* wcs);
 
   // The inverse of safe_mbstowcs.
-  static bool safe_wcstombs(const wstring &wcs, string *mbs);
+  static bool safe_wcstombs(const wstring& wcs, string* mbs);
 
   // Returns the base name of a file, e.g. strips off the path.
-  static wstring GetBaseName(const wstring &filename);
+  static wstring GetBaseName(const wstring& filename);
 
  private:
   // Disallow instantiation and other object-based operations.
@@ -102,9 +102,9 @@ class WindowsStringUtils {
 };
 
 // static
-inline void WindowsStringUtils::safe_wcscpy(wchar_t *destination,
+inline void WindowsStringUtils::safe_wcscpy(wchar_t* destination,
                                             size_t destination_size,
-                                            const wchar_t *source) {
+                                            const wchar_t* source) {
 #if _MSC_VER >= 1400  // MSVC 2005/8
   wcscpy_s(destination, destination_size, source);
 #else  // _MSC_VER >= 1400
@@ -118,9 +118,9 @@ inline void WindowsStringUtils::safe_wcscpy(wchar_t *destination,
 }
 
 // static
-inline void WindowsStringUtils::safe_wcsncpy(wchar_t *destination,
+inline void WindowsStringUtils::safe_wcsncpy(wchar_t* destination,
                                              size_t destination_size,
-                                             const wchar_t *source,
+                                             const wchar_t* source,
                                              size_t count) {
 #if _MSC_VER >= 1400  // MSVC 2005/8
   wcsncpy_s(destination, destination_size, source, count);
@@ -139,4 +139,4 @@ inline void WindowsStringUtils::safe_wcsncpy(wchar_t *destination,
 
 }  // namespace google_breakpad
 
-#endif  // COMMON_WINDOWS_STRING_UTILS_INL_H__
+#endif  // COMMON_WINDOWS_STRING_UTILS_INL_H_
diff --git a/src/MEGASync/google_breakpad/common/windows/string_utils.cc b/src/MEGASync/google_breakpad/common/windows/string_utils.cc
index e6ffa082..90aab038 100644
--- a/src/MEGASync/google_breakpad/common/windows/string_utils.cc
+++ b/src/MEGASync/google_breakpad/common/windows/string_utils.cc
@@ -35,7 +35,7 @@
 namespace google_breakpad {
 
 // static
-wstring WindowsStringUtils::GetBaseName(const wstring &filename) {
+wstring WindowsStringUtils::GetBaseName(const wstring& filename) {
   wstring base_name(filename);
   size_t slash_pos = base_name.find_last_of(L"/\\");
   if (slash_pos != wstring::npos) {
@@ -45,7 +45,7 @@ wstring WindowsStringUtils::GetBaseName(const wstring &filename) {
 }
 
 // static
-bool WindowsStringUtils::safe_mbstowcs(const string &mbs, wstring *wcs) {
+bool WindowsStringUtils::safe_mbstowcs(const string& mbs, wstring* wcs) {
   assert(wcs);
 
   // First, determine the length of the destination buffer.
@@ -58,7 +58,7 @@ bool WindowsStringUtils::safe_mbstowcs(const string &mbs, wstring *wcs) {
   }
   assert(wcs_length > 0);
 #else  // _MSC_VER >= 1400
-  if ((wcs_length = mbstowcs(NULL, mbs.c_str(), mbs.length())) < 0) {
+  if ((wcs_length = mbstowcs(NULL, mbs.c_str(), mbs.length())) == (size_t)-1) {
     return false;
   }
 
@@ -75,7 +75,7 @@ bool WindowsStringUtils::safe_mbstowcs(const string &mbs, wstring *wcs) {
     return false;
   }
 #else  // _MSC_VER >= 1400
-  if (mbstowcs(&wcs_v[0], mbs.c_str(), mbs.length()) < 0) {
+  if (mbstowcs(&wcs_v[0], mbs.c_str(), mbs.length()) == (size_t)-1) {
     return false;
   }
 
@@ -88,7 +88,7 @@ bool WindowsStringUtils::safe_mbstowcs(const string &mbs, wstring *wcs) {
 }
 
 // static
-bool WindowsStringUtils::safe_wcstombs(const wstring &wcs, string *mbs) {
+bool WindowsStringUtils::safe_wcstombs(const wstring& wcs, string* mbs) {
   assert(mbs);
 
   // First, determine the length of the destination buffer.
@@ -101,7 +101,7 @@ bool WindowsStringUtils::safe_wcstombs(const wstring &wcs, string *mbs) {
   }
   assert(mbs_length > 0);
 #else  // _MSC_VER >= 1400
-  if ((mbs_length = wcstombs(NULL, wcs.c_str(), wcs.length())) < 0) {
+  if ((mbs_length = wcstombs(NULL, wcs.c_str(), wcs.length())) == (size_t)-1) {
     return false;
   }
 
@@ -118,7 +118,7 @@ bool WindowsStringUtils::safe_wcstombs(const wstring &wcs, string *mbs) {
     return false;
   }
 #else  // _MSC_VER >= 1400
-  if (wcstombs(&mbs_v[0], wcs.c_str(), wcs.length()) < 0) {
+  if (wcstombs(&mbs_v[0], wcs.c_str(), wcs.length()) == (size_t)-1) {
     return false;
   }
 
diff --git a/src/MEGASync/google_breakpad/common/windows/symbol_collector_client.cc b/src/MEGASync/google_breakpad/common/windows/symbol_collector_client.cc
new file mode 100644
index 00000000..30c663ed
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/windows/symbol_collector_client.cc
@@ -0,0 +1,155 @@
+#include "common/windows/symbol_collector_client.h"
+
+#include <stdio.h>
+
+#include <regex>
+
+#include "common/windows/http_upload.h"
+
+namespace google_breakpad {
+
+  // static
+  bool SymbolCollectorClient::CreateUploadUrl(
+      wstring& api_url,
+      wstring& api_key,
+      UploadUrlResponse *uploadUrlResponse) {
+    wstring url = api_url +
+        L"/v1/uploads:create"
+        L"?key=" + api_key;
+    wstring response;
+    int response_code;
+
+    if (!HTTPUpload::SendSimplePostRequest(
+        url,
+        L"",
+        L"",
+        NULL,
+        &response,
+        &response_code)) {
+      wprintf(L"Failed to create upload url.\n");
+      wprintf(L"Response code: %ld\n", response_code);
+      wprintf(L"Response:\n");
+      wprintf(L"%s\n", response.c_str());
+      return false;
+    }
+
+    // Note camel-case rather than underscores.
+    std::wregex upload_url_regex(L"\"uploadUrl\": \"([^\"]+)\"");
+    std::wregex upload_key_regex(L"\"uploadKey\": \"([^\"]+)\"");
+
+    std::wsmatch upload_url_match;
+    if (!std::regex_search(response, upload_url_match, upload_url_regex) ||
+        upload_url_match.size() != 2) {
+      wprintf(L"Failed to parse create url response.");
+      wprintf(L"Response:\n");
+      wprintf(L"%s\n", response.c_str());
+      return false;
+    }
+    wstring upload_url = upload_url_match[1].str();
+
+    std::wsmatch upload_key_match;
+    if (!std::regex_search(response, upload_key_match, upload_key_regex) ||
+        upload_key_match.size() != 2) {
+      wprintf(L"Failed to parse create url response.");
+      wprintf(L"Response:\n");
+      wprintf(L"%s\n", response.c_str());
+      return false;
+    }
+    wstring upload_key = upload_key_match[1].str();
+
+    uploadUrlResponse->upload_url = upload_url;
+    uploadUrlResponse->upload_key = upload_key;
+    return true;
+  }
+
+  // static
+  CompleteUploadResult SymbolCollectorClient::CompleteUpload(
+      wstring& api_url,
+      wstring& api_key,
+      const wstring& upload_key,
+      const wstring& debug_file,
+      const wstring& debug_id) {
+    wstring url = api_url +
+        L"/v1/uploads/" + upload_key + L":complete"
+        L"?key=" + api_key;
+    wstring body =
+        L"{ symbol_id: {"
+        L"debug_file: \"" + debug_file + L"\", "
+        L"debug_id: \"" + debug_id + L"\" "
+        L"} }";
+    wstring response;
+    int response_code;
+
+    if (!HTTPUpload::SendSimplePostRequest(
+        url,
+        body,
+        L"application/json",
+        NULL,
+        &response,
+        &response_code)) {
+      wprintf(L"Failed to complete upload.\n");
+      wprintf(L"Response code: %ld\n", response_code);
+      wprintf(L"Response:\n");
+      wprintf(L"%s\n", response.c_str());
+      return CompleteUploadResult::Error;
+    }
+
+    std::wregex result_regex(L"\"result\": \"([^\"]+)\"");
+    std::wsmatch result_match;
+    if (!std::regex_search(response, result_match, result_regex) ||
+        result_match.size() != 2) {
+      wprintf(L"Failed to parse complete upload response.");
+      wprintf(L"Response:\n");
+      wprintf(L"%s\n", response.c_str());
+      return CompleteUploadResult::Error;
+    }
+    wstring result = result_match[1].str();
+
+    if (result.compare(L"DUPLICATE_DATA") == 0) {
+      return CompleteUploadResult::DuplicateData;
+    }
+
+    return CompleteUploadResult::Ok;
+  }
+
+  // static
+  SymbolStatus SymbolCollectorClient::CheckSymbolStatus(
+      wstring& api_url,
+      wstring& api_key,
+      const wstring& debug_file,
+      const wstring& debug_id) {
+    wstring response;
+    int response_code;
+    wstring url = api_url +
+        L"/v1/symbols/" + debug_file + L"/" + debug_id + L":checkStatus"
+        L"?key=" + api_key;
+
+    if (!HTTPUpload::SendGetRequest(
+        url,
+        NULL,
+        &response,
+        &response_code)) {
+      wprintf(L"Failed to check symbol status.\n");
+      wprintf(L"Response code: %ld\n", response_code);
+      wprintf(L"Response:\n");
+      wprintf(L"%s\n", response.c_str());
+      return SymbolStatus::Unknown;
+    }
+
+    std::wregex status_regex(L"\"status\": \"([^\"]+)\"");
+    std::wsmatch status_match;
+    if (!std::regex_search(response, status_match, status_regex) ||
+        status_match.size() != 2) {
+      wprintf(L"Failed to parse check symbol status response.");
+      wprintf(L"Response:\n");
+      wprintf(L"%s\n", response.c_str());
+      return SymbolStatus::Unknown;
+    }
+    wstring status = status_match[1].str();
+
+    return (status.compare(L"FOUND") == 0) ?
+      SymbolStatus::Found :
+      SymbolStatus::Missing;
+  }
+
+}  // namespace google_breakpad
\ No newline at end of file
diff --git a/src/MEGASync/google_breakpad/common/windows/symbol_collector_client.h b/src/MEGASync/google_breakpad/common/windows/symbol_collector_client.h
new file mode 100644
index 00000000..30e0cb32
--- /dev/null
+++ b/src/MEGASync/google_breakpad/common/windows/symbol_collector_client.h
@@ -0,0 +1,89 @@
+// Copyright (c) 2019, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef COMMON_WINDOWS_SYMBOL_COLLECTOR_CLIENT_H_
+#define COMMON_WINDOWS_SYMBOL_COLLECTOR_CLIENT_H_
+
+#include <string>
+
+namespace google_breakpad {
+
+  using std::wstring;
+
+  struct UploadUrlResponse {
+    // URL at which to HTTP PUT symbol file.
+    wstring upload_url;
+    // Unique key used to complete upload of symbol file.
+    wstring upload_key;
+  };
+
+  enum SymbolStatus {
+    Found,
+    Missing,
+    Unknown
+  };
+
+  enum CompleteUploadResult {
+    Ok,
+    DuplicateData,
+    Error
+  };
+
+  // Client to interact with sym-upload-v2 API server via HTTP/REST.
+  class SymbolCollectorClient {
+  public:
+    // Returns a URL at which a symbol file can be HTTP PUT without
+    // authentication, along with an upload key that can be used to
+    // complete the upload process with CompleteUpload.
+    static bool CreateUploadUrl(
+        wstring& api_url,
+        wstring& api_key,
+        UploadUrlResponse *uploadUrlResponse);
+
+    // Notify the API that symbol file upload is finished and its contents
+    // are ready to be read and/or used for further processing.
+    static CompleteUploadResult CompleteUpload(
+        wstring& api_url,
+        wstring& api_key,
+        const wstring& upload_key,
+        const wstring& debug_file,
+        const wstring& debug_id);
+
+    // Returns whether or not a symbol file corresponding to the debug_file/
+    // debug_id pair is already present in symbol storage.
+    static SymbolStatus CheckSymbolStatus(
+        wstring& api_url,
+        wstring& api_key,
+        const wstring& debug_file,
+        const wstring& debug_id);
+  };
+
+}  // namespace google_breakpad
+
+#endif  // COMMON_WINDOWS_SYMBOL_COLLECTOR_CLIENT_H_
diff --git a/src/MEGASync/google_breakpad/google_breakpad.pri b/src/MEGASync/google_breakpad/google_breakpad.pri
index 350626b5..c37201d5 100644
--- a/src/MEGASync/google_breakpad/google_breakpad.pri
+++ b/src/MEGASync/google_breakpad/google_breakpad.pri
@@ -16,7 +16,7 @@ macx {
   SOURCES += $$PWD/common/md5.cc
   SOURCES += $$PWD/common/string_conversion.cc
   SOURCES += $$PWD/common/linux/linux_libc_support.cc
-  SOURCES += $$PWD/common/convert_UTF.c
+  SOURCES += $$PWD/common/convert_UTF.cc
 
   OBJECTIVE_SOURCES += $$PWD/common/mac/MachIPC.mm
 
@@ -30,9 +30,12 @@ unix:!macx {
   SOURCES += $$PWD/client/linux/crash_generation/crash_generation_client.cc
   SOURCES += $$PWD/client/linux/handler/exception_handler.cc
   SOURCES += $$PWD/client/linux/handler/minidump_descriptor.cc
+  SOURCES += $$PWD/client/linux/microdump_writer/microdump_writer.cc
   SOURCES += $$PWD/client/linux/minidump_writer/minidump_writer.cc
   SOURCES += $$PWD/client/linux/minidump_writer/linux_dumper.cc
   SOURCES += $$PWD/client/linux/minidump_writer/linux_ptrace_dumper.cc
+  SOURCES += $$PWD/client/linux/dump_writer_common/ucontext_reader.cc
+  SOURCES += $$PWD/client/linux/dump_writer_common/thread_info.cc
   SOURCES += $$PWD/client/linux/log/log.cc
   SOURCES += $$PWD/client/minidump_file_writer.cc
   SOURCES += $$PWD/common/linux/linux_libc_support.cc
@@ -41,8 +44,9 @@ unix:!macx {
   SOURCES += $$PWD/common/linux/safe_readlink.cc
   SOURCES += $$PWD/common/linux/guid_creator.cc
   SOURCES += $$PWD/common/linux/elfutils.cc
+  SOURCES += $$PWD/common/linux/breakpad_getcontext.S
   SOURCES += $$PWD/common/string_conversion.cc
-  SOURCES += $$PWD/common/convert_UTF.c
+  SOURCES += $$PWD/common/convert_UTF.cc
 
   QMAKE_CXXFLAGS+=-g
 }
diff --git a/src/MEGASync/google_breakpad/google_breakpad/common/breakpad_types.h b/src/MEGASync/google_breakpad/google_breakpad/common/breakpad_types.h
index a60c5f35..1f59603c 100644
--- a/src/MEGASync/google_breakpad/google_breakpad/common/breakpad_types.h
+++ b/src/MEGASync/google_breakpad/google_breakpad/common/breakpad_types.h
@@ -40,35 +40,19 @@
 #ifndef GOOGLE_BREAKPAD_COMMON_BREAKPAD_TYPES_H__
 #define GOOGLE_BREAKPAD_COMMON_BREAKPAD_TYPES_H__
 
-#ifndef _WIN32
+#if (defined(_INTTYPES_H) || defined(_INTTYPES_H_)) && \
+    !defined(__STDC_FORMAT_MACROS)
+// Work-around for __STDC_FORMAT_MACROS not defined error
+// I don't want to touch the upstream meganz/sdk
+// #error "inttypes.h has already been included before this header file, but "
+// #error "without __STDC_FORMAT_MACROS defined."
+#endif
 
 #ifndef __STDC_FORMAT_MACROS
 #define __STDC_FORMAT_MACROS
 #endif  /* __STDC_FORMAT_MACROS */
 #include <inttypes.h>
 
-#else  /* !_WIN32 */
-
-#if _MSC_VER >= 1600
-#include <stdint.h>
-#elif defined(BREAKPAD_CUSTOM_STDINT_H)
-/* Visual C++ Pre-2010 did not ship a stdint.h, so allow
- * consumers of this library to provide their own because
- * there are often subtle type incompatibilities.
- */
-#include BREAKPAD_CUSTOM_STDINT_H
-#else
-#include <WTypes.h>
-
-typedef unsigned __int8  uint8_t;
-typedef unsigned __int16 uint16_t;
-typedef __int32 int32_t;
-typedef unsigned __int32 uint32_t;
-typedef unsigned __int64 uint64_t;
-#endif
-
-#endif  /* !_WIN32 */
-
 typedef struct {
   uint64_t high;
   uint64_t low;
diff --git a/src/MEGASync/google_breakpad/google_breakpad/common/minidump_cpu_arm64.h b/src/MEGASync/google_breakpad/google_breakpad/common/minidump_cpu_arm64.h
index 5ace0d9d..0411bebb 100644
--- a/src/MEGASync/google_breakpad/google_breakpad/common/minidump_cpu_arm64.h
+++ b/src/MEGASync/google_breakpad/google_breakpad/common/minidump_cpu_arm64.h
@@ -66,7 +66,61 @@
 #ifndef GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_ARM64_H__
 #define GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_ARM64_H__
 
+#include "google_breakpad/common/breakpad_types.h"
+
 #define MD_FLOATINGSAVEAREA_ARM64_FPR_COUNT 32
+#define MD_CONTEXT_ARM64_GPR_COUNT 33
+
+typedef struct {
+  /* 32 128-bit floating point registers, d0 .. d31. */
+  uint128_struct regs[MD_FLOATINGSAVEAREA_ARM64_FPR_COUNT];
+
+  uint32_t fpcr;       /* FPU control register */
+  uint32_t fpsr;       /* FPU status register */
+} MDFloatingSaveAreaARM64;
+
+/* For (MDRawContextARM64).context_flags.  These values indicate the type of
+ * context stored in the structure. */
+#define MD_CONTEXT_ARM64 0x00400000
+#define MD_CONTEXT_ARM64_CONTROL (MD_CONTEXT_ARM64 | 0x00000001)
+#define MD_CONTEXT_ARM64_INTEGER (MD_CONTEXT_ARM64 | 0x00000002)
+#define MD_CONTEXT_ARM64_FLOATING_POINT (MD_CONTEXT_ARM64 | 0x00000004)
+#define MD_CONTEXT_ARM64_DEBUG (MD_CONTEXT_ARM64 | 0x00000008)
+#define MD_CONTEXT_ARM64_FULL (MD_CONTEXT_ARM64_CONTROL | \
+                               MD_CONTEXT_ARM64_INTEGER | \
+                               MD_CONTEXT_ARM64_FLOATING_POINT)
+#define MD_CONTEXT_ARM64_ALL (MD_CONTEXT_ARM64_FULL | MD_CONTEXT_ARM64_DEBUG)
+
+typedef struct {
+  /* Determines which fields of this struct are populated */
+  uint32_t context_flags;
+
+  /* CPSR (flags, basically): 32 bits:
+        bit 31 - N (negative)
+        bit 30 - Z (zero)
+        bit 29 - C (carry)
+        bit 28 - V (overflow)
+        bit 27 - Q (saturation flag, sticky)
+     All other fields -- ignore */
+  uint32_t cpsr;
+
+  /* 33 64-bit integer registers, x0 .. x31 + the PC
+   * Note the following fixed uses:
+   *   x29 is the frame pointer
+   *   x30 is the link register
+   *   x31 is the stack pointer
+   *   The PC is effectively x32.
+   */
+  uint64_t iregs[MD_CONTEXT_ARM64_GPR_COUNT];
+
+  /* The next field is included with MD_CONTEXT64_ARM_FLOATING_POINT */
+  MDFloatingSaveAreaARM64 float_save;
+
+  uint32_t bcr[8];
+  uint64_t bvr[8];
+  uint32_t wcr[2];
+  uint64_t wvr[2];
+} MDRawContextARM64;
 
 typedef struct {
   uint32_t       fpsr;      /* FPU status register */
@@ -74,9 +128,7 @@ typedef struct {
 
   /* 32 128-bit floating point registers, d0 .. d31. */
   uint128_struct regs[MD_FLOATINGSAVEAREA_ARM64_FPR_COUNT];
-} MDFloatingSaveAreaARM64;
-
-#define MD_CONTEXT_ARM64_GPR_COUNT 33
+} MDFloatingSaveAreaARM64_Old;
 
 /* Use the same 32-bit alignment when accessing this structure from 64-bit code
  * as is used natively in 32-bit code. */
@@ -107,9 +159,9 @@ typedef struct {
   uint32_t    cpsr;
 
   /* The next field is included with MD_CONTEXT64_ARM_FLOATING_POINT */
-  MDFloatingSaveAreaARM64 float_save;
+  MDFloatingSaveAreaARM64_Old float_save;
 
-} MDRawContextARM64;
+} MDRawContextARM64_Old;
 
 #pragma pack(pop)
 
@@ -123,18 +175,18 @@ enum MDARM64RegisterNumbers {
   MD_CONTEXT_ARM64_REG_PC     = 32
 };
 
-/* For (MDRawContextARM64).context_flags.  These values indicate the type of
- * context stored in the structure. MD_CONTEXT_ARM64 is Breakpad-defined.
+/* For (MDRawContextARM64_Old).context_flags.  These values indicate the type of
+ * context stored in the structure. MD_CONTEXT_ARM64_OLD is Breakpad-defined.
  * This value was chosen to avoid likely conflicts with MD_CONTEXT_*
  * for other CPUs. */
-#define MD_CONTEXT_ARM64                   0x80000000
-#define MD_CONTEXT_ARM64_INTEGER           (MD_CONTEXT_ARM64 | 0x00000002)
-#define MD_CONTEXT_ARM64_FLOATING_POINT    (MD_CONTEXT_ARM64 | 0x00000004)
+#define MD_CONTEXT_ARM64_OLD                   0x80000000
+#define MD_CONTEXT_ARM64_INTEGER_OLD           (MD_CONTEXT_ARM64_OLD | 0x00000002)
+#define MD_CONTEXT_ARM64_FLOATING_POINT_OLD    (MD_CONTEXT_ARM64_OLD | 0x00000004)
 
-#define MD_CONTEXT_ARM64_FULL              (MD_CONTEXT_ARM64_INTEGER | \
-                                          MD_CONTEXT_ARM64_FLOATING_POINT)
+#define MD_CONTEXT_ARM64_FULL_OLD              (MD_CONTEXT_ARM64_INTEGER_OLD | \
+                                          MD_CONTEXT_ARM64_FLOATING_POINT_OLD)
 
-#define MD_CONTEXT_ARM64_ALL               (MD_CONTEXT_ARM64_INTEGER | \
-                                          MD_CONTEXT_ARM64_FLOATING_POINT)
+#define MD_CONTEXT_ARM64_ALL_OLD               (MD_CONTEXT_ARM64_INTEGER_OLD | \
+                                          MD_CONTEXT_ARM64_FLOATING_POINT_OLD)
 
 #endif  /* GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_ARM64_H__ */
diff --git a/src/MEGASync/google_breakpad/google_breakpad/common/minidump_cpu_mips.h b/src/MEGASync/google_breakpad/google_breakpad/common/minidump_cpu_mips.h
index 4378aac2..f4e2b589 100644
--- a/src/MEGASync/google_breakpad/google_breakpad/common/minidump_cpu_mips.h
+++ b/src/MEGASync/google_breakpad/google_breakpad/common/minidump_cpu_mips.h
@@ -66,24 +66,6 @@
 #ifndef GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_MIPS_H__
 #define GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_MIPS_H__
 
-#if defined(__mips__) && !defined(__ANDROID__)
-typedef struct {
-  uint64_t regs[32];
-  uint64_t lo;
-  uint64_t hi;
-  uint64_t epc;
-  uint64_t badvaddr;
-  uint64_t status;
-  uint64_t cause;
-} user_regs_struct;
-
-typedef struct {
-  uint64_t regs[32];
-  uint32_t fpcsr;
-  uint32_t fir;
-} user_fpregs_struct;
-#endif
-
 #define MD_CONTEXT_MIPS_GPR_COUNT 32
 #define MD_FLOATINGSAVEAREA_MIPS_FPR_COUNT 32
 #define MD_CONTEXT_MIPS_DSP_COUNT 3
@@ -112,8 +94,8 @@ typedef struct {
 
   /* 32 64-bit integer registers, r0..r31.
    * Note the following fixed uses:
-   *   r30 is the stack pointer.
-   *   r31 is the return address (link register).
+   *   r29 is the stack pointer.
+   *   r31 is the return address.
    */
   uint64_t iregs[MD_CONTEXT_MIPS_GPR_COUNT];
 
@@ -175,4 +157,20 @@ enum MDMIPSRegisterNumbers {
                                            MD_CONTEXT_MIPS_FLOATING_POINT \
                                            MD_CONTEXT_MIPS_DSP)
 
+/**
+ * Breakpad defines for MIPS64
+ */
+#define MD_CONTEXT_MIPS64  0x00080000
+#define MD_CONTEXT_MIPS64_INTEGER           (MD_CONTEXT_MIPS64 | 0x00000002)
+#define MD_CONTEXT_MIPS64_FLOATING_POINT    (MD_CONTEXT_MIPS64 | 0x00000004)
+#define MD_CONTEXT_MIPS64_DSP               (MD_CONTEXT_MIPS64 | 0x00000008)
+
+#define MD_CONTEXT_MIPS64_FULL              (MD_CONTEXT_MIPS64_INTEGER | \
+                                             MD_CONTEXT_MIPS64_FLOATING_POINT | \
+                                             MD_CONTEXT_MIPS64_DSP)
+
+#define MD_CONTEXT_MIPS64_ALL               (MD_CONTEXT_MIPS64_INTEGER | \
+                                             MD_CONTEXT_MIPS64_FLOATING_POINT \
+                                             MD_CONTEXT_MIPS64_DSP)
+
 #endif  // GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_MIPS_H__
diff --git a/src/MEGASync/google_breakpad/google_breakpad/common/minidump_cpu_ppc.h b/src/MEGASync/google_breakpad/google_breakpad/common/minidump_cpu_ppc.h
index 02ac3220..b24cc424 100644
--- a/src/MEGASync/google_breakpad/google_breakpad/common/minidump_cpu_ppc.h
+++ b/src/MEGASync/google_breakpad/google_breakpad/common/minidump_cpu_ppc.h
@@ -140,6 +140,11 @@ typedef struct {
   MDVectorSaveAreaPPC   vector_save;
 } MDRawContextPPC;  /* Based on ppc_thread_state */
 
+/* Indices into gpr for registers with a dedicated or conventional purpose. */
+enum MDPPCRegisterNumbers {
+  MD_CONTEXT_PPC_REG_SP = 1
+};
+
 #if defined(__SUNPRO_C) || defined(__SUNPRO_CC)
 #pragma pack(0)
 #else
diff --git a/src/MEGASync/google_breakpad/google_breakpad/common/minidump_cpu_ppc64.h b/src/MEGASync/google_breakpad/google_breakpad/common/minidump_cpu_ppc64.h
index 3a883230..61f41938 100644
--- a/src/MEGASync/google_breakpad/google_breakpad/common/minidump_cpu_ppc64.h
+++ b/src/MEGASync/google_breakpad/google_breakpad/common/minidump_cpu_ppc64.h
@@ -112,6 +112,11 @@ typedef struct {
   MDVectorSaveAreaPPC   vector_save;
 } MDRawContextPPC64;  /* Based on ppc_thread_state */
 
+/* Indices into gpr for registers with a dedicated or conventional purpose. */
+enum MDPPC64RegisterNumbers {
+  MD_CONTEXT_PPC64_REG_SP = 1
+};
+
 /* For (MDRawContextPPC).context_flags.  These values indicate the type of
  * context stored in the structure.  MD_CONTEXT_PPC is Breakpad-defined.  Its
  * value was chosen to avoid likely conflicts with MD_CONTEXT_* for other
diff --git a/src/MEGASync/google_breakpad/google_breakpad/common/minidump_cpu_sparc.h b/src/MEGASync/google_breakpad/google_breakpad/common/minidump_cpu_sparc.h
index ddc4c759..95c08b17 100644
--- a/src/MEGASync/google_breakpad/google_breakpad/common/minidump_cpu_sparc.h
+++ b/src/MEGASync/google_breakpad/google_breakpad/common/minidump_cpu_sparc.h
@@ -138,6 +138,11 @@ typedef struct {
 
 } MDRawContextSPARC;  /* CONTEXT_SPARC */
 
+/* Indices into g_r for registers with a dedicated or conventional purpose. */
+enum MDSPARCRegisterNumbers {
+  MD_CONTEXT_SPARC_REG_SP = 14
+};
+
 /* For (MDRawContextSPARC).context_flags.  These values indicate the type of
  * context stored in the structure.  MD_CONTEXT_SPARC is Breakpad-defined.  Its
  * value was chosen to avoid likely conflicts with MD_CONTEXT_* for other
diff --git a/src/MEGASync/google_breakpad/google_breakpad/common/minidump_exception_fuchsia.h b/src/MEGASync/google_breakpad/google_breakpad/common/minidump_exception_fuchsia.h
new file mode 100644
index 00000000..f26a8a2a
--- /dev/null
+++ b/src/MEGASync/google_breakpad/google_breakpad/common/minidump_exception_fuchsia.h
@@ -0,0 +1,58 @@
+/* Copyright (c) 2019, Google Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ * copyright notice, this list of conditions and the following disclaimer
+ * in the documentation and/or other materials provided with the
+ * distribution.
+ *     * Neither the name of Google Inc. nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
+
+/* minidump_exception_fuchsia.h: A definition of exception codes for Fuchsia.
+ *
+ * Author: Ivan Penkov */
+
+#ifndef GOOGLE_BREAKPAD_COMMON_MINIDUMP_EXCEPTION_FUCHSIA_H_
+#define GOOGLE_BREAKPAD_COMMON_MINIDUMP_EXCEPTION_FUCHSIA_H_
+
+#include <stddef.h>
+
+#include "google_breakpad/common/breakpad_types.h"
+
+// Based on zircon/system/public/zircon/syscalls/exception.h
+typedef enum {
+  // Architectural exceptions
+  MD_EXCEPTION_CODE_FUCHSIA_GENERAL = 0x8,
+  MD_EXCEPTION_CODE_FUCHSIA_FATAL_PAGE_FAULT = 0x108,
+  MD_EXCEPTION_CODE_FUCHSIA_UNDEFINED_INSTRUCTION = 0x208,
+  MD_EXCEPTION_CODE_FUCHSIA_SW_BREAKPOINT = 0x308,
+  MD_EXCEPTION_CODE_FUCHSIA_HW_BREAKPOINT = 0x408,
+  MD_EXCEPTION_CODE_FUCHSIA_UNALIGNED_ACCESS = 0x508,
+  //
+  // Synthetic exceptions
+  MD_EXCEPTION_CODE_FUCHSIA_THREAD_STARTING = 0x8008,
+  MD_EXCEPTION_CODE_FUCHSIA_THREAD_EXITING = 0x8108,
+  MD_EXCEPTION_CODE_FUCHSIA_POLICY_ERROR = 0x8208,
+  MD_EXCEPTION_CODE_FUCHSIA_PROCESS_STARTING = 0x8308,
+} MDExceptionCodeFuchsia;
+
+#endif  // GOOGLE_BREAKPAD_COMMON_MINIDUMP_EXCEPTION_FUCHSIA_H_
diff --git a/src/MEGASync/google_breakpad/google_breakpad/common/minidump_exception_linux.h b/src/MEGASync/google_breakpad/google_breakpad/common/minidump_exception_linux.h
index 9e7e4f1e..6138d5d7 100644
--- a/src/MEGASync/google_breakpad/google_breakpad/common/minidump_exception_linux.h
+++ b/src/MEGASync/google_breakpad/google_breakpad/common/minidump_exception_linux.h
@@ -84,4 +84,42 @@ typedef enum {
                                                        dump requested. */
 } MDExceptionCodeLinux;
 
+/* For (MDException).exception_flags.  These values come from
+ * asm-generic/siginfo.h.
+ */
+typedef enum {
+  /* SIGILL */
+  MD_EXCEPTION_FLAG_LIN_ILL_ILLOPC = 1,
+  MD_EXCEPTION_FLAG_LIN_ILL_ILLOPN = 2,
+  MD_EXCEPTION_FLAG_LIN_ILL_ILLADR = 3,
+  MD_EXCEPTION_FLAG_LIN_ILL_ILLTRP = 4,
+  MD_EXCEPTION_FLAG_LIN_ILL_PRVOPC = 5,
+  MD_EXCEPTION_FLAG_LIN_ILL_PRVREG = 6,
+  MD_EXCEPTION_FLAG_LIN_ILL_COPROC = 7,
+  MD_EXCEPTION_FLAG_LIN_ILL_BADSTK = 8,
+
+  /* SIGFPE */
+  MD_EXCEPTION_FLAG_LIN_FPE_INTDIV = 1,
+  MD_EXCEPTION_FLAG_LIN_FPE_INTOVF = 2,
+  MD_EXCEPTION_FLAG_LIN_FPE_FLTDIV = 3,
+  MD_EXCEPTION_FLAG_LIN_FPE_FLTOVF = 4,
+  MD_EXCEPTION_FLAG_LIN_FPE_FLTUND = 5,
+  MD_EXCEPTION_FLAG_LIN_FPE_FLTRES = 6,
+  MD_EXCEPTION_FLAG_LIN_FPE_FLTINV = 7,
+  MD_EXCEPTION_FLAG_LIN_FPE_FLTSUB = 8,
+
+  /* SIGSEGV */
+  MD_EXCEPTION_FLAG_LIN_SEGV_MAPERR = 1,
+  MD_EXCEPTION_FLAG_LIN_SEGV_ACCERR = 2,
+  MD_EXCEPTION_FLAG_LIN_SEGV_BNDERR = 3,
+  MD_EXCEPTION_FLAG_LIN_SEGV_PKUERR = 4,
+
+  /* SIGBUS */
+  MD_EXCEPTION_FLAG_LIN_BUS_ADRALN = 1,
+  MD_EXCEPTION_FLAG_LIN_BUS_ADRERR = 2,
+  MD_EXCEPTION_FLAG_LIN_BUS_OBJERR = 3,
+  MD_EXCEPTION_FLAG_LIN_BUS_MCEERR_AR = 4,
+  MD_EXCEPTION_FLAG_LIN_BUS_MCEERR_AO = 5,
+} MDExceptionFlagLinux;
+
 #endif  /* GOOGLE_BREAKPAD_COMMON_MINIDUMP_EXCEPTION_LINUX_H__ */
diff --git a/src/MEGASync/google_breakpad/google_breakpad/common/minidump_exception_mac.h b/src/MEGASync/google_breakpad/google_breakpad/common/minidump_exception_mac.h
index 91c1c097..fadbf4ef 100644
--- a/src/MEGASync/google_breakpad/google_breakpad/common/minidump_exception_mac.h
+++ b/src/MEGASync/google_breakpad/google_breakpad/common/minidump_exception_mac.h
@@ -34,7 +34,7 @@
  *
  * Author: Mark Mentovai
  * Split into its own file: Neal Sidhwaney */
- 
+
 
 #ifndef GOOGLE_BREAKPAD_COMMON_MINIDUMP_EXCEPTION_MAC_H__
 #define GOOGLE_BREAKPAD_COMMON_MINIDUMP_EXCEPTION_MAC_H__
@@ -65,8 +65,10 @@ typedef enum {
       /* EXC_SYSCALL */
   MD_EXCEPTION_MAC_MACH_SYSCALL    = 8,
       /* EXC_MACH_SYSCALL */
-  MD_EXCEPTION_MAC_RPC_ALERT       = 9
+  MD_EXCEPTION_MAC_RPC_ALERT       = 9,
       /* EXC_RPC_ALERT */
+  MD_EXCEPTION_MAC_SIMULATED       = 0x43507378
+      /* Fake exception code used by Crashpad's SimulateCrash ('CPsx'). */
 } MDExceptionMac;
 
 /* For (MDException).exception_flags.  Breakpad minidump extension for Mac OS X
@@ -85,6 +87,8 @@ typedef enum {
       /* KERN_MEMORY_FAILURE */
   MD_EXCEPTION_CODE_MAC_MEMORY_ERROR       = 10,
       /* KERN_MEMORY_ERROR */
+  MD_EXCEPTION_CODE_MAC_CODESIGN_ERROR     = 50,
+      /* KERN_CODESIGN_ERROR */
 
   /* With MD_EXCEPTION_SOFTWARE */
   MD_EXCEPTION_CODE_MAC_BAD_SYSCALL  = 0x00010000,  /* Mach SIGSYS */
diff --git a/src/MEGASync/google_breakpad/google_breakpad/common/minidump_exception_win32.h b/src/MEGASync/google_breakpad/google_breakpad/common/minidump_exception_win32.h
index 458a7054..4b5d57c8 100644
--- a/src/MEGASync/google_breakpad/google_breakpad/common/minidump_exception_win32.h
+++ b/src/MEGASync/google_breakpad/google_breakpad/common/minidump_exception_win32.h
@@ -94,17 +94,2162 @@ typedef enum {
       /* EXCEPTION_PRIV_INSTRUCTION */
   MD_EXCEPTION_CODE_WIN_STACK_OVERFLOW           = 0xc00000fd,
       /* EXCEPTION_STACK_OVERFLOW */
+  MD_EXCEPTION_CODE_WIN_BAD_FUNCTION_TABLE       = 0xc00000ff,
+      /* EXCEPTION_BAD_FUNCTION_TABLE */
   MD_EXCEPTION_CODE_WIN_POSSIBLE_DEADLOCK        = 0xc0000194,
       /* EXCEPTION_POSSIBLE_DEADLOCK */
   MD_EXCEPTION_CODE_WIN_STACK_BUFFER_OVERRUN     = 0xc0000409,
       /* STATUS_STACK_BUFFER_OVERRUN */
   MD_EXCEPTION_CODE_WIN_HEAP_CORRUPTION          = 0xc0000374,
       /* STATUS_HEAP_CORRUPTION */
-  MD_EXCEPTION_CODE_WIN_UNHANDLED_CPP_EXCEPTION  = 0xe06d7363
+  MD_EXCEPTION_OUT_OF_MEMORY                     = 0xe0000008,
+      /* Exception thrown by Chromium allocators to indicate OOM.
+	     See base/process/memory.h in Chromium for rationale. */
+  MD_EXCEPTION_CODE_WIN_UNHANDLED_CPP_EXCEPTION  = 0xe06d7363,
       /* Per http://support.microsoft.com/kb/185294,
          generated by Visual C++ compiler */
+  MD_EXCEPTION_CODE_WIN_SIMULATED                = 0x0517a7ed
+      /* Fake exception code used by Crashpad's
+         CrashpadClient::DumpWithoutCrash. */
 } MDExceptionCodeWin;
 
+
+/* For (MDException).exception_information[2], when (MDException).exception_code
+ * is MD_EXCEPTION_CODE_WIN_IN_PAGE_ERROR. This describes the underlying reason
+ * for the error. These values come from ntstatus.h.
+ *
+ * The content of this enum was created from ntstatus.h in the 8.1 SDK with
+ *
+ * egrep '#define [A-Z_0-9]+\s+\(\(NTSTATUS\)0xC[0-9A-F]+L\)' ntstatus.h
+ * | tr -d '\r'
+ * | sed -r 's@#define ([A-Z_0-9]+)\s+\(\(NTSTATUS\)(0xC[0-9A-F]+)L\).*@\2 \1@'
+ * | sort
+ * | sed -r 's@(0xC[0-9A-F]+) ([A-Z_0-9]+)@  MD_NTSTATUS_WIN_\2 = \1,@'
+ *
+ * With easy copy to clipboard with
+ * | xclip -selection c  # on linux
+ * | clip  # on windows
+ * | pbcopy  # on mac
+ *
+ * and then the last comma manually removed. */
+typedef enum {
+  MD_NTSTATUS_WIN_STATUS_UNSUCCESSFUL = 0xC0000001,
+  MD_NTSTATUS_WIN_STATUS_NOT_IMPLEMENTED = 0xC0000002,
+  MD_NTSTATUS_WIN_STATUS_INVALID_INFO_CLASS = 0xC0000003,
+  MD_NTSTATUS_WIN_STATUS_INFO_LENGTH_MISMATCH = 0xC0000004,
+  MD_NTSTATUS_WIN_STATUS_ACCESS_VIOLATION = 0xC0000005,
+  MD_NTSTATUS_WIN_STATUS_IN_PAGE_ERROR = 0xC0000006,
+  MD_NTSTATUS_WIN_STATUS_PAGEFILE_QUOTA = 0xC0000007,
+  MD_NTSTATUS_WIN_STATUS_INVALID_HANDLE = 0xC0000008,
+  MD_NTSTATUS_WIN_STATUS_BAD_INITIAL_STACK = 0xC0000009,
+  MD_NTSTATUS_WIN_STATUS_BAD_INITIAL_PC = 0xC000000A,
+  MD_NTSTATUS_WIN_STATUS_INVALID_CID = 0xC000000B,
+  MD_NTSTATUS_WIN_STATUS_TIMER_NOT_CANCELED = 0xC000000C,
+  MD_NTSTATUS_WIN_STATUS_INVALID_PARAMETER = 0xC000000D,
+  MD_NTSTATUS_WIN_STATUS_NO_SUCH_DEVICE = 0xC000000E,
+  MD_NTSTATUS_WIN_STATUS_NO_SUCH_FILE = 0xC000000F,
+  MD_NTSTATUS_WIN_STATUS_INVALID_DEVICE_REQUEST = 0xC0000010,
+  MD_NTSTATUS_WIN_STATUS_END_OF_FILE = 0xC0000011,
+  MD_NTSTATUS_WIN_STATUS_WRONG_VOLUME = 0xC0000012,
+  MD_NTSTATUS_WIN_STATUS_NO_MEDIA_IN_DEVICE = 0xC0000013,
+  MD_NTSTATUS_WIN_STATUS_UNRECOGNIZED_MEDIA = 0xC0000014,
+  MD_NTSTATUS_WIN_STATUS_NONEXISTENT_SECTOR = 0xC0000015,
+  MD_NTSTATUS_WIN_STATUS_MORE_PROCESSING_REQUIRED = 0xC0000016,
+  MD_NTSTATUS_WIN_STATUS_NO_MEMORY = 0xC0000017,
+  MD_NTSTATUS_WIN_STATUS_CONFLICTING_ADDRESSES = 0xC0000018,
+  MD_NTSTATUS_WIN_STATUS_NOT_MAPPED_VIEW = 0xC0000019,
+  MD_NTSTATUS_WIN_STATUS_UNABLE_TO_FREE_VM = 0xC000001A,
+  MD_NTSTATUS_WIN_STATUS_UNABLE_TO_DELETE_SECTION = 0xC000001B,
+  MD_NTSTATUS_WIN_STATUS_INVALID_SYSTEM_SERVICE = 0xC000001C,
+  MD_NTSTATUS_WIN_STATUS_ILLEGAL_INSTRUCTION = 0xC000001D,
+  MD_NTSTATUS_WIN_STATUS_INVALID_LOCK_SEQUENCE = 0xC000001E,
+  MD_NTSTATUS_WIN_STATUS_INVALID_VIEW_SIZE = 0xC000001F,
+  MD_NTSTATUS_WIN_STATUS_INVALID_FILE_FOR_SECTION = 0xC0000020,
+  MD_NTSTATUS_WIN_STATUS_ALREADY_COMMITTED = 0xC0000021,
+  MD_NTSTATUS_WIN_STATUS_ACCESS_DENIED = 0xC0000022,
+  MD_NTSTATUS_WIN_STATUS_BUFFER_TOO_SMALL = 0xC0000023,
+  MD_NTSTATUS_WIN_STATUS_OBJECT_TYPE_MISMATCH = 0xC0000024,
+  MD_NTSTATUS_WIN_STATUS_NONCONTINUABLE_EXCEPTION = 0xC0000025,
+  MD_NTSTATUS_WIN_STATUS_INVALID_DISPOSITION = 0xC0000026,
+  MD_NTSTATUS_WIN_STATUS_UNWIND = 0xC0000027,
+  MD_NTSTATUS_WIN_STATUS_BAD_STACK = 0xC0000028,
+  MD_NTSTATUS_WIN_STATUS_INVALID_UNWIND_TARGET = 0xC0000029,
+  MD_NTSTATUS_WIN_STATUS_NOT_LOCKED = 0xC000002A,
+  MD_NTSTATUS_WIN_STATUS_PARITY_ERROR = 0xC000002B,
+  MD_NTSTATUS_WIN_STATUS_UNABLE_TO_DECOMMIT_VM = 0xC000002C,
+  MD_NTSTATUS_WIN_STATUS_NOT_COMMITTED = 0xC000002D,
+  MD_NTSTATUS_WIN_STATUS_INVALID_PORT_ATTRIBUTES = 0xC000002E,
+  MD_NTSTATUS_WIN_STATUS_PORT_MESSAGE_TOO_LONG = 0xC000002F,
+  MD_NTSTATUS_WIN_STATUS_INVALID_PARAMETER_MIX = 0xC0000030,
+  MD_NTSTATUS_WIN_STATUS_INVALID_QUOTA_LOWER = 0xC0000031,
+  MD_NTSTATUS_WIN_STATUS_DISK_CORRUPT_ERROR = 0xC0000032,
+  MD_NTSTATUS_WIN_STATUS_OBJECT_NAME_INVALID = 0xC0000033,
+  MD_NTSTATUS_WIN_STATUS_OBJECT_NAME_NOT_FOUND = 0xC0000034,
+  MD_NTSTATUS_WIN_STATUS_OBJECT_NAME_COLLISION = 0xC0000035,
+  MD_NTSTATUS_WIN_STATUS_PORT_DISCONNECTED = 0xC0000037,
+  MD_NTSTATUS_WIN_STATUS_DEVICE_ALREADY_ATTACHED = 0xC0000038,
+  MD_NTSTATUS_WIN_STATUS_OBJECT_PATH_INVALID = 0xC0000039,
+  MD_NTSTATUS_WIN_STATUS_OBJECT_PATH_NOT_FOUND = 0xC000003A,
+  MD_NTSTATUS_WIN_STATUS_OBJECT_PATH_SYNTAX_BAD = 0xC000003B,
+  MD_NTSTATUS_WIN_STATUS_DATA_OVERRUN = 0xC000003C,
+  MD_NTSTATUS_WIN_STATUS_DATA_LATE_ERROR = 0xC000003D,
+  MD_NTSTATUS_WIN_STATUS_DATA_ERROR = 0xC000003E,
+  MD_NTSTATUS_WIN_STATUS_CRC_ERROR = 0xC000003F,
+  MD_NTSTATUS_WIN_STATUS_SECTION_TOO_BIG = 0xC0000040,
+  MD_NTSTATUS_WIN_STATUS_PORT_CONNECTION_REFUSED = 0xC0000041,
+  MD_NTSTATUS_WIN_STATUS_INVALID_PORT_HANDLE = 0xC0000042,
+  MD_NTSTATUS_WIN_STATUS_SHARING_VIOLATION = 0xC0000043,
+  MD_NTSTATUS_WIN_STATUS_QUOTA_EXCEEDED = 0xC0000044,
+  MD_NTSTATUS_WIN_STATUS_INVALID_PAGE_PROTECTION = 0xC0000045,
+  MD_NTSTATUS_WIN_STATUS_MUTANT_NOT_OWNED = 0xC0000046,
+  MD_NTSTATUS_WIN_STATUS_SEMAPHORE_LIMIT_EXCEEDED = 0xC0000047,
+  MD_NTSTATUS_WIN_STATUS_PORT_ALREADY_SET = 0xC0000048,
+  MD_NTSTATUS_WIN_STATUS_SECTION_NOT_IMAGE = 0xC0000049,
+  MD_NTSTATUS_WIN_STATUS_SUSPEND_COUNT_EXCEEDED = 0xC000004A,
+  MD_NTSTATUS_WIN_STATUS_THREAD_IS_TERMINATING = 0xC000004B,
+  MD_NTSTATUS_WIN_STATUS_BAD_WORKING_SET_LIMIT = 0xC000004C,
+  MD_NTSTATUS_WIN_STATUS_INCOMPATIBLE_FILE_MAP = 0xC000004D,
+  MD_NTSTATUS_WIN_STATUS_SECTION_PROTECTION = 0xC000004E,
+  MD_NTSTATUS_WIN_STATUS_EAS_NOT_SUPPORTED = 0xC000004F,
+  MD_NTSTATUS_WIN_STATUS_EA_TOO_LARGE = 0xC0000050,
+  MD_NTSTATUS_WIN_STATUS_NONEXISTENT_EA_ENTRY = 0xC0000051,
+  MD_NTSTATUS_WIN_STATUS_NO_EAS_ON_FILE = 0xC0000052,
+  MD_NTSTATUS_WIN_STATUS_EA_CORRUPT_ERROR = 0xC0000053,
+  MD_NTSTATUS_WIN_STATUS_FILE_LOCK_CONFLICT = 0xC0000054,
+  MD_NTSTATUS_WIN_STATUS_LOCK_NOT_GRANTED = 0xC0000055,
+  MD_NTSTATUS_WIN_STATUS_DELETE_PENDING = 0xC0000056,
+  MD_NTSTATUS_WIN_STATUS_CTL_FILE_NOT_SUPPORTED = 0xC0000057,
+  MD_NTSTATUS_WIN_STATUS_UNKNOWN_REVISION = 0xC0000058,
+  MD_NTSTATUS_WIN_STATUS_REVISION_MISMATCH = 0xC0000059,
+  MD_NTSTATUS_WIN_STATUS_INVALID_OWNER = 0xC000005A,
+  MD_NTSTATUS_WIN_STATUS_INVALID_PRIMARY_GROUP = 0xC000005B,
+  MD_NTSTATUS_WIN_STATUS_NO_IMPERSONATION_TOKEN = 0xC000005C,
+  MD_NTSTATUS_WIN_STATUS_CANT_DISABLE_MANDATORY = 0xC000005D,
+  MD_NTSTATUS_WIN_STATUS_NO_LOGON_SERVERS = 0xC000005E,
+  MD_NTSTATUS_WIN_STATUS_NO_SUCH_LOGON_SESSION = 0xC000005F,
+  MD_NTSTATUS_WIN_STATUS_NO_SUCH_PRIVILEGE = 0xC0000060,
+  MD_NTSTATUS_WIN_STATUS_PRIVILEGE_NOT_HELD = 0xC0000061,
+  MD_NTSTATUS_WIN_STATUS_INVALID_ACCOUNT_NAME = 0xC0000062,
+  MD_NTSTATUS_WIN_STATUS_USER_EXISTS = 0xC0000063,
+  MD_NTSTATUS_WIN_STATUS_NO_SUCH_USER = 0xC0000064,
+  MD_NTSTATUS_WIN_STATUS_GROUP_EXISTS = 0xC0000065,
+  MD_NTSTATUS_WIN_STATUS_NO_SUCH_GROUP = 0xC0000066,
+  MD_NTSTATUS_WIN_STATUS_MEMBER_IN_GROUP = 0xC0000067,
+  MD_NTSTATUS_WIN_STATUS_MEMBER_NOT_IN_GROUP = 0xC0000068,
+  MD_NTSTATUS_WIN_STATUS_LAST_ADMIN = 0xC0000069,
+  MD_NTSTATUS_WIN_STATUS_WRONG_PASSWORD = 0xC000006A,
+  MD_NTSTATUS_WIN_STATUS_ILL_FORMED_PASSWORD = 0xC000006B,
+  MD_NTSTATUS_WIN_STATUS_PASSWORD_RESTRICTION = 0xC000006C,
+  MD_NTSTATUS_WIN_STATUS_LOGON_FAILURE = 0xC000006D,
+  MD_NTSTATUS_WIN_STATUS_ACCOUNT_RESTRICTION = 0xC000006E,
+  MD_NTSTATUS_WIN_STATUS_INVALID_LOGON_HOURS = 0xC000006F,
+  MD_NTSTATUS_WIN_STATUS_INVALID_WORKSTATION = 0xC0000070,
+  MD_NTSTATUS_WIN_STATUS_PASSWORD_EXPIRED = 0xC0000071,
+  MD_NTSTATUS_WIN_STATUS_ACCOUNT_DISABLED = 0xC0000072,
+  MD_NTSTATUS_WIN_STATUS_NONE_MAPPED = 0xC0000073,
+  MD_NTSTATUS_WIN_STATUS_TOO_MANY_LUIDS_REQUESTED = 0xC0000074,
+  MD_NTSTATUS_WIN_STATUS_LUIDS_EXHAUSTED = 0xC0000075,
+  MD_NTSTATUS_WIN_STATUS_INVALID_SUB_AUTHORITY = 0xC0000076,
+  MD_NTSTATUS_WIN_STATUS_INVALID_ACL = 0xC0000077,
+  MD_NTSTATUS_WIN_STATUS_INVALID_SID = 0xC0000078,
+  MD_NTSTATUS_WIN_STATUS_INVALID_SECURITY_DESCR = 0xC0000079,
+  MD_NTSTATUS_WIN_STATUS_PROCEDURE_NOT_FOUND = 0xC000007A,
+  MD_NTSTATUS_WIN_STATUS_INVALID_IMAGE_FORMAT = 0xC000007B,
+  MD_NTSTATUS_WIN_STATUS_NO_TOKEN = 0xC000007C,
+  MD_NTSTATUS_WIN_STATUS_BAD_INHERITANCE_ACL = 0xC000007D,
+  MD_NTSTATUS_WIN_STATUS_RANGE_NOT_LOCKED = 0xC000007E,
+  MD_NTSTATUS_WIN_STATUS_DISK_FULL = 0xC000007F,
+  MD_NTSTATUS_WIN_STATUS_SERVER_DISABLED = 0xC0000080,
+  MD_NTSTATUS_WIN_STATUS_SERVER_NOT_DISABLED = 0xC0000081,
+  MD_NTSTATUS_WIN_STATUS_TOO_MANY_GUIDS_REQUESTED = 0xC0000082,
+  MD_NTSTATUS_WIN_STATUS_GUIDS_EXHAUSTED = 0xC0000083,
+  MD_NTSTATUS_WIN_STATUS_INVALID_ID_AUTHORITY = 0xC0000084,
+  MD_NTSTATUS_WIN_STATUS_AGENTS_EXHAUSTED = 0xC0000085,
+  MD_NTSTATUS_WIN_STATUS_INVALID_VOLUME_LABEL = 0xC0000086,
+  MD_NTSTATUS_WIN_STATUS_SECTION_NOT_EXTENDED = 0xC0000087,
+  MD_NTSTATUS_WIN_STATUS_NOT_MAPPED_DATA = 0xC0000088,
+  MD_NTSTATUS_WIN_STATUS_RESOURCE_DATA_NOT_FOUND = 0xC0000089,
+  MD_NTSTATUS_WIN_STATUS_RESOURCE_TYPE_NOT_FOUND = 0xC000008A,
+  MD_NTSTATUS_WIN_STATUS_RESOURCE_NAME_NOT_FOUND = 0xC000008B,
+  MD_NTSTATUS_WIN_STATUS_ARRAY_BOUNDS_EXCEEDED = 0xC000008C,
+  MD_NTSTATUS_WIN_STATUS_FLOAT_DENORMAL_OPERAND = 0xC000008D,
+  MD_NTSTATUS_WIN_STATUS_FLOAT_DIVIDE_BY_ZERO = 0xC000008E,
+  MD_NTSTATUS_WIN_STATUS_FLOAT_INEXACT_RESULT = 0xC000008F,
+  MD_NTSTATUS_WIN_STATUS_FLOAT_INVALID_OPERATION = 0xC0000090,
+  MD_NTSTATUS_WIN_STATUS_FLOAT_OVERFLOW = 0xC0000091,
+  MD_NTSTATUS_WIN_STATUS_FLOAT_STACK_CHECK = 0xC0000092,
+  MD_NTSTATUS_WIN_STATUS_FLOAT_UNDERFLOW = 0xC0000093,
+  MD_NTSTATUS_WIN_STATUS_INTEGER_DIVIDE_BY_ZERO = 0xC0000094,
+  MD_NTSTATUS_WIN_STATUS_INTEGER_OVERFLOW = 0xC0000095,
+  MD_NTSTATUS_WIN_STATUS_PRIVILEGED_INSTRUCTION = 0xC0000096,
+  MD_NTSTATUS_WIN_STATUS_TOO_MANY_PAGING_FILES = 0xC0000097,
+  MD_NTSTATUS_WIN_STATUS_FILE_INVALID = 0xC0000098,
+  MD_NTSTATUS_WIN_STATUS_ALLOTTED_SPACE_EXCEEDED = 0xC0000099,
+  MD_NTSTATUS_WIN_STATUS_INSUFFICIENT_RESOURCES = 0xC000009A,
+  MD_NTSTATUS_WIN_STATUS_DFS_EXIT_PATH_FOUND = 0xC000009B,
+  MD_NTSTATUS_WIN_STATUS_DEVICE_DATA_ERROR = 0xC000009C,
+  MD_NTSTATUS_WIN_STATUS_DEVICE_NOT_CONNECTED = 0xC000009D,
+  MD_NTSTATUS_WIN_STATUS_DEVICE_POWER_FAILURE = 0xC000009E,
+  MD_NTSTATUS_WIN_STATUS_FREE_VM_NOT_AT_BASE = 0xC000009F,
+  MD_NTSTATUS_WIN_STATUS_MEMORY_NOT_ALLOCATED = 0xC00000A0,
+  MD_NTSTATUS_WIN_STATUS_WORKING_SET_QUOTA = 0xC00000A1,
+  MD_NTSTATUS_WIN_STATUS_MEDIA_WRITE_PROTECTED = 0xC00000A2,
+  MD_NTSTATUS_WIN_STATUS_DEVICE_NOT_READY = 0xC00000A3,
+  MD_NTSTATUS_WIN_STATUS_INVALID_GROUP_ATTRIBUTES = 0xC00000A4,
+  MD_NTSTATUS_WIN_STATUS_BAD_IMPERSONATION_LEVEL = 0xC00000A5,
+  MD_NTSTATUS_WIN_STATUS_CANT_OPEN_ANONYMOUS = 0xC00000A6,
+  MD_NTSTATUS_WIN_STATUS_BAD_VALIDATION_CLASS = 0xC00000A7,
+  MD_NTSTATUS_WIN_STATUS_BAD_TOKEN_TYPE = 0xC00000A8,
+  MD_NTSTATUS_WIN_STATUS_BAD_MASTER_BOOT_RECORD = 0xC00000A9,
+  MD_NTSTATUS_WIN_STATUS_INSTRUCTION_MISALIGNMENT = 0xC00000AA,
+  MD_NTSTATUS_WIN_STATUS_INSTANCE_NOT_AVAILABLE = 0xC00000AB,
+  MD_NTSTATUS_WIN_STATUS_PIPE_NOT_AVAILABLE = 0xC00000AC,
+  MD_NTSTATUS_WIN_STATUS_INVALID_PIPE_STATE = 0xC00000AD,
+  MD_NTSTATUS_WIN_STATUS_PIPE_BUSY = 0xC00000AE,
+  MD_NTSTATUS_WIN_STATUS_ILLEGAL_FUNCTION = 0xC00000AF,
+  MD_NTSTATUS_WIN_STATUS_PIPE_DISCONNECTED = 0xC00000B0,
+  MD_NTSTATUS_WIN_STATUS_PIPE_CLOSING = 0xC00000B1,
+  MD_NTSTATUS_WIN_STATUS_PIPE_CONNECTED = 0xC00000B2,
+  MD_NTSTATUS_WIN_STATUS_PIPE_LISTENING = 0xC00000B3,
+  MD_NTSTATUS_WIN_STATUS_INVALID_READ_MODE = 0xC00000B4,
+  MD_NTSTATUS_WIN_STATUS_IO_TIMEOUT = 0xC00000B5,
+  MD_NTSTATUS_WIN_STATUS_FILE_FORCED_CLOSED = 0xC00000B6,
+  MD_NTSTATUS_WIN_STATUS_PROFILING_NOT_STARTED = 0xC00000B7,
+  MD_NTSTATUS_WIN_STATUS_PROFILING_NOT_STOPPED = 0xC00000B8,
+  MD_NTSTATUS_WIN_STATUS_COULD_NOT_INTERPRET = 0xC00000B9,
+  MD_NTSTATUS_WIN_STATUS_FILE_IS_A_DIRECTORY = 0xC00000BA,
+  MD_NTSTATUS_WIN_STATUS_NOT_SUPPORTED = 0xC00000BB,
+  MD_NTSTATUS_WIN_STATUS_REMOTE_NOT_LISTENING = 0xC00000BC,
+  MD_NTSTATUS_WIN_STATUS_DUPLICATE_NAME = 0xC00000BD,
+  MD_NTSTATUS_WIN_STATUS_BAD_NETWORK_PATH = 0xC00000BE,
+  MD_NTSTATUS_WIN_STATUS_NETWORK_BUSY = 0xC00000BF,
+  MD_NTSTATUS_WIN_STATUS_DEVICE_DOES_NOT_EXIST = 0xC00000C0,
+  MD_NTSTATUS_WIN_STATUS_TOO_MANY_COMMANDS = 0xC00000C1,
+  MD_NTSTATUS_WIN_STATUS_ADAPTER_HARDWARE_ERROR = 0xC00000C2,
+  MD_NTSTATUS_WIN_STATUS_INVALID_NETWORK_RESPONSE = 0xC00000C3,
+  MD_NTSTATUS_WIN_STATUS_UNEXPECTED_NETWORK_ERROR = 0xC00000C4,
+  MD_NTSTATUS_WIN_STATUS_BAD_REMOTE_ADAPTER = 0xC00000C5,
+  MD_NTSTATUS_WIN_STATUS_PRINT_QUEUE_FULL = 0xC00000C6,
+  MD_NTSTATUS_WIN_STATUS_NO_SPOOL_SPACE = 0xC00000C7,
+  MD_NTSTATUS_WIN_STATUS_PRINT_CANCELLED = 0xC00000C8,
+  MD_NTSTATUS_WIN_STATUS_NETWORK_NAME_DELETED = 0xC00000C9,
+  MD_NTSTATUS_WIN_STATUS_NETWORK_ACCESS_DENIED = 0xC00000CA,
+  MD_NTSTATUS_WIN_STATUS_BAD_DEVICE_TYPE = 0xC00000CB,
+  MD_NTSTATUS_WIN_STATUS_BAD_NETWORK_NAME = 0xC00000CC,
+  MD_NTSTATUS_WIN_STATUS_TOO_MANY_NAMES = 0xC00000CD,
+  MD_NTSTATUS_WIN_STATUS_TOO_MANY_SESSIONS = 0xC00000CE,
+  MD_NTSTATUS_WIN_STATUS_SHARING_PAUSED = 0xC00000CF,
+  MD_NTSTATUS_WIN_STATUS_REQUEST_NOT_ACCEPTED = 0xC00000D0,
+  MD_NTSTATUS_WIN_STATUS_REDIRECTOR_PAUSED = 0xC00000D1,
+  MD_NTSTATUS_WIN_STATUS_NET_WRITE_FAULT = 0xC00000D2,
+  MD_NTSTATUS_WIN_STATUS_PROFILING_AT_LIMIT = 0xC00000D3,
+  MD_NTSTATUS_WIN_STATUS_NOT_SAME_DEVICE = 0xC00000D4,
+  MD_NTSTATUS_WIN_STATUS_FILE_RENAMED = 0xC00000D5,
+  MD_NTSTATUS_WIN_STATUS_VIRTUAL_CIRCUIT_CLOSED = 0xC00000D6,
+  MD_NTSTATUS_WIN_STATUS_NO_SECURITY_ON_OBJECT = 0xC00000D7,
+  MD_NTSTATUS_WIN_STATUS_CANT_WAIT = 0xC00000D8,
+  MD_NTSTATUS_WIN_STATUS_PIPE_EMPTY = 0xC00000D9,
+  MD_NTSTATUS_WIN_STATUS_CANT_ACCESS_DOMAIN_INFO = 0xC00000DA,
+  MD_NTSTATUS_WIN_STATUS_CANT_TERMINATE_SELF = 0xC00000DB,
+  MD_NTSTATUS_WIN_STATUS_INVALID_SERVER_STATE = 0xC00000DC,
+  MD_NTSTATUS_WIN_STATUS_INVALID_DOMAIN_STATE = 0xC00000DD,
+  MD_NTSTATUS_WIN_STATUS_INVALID_DOMAIN_ROLE = 0xC00000DE,
+  MD_NTSTATUS_WIN_STATUS_NO_SUCH_DOMAIN = 0xC00000DF,
+  MD_NTSTATUS_WIN_STATUS_DOMAIN_EXISTS = 0xC00000E0,
+  MD_NTSTATUS_WIN_STATUS_DOMAIN_LIMIT_EXCEEDED = 0xC00000E1,
+  MD_NTSTATUS_WIN_STATUS_OPLOCK_NOT_GRANTED = 0xC00000E2,
+  MD_NTSTATUS_WIN_STATUS_INVALID_OPLOCK_PROTOCOL = 0xC00000E3,
+  MD_NTSTATUS_WIN_STATUS_INTERNAL_DB_CORRUPTION = 0xC00000E4,
+  MD_NTSTATUS_WIN_STATUS_INTERNAL_ERROR = 0xC00000E5,
+  MD_NTSTATUS_WIN_STATUS_GENERIC_NOT_MAPPED = 0xC00000E6,
+  MD_NTSTATUS_WIN_STATUS_BAD_DESCRIPTOR_FORMAT = 0xC00000E7,
+  MD_NTSTATUS_WIN_STATUS_INVALID_USER_BUFFER = 0xC00000E8,
+  MD_NTSTATUS_WIN_STATUS_UNEXPECTED_IO_ERROR = 0xC00000E9,
+  MD_NTSTATUS_WIN_STATUS_UNEXPECTED_MM_CREATE_ERR = 0xC00000EA,
+  MD_NTSTATUS_WIN_STATUS_UNEXPECTED_MM_MAP_ERROR = 0xC00000EB,
+  MD_NTSTATUS_WIN_STATUS_UNEXPECTED_MM_EXTEND_ERR = 0xC00000EC,
+  MD_NTSTATUS_WIN_STATUS_NOT_LOGON_PROCESS = 0xC00000ED,
+  MD_NTSTATUS_WIN_STATUS_LOGON_SESSION_EXISTS = 0xC00000EE,
+  MD_NTSTATUS_WIN_STATUS_INVALID_PARAMETER_1 = 0xC00000EF,
+  MD_NTSTATUS_WIN_STATUS_INVALID_PARAMETER_2 = 0xC00000F0,
+  MD_NTSTATUS_WIN_STATUS_INVALID_PARAMETER_3 = 0xC00000F1,
+  MD_NTSTATUS_WIN_STATUS_INVALID_PARAMETER_4 = 0xC00000F2,
+  MD_NTSTATUS_WIN_STATUS_INVALID_PARAMETER_5 = 0xC00000F3,
+  MD_NTSTATUS_WIN_STATUS_INVALID_PARAMETER_6 = 0xC00000F4,
+  MD_NTSTATUS_WIN_STATUS_INVALID_PARAMETER_7 = 0xC00000F5,
+  MD_NTSTATUS_WIN_STATUS_INVALID_PARAMETER_8 = 0xC00000F6,
+  MD_NTSTATUS_WIN_STATUS_INVALID_PARAMETER_9 = 0xC00000F7,
+  MD_NTSTATUS_WIN_STATUS_INVALID_PARAMETER_10 = 0xC00000F8,
+  MD_NTSTATUS_WIN_STATUS_INVALID_PARAMETER_11 = 0xC00000F9,
+  MD_NTSTATUS_WIN_STATUS_INVALID_PARAMETER_12 = 0xC00000FA,
+  MD_NTSTATUS_WIN_STATUS_REDIRECTOR_NOT_STARTED = 0xC00000FB,
+  MD_NTSTATUS_WIN_STATUS_REDIRECTOR_STARTED = 0xC00000FC,
+  MD_NTSTATUS_WIN_STATUS_STACK_OVERFLOW = 0xC00000FD,
+  MD_NTSTATUS_WIN_STATUS_NO_SUCH_PACKAGE = 0xC00000FE,
+  MD_NTSTATUS_WIN_STATUS_BAD_FUNCTION_TABLE = 0xC00000FF,
+  MD_NTSTATUS_WIN_STATUS_VARIABLE_NOT_FOUND = 0xC0000100,
+  MD_NTSTATUS_WIN_STATUS_DIRECTORY_NOT_EMPTY = 0xC0000101,
+  MD_NTSTATUS_WIN_STATUS_FILE_CORRUPT_ERROR = 0xC0000102,
+  MD_NTSTATUS_WIN_STATUS_NOT_A_DIRECTORY = 0xC0000103,
+  MD_NTSTATUS_WIN_STATUS_BAD_LOGON_SESSION_STATE = 0xC0000104,
+  MD_NTSTATUS_WIN_STATUS_LOGON_SESSION_COLLISION = 0xC0000105,
+  MD_NTSTATUS_WIN_STATUS_NAME_TOO_LONG = 0xC0000106,
+  MD_NTSTATUS_WIN_STATUS_FILES_OPEN = 0xC0000107,
+  MD_NTSTATUS_WIN_STATUS_CONNECTION_IN_USE = 0xC0000108,
+  MD_NTSTATUS_WIN_STATUS_MESSAGE_NOT_FOUND = 0xC0000109,
+  MD_NTSTATUS_WIN_STATUS_PROCESS_IS_TERMINATING = 0xC000010A,
+  MD_NTSTATUS_WIN_STATUS_INVALID_LOGON_TYPE = 0xC000010B,
+  MD_NTSTATUS_WIN_STATUS_NO_GUID_TRANSLATION = 0xC000010C,
+  MD_NTSTATUS_WIN_STATUS_CANNOT_IMPERSONATE = 0xC000010D,
+  MD_NTSTATUS_WIN_STATUS_IMAGE_ALREADY_LOADED = 0xC000010E,
+  MD_NTSTATUS_WIN_STATUS_ABIOS_NOT_PRESENT = 0xC000010F,
+  MD_NTSTATUS_WIN_STATUS_ABIOS_LID_NOT_EXIST = 0xC0000110,
+  MD_NTSTATUS_WIN_STATUS_ABIOS_LID_ALREADY_OWNED = 0xC0000111,
+  MD_NTSTATUS_WIN_STATUS_ABIOS_NOT_LID_OWNER = 0xC0000112,
+  MD_NTSTATUS_WIN_STATUS_ABIOS_INVALID_COMMAND = 0xC0000113,
+  MD_NTSTATUS_WIN_STATUS_ABIOS_INVALID_LID = 0xC0000114,
+  MD_NTSTATUS_WIN_STATUS_ABIOS_SELECTOR_NOT_AVAILABLE = 0xC0000115,
+  MD_NTSTATUS_WIN_STATUS_ABIOS_INVALID_SELECTOR = 0xC0000116,
+  MD_NTSTATUS_WIN_STATUS_NO_LDT = 0xC0000117,
+  MD_NTSTATUS_WIN_STATUS_INVALID_LDT_SIZE = 0xC0000118,
+  MD_NTSTATUS_WIN_STATUS_INVALID_LDT_OFFSET = 0xC0000119,
+  MD_NTSTATUS_WIN_STATUS_INVALID_LDT_DESCRIPTOR = 0xC000011A,
+  MD_NTSTATUS_WIN_STATUS_INVALID_IMAGE_NE_FORMAT = 0xC000011B,
+  MD_NTSTATUS_WIN_STATUS_RXACT_INVALID_STATE = 0xC000011C,
+  MD_NTSTATUS_WIN_STATUS_RXACT_COMMIT_FAILURE = 0xC000011D,
+  MD_NTSTATUS_WIN_STATUS_MAPPED_FILE_SIZE_ZERO = 0xC000011E,
+  MD_NTSTATUS_WIN_STATUS_TOO_MANY_OPENED_FILES = 0xC000011F,
+  MD_NTSTATUS_WIN_STATUS_CANCELLED = 0xC0000120,
+  MD_NTSTATUS_WIN_STATUS_CANNOT_DELETE = 0xC0000121,
+  MD_NTSTATUS_WIN_STATUS_INVALID_COMPUTER_NAME = 0xC0000122,
+  MD_NTSTATUS_WIN_STATUS_FILE_DELETED = 0xC0000123,
+  MD_NTSTATUS_WIN_STATUS_SPECIAL_ACCOUNT = 0xC0000124,
+  MD_NTSTATUS_WIN_STATUS_SPECIAL_GROUP = 0xC0000125,
+  MD_NTSTATUS_WIN_STATUS_SPECIAL_USER = 0xC0000126,
+  MD_NTSTATUS_WIN_STATUS_MEMBERS_PRIMARY_GROUP = 0xC0000127,
+  MD_NTSTATUS_WIN_STATUS_FILE_CLOSED = 0xC0000128,
+  MD_NTSTATUS_WIN_STATUS_TOO_MANY_THREADS = 0xC0000129,
+  MD_NTSTATUS_WIN_STATUS_THREAD_NOT_IN_PROCESS = 0xC000012A,
+  MD_NTSTATUS_WIN_STATUS_TOKEN_ALREADY_IN_USE = 0xC000012B,
+  MD_NTSTATUS_WIN_STATUS_PAGEFILE_QUOTA_EXCEEDED = 0xC000012C,
+  MD_NTSTATUS_WIN_STATUS_COMMITMENT_LIMIT = 0xC000012D,
+  MD_NTSTATUS_WIN_STATUS_INVALID_IMAGE_LE_FORMAT = 0xC000012E,
+  MD_NTSTATUS_WIN_STATUS_INVALID_IMAGE_NOT_MZ = 0xC000012F,
+  MD_NTSTATUS_WIN_STATUS_INVALID_IMAGE_PROTECT = 0xC0000130,
+  MD_NTSTATUS_WIN_STATUS_INVALID_IMAGE_WIN_16 = 0xC0000131,
+  MD_NTSTATUS_WIN_STATUS_LOGON_SERVER_CONFLICT = 0xC0000132,
+  MD_NTSTATUS_WIN_STATUS_TIME_DIFFERENCE_AT_DC = 0xC0000133,
+  MD_NTSTATUS_WIN_STATUS_SYNCHRONIZATION_REQUIRED = 0xC0000134,
+  MD_NTSTATUS_WIN_STATUS_DLL_NOT_FOUND = 0xC0000135,
+  MD_NTSTATUS_WIN_STATUS_OPEN_FAILED = 0xC0000136,
+  MD_NTSTATUS_WIN_STATUS_IO_PRIVILEGE_FAILED = 0xC0000137,
+  MD_NTSTATUS_WIN_STATUS_ORDINAL_NOT_FOUND = 0xC0000138,
+  MD_NTSTATUS_WIN_STATUS_ENTRYPOINT_NOT_FOUND = 0xC0000139,
+  MD_NTSTATUS_WIN_STATUS_CONTROL_C_EXIT = 0xC000013A,
+  MD_NTSTATUS_WIN_STATUS_LOCAL_DISCONNECT = 0xC000013B,
+  MD_NTSTATUS_WIN_STATUS_REMOTE_DISCONNECT = 0xC000013C,
+  MD_NTSTATUS_WIN_STATUS_REMOTE_RESOURCES = 0xC000013D,
+  MD_NTSTATUS_WIN_STATUS_LINK_FAILED = 0xC000013E,
+  MD_NTSTATUS_WIN_STATUS_LINK_TIMEOUT = 0xC000013F,
+  MD_NTSTATUS_WIN_STATUS_INVALID_CONNECTION = 0xC0000140,
+  MD_NTSTATUS_WIN_STATUS_INVALID_ADDRESS = 0xC0000141,
+  MD_NTSTATUS_WIN_STATUS_DLL_INIT_FAILED = 0xC0000142,
+  MD_NTSTATUS_WIN_STATUS_MISSING_SYSTEMFILE = 0xC0000143,
+  MD_NTSTATUS_WIN_STATUS_UNHANDLED_EXCEPTION = 0xC0000144,
+  MD_NTSTATUS_WIN_STATUS_APP_INIT_FAILURE = 0xC0000145,
+  MD_NTSTATUS_WIN_STATUS_PAGEFILE_CREATE_FAILED = 0xC0000146,
+  MD_NTSTATUS_WIN_STATUS_NO_PAGEFILE = 0xC0000147,
+  MD_NTSTATUS_WIN_STATUS_INVALID_LEVEL = 0xC0000148,
+  MD_NTSTATUS_WIN_STATUS_WRONG_PASSWORD_CORE = 0xC0000149,
+  MD_NTSTATUS_WIN_STATUS_ILLEGAL_FLOAT_CONTEXT = 0xC000014A,
+  MD_NTSTATUS_WIN_STATUS_PIPE_BROKEN = 0xC000014B,
+  MD_NTSTATUS_WIN_STATUS_REGISTRY_CORRUPT = 0xC000014C,
+  MD_NTSTATUS_WIN_STATUS_REGISTRY_IO_FAILED = 0xC000014D,
+  MD_NTSTATUS_WIN_STATUS_NO_EVENT_PAIR = 0xC000014E,
+  MD_NTSTATUS_WIN_STATUS_UNRECOGNIZED_VOLUME = 0xC000014F,
+  MD_NTSTATUS_WIN_STATUS_SERIAL_NO_DEVICE_INITED = 0xC0000150,
+  MD_NTSTATUS_WIN_STATUS_NO_SUCH_ALIAS = 0xC0000151,
+  MD_NTSTATUS_WIN_STATUS_MEMBER_NOT_IN_ALIAS = 0xC0000152,
+  MD_NTSTATUS_WIN_STATUS_MEMBER_IN_ALIAS = 0xC0000153,
+  MD_NTSTATUS_WIN_STATUS_ALIAS_EXISTS = 0xC0000154,
+  MD_NTSTATUS_WIN_STATUS_LOGON_NOT_GRANTED = 0xC0000155,
+  MD_NTSTATUS_WIN_STATUS_TOO_MANY_SECRETS = 0xC0000156,
+  MD_NTSTATUS_WIN_STATUS_SECRET_TOO_LONG = 0xC0000157,
+  MD_NTSTATUS_WIN_STATUS_INTERNAL_DB_ERROR = 0xC0000158,
+  MD_NTSTATUS_WIN_STATUS_FULLSCREEN_MODE = 0xC0000159,
+  MD_NTSTATUS_WIN_STATUS_TOO_MANY_CONTEXT_IDS = 0xC000015A,
+  MD_NTSTATUS_WIN_STATUS_LOGON_TYPE_NOT_GRANTED = 0xC000015B,
+  MD_NTSTATUS_WIN_STATUS_NOT_REGISTRY_FILE = 0xC000015C,
+  MD_NTSTATUS_WIN_STATUS_NT_CROSS_ENCRYPTION_REQUIRED = 0xC000015D,
+  MD_NTSTATUS_WIN_STATUS_DOMAIN_CTRLR_CONFIG_ERROR = 0xC000015E,
+  MD_NTSTATUS_WIN_STATUS_FT_MISSING_MEMBER = 0xC000015F,
+  MD_NTSTATUS_WIN_STATUS_ILL_FORMED_SERVICE_ENTRY = 0xC0000160,
+  MD_NTSTATUS_WIN_STATUS_ILLEGAL_CHARACTER = 0xC0000161,
+  MD_NTSTATUS_WIN_STATUS_UNMAPPABLE_CHARACTER = 0xC0000162,
+  MD_NTSTATUS_WIN_STATUS_UNDEFINED_CHARACTER = 0xC0000163,
+  MD_NTSTATUS_WIN_STATUS_FLOPPY_VOLUME = 0xC0000164,
+  MD_NTSTATUS_WIN_STATUS_FLOPPY_ID_MARK_NOT_FOUND = 0xC0000165,
+  MD_NTSTATUS_WIN_STATUS_FLOPPY_WRONG_CYLINDER = 0xC0000166,
+  MD_NTSTATUS_WIN_STATUS_FLOPPY_UNKNOWN_ERROR = 0xC0000167,
+  MD_NTSTATUS_WIN_STATUS_FLOPPY_BAD_REGISTERS = 0xC0000168,
+  MD_NTSTATUS_WIN_STATUS_DISK_RECALIBRATE_FAILED = 0xC0000169,
+  MD_NTSTATUS_WIN_STATUS_DISK_OPERATION_FAILED = 0xC000016A,
+  MD_NTSTATUS_WIN_STATUS_DISK_RESET_FAILED = 0xC000016B,
+  MD_NTSTATUS_WIN_STATUS_SHARED_IRQ_BUSY = 0xC000016C,
+  MD_NTSTATUS_WIN_STATUS_FT_ORPHANING = 0xC000016D,
+  MD_NTSTATUS_WIN_STATUS_BIOS_FAILED_TO_CONNECT_INTERRUPT = 0xC000016E,
+  MD_NTSTATUS_WIN_STATUS_PARTITION_FAILURE = 0xC0000172,
+  MD_NTSTATUS_WIN_STATUS_INVALID_BLOCK_LENGTH = 0xC0000173,
+  MD_NTSTATUS_WIN_STATUS_DEVICE_NOT_PARTITIONED = 0xC0000174,
+  MD_NTSTATUS_WIN_STATUS_UNABLE_TO_LOCK_MEDIA = 0xC0000175,
+  MD_NTSTATUS_WIN_STATUS_UNABLE_TO_UNLOAD_MEDIA = 0xC0000176,
+  MD_NTSTATUS_WIN_STATUS_EOM_OVERFLOW = 0xC0000177,
+  MD_NTSTATUS_WIN_STATUS_NO_MEDIA = 0xC0000178,
+  MD_NTSTATUS_WIN_STATUS_NO_SUCH_MEMBER = 0xC000017A,
+  MD_NTSTATUS_WIN_STATUS_INVALID_MEMBER = 0xC000017B,
+  MD_NTSTATUS_WIN_STATUS_KEY_DELETED = 0xC000017C,
+  MD_NTSTATUS_WIN_STATUS_NO_LOG_SPACE = 0xC000017D,
+  MD_NTSTATUS_WIN_STATUS_TOO_MANY_SIDS = 0xC000017E,
+  MD_NTSTATUS_WIN_STATUS_LM_CROSS_ENCRYPTION_REQUIRED = 0xC000017F,
+  MD_NTSTATUS_WIN_STATUS_KEY_HAS_CHILDREN = 0xC0000180,
+  MD_NTSTATUS_WIN_STATUS_CHILD_MUST_BE_VOLATILE = 0xC0000181,
+  MD_NTSTATUS_WIN_STATUS_DEVICE_CONFIGURATION_ERROR = 0xC0000182,
+  MD_NTSTATUS_WIN_STATUS_DRIVER_INTERNAL_ERROR = 0xC0000183,
+  MD_NTSTATUS_WIN_STATUS_INVALID_DEVICE_STATE = 0xC0000184,
+  MD_NTSTATUS_WIN_STATUS_IO_DEVICE_ERROR = 0xC0000185,
+  MD_NTSTATUS_WIN_STATUS_DEVICE_PROTOCOL_ERROR = 0xC0000186,
+  MD_NTSTATUS_WIN_STATUS_BACKUP_CONTROLLER = 0xC0000187,
+  MD_NTSTATUS_WIN_STATUS_LOG_FILE_FULL = 0xC0000188,
+  MD_NTSTATUS_WIN_STATUS_TOO_LATE = 0xC0000189,
+  MD_NTSTATUS_WIN_STATUS_NO_TRUST_LSA_SECRET = 0xC000018A,
+  MD_NTSTATUS_WIN_STATUS_NO_TRUST_SAM_ACCOUNT = 0xC000018B,
+  MD_NTSTATUS_WIN_STATUS_TRUSTED_DOMAIN_FAILURE = 0xC000018C,
+  MD_NTSTATUS_WIN_STATUS_TRUSTED_RELATIONSHIP_FAILURE = 0xC000018D,
+  MD_NTSTATUS_WIN_STATUS_EVENTLOG_FILE_CORRUPT = 0xC000018E,
+  MD_NTSTATUS_WIN_STATUS_EVENTLOG_CANT_START = 0xC000018F,
+  MD_NTSTATUS_WIN_STATUS_TRUST_FAILURE = 0xC0000190,
+  MD_NTSTATUS_WIN_STATUS_MUTANT_LIMIT_EXCEEDED = 0xC0000191,
+  MD_NTSTATUS_WIN_STATUS_NETLOGON_NOT_STARTED = 0xC0000192,
+  MD_NTSTATUS_WIN_STATUS_ACCOUNT_EXPIRED = 0xC0000193,
+  MD_NTSTATUS_WIN_STATUS_POSSIBLE_DEADLOCK = 0xC0000194,
+  MD_NTSTATUS_WIN_STATUS_NETWORK_CREDENTIAL_CONFLICT = 0xC0000195,
+  MD_NTSTATUS_WIN_STATUS_REMOTE_SESSION_LIMIT = 0xC0000196,
+  MD_NTSTATUS_WIN_STATUS_EVENTLOG_FILE_CHANGED = 0xC0000197,
+  MD_NTSTATUS_WIN_STATUS_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT = 0xC0000198,
+  MD_NTSTATUS_WIN_STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT = 0xC0000199,
+  MD_NTSTATUS_WIN_STATUS_NOLOGON_SERVER_TRUST_ACCOUNT = 0xC000019A,
+  MD_NTSTATUS_WIN_STATUS_DOMAIN_TRUST_INCONSISTENT = 0xC000019B,
+  MD_NTSTATUS_WIN_STATUS_FS_DRIVER_REQUIRED = 0xC000019C,
+  MD_NTSTATUS_WIN_STATUS_IMAGE_ALREADY_LOADED_AS_DLL = 0xC000019D,
+  MD_NTSTATUS_WIN_STATUS_INCOMPATIBLE_WITH_GLOBAL_SHORT_NAME_REGISTRY_SETTING = 0xC000019E,
+  MD_NTSTATUS_WIN_STATUS_SHORT_NAMES_NOT_ENABLED_ON_VOLUME = 0xC000019F,
+  MD_NTSTATUS_WIN_STATUS_SECURITY_STREAM_IS_INCONSISTENT = 0xC00001A0,
+  MD_NTSTATUS_WIN_STATUS_INVALID_LOCK_RANGE = 0xC00001A1,
+  MD_NTSTATUS_WIN_STATUS_INVALID_ACE_CONDITION = 0xC00001A2,
+  MD_NTSTATUS_WIN_STATUS_IMAGE_SUBSYSTEM_NOT_PRESENT = 0xC00001A3,
+  MD_NTSTATUS_WIN_STATUS_NOTIFICATION_GUID_ALREADY_DEFINED = 0xC00001A4,
+  MD_NTSTATUS_WIN_STATUS_INVALID_EXCEPTION_HANDLER = 0xC00001A5,
+  MD_NTSTATUS_WIN_STATUS_DUPLICATE_PRIVILEGES = 0xC00001A6,
+  MD_NTSTATUS_WIN_STATUS_NOT_ALLOWED_ON_SYSTEM_FILE = 0xC00001A7,
+  MD_NTSTATUS_WIN_STATUS_REPAIR_NEEDED = 0xC00001A8,
+  MD_NTSTATUS_WIN_STATUS_QUOTA_NOT_ENABLED = 0xC00001A9,
+  MD_NTSTATUS_WIN_STATUS_NO_APPLICATION_PACKAGE = 0xC00001AA,
+  MD_NTSTATUS_WIN_STATUS_NETWORK_OPEN_RESTRICTION = 0xC0000201,
+  MD_NTSTATUS_WIN_STATUS_NO_USER_SESSION_KEY = 0xC0000202,
+  MD_NTSTATUS_WIN_STATUS_USER_SESSION_DELETED = 0xC0000203,
+  MD_NTSTATUS_WIN_STATUS_RESOURCE_LANG_NOT_FOUND = 0xC0000204,
+  MD_NTSTATUS_WIN_STATUS_INSUFF_SERVER_RESOURCES = 0xC0000205,
+  MD_NTSTATUS_WIN_STATUS_INVALID_BUFFER_SIZE = 0xC0000206,
+  MD_NTSTATUS_WIN_STATUS_INVALID_ADDRESS_COMPONENT = 0xC0000207,
+  MD_NTSTATUS_WIN_STATUS_INVALID_ADDRESS_WILDCARD = 0xC0000208,
+  MD_NTSTATUS_WIN_STATUS_TOO_MANY_ADDRESSES = 0xC0000209,
+  MD_NTSTATUS_WIN_STATUS_ADDRESS_ALREADY_EXISTS = 0xC000020A,
+  MD_NTSTATUS_WIN_STATUS_ADDRESS_CLOSED = 0xC000020B,
+  MD_NTSTATUS_WIN_STATUS_CONNECTION_DISCONNECTED = 0xC000020C,
+  MD_NTSTATUS_WIN_STATUS_CONNECTION_RESET = 0xC000020D,
+  MD_NTSTATUS_WIN_STATUS_TOO_MANY_NODES = 0xC000020E,
+  MD_NTSTATUS_WIN_STATUS_TRANSACTION_ABORTED = 0xC000020F,
+  MD_NTSTATUS_WIN_STATUS_TRANSACTION_TIMED_OUT = 0xC0000210,
+  MD_NTSTATUS_WIN_STATUS_TRANSACTION_NO_RELEASE = 0xC0000211,
+  MD_NTSTATUS_WIN_STATUS_TRANSACTION_NO_MATCH = 0xC0000212,
+  MD_NTSTATUS_WIN_STATUS_TRANSACTION_RESPONDED = 0xC0000213,
+  MD_NTSTATUS_WIN_STATUS_TRANSACTION_INVALID_ID = 0xC0000214,
+  MD_NTSTATUS_WIN_STATUS_TRANSACTION_INVALID_TYPE = 0xC0000215,
+  MD_NTSTATUS_WIN_STATUS_NOT_SERVER_SESSION = 0xC0000216,
+  MD_NTSTATUS_WIN_STATUS_NOT_CLIENT_SESSION = 0xC0000217,
+  MD_NTSTATUS_WIN_STATUS_CANNOT_LOAD_REGISTRY_FILE = 0xC0000218,
+  MD_NTSTATUS_WIN_STATUS_DEBUG_ATTACH_FAILED = 0xC0000219,
+  MD_NTSTATUS_WIN_STATUS_SYSTEM_PROCESS_TERMINATED = 0xC000021A,
+  MD_NTSTATUS_WIN_STATUS_DATA_NOT_ACCEPTED = 0xC000021B,
+  MD_NTSTATUS_WIN_STATUS_NO_BROWSER_SERVERS_FOUND = 0xC000021C,
+  MD_NTSTATUS_WIN_STATUS_VDM_HARD_ERROR = 0xC000021D,
+  MD_NTSTATUS_WIN_STATUS_DRIVER_CANCEL_TIMEOUT = 0xC000021E,
+  MD_NTSTATUS_WIN_STATUS_REPLY_MESSAGE_MISMATCH = 0xC000021F,
+  MD_NTSTATUS_WIN_STATUS_MAPPED_ALIGNMENT = 0xC0000220,
+  MD_NTSTATUS_WIN_STATUS_IMAGE_CHECKSUM_MISMATCH = 0xC0000221,
+  MD_NTSTATUS_WIN_STATUS_LOST_WRITEBEHIND_DATA = 0xC0000222,
+  MD_NTSTATUS_WIN_STATUS_CLIENT_SERVER_PARAMETERS_INVALID = 0xC0000223,
+  MD_NTSTATUS_WIN_STATUS_PASSWORD_MUST_CHANGE = 0xC0000224,
+  MD_NTSTATUS_WIN_STATUS_NOT_FOUND = 0xC0000225,
+  MD_NTSTATUS_WIN_STATUS_NOT_TINY_STREAM = 0xC0000226,
+  MD_NTSTATUS_WIN_STATUS_RECOVERY_FAILURE = 0xC0000227,
+  MD_NTSTATUS_WIN_STATUS_STACK_OVERFLOW_READ = 0xC0000228,
+  MD_NTSTATUS_WIN_STATUS_FAIL_CHECK = 0xC0000229,
+  MD_NTSTATUS_WIN_STATUS_DUPLICATE_OBJECTID = 0xC000022A,
+  MD_NTSTATUS_WIN_STATUS_OBJECTID_EXISTS = 0xC000022B,
+  MD_NTSTATUS_WIN_STATUS_CONVERT_TO_LARGE = 0xC000022C,
+  MD_NTSTATUS_WIN_STATUS_RETRY = 0xC000022D,
+  MD_NTSTATUS_WIN_STATUS_FOUND_OUT_OF_SCOPE = 0xC000022E,
+  MD_NTSTATUS_WIN_STATUS_ALLOCATE_BUCKET = 0xC000022F,
+  MD_NTSTATUS_WIN_STATUS_PROPSET_NOT_FOUND = 0xC0000230,
+  MD_NTSTATUS_WIN_STATUS_MARSHALL_OVERFLOW = 0xC0000231,
+  MD_NTSTATUS_WIN_STATUS_INVALID_VARIANT = 0xC0000232,
+  MD_NTSTATUS_WIN_STATUS_DOMAIN_CONTROLLER_NOT_FOUND = 0xC0000233,
+  MD_NTSTATUS_WIN_STATUS_ACCOUNT_LOCKED_OUT = 0xC0000234,
+  MD_NTSTATUS_WIN_STATUS_HANDLE_NOT_CLOSABLE = 0xC0000235,
+  MD_NTSTATUS_WIN_STATUS_CONNECTION_REFUSED = 0xC0000236,
+  MD_NTSTATUS_WIN_STATUS_GRACEFUL_DISCONNECT = 0xC0000237,
+  MD_NTSTATUS_WIN_STATUS_ADDRESS_ALREADY_ASSOCIATED = 0xC0000238,
+  MD_NTSTATUS_WIN_STATUS_ADDRESS_NOT_ASSOCIATED = 0xC0000239,
+  MD_NTSTATUS_WIN_STATUS_CONNECTION_INVALID = 0xC000023A,
+  MD_NTSTATUS_WIN_STATUS_CONNECTION_ACTIVE = 0xC000023B,
+  MD_NTSTATUS_WIN_STATUS_NETWORK_UNREACHABLE = 0xC000023C,
+  MD_NTSTATUS_WIN_STATUS_HOST_UNREACHABLE = 0xC000023D,
+  MD_NTSTATUS_WIN_STATUS_PROTOCOL_UNREACHABLE = 0xC000023E,
+  MD_NTSTATUS_WIN_STATUS_PORT_UNREACHABLE = 0xC000023F,
+  MD_NTSTATUS_WIN_STATUS_REQUEST_ABORTED = 0xC0000240,
+  MD_NTSTATUS_WIN_STATUS_CONNECTION_ABORTED = 0xC0000241,
+  MD_NTSTATUS_WIN_STATUS_BAD_COMPRESSION_BUFFER = 0xC0000242,
+  MD_NTSTATUS_WIN_STATUS_USER_MAPPED_FILE = 0xC0000243,
+  MD_NTSTATUS_WIN_STATUS_AUDIT_FAILED = 0xC0000244,
+  MD_NTSTATUS_WIN_STATUS_TIMER_RESOLUTION_NOT_SET = 0xC0000245,
+  MD_NTSTATUS_WIN_STATUS_CONNECTION_COUNT_LIMIT = 0xC0000246,
+  MD_NTSTATUS_WIN_STATUS_LOGIN_TIME_RESTRICTION = 0xC0000247,
+  MD_NTSTATUS_WIN_STATUS_LOGIN_WKSTA_RESTRICTION = 0xC0000248,
+  MD_NTSTATUS_WIN_STATUS_IMAGE_MP_UP_MISMATCH = 0xC0000249,
+  MD_NTSTATUS_WIN_STATUS_INSUFFICIENT_LOGON_INFO = 0xC0000250,
+  MD_NTSTATUS_WIN_STATUS_BAD_DLL_ENTRYPOINT = 0xC0000251,
+  MD_NTSTATUS_WIN_STATUS_BAD_SERVICE_ENTRYPOINT = 0xC0000252,
+  MD_NTSTATUS_WIN_STATUS_LPC_REPLY_LOST = 0xC0000253,
+  MD_NTSTATUS_WIN_STATUS_IP_ADDRESS_CONFLICT1 = 0xC0000254,
+  MD_NTSTATUS_WIN_STATUS_IP_ADDRESS_CONFLICT2 = 0xC0000255,
+  MD_NTSTATUS_WIN_STATUS_REGISTRY_QUOTA_LIMIT = 0xC0000256,
+  MD_NTSTATUS_WIN_STATUS_PATH_NOT_COVERED = 0xC0000257,
+  MD_NTSTATUS_WIN_STATUS_NO_CALLBACK_ACTIVE = 0xC0000258,
+  MD_NTSTATUS_WIN_STATUS_LICENSE_QUOTA_EXCEEDED = 0xC0000259,
+  MD_NTSTATUS_WIN_STATUS_PWD_TOO_SHORT = 0xC000025A,
+  MD_NTSTATUS_WIN_STATUS_PWD_TOO_RECENT = 0xC000025B,
+  MD_NTSTATUS_WIN_STATUS_PWD_HISTORY_CONFLICT = 0xC000025C,
+  MD_NTSTATUS_WIN_STATUS_PLUGPLAY_NO_DEVICE = 0xC000025E,
+  MD_NTSTATUS_WIN_STATUS_UNSUPPORTED_COMPRESSION = 0xC000025F,
+  MD_NTSTATUS_WIN_STATUS_INVALID_HW_PROFILE = 0xC0000260,
+  MD_NTSTATUS_WIN_STATUS_INVALID_PLUGPLAY_DEVICE_PATH = 0xC0000261,
+  MD_NTSTATUS_WIN_STATUS_DRIVER_ORDINAL_NOT_FOUND = 0xC0000262,
+  MD_NTSTATUS_WIN_STATUS_DRIVER_ENTRYPOINT_NOT_FOUND = 0xC0000263,
+  MD_NTSTATUS_WIN_STATUS_RESOURCE_NOT_OWNED = 0xC0000264,
+  MD_NTSTATUS_WIN_STATUS_TOO_MANY_LINKS = 0xC0000265,
+  MD_NTSTATUS_WIN_STATUS_QUOTA_LIST_INCONSISTENT = 0xC0000266,
+  MD_NTSTATUS_WIN_STATUS_FILE_IS_OFFLINE = 0xC0000267,
+  MD_NTSTATUS_WIN_STATUS_EVALUATION_EXPIRATION = 0xC0000268,
+  MD_NTSTATUS_WIN_STATUS_ILLEGAL_DLL_RELOCATION = 0xC0000269,
+  MD_NTSTATUS_WIN_STATUS_LICENSE_VIOLATION = 0xC000026A,
+  MD_NTSTATUS_WIN_STATUS_DLL_INIT_FAILED_LOGOFF = 0xC000026B,
+  MD_NTSTATUS_WIN_STATUS_DRIVER_UNABLE_TO_LOAD = 0xC000026C,
+  MD_NTSTATUS_WIN_STATUS_DFS_UNAVAILABLE = 0xC000026D,
+  MD_NTSTATUS_WIN_STATUS_VOLUME_DISMOUNTED = 0xC000026E,
+  MD_NTSTATUS_WIN_STATUS_WX86_INTERNAL_ERROR = 0xC000026F,
+  MD_NTSTATUS_WIN_STATUS_WX86_FLOAT_STACK_CHECK = 0xC0000270,
+  MD_NTSTATUS_WIN_STATUS_VALIDATE_CONTINUE = 0xC0000271,
+  MD_NTSTATUS_WIN_STATUS_NO_MATCH = 0xC0000272,
+  MD_NTSTATUS_WIN_STATUS_NO_MORE_MATCHES = 0xC0000273,
+  MD_NTSTATUS_WIN_STATUS_NOT_A_REPARSE_POINT = 0xC0000275,
+  MD_NTSTATUS_WIN_STATUS_IO_REPARSE_TAG_INVALID = 0xC0000276,
+  MD_NTSTATUS_WIN_STATUS_IO_REPARSE_TAG_MISMATCH = 0xC0000277,
+  MD_NTSTATUS_WIN_STATUS_IO_REPARSE_DATA_INVALID = 0xC0000278,
+  MD_NTSTATUS_WIN_STATUS_IO_REPARSE_TAG_NOT_HANDLED = 0xC0000279,
+  MD_NTSTATUS_WIN_STATUS_PWD_TOO_LONG = 0xC000027A,
+  MD_NTSTATUS_WIN_STATUS_STOWED_EXCEPTION = 0xC000027B,
+  MD_NTSTATUS_WIN_STATUS_REPARSE_POINT_NOT_RESOLVED = 0xC0000280,
+  MD_NTSTATUS_WIN_STATUS_DIRECTORY_IS_A_REPARSE_POINT = 0xC0000281,
+  MD_NTSTATUS_WIN_STATUS_RANGE_LIST_CONFLICT = 0xC0000282,
+  MD_NTSTATUS_WIN_STATUS_SOURCE_ELEMENT_EMPTY = 0xC0000283,
+  MD_NTSTATUS_WIN_STATUS_DESTINATION_ELEMENT_FULL = 0xC0000284,
+  MD_NTSTATUS_WIN_STATUS_ILLEGAL_ELEMENT_ADDRESS = 0xC0000285,
+  MD_NTSTATUS_WIN_STATUS_MAGAZINE_NOT_PRESENT = 0xC0000286,
+  MD_NTSTATUS_WIN_STATUS_REINITIALIZATION_NEEDED = 0xC0000287,
+  MD_NTSTATUS_WIN_STATUS_ENCRYPTION_FAILED = 0xC000028A,
+  MD_NTSTATUS_WIN_STATUS_DECRYPTION_FAILED = 0xC000028B,
+  MD_NTSTATUS_WIN_STATUS_RANGE_NOT_FOUND = 0xC000028C,
+  MD_NTSTATUS_WIN_STATUS_NO_RECOVERY_POLICY = 0xC000028D,
+  MD_NTSTATUS_WIN_STATUS_NO_EFS = 0xC000028E,
+  MD_NTSTATUS_WIN_STATUS_WRONG_EFS = 0xC000028F,
+  MD_NTSTATUS_WIN_STATUS_NO_USER_KEYS = 0xC0000290,
+  MD_NTSTATUS_WIN_STATUS_FILE_NOT_ENCRYPTED = 0xC0000291,
+  MD_NTSTATUS_WIN_STATUS_NOT_EXPORT_FORMAT = 0xC0000292,
+  MD_NTSTATUS_WIN_STATUS_FILE_ENCRYPTED = 0xC0000293,
+  MD_NTSTATUS_WIN_STATUS_WMI_GUID_NOT_FOUND = 0xC0000295,
+  MD_NTSTATUS_WIN_STATUS_WMI_INSTANCE_NOT_FOUND = 0xC0000296,
+  MD_NTSTATUS_WIN_STATUS_WMI_ITEMID_NOT_FOUND = 0xC0000297,
+  MD_NTSTATUS_WIN_STATUS_WMI_TRY_AGAIN = 0xC0000298,
+  MD_NTSTATUS_WIN_STATUS_SHARED_POLICY = 0xC0000299,
+  MD_NTSTATUS_WIN_STATUS_POLICY_OBJECT_NOT_FOUND = 0xC000029A,
+  MD_NTSTATUS_WIN_STATUS_POLICY_ONLY_IN_DS = 0xC000029B,
+  MD_NTSTATUS_WIN_STATUS_VOLUME_NOT_UPGRADED = 0xC000029C,
+  MD_NTSTATUS_WIN_STATUS_REMOTE_STORAGE_NOT_ACTIVE = 0xC000029D,
+  MD_NTSTATUS_WIN_STATUS_REMOTE_STORAGE_MEDIA_ERROR = 0xC000029E,
+  MD_NTSTATUS_WIN_STATUS_NO_TRACKING_SERVICE = 0xC000029F,
+  MD_NTSTATUS_WIN_STATUS_SERVER_SID_MISMATCH = 0xC00002A0,
+  MD_NTSTATUS_WIN_STATUS_DS_NO_ATTRIBUTE_OR_VALUE = 0xC00002A1,
+  MD_NTSTATUS_WIN_STATUS_DS_INVALID_ATTRIBUTE_SYNTAX = 0xC00002A2,
+  MD_NTSTATUS_WIN_STATUS_DS_ATTRIBUTE_TYPE_UNDEFINED = 0xC00002A3,
+  MD_NTSTATUS_WIN_STATUS_DS_ATTRIBUTE_OR_VALUE_EXISTS = 0xC00002A4,
+  MD_NTSTATUS_WIN_STATUS_DS_BUSY = 0xC00002A5,
+  MD_NTSTATUS_WIN_STATUS_DS_UNAVAILABLE = 0xC00002A6,
+  MD_NTSTATUS_WIN_STATUS_DS_NO_RIDS_ALLOCATED = 0xC00002A7,
+  MD_NTSTATUS_WIN_STATUS_DS_NO_MORE_RIDS = 0xC00002A8,
+  MD_NTSTATUS_WIN_STATUS_DS_INCORRECT_ROLE_OWNER = 0xC00002A9,
+  MD_NTSTATUS_WIN_STATUS_DS_RIDMGR_INIT_ERROR = 0xC00002AA,
+  MD_NTSTATUS_WIN_STATUS_DS_OBJ_CLASS_VIOLATION = 0xC00002AB,
+  MD_NTSTATUS_WIN_STATUS_DS_CANT_ON_NON_LEAF = 0xC00002AC,
+  MD_NTSTATUS_WIN_STATUS_DS_CANT_ON_RDN = 0xC00002AD,
+  MD_NTSTATUS_WIN_STATUS_DS_CANT_MOD_OBJ_CLASS = 0xC00002AE,
+  MD_NTSTATUS_WIN_STATUS_DS_CROSS_DOM_MOVE_FAILED = 0xC00002AF,
+  MD_NTSTATUS_WIN_STATUS_DS_GC_NOT_AVAILABLE = 0xC00002B0,
+  MD_NTSTATUS_WIN_STATUS_DIRECTORY_SERVICE_REQUIRED = 0xC00002B1,
+  MD_NTSTATUS_WIN_STATUS_REPARSE_ATTRIBUTE_CONFLICT = 0xC00002B2,
+  MD_NTSTATUS_WIN_STATUS_CANT_ENABLE_DENY_ONLY = 0xC00002B3,
+  MD_NTSTATUS_WIN_STATUS_FLOAT_MULTIPLE_FAULTS = 0xC00002B4,
+  MD_NTSTATUS_WIN_STATUS_FLOAT_MULTIPLE_TRAPS = 0xC00002B5,
+  MD_NTSTATUS_WIN_STATUS_DEVICE_REMOVED = 0xC00002B6,
+  MD_NTSTATUS_WIN_STATUS_JOURNAL_DELETE_IN_PROGRESS = 0xC00002B7,
+  MD_NTSTATUS_WIN_STATUS_JOURNAL_NOT_ACTIVE = 0xC00002B8,
+  MD_NTSTATUS_WIN_STATUS_NOINTERFACE = 0xC00002B9,
+  MD_NTSTATUS_WIN_STATUS_DS_RIDMGR_DISABLED = 0xC00002BA,
+  MD_NTSTATUS_WIN_STATUS_DS_ADMIN_LIMIT_EXCEEDED = 0xC00002C1,
+  MD_NTSTATUS_WIN_STATUS_DRIVER_FAILED_SLEEP = 0xC00002C2,
+  MD_NTSTATUS_WIN_STATUS_MUTUAL_AUTHENTICATION_FAILED = 0xC00002C3,
+  MD_NTSTATUS_WIN_STATUS_CORRUPT_SYSTEM_FILE = 0xC00002C4,
+  MD_NTSTATUS_WIN_STATUS_DATATYPE_MISALIGNMENT_ERROR = 0xC00002C5,
+  MD_NTSTATUS_WIN_STATUS_WMI_READ_ONLY = 0xC00002C6,
+  MD_NTSTATUS_WIN_STATUS_WMI_SET_FAILURE = 0xC00002C7,
+  MD_NTSTATUS_WIN_STATUS_COMMITMENT_MINIMUM = 0xC00002C8,
+  MD_NTSTATUS_WIN_STATUS_REG_NAT_CONSUMPTION = 0xC00002C9,
+  MD_NTSTATUS_WIN_STATUS_TRANSPORT_FULL = 0xC00002CA,
+  MD_NTSTATUS_WIN_STATUS_DS_SAM_INIT_FAILURE = 0xC00002CB,
+  MD_NTSTATUS_WIN_STATUS_ONLY_IF_CONNECTED = 0xC00002CC,
+  MD_NTSTATUS_WIN_STATUS_DS_SENSITIVE_GROUP_VIOLATION = 0xC00002CD,
+  MD_NTSTATUS_WIN_STATUS_PNP_RESTART_ENUMERATION = 0xC00002CE,
+  MD_NTSTATUS_WIN_STATUS_JOURNAL_ENTRY_DELETED = 0xC00002CF,
+  MD_NTSTATUS_WIN_STATUS_DS_CANT_MOD_PRIMARYGROUPID = 0xC00002D0,
+  MD_NTSTATUS_WIN_STATUS_SYSTEM_IMAGE_BAD_SIGNATURE = 0xC00002D1,
+  MD_NTSTATUS_WIN_STATUS_PNP_REBOOT_REQUIRED = 0xC00002D2,
+  MD_NTSTATUS_WIN_STATUS_POWER_STATE_INVALID = 0xC00002D3,
+  MD_NTSTATUS_WIN_STATUS_DS_INVALID_GROUP_TYPE = 0xC00002D4,
+  MD_NTSTATUS_WIN_STATUS_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN = 0xC00002D5,
+  MD_NTSTATUS_WIN_STATUS_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN = 0xC00002D6,
+  MD_NTSTATUS_WIN_STATUS_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER = 0xC00002D7,
+  MD_NTSTATUS_WIN_STATUS_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER = 0xC00002D8,
+  MD_NTSTATUS_WIN_STATUS_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER = 0xC00002D9,
+  MD_NTSTATUS_WIN_STATUS_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER = 0xC00002DA,
+  MD_NTSTATUS_WIN_STATUS_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER = 0xC00002DB,
+  MD_NTSTATUS_WIN_STATUS_DS_HAVE_PRIMARY_MEMBERS = 0xC00002DC,
+  MD_NTSTATUS_WIN_STATUS_WMI_NOT_SUPPORTED = 0xC00002DD,
+  MD_NTSTATUS_WIN_STATUS_INSUFFICIENT_POWER = 0xC00002DE,
+  MD_NTSTATUS_WIN_STATUS_SAM_NEED_BOOTKEY_PASSWORD = 0xC00002DF,
+  MD_NTSTATUS_WIN_STATUS_SAM_NEED_BOOTKEY_FLOPPY = 0xC00002E0,
+  MD_NTSTATUS_WIN_STATUS_DS_CANT_START = 0xC00002E1,
+  MD_NTSTATUS_WIN_STATUS_DS_INIT_FAILURE = 0xC00002E2,
+  MD_NTSTATUS_WIN_STATUS_SAM_INIT_FAILURE = 0xC00002E3,
+  MD_NTSTATUS_WIN_STATUS_DS_GC_REQUIRED = 0xC00002E4,
+  MD_NTSTATUS_WIN_STATUS_DS_LOCAL_MEMBER_OF_LOCAL_ONLY = 0xC00002E5,
+  MD_NTSTATUS_WIN_STATUS_DS_NO_FPO_IN_UNIVERSAL_GROUPS = 0xC00002E6,
+  MD_NTSTATUS_WIN_STATUS_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED = 0xC00002E7,
+  MD_NTSTATUS_WIN_STATUS_MULTIPLE_FAULT_VIOLATION = 0xC00002E8,
+  MD_NTSTATUS_WIN_STATUS_CURRENT_DOMAIN_NOT_ALLOWED = 0xC00002E9,
+  MD_NTSTATUS_WIN_STATUS_CANNOT_MAKE = 0xC00002EA,
+  MD_NTSTATUS_WIN_STATUS_SYSTEM_SHUTDOWN = 0xC00002EB,
+  MD_NTSTATUS_WIN_STATUS_DS_INIT_FAILURE_CONSOLE = 0xC00002EC,
+  MD_NTSTATUS_WIN_STATUS_DS_SAM_INIT_FAILURE_CONSOLE = 0xC00002ED,
+  MD_NTSTATUS_WIN_STATUS_UNFINISHED_CONTEXT_DELETED = 0xC00002EE,
+  MD_NTSTATUS_WIN_STATUS_NO_TGT_REPLY = 0xC00002EF,
+  MD_NTSTATUS_WIN_STATUS_OBJECTID_NOT_FOUND = 0xC00002F0,
+  MD_NTSTATUS_WIN_STATUS_NO_IP_ADDRESSES = 0xC00002F1,
+  MD_NTSTATUS_WIN_STATUS_WRONG_CREDENTIAL_HANDLE = 0xC00002F2,
+  MD_NTSTATUS_WIN_STATUS_CRYPTO_SYSTEM_INVALID = 0xC00002F3,
+  MD_NTSTATUS_WIN_STATUS_MAX_REFERRALS_EXCEEDED = 0xC00002F4,
+  MD_NTSTATUS_WIN_STATUS_MUST_BE_KDC = 0xC00002F5,
+  MD_NTSTATUS_WIN_STATUS_STRONG_CRYPTO_NOT_SUPPORTED = 0xC00002F6,
+  MD_NTSTATUS_WIN_STATUS_TOO_MANY_PRINCIPALS = 0xC00002F7,
+  MD_NTSTATUS_WIN_STATUS_NO_PA_DATA = 0xC00002F8,
+  MD_NTSTATUS_WIN_STATUS_PKINIT_NAME_MISMATCH = 0xC00002F9,
+  MD_NTSTATUS_WIN_STATUS_SMARTCARD_LOGON_REQUIRED = 0xC00002FA,
+  MD_NTSTATUS_WIN_STATUS_KDC_INVALID_REQUEST = 0xC00002FB,
+  MD_NTSTATUS_WIN_STATUS_KDC_UNABLE_TO_REFER = 0xC00002FC,
+  MD_NTSTATUS_WIN_STATUS_KDC_UNKNOWN_ETYPE = 0xC00002FD,
+  MD_NTSTATUS_WIN_STATUS_SHUTDOWN_IN_PROGRESS = 0xC00002FE,
+  MD_NTSTATUS_WIN_STATUS_SERVER_SHUTDOWN_IN_PROGRESS = 0xC00002FF,
+  MD_NTSTATUS_WIN_STATUS_NOT_SUPPORTED_ON_SBS = 0xC0000300,
+  MD_NTSTATUS_WIN_STATUS_WMI_GUID_DISCONNECTED = 0xC0000301,
+  MD_NTSTATUS_WIN_STATUS_WMI_ALREADY_DISABLED = 0xC0000302,
+  MD_NTSTATUS_WIN_STATUS_WMI_ALREADY_ENABLED = 0xC0000303,
+  MD_NTSTATUS_WIN_STATUS_MFT_TOO_FRAGMENTED = 0xC0000304,
+  MD_NTSTATUS_WIN_STATUS_COPY_PROTECTION_FAILURE = 0xC0000305,
+  MD_NTSTATUS_WIN_STATUS_CSS_AUTHENTICATION_FAILURE = 0xC0000306,
+  MD_NTSTATUS_WIN_STATUS_CSS_KEY_NOT_PRESENT = 0xC0000307,
+  MD_NTSTATUS_WIN_STATUS_CSS_KEY_NOT_ESTABLISHED = 0xC0000308,
+  MD_NTSTATUS_WIN_STATUS_CSS_SCRAMBLED_SECTOR = 0xC0000309,
+  MD_NTSTATUS_WIN_STATUS_CSS_REGION_MISMATCH = 0xC000030A,
+  MD_NTSTATUS_WIN_STATUS_CSS_RESETS_EXHAUSTED = 0xC000030B,
+  MD_NTSTATUS_WIN_STATUS_PASSWORD_CHANGE_REQUIRED = 0xC000030C,
+  MD_NTSTATUS_WIN_STATUS_PKINIT_FAILURE = 0xC0000320,
+  MD_NTSTATUS_WIN_STATUS_SMARTCARD_SUBSYSTEM_FAILURE = 0xC0000321,
+  MD_NTSTATUS_WIN_STATUS_NO_KERB_KEY = 0xC0000322,
+  MD_NTSTATUS_WIN_STATUS_HOST_DOWN = 0xC0000350,
+  MD_NTSTATUS_WIN_STATUS_UNSUPPORTED_PREAUTH = 0xC0000351,
+  MD_NTSTATUS_WIN_STATUS_EFS_ALG_BLOB_TOO_BIG = 0xC0000352,
+  MD_NTSTATUS_WIN_STATUS_PORT_NOT_SET = 0xC0000353,
+  MD_NTSTATUS_WIN_STATUS_DEBUGGER_INACTIVE = 0xC0000354,
+  MD_NTSTATUS_WIN_STATUS_DS_VERSION_CHECK_FAILURE = 0xC0000355,
+  MD_NTSTATUS_WIN_STATUS_AUDITING_DISABLED = 0xC0000356,
+  MD_NTSTATUS_WIN_STATUS_PRENT4_MACHINE_ACCOUNT = 0xC0000357,
+  MD_NTSTATUS_WIN_STATUS_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER = 0xC0000358,
+  MD_NTSTATUS_WIN_STATUS_INVALID_IMAGE_WIN_32 = 0xC0000359,
+  MD_NTSTATUS_WIN_STATUS_INVALID_IMAGE_WIN_64 = 0xC000035A,
+  MD_NTSTATUS_WIN_STATUS_BAD_BINDINGS = 0xC000035B,
+  MD_NTSTATUS_WIN_STATUS_NETWORK_SESSION_EXPIRED = 0xC000035C,
+  MD_NTSTATUS_WIN_STATUS_APPHELP_BLOCK = 0xC000035D,
+  MD_NTSTATUS_WIN_STATUS_ALL_SIDS_FILTERED = 0xC000035E,
+  MD_NTSTATUS_WIN_STATUS_NOT_SAFE_MODE_DRIVER = 0xC000035F,
+  MD_NTSTATUS_WIN_STATUS_ACCESS_DISABLED_BY_POLICY_DEFAULT = 0xC0000361,
+  MD_NTSTATUS_WIN_STATUS_ACCESS_DISABLED_BY_POLICY_PATH = 0xC0000362,
+  MD_NTSTATUS_WIN_STATUS_ACCESS_DISABLED_BY_POLICY_PUBLISHER = 0xC0000363,
+  MD_NTSTATUS_WIN_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER = 0xC0000364,
+  MD_NTSTATUS_WIN_STATUS_FAILED_DRIVER_ENTRY = 0xC0000365,
+  MD_NTSTATUS_WIN_STATUS_DEVICE_ENUMERATION_ERROR = 0xC0000366,
+  MD_NTSTATUS_WIN_STATUS_MOUNT_POINT_NOT_RESOLVED = 0xC0000368,
+  MD_NTSTATUS_WIN_STATUS_INVALID_DEVICE_OBJECT_PARAMETER = 0xC0000369,
+  MD_NTSTATUS_WIN_STATUS_MCA_OCCURED = 0xC000036A,
+  MD_NTSTATUS_WIN_STATUS_DRIVER_BLOCKED_CRITICAL = 0xC000036B,
+  MD_NTSTATUS_WIN_STATUS_DRIVER_BLOCKED = 0xC000036C,
+  MD_NTSTATUS_WIN_STATUS_DRIVER_DATABASE_ERROR = 0xC000036D,
+  MD_NTSTATUS_WIN_STATUS_SYSTEM_HIVE_TOO_LARGE = 0xC000036E,
+  MD_NTSTATUS_WIN_STATUS_INVALID_IMPORT_OF_NON_DLL = 0xC000036F,
+  MD_NTSTATUS_WIN_STATUS_NO_SECRETS = 0xC0000371,
+  MD_NTSTATUS_WIN_STATUS_ACCESS_DISABLED_NO_SAFER_UI_BY_POLICY = 0xC0000372,
+  MD_NTSTATUS_WIN_STATUS_FAILED_STACK_SWITCH = 0xC0000373,
+  MD_NTSTATUS_WIN_STATUS_HEAP_CORRUPTION = 0xC0000374,
+  MD_NTSTATUS_WIN_STATUS_SMARTCARD_WRONG_PIN = 0xC0000380,
+  MD_NTSTATUS_WIN_STATUS_SMARTCARD_CARD_BLOCKED = 0xC0000381,
+  MD_NTSTATUS_WIN_STATUS_SMARTCARD_CARD_NOT_AUTHENTICATED = 0xC0000382,
+  MD_NTSTATUS_WIN_STATUS_SMARTCARD_NO_CARD = 0xC0000383,
+  MD_NTSTATUS_WIN_STATUS_SMARTCARD_NO_KEY_CONTAINER = 0xC0000384,
+  MD_NTSTATUS_WIN_STATUS_SMARTCARD_NO_CERTIFICATE = 0xC0000385,
+  MD_NTSTATUS_WIN_STATUS_SMARTCARD_NO_KEYSET = 0xC0000386,
+  MD_NTSTATUS_WIN_STATUS_SMARTCARD_IO_ERROR = 0xC0000387,
+  MD_NTSTATUS_WIN_STATUS_DOWNGRADE_DETECTED = 0xC0000388,
+  MD_NTSTATUS_WIN_STATUS_SMARTCARD_CERT_REVOKED = 0xC0000389,
+  MD_NTSTATUS_WIN_STATUS_ISSUING_CA_UNTRUSTED = 0xC000038A,
+  MD_NTSTATUS_WIN_STATUS_REVOCATION_OFFLINE_C = 0xC000038B,
+  MD_NTSTATUS_WIN_STATUS_PKINIT_CLIENT_FAILURE = 0xC000038C,
+  MD_NTSTATUS_WIN_STATUS_SMARTCARD_CERT_EXPIRED = 0xC000038D,
+  MD_NTSTATUS_WIN_STATUS_DRIVER_FAILED_PRIOR_UNLOAD = 0xC000038E,
+  MD_NTSTATUS_WIN_STATUS_SMARTCARD_SILENT_CONTEXT = 0xC000038F,
+  MD_NTSTATUS_WIN_STATUS_PER_USER_TRUST_QUOTA_EXCEEDED = 0xC0000401,
+  MD_NTSTATUS_WIN_STATUS_ALL_USER_TRUST_QUOTA_EXCEEDED = 0xC0000402,
+  MD_NTSTATUS_WIN_STATUS_USER_DELETE_TRUST_QUOTA_EXCEEDED = 0xC0000403,
+  MD_NTSTATUS_WIN_STATUS_DS_NAME_NOT_UNIQUE = 0xC0000404,
+  MD_NTSTATUS_WIN_STATUS_DS_DUPLICATE_ID_FOUND = 0xC0000405,
+  MD_NTSTATUS_WIN_STATUS_DS_GROUP_CONVERSION_ERROR = 0xC0000406,
+  MD_NTSTATUS_WIN_STATUS_VOLSNAP_PREPARE_HIBERNATE = 0xC0000407,
+  MD_NTSTATUS_WIN_STATUS_USER2USER_REQUIRED = 0xC0000408,
+  MD_NTSTATUS_WIN_STATUS_STACK_BUFFER_OVERRUN = 0xC0000409,
+  MD_NTSTATUS_WIN_STATUS_NO_S4U_PROT_SUPPORT = 0xC000040A,
+  MD_NTSTATUS_WIN_STATUS_CROSSREALM_DELEGATION_FAILURE = 0xC000040B,
+  MD_NTSTATUS_WIN_STATUS_REVOCATION_OFFLINE_KDC = 0xC000040C,
+  MD_NTSTATUS_WIN_STATUS_ISSUING_CA_UNTRUSTED_KDC = 0xC000040D,
+  MD_NTSTATUS_WIN_STATUS_KDC_CERT_EXPIRED = 0xC000040E,
+  MD_NTSTATUS_WIN_STATUS_KDC_CERT_REVOKED = 0xC000040F,
+  MD_NTSTATUS_WIN_STATUS_PARAMETER_QUOTA_EXCEEDED = 0xC0000410,
+  MD_NTSTATUS_WIN_STATUS_HIBERNATION_FAILURE = 0xC0000411,
+  MD_NTSTATUS_WIN_STATUS_DELAY_LOAD_FAILED = 0xC0000412,
+  MD_NTSTATUS_WIN_STATUS_AUTHENTICATION_FIREWALL_FAILED = 0xC0000413,
+  MD_NTSTATUS_WIN_STATUS_VDM_DISALLOWED = 0xC0000414,
+  MD_NTSTATUS_WIN_STATUS_HUNG_DISPLAY_DRIVER_THREAD = 0xC0000415,
+  MD_NTSTATUS_WIN_STATUS_INSUFFICIENT_RESOURCE_FOR_SPECIFIED_SHARED_SECTION_SIZE = 0xC0000416,
+  MD_NTSTATUS_WIN_STATUS_INVALID_CRUNTIME_PARAMETER = 0xC0000417,
+  MD_NTSTATUS_WIN_STATUS_NTLM_BLOCKED = 0xC0000418,
+  MD_NTSTATUS_WIN_STATUS_DS_SRC_SID_EXISTS_IN_FOREST = 0xC0000419,
+  MD_NTSTATUS_WIN_STATUS_DS_DOMAIN_NAME_EXISTS_IN_FOREST = 0xC000041A,
+  MD_NTSTATUS_WIN_STATUS_DS_FLAT_NAME_EXISTS_IN_FOREST = 0xC000041B,
+  MD_NTSTATUS_WIN_STATUS_INVALID_USER_PRINCIPAL_NAME = 0xC000041C,
+  MD_NTSTATUS_WIN_STATUS_FATAL_USER_CALLBACK_EXCEPTION = 0xC000041D,
+  MD_NTSTATUS_WIN_STATUS_ASSERTION_FAILURE = 0xC0000420,
+  MD_NTSTATUS_WIN_STATUS_VERIFIER_STOP = 0xC0000421,
+  MD_NTSTATUS_WIN_STATUS_CALLBACK_POP_STACK = 0xC0000423,
+  MD_NTSTATUS_WIN_STATUS_INCOMPATIBLE_DRIVER_BLOCKED = 0xC0000424,
+  MD_NTSTATUS_WIN_STATUS_HIVE_UNLOADED = 0xC0000425,
+  MD_NTSTATUS_WIN_STATUS_COMPRESSION_DISABLED = 0xC0000426,
+  MD_NTSTATUS_WIN_STATUS_FILE_SYSTEM_LIMITATION = 0xC0000427,
+  MD_NTSTATUS_WIN_STATUS_INVALID_IMAGE_HASH = 0xC0000428,
+  MD_NTSTATUS_WIN_STATUS_NOT_CAPABLE = 0xC0000429,
+  MD_NTSTATUS_WIN_STATUS_REQUEST_OUT_OF_SEQUENCE = 0xC000042A,
+  MD_NTSTATUS_WIN_STATUS_IMPLEMENTATION_LIMIT = 0xC000042B,
+  MD_NTSTATUS_WIN_STATUS_ELEVATION_REQUIRED = 0xC000042C,
+  MD_NTSTATUS_WIN_STATUS_NO_SECURITY_CONTEXT = 0xC000042D,
+  MD_NTSTATUS_WIN_STATUS_PKU2U_CERT_FAILURE = 0xC000042F,
+  MD_NTSTATUS_WIN_STATUS_BEYOND_VDL = 0xC0000432,
+  MD_NTSTATUS_WIN_STATUS_ENCOUNTERED_WRITE_IN_PROGRESS = 0xC0000433,
+  MD_NTSTATUS_WIN_STATUS_PTE_CHANGED = 0xC0000434,
+  MD_NTSTATUS_WIN_STATUS_PURGE_FAILED = 0xC0000435,
+  MD_NTSTATUS_WIN_STATUS_CRED_REQUIRES_CONFIRMATION = 0xC0000440,
+  MD_NTSTATUS_WIN_STATUS_CS_ENCRYPTION_INVALID_SERVER_RESPONSE = 0xC0000441,
+  MD_NTSTATUS_WIN_STATUS_CS_ENCRYPTION_UNSUPPORTED_SERVER = 0xC0000442,
+  MD_NTSTATUS_WIN_STATUS_CS_ENCRYPTION_EXISTING_ENCRYPTED_FILE = 0xC0000443,
+  MD_NTSTATUS_WIN_STATUS_CS_ENCRYPTION_NEW_ENCRYPTED_FILE = 0xC0000444,
+  MD_NTSTATUS_WIN_STATUS_CS_ENCRYPTION_FILE_NOT_CSE = 0xC0000445,
+  MD_NTSTATUS_WIN_STATUS_INVALID_LABEL = 0xC0000446,
+  MD_NTSTATUS_WIN_STATUS_DRIVER_PROCESS_TERMINATED = 0xC0000450,
+  MD_NTSTATUS_WIN_STATUS_AMBIGUOUS_SYSTEM_DEVICE = 0xC0000451,
+  MD_NTSTATUS_WIN_STATUS_SYSTEM_DEVICE_NOT_FOUND = 0xC0000452,
+  MD_NTSTATUS_WIN_STATUS_RESTART_BOOT_APPLICATION = 0xC0000453,
+  MD_NTSTATUS_WIN_STATUS_INSUFFICIENT_NVRAM_RESOURCES = 0xC0000454,
+  MD_NTSTATUS_WIN_STATUS_INVALID_SESSION = 0xC0000455,
+  MD_NTSTATUS_WIN_STATUS_THREAD_ALREADY_IN_SESSION = 0xC0000456,
+  MD_NTSTATUS_WIN_STATUS_THREAD_NOT_IN_SESSION = 0xC0000457,
+  MD_NTSTATUS_WIN_STATUS_INVALID_WEIGHT = 0xC0000458,
+  MD_NTSTATUS_WIN_STATUS_REQUEST_PAUSED = 0xC0000459,
+  MD_NTSTATUS_WIN_STATUS_NO_RANGES_PROCESSED = 0xC0000460,
+  MD_NTSTATUS_WIN_STATUS_DISK_RESOURCES_EXHAUSTED = 0xC0000461,
+  MD_NTSTATUS_WIN_STATUS_NEEDS_REMEDIATION = 0xC0000462,
+  MD_NTSTATUS_WIN_STATUS_DEVICE_FEATURE_NOT_SUPPORTED = 0xC0000463,
+  MD_NTSTATUS_WIN_STATUS_DEVICE_UNREACHABLE = 0xC0000464,
+  MD_NTSTATUS_WIN_STATUS_INVALID_TOKEN = 0xC0000465,
+  MD_NTSTATUS_WIN_STATUS_SERVER_UNAVAILABLE = 0xC0000466,
+  MD_NTSTATUS_WIN_STATUS_FILE_NOT_AVAILABLE = 0xC0000467,
+  MD_NTSTATUS_WIN_STATUS_DEVICE_INSUFFICIENT_RESOURCES = 0xC0000468,
+  MD_NTSTATUS_WIN_STATUS_PACKAGE_UPDATING = 0xC0000469,
+  MD_NTSTATUS_WIN_STATUS_NOT_READ_FROM_COPY = 0xC000046A,
+  MD_NTSTATUS_WIN_STATUS_FT_WRITE_FAILURE = 0xC000046B,
+  MD_NTSTATUS_WIN_STATUS_FT_DI_SCAN_REQUIRED = 0xC000046C,
+  MD_NTSTATUS_WIN_STATUS_OBJECT_NOT_EXTERNALLY_BACKED = 0xC000046D,
+  MD_NTSTATUS_WIN_STATUS_EXTERNAL_BACKING_PROVIDER_UNKNOWN = 0xC000046E,
+  MD_NTSTATUS_WIN_STATUS_DATA_CHECKSUM_ERROR = 0xC0000470,
+  MD_NTSTATUS_WIN_STATUS_INTERMIXED_KERNEL_EA_OPERATION = 0xC0000471,
+  MD_NTSTATUS_WIN_STATUS_TRIM_READ_ZERO_NOT_SUPPORTED = 0xC0000472,
+  MD_NTSTATUS_WIN_STATUS_TOO_MANY_SEGMENT_DESCRIPTORS = 0xC0000473,
+  MD_NTSTATUS_WIN_STATUS_INVALID_OFFSET_ALIGNMENT = 0xC0000474,
+  MD_NTSTATUS_WIN_STATUS_INVALID_FIELD_IN_PARAMETER_LIST = 0xC0000475,
+  MD_NTSTATUS_WIN_STATUS_OPERATION_IN_PROGRESS = 0xC0000476,
+  MD_NTSTATUS_WIN_STATUS_INVALID_INITIATOR_TARGET_PATH = 0xC0000477,
+  MD_NTSTATUS_WIN_STATUS_SCRUB_DATA_DISABLED = 0xC0000478,
+  MD_NTSTATUS_WIN_STATUS_NOT_REDUNDANT_STORAGE = 0xC0000479,
+  MD_NTSTATUS_WIN_STATUS_RESIDENT_FILE_NOT_SUPPORTED = 0xC000047A,
+  MD_NTSTATUS_WIN_STATUS_COMPRESSED_FILE_NOT_SUPPORTED = 0xC000047B,
+  MD_NTSTATUS_WIN_STATUS_DIRECTORY_NOT_SUPPORTED = 0xC000047C,
+  MD_NTSTATUS_WIN_STATUS_IO_OPERATION_TIMEOUT = 0xC000047D,
+  MD_NTSTATUS_WIN_STATUS_SYSTEM_NEEDS_REMEDIATION = 0xC000047E,
+  MD_NTSTATUS_WIN_STATUS_APPX_INTEGRITY_FAILURE_CLR_NGEN = 0xC000047F,
+  MD_NTSTATUS_WIN_STATUS_SHARE_UNAVAILABLE = 0xC0000480,
+  MD_NTSTATUS_WIN_STATUS_APISET_NOT_HOSTED = 0xC0000481,
+  MD_NTSTATUS_WIN_STATUS_APISET_NOT_PRESENT = 0xC0000482,
+  MD_NTSTATUS_WIN_STATUS_DEVICE_HARDWARE_ERROR = 0xC0000483,
+  MD_NTSTATUS_WIN_STATUS_INVALID_TASK_NAME = 0xC0000500,
+  MD_NTSTATUS_WIN_STATUS_INVALID_TASK_INDEX = 0xC0000501,
+  MD_NTSTATUS_WIN_STATUS_THREAD_ALREADY_IN_TASK = 0xC0000502,
+  MD_NTSTATUS_WIN_STATUS_CALLBACK_BYPASS = 0xC0000503,
+  MD_NTSTATUS_WIN_STATUS_UNDEFINED_SCOPE = 0xC0000504,
+  MD_NTSTATUS_WIN_STATUS_INVALID_CAP = 0xC0000505,
+  MD_NTSTATUS_WIN_STATUS_NOT_GUI_PROCESS = 0xC0000506,
+  MD_NTSTATUS_WIN_STATUS_FAIL_FAST_EXCEPTION = 0xC0000602,
+  MD_NTSTATUS_WIN_STATUS_IMAGE_CERT_REVOKED = 0xC0000603,
+  MD_NTSTATUS_WIN_STATUS_DYNAMIC_CODE_BLOCKED = 0xC0000604,
+  MD_NTSTATUS_WIN_STATUS_PORT_CLOSED = 0xC0000700,
+  MD_NTSTATUS_WIN_STATUS_MESSAGE_LOST = 0xC0000701,
+  MD_NTSTATUS_WIN_STATUS_INVALID_MESSAGE = 0xC0000702,
+  MD_NTSTATUS_WIN_STATUS_REQUEST_CANCELED = 0xC0000703,
+  MD_NTSTATUS_WIN_STATUS_RECURSIVE_DISPATCH = 0xC0000704,
+  MD_NTSTATUS_WIN_STATUS_LPC_RECEIVE_BUFFER_EXPECTED = 0xC0000705,
+  MD_NTSTATUS_WIN_STATUS_LPC_INVALID_CONNECTION_USAGE = 0xC0000706,
+  MD_NTSTATUS_WIN_STATUS_LPC_REQUESTS_NOT_ALLOWED = 0xC0000707,
+  MD_NTSTATUS_WIN_STATUS_RESOURCE_IN_USE = 0xC0000708,
+  MD_NTSTATUS_WIN_STATUS_HARDWARE_MEMORY_ERROR = 0xC0000709,
+  MD_NTSTATUS_WIN_STATUS_THREADPOOL_HANDLE_EXCEPTION = 0xC000070A,
+  MD_NTSTATUS_WIN_STATUS_THREADPOOL_SET_EVENT_ON_COMPLETION_FAILED = 0xC000070B,
+  MD_NTSTATUS_WIN_STATUS_THREADPOOL_RELEASE_SEMAPHORE_ON_COMPLETION_FAILED = 0xC000070C,
+  MD_NTSTATUS_WIN_STATUS_THREADPOOL_RELEASE_MUTEX_ON_COMPLETION_FAILED = 0xC000070D,
+  MD_NTSTATUS_WIN_STATUS_THREADPOOL_FREE_LIBRARY_ON_COMPLETION_FAILED = 0xC000070E,
+  MD_NTSTATUS_WIN_STATUS_THREADPOOL_RELEASED_DURING_OPERATION = 0xC000070F,
+  MD_NTSTATUS_WIN_STATUS_CALLBACK_RETURNED_WHILE_IMPERSONATING = 0xC0000710,
+  MD_NTSTATUS_WIN_STATUS_APC_RETURNED_WHILE_IMPERSONATING = 0xC0000711,
+  MD_NTSTATUS_WIN_STATUS_PROCESS_IS_PROTECTED = 0xC0000712,
+  MD_NTSTATUS_WIN_STATUS_MCA_EXCEPTION = 0xC0000713,
+  MD_NTSTATUS_WIN_STATUS_CERTIFICATE_MAPPING_NOT_UNIQUE = 0xC0000714,
+  MD_NTSTATUS_WIN_STATUS_SYMLINK_CLASS_DISABLED = 0xC0000715,
+  MD_NTSTATUS_WIN_STATUS_INVALID_IDN_NORMALIZATION = 0xC0000716,
+  MD_NTSTATUS_WIN_STATUS_NO_UNICODE_TRANSLATION = 0xC0000717,
+  MD_NTSTATUS_WIN_STATUS_ALREADY_REGISTERED = 0xC0000718,
+  MD_NTSTATUS_WIN_STATUS_CONTEXT_MISMATCH = 0xC0000719,
+  MD_NTSTATUS_WIN_STATUS_PORT_ALREADY_HAS_COMPLETION_LIST = 0xC000071A,
+  MD_NTSTATUS_WIN_STATUS_CALLBACK_RETURNED_THREAD_PRIORITY = 0xC000071B,
+  MD_NTSTATUS_WIN_STATUS_INVALID_THREAD = 0xC000071C,
+  MD_NTSTATUS_WIN_STATUS_CALLBACK_RETURNED_TRANSACTION = 0xC000071D,
+  MD_NTSTATUS_WIN_STATUS_CALLBACK_RETURNED_LDR_LOCK = 0xC000071E,
+  MD_NTSTATUS_WIN_STATUS_CALLBACK_RETURNED_LANG = 0xC000071F,
+  MD_NTSTATUS_WIN_STATUS_CALLBACK_RETURNED_PRI_BACK = 0xC0000720,
+  MD_NTSTATUS_WIN_STATUS_CALLBACK_RETURNED_THREAD_AFFINITY = 0xC0000721,
+  MD_NTSTATUS_WIN_STATUS_DISK_REPAIR_DISABLED = 0xC0000800,
+  MD_NTSTATUS_WIN_STATUS_DS_DOMAIN_RENAME_IN_PROGRESS = 0xC0000801,
+  MD_NTSTATUS_WIN_STATUS_DISK_QUOTA_EXCEEDED = 0xC0000802,
+  MD_NTSTATUS_WIN_STATUS_CONTENT_BLOCKED = 0xC0000804,
+  MD_NTSTATUS_WIN_STATUS_BAD_CLUSTERS = 0xC0000805,
+  MD_NTSTATUS_WIN_STATUS_VOLUME_DIRTY = 0xC0000806,
+  MD_NTSTATUS_WIN_STATUS_DISK_REPAIR_UNSUCCESSFUL = 0xC0000808,
+  MD_NTSTATUS_WIN_STATUS_CORRUPT_LOG_OVERFULL = 0xC0000809,
+  MD_NTSTATUS_WIN_STATUS_CORRUPT_LOG_CORRUPTED = 0xC000080A,
+  MD_NTSTATUS_WIN_STATUS_CORRUPT_LOG_UNAVAILABLE = 0xC000080B,
+  MD_NTSTATUS_WIN_STATUS_CORRUPT_LOG_DELETED_FULL = 0xC000080C,
+  MD_NTSTATUS_WIN_STATUS_CORRUPT_LOG_CLEARED = 0xC000080D,
+  MD_NTSTATUS_WIN_STATUS_ORPHAN_NAME_EXHAUSTED = 0xC000080E,
+  MD_NTSTATUS_WIN_STATUS_PROACTIVE_SCAN_IN_PROGRESS = 0xC000080F,
+  MD_NTSTATUS_WIN_STATUS_ENCRYPTED_IO_NOT_POSSIBLE = 0xC0000810,
+  MD_NTSTATUS_WIN_STATUS_CORRUPT_LOG_UPLEVEL_RECORDS = 0xC0000811,
+  MD_NTSTATUS_WIN_STATUS_FILE_CHECKED_OUT = 0xC0000901,
+  MD_NTSTATUS_WIN_STATUS_CHECKOUT_REQUIRED = 0xC0000902,
+  MD_NTSTATUS_WIN_STATUS_BAD_FILE_TYPE = 0xC0000903,
+  MD_NTSTATUS_WIN_STATUS_FILE_TOO_LARGE = 0xC0000904,
+  MD_NTSTATUS_WIN_STATUS_FORMS_AUTH_REQUIRED = 0xC0000905,
+  MD_NTSTATUS_WIN_STATUS_VIRUS_INFECTED = 0xC0000906,
+  MD_NTSTATUS_WIN_STATUS_VIRUS_DELETED = 0xC0000907,
+  MD_NTSTATUS_WIN_STATUS_BAD_MCFG_TABLE = 0xC0000908,
+  MD_NTSTATUS_WIN_STATUS_CANNOT_BREAK_OPLOCK = 0xC0000909,
+  MD_NTSTATUS_WIN_STATUS_BAD_KEY = 0xC000090A,
+  MD_NTSTATUS_WIN_STATUS_BAD_DATA = 0xC000090B,
+  MD_NTSTATUS_WIN_STATUS_NO_KEY = 0xC000090C,
+  MD_NTSTATUS_WIN_STATUS_FILE_HANDLE_REVOKED = 0xC0000910,
+  MD_NTSTATUS_WIN_STATUS_WOW_ASSERTION = 0xC0009898,
+  MD_NTSTATUS_WIN_STATUS_INVALID_SIGNATURE = 0xC000A000,
+  MD_NTSTATUS_WIN_STATUS_HMAC_NOT_SUPPORTED = 0xC000A001,
+  MD_NTSTATUS_WIN_STATUS_AUTH_TAG_MISMATCH = 0xC000A002,
+  MD_NTSTATUS_WIN_STATUS_INVALID_STATE_TRANSITION = 0xC000A003,
+  MD_NTSTATUS_WIN_STATUS_INVALID_KERNEL_INFO_VERSION = 0xC000A004,
+  MD_NTSTATUS_WIN_STATUS_INVALID_PEP_INFO_VERSION = 0xC000A005,
+  MD_NTSTATUS_WIN_STATUS_IPSEC_QUEUE_OVERFLOW = 0xC000A010,
+  MD_NTSTATUS_WIN_STATUS_ND_QUEUE_OVERFLOW = 0xC000A011,
+  MD_NTSTATUS_WIN_STATUS_HOPLIMIT_EXCEEDED = 0xC000A012,
+  MD_NTSTATUS_WIN_STATUS_PROTOCOL_NOT_SUPPORTED = 0xC000A013,
+  MD_NTSTATUS_WIN_STATUS_FASTPATH_REJECTED = 0xC000A014,
+  MD_NTSTATUS_WIN_STATUS_LOST_WRITEBEHIND_DATA_NETWORK_DISCONNECTED = 0xC000A080,
+  MD_NTSTATUS_WIN_STATUS_LOST_WRITEBEHIND_DATA_NETWORK_SERVER_ERROR = 0xC000A081,
+  MD_NTSTATUS_WIN_STATUS_LOST_WRITEBEHIND_DATA_LOCAL_DISK_ERROR = 0xC000A082,
+  MD_NTSTATUS_WIN_STATUS_XML_PARSE_ERROR = 0xC000A083,
+  MD_NTSTATUS_WIN_STATUS_XMLDSIG_ERROR = 0xC000A084,
+  MD_NTSTATUS_WIN_STATUS_WRONG_COMPARTMENT = 0xC000A085,
+  MD_NTSTATUS_WIN_STATUS_AUTHIP_FAILURE = 0xC000A086,
+  MD_NTSTATUS_WIN_STATUS_DS_OID_MAPPED_GROUP_CANT_HAVE_MEMBERS = 0xC000A087,
+  MD_NTSTATUS_WIN_STATUS_DS_OID_NOT_FOUND = 0xC000A088,
+  MD_NTSTATUS_WIN_STATUS_INCORRECT_ACCOUNT_TYPE = 0xC000A089,
+  MD_NTSTATUS_WIN_STATUS_HASH_NOT_SUPPORTED = 0xC000A100,
+  MD_NTSTATUS_WIN_STATUS_HASH_NOT_PRESENT = 0xC000A101,
+  MD_NTSTATUS_WIN_STATUS_SECONDARY_IC_PROVIDER_NOT_REGISTERED = 0xC000A121,
+  MD_NTSTATUS_WIN_STATUS_GPIO_CLIENT_INFORMATION_INVALID = 0xC000A122,
+  MD_NTSTATUS_WIN_STATUS_GPIO_VERSION_NOT_SUPPORTED = 0xC000A123,
+  MD_NTSTATUS_WIN_STATUS_GPIO_INVALID_REGISTRATION_PACKET = 0xC000A124,
+  MD_NTSTATUS_WIN_STATUS_GPIO_OPERATION_DENIED = 0xC000A125,
+  MD_NTSTATUS_WIN_STATUS_GPIO_INCOMPATIBLE_CONNECT_MODE = 0xC000A126,
+  MD_NTSTATUS_WIN_STATUS_CANNOT_SWITCH_RUNLEVEL = 0xC000A141,
+  MD_NTSTATUS_WIN_STATUS_INVALID_RUNLEVEL_SETTING = 0xC000A142,
+  MD_NTSTATUS_WIN_STATUS_RUNLEVEL_SWITCH_TIMEOUT = 0xC000A143,
+  MD_NTSTATUS_WIN_STATUS_RUNLEVEL_SWITCH_AGENT_TIMEOUT = 0xC000A145,
+  MD_NTSTATUS_WIN_STATUS_RUNLEVEL_SWITCH_IN_PROGRESS = 0xC000A146,
+  MD_NTSTATUS_WIN_STATUS_NOT_APPCONTAINER = 0xC000A200,
+  MD_NTSTATUS_WIN_STATUS_NOT_SUPPORTED_IN_APPCONTAINER = 0xC000A201,
+  MD_NTSTATUS_WIN_STATUS_INVALID_PACKAGE_SID_LENGTH = 0xC000A202,
+  MD_NTSTATUS_WIN_STATUS_APP_DATA_NOT_FOUND = 0xC000A281,
+  MD_NTSTATUS_WIN_STATUS_APP_DATA_EXPIRED = 0xC000A282,
+  MD_NTSTATUS_WIN_STATUS_APP_DATA_CORRUPT = 0xC000A283,
+  MD_NTSTATUS_WIN_STATUS_APP_DATA_LIMIT_EXCEEDED = 0xC000A284,
+  MD_NTSTATUS_WIN_STATUS_APP_DATA_REBOOT_REQUIRED = 0xC000A285,
+  MD_NTSTATUS_WIN_STATUS_OFFLOAD_READ_FLT_NOT_SUPPORTED = 0xC000A2A1,
+  MD_NTSTATUS_WIN_STATUS_OFFLOAD_WRITE_FLT_NOT_SUPPORTED = 0xC000A2A2,
+  MD_NTSTATUS_WIN_STATUS_OFFLOAD_READ_FILE_NOT_SUPPORTED = 0xC000A2A3,
+  MD_NTSTATUS_WIN_STATUS_OFFLOAD_WRITE_FILE_NOT_SUPPORTED = 0xC000A2A4,
+  MD_NTSTATUS_WIN_DBG_NO_STATE_CHANGE = 0xC0010001,
+  MD_NTSTATUS_WIN_DBG_APP_NOT_IDLE = 0xC0010002,
+  MD_NTSTATUS_WIN_RPC_NT_INVALID_STRING_BINDING = 0xC0020001,
+  MD_NTSTATUS_WIN_RPC_NT_WRONG_KIND_OF_BINDING = 0xC0020002,
+  MD_NTSTATUS_WIN_RPC_NT_INVALID_BINDING = 0xC0020003,
+  MD_NTSTATUS_WIN_RPC_NT_PROTSEQ_NOT_SUPPORTED = 0xC0020004,
+  MD_NTSTATUS_WIN_RPC_NT_INVALID_RPC_PROTSEQ = 0xC0020005,
+  MD_NTSTATUS_WIN_RPC_NT_INVALID_STRING_UUID = 0xC0020006,
+  MD_NTSTATUS_WIN_RPC_NT_INVALID_ENDPOINT_FORMAT = 0xC0020007,
+  MD_NTSTATUS_WIN_RPC_NT_INVALID_NET_ADDR = 0xC0020008,
+  MD_NTSTATUS_WIN_RPC_NT_NO_ENDPOINT_FOUND = 0xC0020009,
+  MD_NTSTATUS_WIN_RPC_NT_INVALID_TIMEOUT = 0xC002000A,
+  MD_NTSTATUS_WIN_RPC_NT_OBJECT_NOT_FOUND = 0xC002000B,
+  MD_NTSTATUS_WIN_RPC_NT_ALREADY_REGISTERED = 0xC002000C,
+  MD_NTSTATUS_WIN_RPC_NT_TYPE_ALREADY_REGISTERED = 0xC002000D,
+  MD_NTSTATUS_WIN_RPC_NT_ALREADY_LISTENING = 0xC002000E,
+  MD_NTSTATUS_WIN_RPC_NT_NO_PROTSEQS_REGISTERED = 0xC002000F,
+  MD_NTSTATUS_WIN_RPC_NT_NOT_LISTENING = 0xC0020010,
+  MD_NTSTATUS_WIN_RPC_NT_UNKNOWN_MGR_TYPE = 0xC0020011,
+  MD_NTSTATUS_WIN_RPC_NT_UNKNOWN_IF = 0xC0020012,
+  MD_NTSTATUS_WIN_RPC_NT_NO_BINDINGS = 0xC0020013,
+  MD_NTSTATUS_WIN_RPC_NT_NO_PROTSEQS = 0xC0020014,
+  MD_NTSTATUS_WIN_RPC_NT_CANT_CREATE_ENDPOINT = 0xC0020015,
+  MD_NTSTATUS_WIN_RPC_NT_OUT_OF_RESOURCES = 0xC0020016,
+  MD_NTSTATUS_WIN_RPC_NT_SERVER_UNAVAILABLE = 0xC0020017,
+  MD_NTSTATUS_WIN_RPC_NT_SERVER_TOO_BUSY = 0xC0020018,
+  MD_NTSTATUS_WIN_RPC_NT_INVALID_NETWORK_OPTIONS = 0xC0020019,
+  MD_NTSTATUS_WIN_RPC_NT_NO_CALL_ACTIVE = 0xC002001A,
+  MD_NTSTATUS_WIN_RPC_NT_CALL_FAILED = 0xC002001B,
+  MD_NTSTATUS_WIN_RPC_NT_CALL_FAILED_DNE = 0xC002001C,
+  MD_NTSTATUS_WIN_RPC_NT_PROTOCOL_ERROR = 0xC002001D,
+  MD_NTSTATUS_WIN_RPC_NT_UNSUPPORTED_TRANS_SYN = 0xC002001F,
+  MD_NTSTATUS_WIN_RPC_NT_UNSUPPORTED_TYPE = 0xC0020021,
+  MD_NTSTATUS_WIN_RPC_NT_INVALID_TAG = 0xC0020022,
+  MD_NTSTATUS_WIN_RPC_NT_INVALID_BOUND = 0xC0020023,
+  MD_NTSTATUS_WIN_RPC_NT_NO_ENTRY_NAME = 0xC0020024,
+  MD_NTSTATUS_WIN_RPC_NT_INVALID_NAME_SYNTAX = 0xC0020025,
+  MD_NTSTATUS_WIN_RPC_NT_UNSUPPORTED_NAME_SYNTAX = 0xC0020026,
+  MD_NTSTATUS_WIN_RPC_NT_UUID_NO_ADDRESS = 0xC0020028,
+  MD_NTSTATUS_WIN_RPC_NT_DUPLICATE_ENDPOINT = 0xC0020029,
+  MD_NTSTATUS_WIN_RPC_NT_UNKNOWN_AUTHN_TYPE = 0xC002002A,
+  MD_NTSTATUS_WIN_RPC_NT_MAX_CALLS_TOO_SMALL = 0xC002002B,
+  MD_NTSTATUS_WIN_RPC_NT_STRING_TOO_LONG = 0xC002002C,
+  MD_NTSTATUS_WIN_RPC_NT_PROTSEQ_NOT_FOUND = 0xC002002D,
+  MD_NTSTATUS_WIN_RPC_NT_PROCNUM_OUT_OF_RANGE = 0xC002002E,
+  MD_NTSTATUS_WIN_RPC_NT_BINDING_HAS_NO_AUTH = 0xC002002F,
+  MD_NTSTATUS_WIN_RPC_NT_UNKNOWN_AUTHN_SERVICE = 0xC0020030,
+  MD_NTSTATUS_WIN_RPC_NT_UNKNOWN_AUTHN_LEVEL = 0xC0020031,
+  MD_NTSTATUS_WIN_RPC_NT_INVALID_AUTH_IDENTITY = 0xC0020032,
+  MD_NTSTATUS_WIN_RPC_NT_UNKNOWN_AUTHZ_SERVICE = 0xC0020033,
+  MD_NTSTATUS_WIN_EPT_NT_INVALID_ENTRY = 0xC0020034,
+  MD_NTSTATUS_WIN_EPT_NT_CANT_PERFORM_OP = 0xC0020035,
+  MD_NTSTATUS_WIN_EPT_NT_NOT_REGISTERED = 0xC0020036,
+  MD_NTSTATUS_WIN_RPC_NT_NOTHING_TO_EXPORT = 0xC0020037,
+  MD_NTSTATUS_WIN_RPC_NT_INCOMPLETE_NAME = 0xC0020038,
+  MD_NTSTATUS_WIN_RPC_NT_INVALID_VERS_OPTION = 0xC0020039,
+  MD_NTSTATUS_WIN_RPC_NT_NO_MORE_MEMBERS = 0xC002003A,
+  MD_NTSTATUS_WIN_RPC_NT_NOT_ALL_OBJS_UNEXPORTED = 0xC002003B,
+  MD_NTSTATUS_WIN_RPC_NT_INTERFACE_NOT_FOUND = 0xC002003C,
+  MD_NTSTATUS_WIN_RPC_NT_ENTRY_ALREADY_EXISTS = 0xC002003D,
+  MD_NTSTATUS_WIN_RPC_NT_ENTRY_NOT_FOUND = 0xC002003E,
+  MD_NTSTATUS_WIN_RPC_NT_NAME_SERVICE_UNAVAILABLE = 0xC002003F,
+  MD_NTSTATUS_WIN_RPC_NT_INVALID_NAF_ID = 0xC0020040,
+  MD_NTSTATUS_WIN_RPC_NT_CANNOT_SUPPORT = 0xC0020041,
+  MD_NTSTATUS_WIN_RPC_NT_NO_CONTEXT_AVAILABLE = 0xC0020042,
+  MD_NTSTATUS_WIN_RPC_NT_INTERNAL_ERROR = 0xC0020043,
+  MD_NTSTATUS_WIN_RPC_NT_ZERO_DIVIDE = 0xC0020044,
+  MD_NTSTATUS_WIN_RPC_NT_ADDRESS_ERROR = 0xC0020045,
+  MD_NTSTATUS_WIN_RPC_NT_FP_DIV_ZERO = 0xC0020046,
+  MD_NTSTATUS_WIN_RPC_NT_FP_UNDERFLOW = 0xC0020047,
+  MD_NTSTATUS_WIN_RPC_NT_FP_OVERFLOW = 0xC0020048,
+  MD_NTSTATUS_WIN_RPC_NT_CALL_IN_PROGRESS = 0xC0020049,
+  MD_NTSTATUS_WIN_RPC_NT_NO_MORE_BINDINGS = 0xC002004A,
+  MD_NTSTATUS_WIN_RPC_NT_GROUP_MEMBER_NOT_FOUND = 0xC002004B,
+  MD_NTSTATUS_WIN_EPT_NT_CANT_CREATE = 0xC002004C,
+  MD_NTSTATUS_WIN_RPC_NT_INVALID_OBJECT = 0xC002004D,
+  MD_NTSTATUS_WIN_RPC_NT_NO_INTERFACES = 0xC002004F,
+  MD_NTSTATUS_WIN_RPC_NT_CALL_CANCELLED = 0xC0020050,
+  MD_NTSTATUS_WIN_RPC_NT_BINDING_INCOMPLETE = 0xC0020051,
+  MD_NTSTATUS_WIN_RPC_NT_COMM_FAILURE = 0xC0020052,
+  MD_NTSTATUS_WIN_RPC_NT_UNSUPPORTED_AUTHN_LEVEL = 0xC0020053,
+  MD_NTSTATUS_WIN_RPC_NT_NO_PRINC_NAME = 0xC0020054,
+  MD_NTSTATUS_WIN_RPC_NT_NOT_RPC_ERROR = 0xC0020055,
+  MD_NTSTATUS_WIN_RPC_NT_SEC_PKG_ERROR = 0xC0020057,
+  MD_NTSTATUS_WIN_RPC_NT_NOT_CANCELLED = 0xC0020058,
+  MD_NTSTATUS_WIN_RPC_NT_INVALID_ASYNC_HANDLE = 0xC0020062,
+  MD_NTSTATUS_WIN_RPC_NT_INVALID_ASYNC_CALL = 0xC0020063,
+  MD_NTSTATUS_WIN_RPC_NT_PROXY_ACCESS_DENIED = 0xC0020064,
+  MD_NTSTATUS_WIN_RPC_NT_COOKIE_AUTH_FAILED = 0xC0020065,
+  MD_NTSTATUS_WIN_RPC_NT_NO_MORE_ENTRIES = 0xC0030001,
+  MD_NTSTATUS_WIN_RPC_NT_SS_CHAR_TRANS_OPEN_FAIL = 0xC0030002,
+  MD_NTSTATUS_WIN_RPC_NT_SS_CHAR_TRANS_SHORT_FILE = 0xC0030003,
+  MD_NTSTATUS_WIN_RPC_NT_SS_IN_NULL_CONTEXT = 0xC0030004,
+  MD_NTSTATUS_WIN_RPC_NT_SS_CONTEXT_MISMATCH = 0xC0030005,
+  MD_NTSTATUS_WIN_RPC_NT_SS_CONTEXT_DAMAGED = 0xC0030006,
+  MD_NTSTATUS_WIN_RPC_NT_SS_HANDLES_MISMATCH = 0xC0030007,
+  MD_NTSTATUS_WIN_RPC_NT_SS_CANNOT_GET_CALL_HANDLE = 0xC0030008,
+  MD_NTSTATUS_WIN_RPC_NT_NULL_REF_POINTER = 0xC0030009,
+  MD_NTSTATUS_WIN_RPC_NT_ENUM_VALUE_OUT_OF_RANGE = 0xC003000A,
+  MD_NTSTATUS_WIN_RPC_NT_BYTE_COUNT_TOO_SMALL = 0xC003000B,
+  MD_NTSTATUS_WIN_RPC_NT_BAD_STUB_DATA = 0xC003000C,
+  MD_NTSTATUS_WIN_RPC_NT_INVALID_ES_ACTION = 0xC0030059,
+  MD_NTSTATUS_WIN_RPC_NT_WRONG_ES_VERSION = 0xC003005A,
+  MD_NTSTATUS_WIN_RPC_NT_WRONG_STUB_VERSION = 0xC003005B,
+  MD_NTSTATUS_WIN_RPC_NT_INVALID_PIPE_OBJECT = 0xC003005C,
+  MD_NTSTATUS_WIN_RPC_NT_INVALID_PIPE_OPERATION = 0xC003005D,
+  MD_NTSTATUS_WIN_RPC_NT_WRONG_PIPE_VERSION = 0xC003005E,
+  MD_NTSTATUS_WIN_RPC_NT_PIPE_CLOSED = 0xC003005F,
+  MD_NTSTATUS_WIN_RPC_NT_PIPE_DISCIPLINE_ERROR = 0xC0030060,
+  MD_NTSTATUS_WIN_RPC_NT_PIPE_EMPTY = 0xC0030061,
+  MD_NTSTATUS_WIN_STATUS_PNP_BAD_MPS_TABLE = 0xC0040035,
+  MD_NTSTATUS_WIN_STATUS_PNP_TRANSLATION_FAILED = 0xC0040036,
+  MD_NTSTATUS_WIN_STATUS_PNP_IRQ_TRANSLATION_FAILED = 0xC0040037,
+  MD_NTSTATUS_WIN_STATUS_PNP_INVALID_ID = 0xC0040038,
+  MD_NTSTATUS_WIN_STATUS_IO_REISSUE_AS_CACHED = 0xC0040039,
+  MD_NTSTATUS_WIN_STATUS_CTX_WINSTATION_NAME_INVALID = 0xC00A0001,
+  MD_NTSTATUS_WIN_STATUS_CTX_INVALID_PD = 0xC00A0002,
+  MD_NTSTATUS_WIN_STATUS_CTX_PD_NOT_FOUND = 0xC00A0003,
+  MD_NTSTATUS_WIN_STATUS_CTX_CLOSE_PENDING = 0xC00A0006,
+  MD_NTSTATUS_WIN_STATUS_CTX_NO_OUTBUF = 0xC00A0007,
+  MD_NTSTATUS_WIN_STATUS_CTX_MODEM_INF_NOT_FOUND = 0xC00A0008,
+  MD_NTSTATUS_WIN_STATUS_CTX_INVALID_MODEMNAME = 0xC00A0009,
+  MD_NTSTATUS_WIN_STATUS_CTX_RESPONSE_ERROR = 0xC00A000A,
+  MD_NTSTATUS_WIN_STATUS_CTX_MODEM_RESPONSE_TIMEOUT = 0xC00A000B,
+  MD_NTSTATUS_WIN_STATUS_CTX_MODEM_RESPONSE_NO_CARRIER = 0xC00A000C,
+  MD_NTSTATUS_WIN_STATUS_CTX_MODEM_RESPONSE_NO_DIALTONE = 0xC00A000D,
+  MD_NTSTATUS_WIN_STATUS_CTX_MODEM_RESPONSE_BUSY = 0xC00A000E,
+  MD_NTSTATUS_WIN_STATUS_CTX_MODEM_RESPONSE_VOICE = 0xC00A000F,
+  MD_NTSTATUS_WIN_STATUS_CTX_TD_ERROR = 0xC00A0010,
+  MD_NTSTATUS_WIN_STATUS_CTX_LICENSE_CLIENT_INVALID = 0xC00A0012,
+  MD_NTSTATUS_WIN_STATUS_CTX_LICENSE_NOT_AVAILABLE = 0xC00A0013,
+  MD_NTSTATUS_WIN_STATUS_CTX_LICENSE_EXPIRED = 0xC00A0014,
+  MD_NTSTATUS_WIN_STATUS_CTX_WINSTATION_NOT_FOUND = 0xC00A0015,
+  MD_NTSTATUS_WIN_STATUS_CTX_WINSTATION_NAME_COLLISION = 0xC00A0016,
+  MD_NTSTATUS_WIN_STATUS_CTX_WINSTATION_BUSY = 0xC00A0017,
+  MD_NTSTATUS_WIN_STATUS_CTX_BAD_VIDEO_MODE = 0xC00A0018,
+  MD_NTSTATUS_WIN_STATUS_CTX_GRAPHICS_INVALID = 0xC00A0022,
+  MD_NTSTATUS_WIN_STATUS_CTX_NOT_CONSOLE = 0xC00A0024,
+  MD_NTSTATUS_WIN_STATUS_CTX_CLIENT_QUERY_TIMEOUT = 0xC00A0026,
+  MD_NTSTATUS_WIN_STATUS_CTX_CONSOLE_DISCONNECT = 0xC00A0027,
+  MD_NTSTATUS_WIN_STATUS_CTX_CONSOLE_CONNECT = 0xC00A0028,
+  MD_NTSTATUS_WIN_STATUS_CTX_SHADOW_DENIED = 0xC00A002A,
+  MD_NTSTATUS_WIN_STATUS_CTX_WINSTATION_ACCESS_DENIED = 0xC00A002B,
+  MD_NTSTATUS_WIN_STATUS_CTX_INVALID_WD = 0xC00A002E,
+  MD_NTSTATUS_WIN_STATUS_CTX_WD_NOT_FOUND = 0xC00A002F,
+  MD_NTSTATUS_WIN_STATUS_CTX_SHADOW_INVALID = 0xC00A0030,
+  MD_NTSTATUS_WIN_STATUS_CTX_SHADOW_DISABLED = 0xC00A0031,
+  MD_NTSTATUS_WIN_STATUS_RDP_PROTOCOL_ERROR = 0xC00A0032,
+  MD_NTSTATUS_WIN_STATUS_CTX_CLIENT_LICENSE_NOT_SET = 0xC00A0033,
+  MD_NTSTATUS_WIN_STATUS_CTX_CLIENT_LICENSE_IN_USE = 0xC00A0034,
+  MD_NTSTATUS_WIN_STATUS_CTX_SHADOW_ENDED_BY_MODE_CHANGE = 0xC00A0035,
+  MD_NTSTATUS_WIN_STATUS_CTX_SHADOW_NOT_RUNNING = 0xC00A0036,
+  MD_NTSTATUS_WIN_STATUS_CTX_LOGON_DISABLED = 0xC00A0037,
+  MD_NTSTATUS_WIN_STATUS_CTX_SECURITY_LAYER_ERROR = 0xC00A0038,
+  MD_NTSTATUS_WIN_STATUS_TS_INCOMPATIBLE_SESSIONS = 0xC00A0039,
+  MD_NTSTATUS_WIN_STATUS_TS_VIDEO_SUBSYSTEM_ERROR = 0xC00A003A,
+  MD_NTSTATUS_WIN_STATUS_MUI_FILE_NOT_FOUND = 0xC00B0001,
+  MD_NTSTATUS_WIN_STATUS_MUI_INVALID_FILE = 0xC00B0002,
+  MD_NTSTATUS_WIN_STATUS_MUI_INVALID_RC_CONFIG = 0xC00B0003,
+  MD_NTSTATUS_WIN_STATUS_MUI_INVALID_LOCALE_NAME = 0xC00B0004,
+  MD_NTSTATUS_WIN_STATUS_MUI_INVALID_ULTIMATEFALLBACK_NAME = 0xC00B0005,
+  MD_NTSTATUS_WIN_STATUS_MUI_FILE_NOT_LOADED = 0xC00B0006,
+  MD_NTSTATUS_WIN_STATUS_RESOURCE_ENUM_USER_STOP = 0xC00B0007,
+  MD_NTSTATUS_WIN_STATUS_CLUSTER_INVALID_NODE = 0xC0130001,
+  MD_NTSTATUS_WIN_STATUS_CLUSTER_NODE_EXISTS = 0xC0130002,
+  MD_NTSTATUS_WIN_STATUS_CLUSTER_JOIN_IN_PROGRESS = 0xC0130003,
+  MD_NTSTATUS_WIN_STATUS_CLUSTER_NODE_NOT_FOUND = 0xC0130004,
+  MD_NTSTATUS_WIN_STATUS_CLUSTER_LOCAL_NODE_NOT_FOUND = 0xC0130005,
+  MD_NTSTATUS_WIN_STATUS_CLUSTER_NETWORK_EXISTS = 0xC0130006,
+  MD_NTSTATUS_WIN_STATUS_CLUSTER_NETWORK_NOT_FOUND = 0xC0130007,
+  MD_NTSTATUS_WIN_STATUS_CLUSTER_NETINTERFACE_EXISTS = 0xC0130008,
+  MD_NTSTATUS_WIN_STATUS_CLUSTER_NETINTERFACE_NOT_FOUND = 0xC0130009,
+  MD_NTSTATUS_WIN_STATUS_CLUSTER_INVALID_REQUEST = 0xC013000A,
+  MD_NTSTATUS_WIN_STATUS_CLUSTER_INVALID_NETWORK_PROVIDER = 0xC013000B,
+  MD_NTSTATUS_WIN_STATUS_CLUSTER_NODE_DOWN = 0xC013000C,
+  MD_NTSTATUS_WIN_STATUS_CLUSTER_NODE_UNREACHABLE = 0xC013000D,
+  MD_NTSTATUS_WIN_STATUS_CLUSTER_NODE_NOT_MEMBER = 0xC013000E,
+  MD_NTSTATUS_WIN_STATUS_CLUSTER_JOIN_NOT_IN_PROGRESS = 0xC013000F,
+  MD_NTSTATUS_WIN_STATUS_CLUSTER_INVALID_NETWORK = 0xC0130010,
+  MD_NTSTATUS_WIN_STATUS_CLUSTER_NO_NET_ADAPTERS = 0xC0130011,
+  MD_NTSTATUS_WIN_STATUS_CLUSTER_NODE_UP = 0xC0130012,
+  MD_NTSTATUS_WIN_STATUS_CLUSTER_NODE_PAUSED = 0xC0130013,
+  MD_NTSTATUS_WIN_STATUS_CLUSTER_NODE_NOT_PAUSED = 0xC0130014,
+  MD_NTSTATUS_WIN_STATUS_CLUSTER_NO_SECURITY_CONTEXT = 0xC0130015,
+  MD_NTSTATUS_WIN_STATUS_CLUSTER_NETWORK_NOT_INTERNAL = 0xC0130016,
+  MD_NTSTATUS_WIN_STATUS_CLUSTER_POISONED = 0xC0130017,
+  MD_NTSTATUS_WIN_STATUS_CLUSTER_NON_CSV_PATH = 0xC0130018,
+  MD_NTSTATUS_WIN_STATUS_CLUSTER_CSV_VOLUME_NOT_LOCAL = 0xC0130019,
+  MD_NTSTATUS_WIN_STATUS_CLUSTER_CSV_READ_OPLOCK_BREAK_IN_PROGRESS = 0xC0130020,
+  MD_NTSTATUS_WIN_STATUS_CLUSTER_CSV_AUTO_PAUSE_ERROR = 0xC0130021,
+  MD_NTSTATUS_WIN_STATUS_CLUSTER_CSV_REDIRECTED = 0xC0130022,
+  MD_NTSTATUS_WIN_STATUS_CLUSTER_CSV_NOT_REDIRECTED = 0xC0130023,
+  MD_NTSTATUS_WIN_STATUS_CLUSTER_CSV_VOLUME_DRAINING = 0xC0130024,
+  MD_NTSTATUS_WIN_STATUS_CLUSTER_CSV_SNAPSHOT_CREATION_IN_PROGRESS = 0xC0130025,
+  MD_NTSTATUS_WIN_STATUS_CLUSTER_CSV_VOLUME_DRAINING_SUCCEEDED_DOWNLEVEL = 0xC0130026,
+  MD_NTSTATUS_WIN_STATUS_ACPI_INVALID_OPCODE = 0xC0140001,
+  MD_NTSTATUS_WIN_STATUS_ACPI_STACK_OVERFLOW = 0xC0140002,
+  MD_NTSTATUS_WIN_STATUS_ACPI_ASSERT_FAILED = 0xC0140003,
+  MD_NTSTATUS_WIN_STATUS_ACPI_INVALID_INDEX = 0xC0140004,
+  MD_NTSTATUS_WIN_STATUS_ACPI_INVALID_ARGUMENT = 0xC0140005,
+  MD_NTSTATUS_WIN_STATUS_ACPI_FATAL = 0xC0140006,
+  MD_NTSTATUS_WIN_STATUS_ACPI_INVALID_SUPERNAME = 0xC0140007,
+  MD_NTSTATUS_WIN_STATUS_ACPI_INVALID_ARGTYPE = 0xC0140008,
+  MD_NTSTATUS_WIN_STATUS_ACPI_INVALID_OBJTYPE = 0xC0140009,
+  MD_NTSTATUS_WIN_STATUS_ACPI_INVALID_TARGETTYPE = 0xC014000A,
+  MD_NTSTATUS_WIN_STATUS_ACPI_INCORRECT_ARGUMENT_COUNT = 0xC014000B,
+  MD_NTSTATUS_WIN_STATUS_ACPI_ADDRESS_NOT_MAPPED = 0xC014000C,
+  MD_NTSTATUS_WIN_STATUS_ACPI_INVALID_EVENTTYPE = 0xC014000D,
+  MD_NTSTATUS_WIN_STATUS_ACPI_HANDLER_COLLISION = 0xC014000E,
+  MD_NTSTATUS_WIN_STATUS_ACPI_INVALID_DATA = 0xC014000F,
+  MD_NTSTATUS_WIN_STATUS_ACPI_INVALID_REGION = 0xC0140010,
+  MD_NTSTATUS_WIN_STATUS_ACPI_INVALID_ACCESS_SIZE = 0xC0140011,
+  MD_NTSTATUS_WIN_STATUS_ACPI_ACQUIRE_GLOBAL_LOCK = 0xC0140012,
+  MD_NTSTATUS_WIN_STATUS_ACPI_ALREADY_INITIALIZED = 0xC0140013,
+  MD_NTSTATUS_WIN_STATUS_ACPI_NOT_INITIALIZED = 0xC0140014,
+  MD_NTSTATUS_WIN_STATUS_ACPI_INVALID_MUTEX_LEVEL = 0xC0140015,
+  MD_NTSTATUS_WIN_STATUS_ACPI_MUTEX_NOT_OWNED = 0xC0140016,
+  MD_NTSTATUS_WIN_STATUS_ACPI_MUTEX_NOT_OWNER = 0xC0140017,
+  MD_NTSTATUS_WIN_STATUS_ACPI_RS_ACCESS = 0xC0140018,
+  MD_NTSTATUS_WIN_STATUS_ACPI_INVALID_TABLE = 0xC0140019,
+  MD_NTSTATUS_WIN_STATUS_ACPI_REG_HANDLER_FAILED = 0xC0140020,
+  MD_NTSTATUS_WIN_STATUS_ACPI_POWER_REQUEST_FAILED = 0xC0140021,
+  MD_NTSTATUS_WIN_STATUS_SXS_SECTION_NOT_FOUND = 0xC0150001,
+  MD_NTSTATUS_WIN_STATUS_SXS_CANT_GEN_ACTCTX = 0xC0150002,
+  MD_NTSTATUS_WIN_STATUS_SXS_INVALID_ACTCTXDATA_FORMAT = 0xC0150003,
+  MD_NTSTATUS_WIN_STATUS_SXS_ASSEMBLY_NOT_FOUND = 0xC0150004,
+  MD_NTSTATUS_WIN_STATUS_SXS_MANIFEST_FORMAT_ERROR = 0xC0150005,
+  MD_NTSTATUS_WIN_STATUS_SXS_MANIFEST_PARSE_ERROR = 0xC0150006,
+  MD_NTSTATUS_WIN_STATUS_SXS_ACTIVATION_CONTEXT_DISABLED = 0xC0150007,
+  MD_NTSTATUS_WIN_STATUS_SXS_KEY_NOT_FOUND = 0xC0150008,
+  MD_NTSTATUS_WIN_STATUS_SXS_VERSION_CONFLICT = 0xC0150009,
+  MD_NTSTATUS_WIN_STATUS_SXS_WRONG_SECTION_TYPE = 0xC015000A,
+  MD_NTSTATUS_WIN_STATUS_SXS_THREAD_QUERIES_DISABLED = 0xC015000B,
+  MD_NTSTATUS_WIN_STATUS_SXS_ASSEMBLY_MISSING = 0xC015000C,
+  MD_NTSTATUS_WIN_STATUS_SXS_PROCESS_DEFAULT_ALREADY_SET = 0xC015000E,
+  MD_NTSTATUS_WIN_STATUS_SXS_EARLY_DEACTIVATION = 0xC015000F,
+  MD_NTSTATUS_WIN_STATUS_SXS_INVALID_DEACTIVATION = 0xC0150010,
+  MD_NTSTATUS_WIN_STATUS_SXS_MULTIPLE_DEACTIVATION = 0xC0150011,
+  MD_NTSTATUS_WIN_STATUS_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT_EMPTY = 0xC0150012,
+  MD_NTSTATUS_WIN_STATUS_SXS_PROCESS_TERMINATION_REQUESTED = 0xC0150013,
+  MD_NTSTATUS_WIN_STATUS_SXS_CORRUPT_ACTIVATION_STACK = 0xC0150014,
+  MD_NTSTATUS_WIN_STATUS_SXS_CORRUPTION = 0xC0150015,
+  MD_NTSTATUS_WIN_STATUS_SXS_INVALID_IDENTITY_ATTRIBUTE_VALUE = 0xC0150016,
+  MD_NTSTATUS_WIN_STATUS_SXS_INVALID_IDENTITY_ATTRIBUTE_NAME = 0xC0150017,
+  MD_NTSTATUS_WIN_STATUS_SXS_IDENTITY_DUPLICATE_ATTRIBUTE = 0xC0150018,
+  MD_NTSTATUS_WIN_STATUS_SXS_IDENTITY_PARSE_ERROR = 0xC0150019,
+  MD_NTSTATUS_WIN_STATUS_SXS_COMPONENT_STORE_CORRUPT = 0xC015001A,
+  MD_NTSTATUS_WIN_STATUS_SXS_FILE_HASH_MISMATCH = 0xC015001B,
+  MD_NTSTATUS_WIN_STATUS_SXS_MANIFEST_IDENTITY_SAME_BUT_CONTENTS_DIFFERENT = 0xC015001C,
+  MD_NTSTATUS_WIN_STATUS_SXS_IDENTITIES_DIFFERENT = 0xC015001D,
+  MD_NTSTATUS_WIN_STATUS_SXS_ASSEMBLY_IS_NOT_A_DEPLOYMENT = 0xC015001E,
+  MD_NTSTATUS_WIN_STATUS_SXS_FILE_NOT_PART_OF_ASSEMBLY = 0xC015001F,
+  MD_NTSTATUS_WIN_STATUS_ADVANCED_INSTALLER_FAILED = 0xC0150020,
+  MD_NTSTATUS_WIN_STATUS_XML_ENCODING_MISMATCH = 0xC0150021,
+  MD_NTSTATUS_WIN_STATUS_SXS_MANIFEST_TOO_BIG = 0xC0150022,
+  MD_NTSTATUS_WIN_STATUS_SXS_SETTING_NOT_REGISTERED = 0xC0150023,
+  MD_NTSTATUS_WIN_STATUS_SXS_TRANSACTION_CLOSURE_INCOMPLETE = 0xC0150024,
+  MD_NTSTATUS_WIN_STATUS_SMI_PRIMITIVE_INSTALLER_FAILED = 0xC0150025,
+  MD_NTSTATUS_WIN_STATUS_GENERIC_COMMAND_FAILED = 0xC0150026,
+  MD_NTSTATUS_WIN_STATUS_SXS_FILE_HASH_MISSING = 0xC0150027,
+  MD_NTSTATUS_WIN_STATUS_TRANSACTIONAL_CONFLICT = 0xC0190001,
+  MD_NTSTATUS_WIN_STATUS_INVALID_TRANSACTION = 0xC0190002,
+  MD_NTSTATUS_WIN_STATUS_TRANSACTION_NOT_ACTIVE = 0xC0190003,
+  MD_NTSTATUS_WIN_STATUS_TM_INITIALIZATION_FAILED = 0xC0190004,
+  MD_NTSTATUS_WIN_STATUS_RM_NOT_ACTIVE = 0xC0190005,
+  MD_NTSTATUS_WIN_STATUS_RM_METADATA_CORRUPT = 0xC0190006,
+  MD_NTSTATUS_WIN_STATUS_TRANSACTION_NOT_JOINED = 0xC0190007,
+  MD_NTSTATUS_WIN_STATUS_DIRECTORY_NOT_RM = 0xC0190008,
+  MD_NTSTATUS_WIN_STATUS_TRANSACTIONS_UNSUPPORTED_REMOTE = 0xC019000A,
+  MD_NTSTATUS_WIN_STATUS_LOG_RESIZE_INVALID_SIZE = 0xC019000B,
+  MD_NTSTATUS_WIN_STATUS_REMOTE_FILE_VERSION_MISMATCH = 0xC019000C,
+  MD_NTSTATUS_WIN_STATUS_CRM_PROTOCOL_ALREADY_EXISTS = 0xC019000F,
+  MD_NTSTATUS_WIN_STATUS_TRANSACTION_PROPAGATION_FAILED = 0xC0190010,
+  MD_NTSTATUS_WIN_STATUS_CRM_PROTOCOL_NOT_FOUND = 0xC0190011,
+  MD_NTSTATUS_WIN_STATUS_TRANSACTION_SUPERIOR_EXISTS = 0xC0190012,
+  MD_NTSTATUS_WIN_STATUS_TRANSACTION_REQUEST_NOT_VALID = 0xC0190013,
+  MD_NTSTATUS_WIN_STATUS_TRANSACTION_NOT_REQUESTED = 0xC0190014,
+  MD_NTSTATUS_WIN_STATUS_TRANSACTION_ALREADY_ABORTED = 0xC0190015,
+  MD_NTSTATUS_WIN_STATUS_TRANSACTION_ALREADY_COMMITTED = 0xC0190016,
+  MD_NTSTATUS_WIN_STATUS_TRANSACTION_INVALID_MARSHALL_BUFFER = 0xC0190017,
+  MD_NTSTATUS_WIN_STATUS_CURRENT_TRANSACTION_NOT_VALID = 0xC0190018,
+  MD_NTSTATUS_WIN_STATUS_LOG_GROWTH_FAILED = 0xC0190019,
+  MD_NTSTATUS_WIN_STATUS_OBJECT_NO_LONGER_EXISTS = 0xC0190021,
+  MD_NTSTATUS_WIN_STATUS_STREAM_MINIVERSION_NOT_FOUND = 0xC0190022,
+  MD_NTSTATUS_WIN_STATUS_STREAM_MINIVERSION_NOT_VALID = 0xC0190023,
+  MD_NTSTATUS_WIN_STATUS_MINIVERSION_INACCESSIBLE_FROM_SPECIFIED_TRANSACTION = 0xC0190024,
+  MD_NTSTATUS_WIN_STATUS_CANT_OPEN_MINIVERSION_WITH_MODIFY_INTENT = 0xC0190025,
+  MD_NTSTATUS_WIN_STATUS_CANT_CREATE_MORE_STREAM_MINIVERSIONS = 0xC0190026,
+  MD_NTSTATUS_WIN_STATUS_HANDLE_NO_LONGER_VALID = 0xC0190028,
+  MD_NTSTATUS_WIN_STATUS_LOG_CORRUPTION_DETECTED = 0xC0190030,
+  MD_NTSTATUS_WIN_STATUS_RM_DISCONNECTED = 0xC0190032,
+  MD_NTSTATUS_WIN_STATUS_ENLISTMENT_NOT_SUPERIOR = 0xC0190033,
+  MD_NTSTATUS_WIN_STATUS_FILE_IDENTITY_NOT_PERSISTENT = 0xC0190036,
+  MD_NTSTATUS_WIN_STATUS_CANT_BREAK_TRANSACTIONAL_DEPENDENCY = 0xC0190037,
+  MD_NTSTATUS_WIN_STATUS_CANT_CROSS_RM_BOUNDARY = 0xC0190038,
+  MD_NTSTATUS_WIN_STATUS_TXF_DIR_NOT_EMPTY = 0xC0190039,
+  MD_NTSTATUS_WIN_STATUS_INDOUBT_TRANSACTIONS_EXIST = 0xC019003A,
+  MD_NTSTATUS_WIN_STATUS_TM_VOLATILE = 0xC019003B,
+  MD_NTSTATUS_WIN_STATUS_ROLLBACK_TIMER_EXPIRED = 0xC019003C,
+  MD_NTSTATUS_WIN_STATUS_TXF_ATTRIBUTE_CORRUPT = 0xC019003D,
+  MD_NTSTATUS_WIN_STATUS_EFS_NOT_ALLOWED_IN_TRANSACTION = 0xC019003E,
+  MD_NTSTATUS_WIN_STATUS_TRANSACTIONAL_OPEN_NOT_ALLOWED = 0xC019003F,
+  MD_NTSTATUS_WIN_STATUS_TRANSACTED_MAPPING_UNSUPPORTED_REMOTE = 0xC0190040,
+  MD_NTSTATUS_WIN_STATUS_TRANSACTION_REQUIRED_PROMOTION = 0xC0190043,
+  MD_NTSTATUS_WIN_STATUS_CANNOT_EXECUTE_FILE_IN_TRANSACTION = 0xC0190044,
+  MD_NTSTATUS_WIN_STATUS_TRANSACTIONS_NOT_FROZEN = 0xC0190045,
+  MD_NTSTATUS_WIN_STATUS_TRANSACTION_FREEZE_IN_PROGRESS = 0xC0190046,
+  MD_NTSTATUS_WIN_STATUS_NOT_SNAPSHOT_VOLUME = 0xC0190047,
+  MD_NTSTATUS_WIN_STATUS_NO_SAVEPOINT_WITH_OPEN_FILES = 0xC0190048,
+  MD_NTSTATUS_WIN_STATUS_SPARSE_NOT_ALLOWED_IN_TRANSACTION = 0xC0190049,
+  MD_NTSTATUS_WIN_STATUS_TM_IDENTITY_MISMATCH = 0xC019004A,
+  MD_NTSTATUS_WIN_STATUS_FLOATED_SECTION = 0xC019004B,
+  MD_NTSTATUS_WIN_STATUS_CANNOT_ACCEPT_TRANSACTED_WORK = 0xC019004C,
+  MD_NTSTATUS_WIN_STATUS_CANNOT_ABORT_TRANSACTIONS = 0xC019004D,
+  MD_NTSTATUS_WIN_STATUS_TRANSACTION_NOT_FOUND = 0xC019004E,
+  MD_NTSTATUS_WIN_STATUS_RESOURCEMANAGER_NOT_FOUND = 0xC019004F,
+  MD_NTSTATUS_WIN_STATUS_ENLISTMENT_NOT_FOUND = 0xC0190050,
+  MD_NTSTATUS_WIN_STATUS_TRANSACTIONMANAGER_NOT_FOUND = 0xC0190051,
+  MD_NTSTATUS_WIN_STATUS_TRANSACTIONMANAGER_NOT_ONLINE = 0xC0190052,
+  MD_NTSTATUS_WIN_STATUS_TRANSACTIONMANAGER_RECOVERY_NAME_COLLISION = 0xC0190053,
+  MD_NTSTATUS_WIN_STATUS_TRANSACTION_NOT_ROOT = 0xC0190054,
+  MD_NTSTATUS_WIN_STATUS_TRANSACTION_OBJECT_EXPIRED = 0xC0190055,
+  MD_NTSTATUS_WIN_STATUS_COMPRESSION_NOT_ALLOWED_IN_TRANSACTION = 0xC0190056,
+  MD_NTSTATUS_WIN_STATUS_TRANSACTION_RESPONSE_NOT_ENLISTED = 0xC0190057,
+  MD_NTSTATUS_WIN_STATUS_TRANSACTION_RECORD_TOO_LONG = 0xC0190058,
+  MD_NTSTATUS_WIN_STATUS_NO_LINK_TRACKING_IN_TRANSACTION = 0xC0190059,
+  MD_NTSTATUS_WIN_STATUS_OPERATION_NOT_SUPPORTED_IN_TRANSACTION = 0xC019005A,
+  MD_NTSTATUS_WIN_STATUS_TRANSACTION_INTEGRITY_VIOLATED = 0xC019005B,
+  MD_NTSTATUS_WIN_STATUS_TRANSACTIONMANAGER_IDENTITY_MISMATCH = 0xC019005C,
+  MD_NTSTATUS_WIN_STATUS_RM_CANNOT_BE_FROZEN_FOR_SNAPSHOT = 0xC019005D,
+  MD_NTSTATUS_WIN_STATUS_TRANSACTION_MUST_WRITETHROUGH = 0xC019005E,
+  MD_NTSTATUS_WIN_STATUS_TRANSACTION_NO_SUPERIOR = 0xC019005F,
+  MD_NTSTATUS_WIN_STATUS_EXPIRED_HANDLE = 0xC0190060,
+  MD_NTSTATUS_WIN_STATUS_TRANSACTION_NOT_ENLISTED = 0xC0190061,
+  MD_NTSTATUS_WIN_STATUS_LOG_SECTOR_INVALID = 0xC01A0001,
+  MD_NTSTATUS_WIN_STATUS_LOG_SECTOR_PARITY_INVALID = 0xC01A0002,
+  MD_NTSTATUS_WIN_STATUS_LOG_SECTOR_REMAPPED = 0xC01A0003,
+  MD_NTSTATUS_WIN_STATUS_LOG_BLOCK_INCOMPLETE = 0xC01A0004,
+  MD_NTSTATUS_WIN_STATUS_LOG_INVALID_RANGE = 0xC01A0005,
+  MD_NTSTATUS_WIN_STATUS_LOG_BLOCKS_EXHAUSTED = 0xC01A0006,
+  MD_NTSTATUS_WIN_STATUS_LOG_READ_CONTEXT_INVALID = 0xC01A0007,
+  MD_NTSTATUS_WIN_STATUS_LOG_RESTART_INVALID = 0xC01A0008,
+  MD_NTSTATUS_WIN_STATUS_LOG_BLOCK_VERSION = 0xC01A0009,
+  MD_NTSTATUS_WIN_STATUS_LOG_BLOCK_INVALID = 0xC01A000A,
+  MD_NTSTATUS_WIN_STATUS_LOG_READ_MODE_INVALID = 0xC01A000B,
+  MD_NTSTATUS_WIN_STATUS_LOG_METADATA_CORRUPT = 0xC01A000D,
+  MD_NTSTATUS_WIN_STATUS_LOG_METADATA_INVALID = 0xC01A000E,
+  MD_NTSTATUS_WIN_STATUS_LOG_METADATA_INCONSISTENT = 0xC01A000F,
+  MD_NTSTATUS_WIN_STATUS_LOG_RESERVATION_INVALID = 0xC01A0010,
+  MD_NTSTATUS_WIN_STATUS_LOG_CANT_DELETE = 0xC01A0011,
+  MD_NTSTATUS_WIN_STATUS_LOG_CONTAINER_LIMIT_EXCEEDED = 0xC01A0012,
+  MD_NTSTATUS_WIN_STATUS_LOG_START_OF_LOG = 0xC01A0013,
+  MD_NTSTATUS_WIN_STATUS_LOG_POLICY_ALREADY_INSTALLED = 0xC01A0014,
+  MD_NTSTATUS_WIN_STATUS_LOG_POLICY_NOT_INSTALLED = 0xC01A0015,
+  MD_NTSTATUS_WIN_STATUS_LOG_POLICY_INVALID = 0xC01A0016,
+  MD_NTSTATUS_WIN_STATUS_LOG_POLICY_CONFLICT = 0xC01A0017,
+  MD_NTSTATUS_WIN_STATUS_LOG_PINNED_ARCHIVE_TAIL = 0xC01A0018,
+  MD_NTSTATUS_WIN_STATUS_LOG_RECORD_NONEXISTENT = 0xC01A0019,
+  MD_NTSTATUS_WIN_STATUS_LOG_RECORDS_RESERVED_INVALID = 0xC01A001A,
+  MD_NTSTATUS_WIN_STATUS_LOG_SPACE_RESERVED_INVALID = 0xC01A001B,
+  MD_NTSTATUS_WIN_STATUS_LOG_TAIL_INVALID = 0xC01A001C,
+  MD_NTSTATUS_WIN_STATUS_LOG_FULL = 0xC01A001D,
+  MD_NTSTATUS_WIN_STATUS_LOG_MULTIPLEXED = 0xC01A001E,
+  MD_NTSTATUS_WIN_STATUS_LOG_DEDICATED = 0xC01A001F,
+  MD_NTSTATUS_WIN_STATUS_LOG_ARCHIVE_NOT_IN_PROGRESS = 0xC01A0020,
+  MD_NTSTATUS_WIN_STATUS_LOG_ARCHIVE_IN_PROGRESS = 0xC01A0021,
+  MD_NTSTATUS_WIN_STATUS_LOG_EPHEMERAL = 0xC01A0022,
+  MD_NTSTATUS_WIN_STATUS_LOG_NOT_ENOUGH_CONTAINERS = 0xC01A0023,
+  MD_NTSTATUS_WIN_STATUS_LOG_CLIENT_ALREADY_REGISTERED = 0xC01A0024,
+  MD_NTSTATUS_WIN_STATUS_LOG_CLIENT_NOT_REGISTERED = 0xC01A0025,
+  MD_NTSTATUS_WIN_STATUS_LOG_FULL_HANDLER_IN_PROGRESS = 0xC01A0026,
+  MD_NTSTATUS_WIN_STATUS_LOG_CONTAINER_READ_FAILED = 0xC01A0027,
+  MD_NTSTATUS_WIN_STATUS_LOG_CONTAINER_WRITE_FAILED = 0xC01A0028,
+  MD_NTSTATUS_WIN_STATUS_LOG_CONTAINER_OPEN_FAILED = 0xC01A0029,
+  MD_NTSTATUS_WIN_STATUS_LOG_CONTAINER_STATE_INVALID = 0xC01A002A,
+  MD_NTSTATUS_WIN_STATUS_LOG_STATE_INVALID = 0xC01A002B,
+  MD_NTSTATUS_WIN_STATUS_LOG_PINNED = 0xC01A002C,
+  MD_NTSTATUS_WIN_STATUS_LOG_METADATA_FLUSH_FAILED = 0xC01A002D,
+  MD_NTSTATUS_WIN_STATUS_LOG_INCONSISTENT_SECURITY = 0xC01A002E,
+  MD_NTSTATUS_WIN_STATUS_LOG_APPENDED_FLUSH_FAILED = 0xC01A002F,
+  MD_NTSTATUS_WIN_STATUS_LOG_PINNED_RESERVATION = 0xC01A0030,
+  MD_NTSTATUS_WIN_STATUS_VIDEO_HUNG_DISPLAY_DRIVER_THREAD = 0xC01B00EA,
+  MD_NTSTATUS_WIN_STATUS_FLT_NO_HANDLER_DEFINED = 0xC01C0001,
+  MD_NTSTATUS_WIN_STATUS_FLT_CONTEXT_ALREADY_DEFINED = 0xC01C0002,
+  MD_NTSTATUS_WIN_STATUS_FLT_INVALID_ASYNCHRONOUS_REQUEST = 0xC01C0003,
+  MD_NTSTATUS_WIN_STATUS_FLT_DISALLOW_FAST_IO = 0xC01C0004,
+  MD_NTSTATUS_WIN_STATUS_FLT_INVALID_NAME_REQUEST = 0xC01C0005,
+  MD_NTSTATUS_WIN_STATUS_FLT_NOT_SAFE_TO_POST_OPERATION = 0xC01C0006,
+  MD_NTSTATUS_WIN_STATUS_FLT_NOT_INITIALIZED = 0xC01C0007,
+  MD_NTSTATUS_WIN_STATUS_FLT_FILTER_NOT_READY = 0xC01C0008,
+  MD_NTSTATUS_WIN_STATUS_FLT_POST_OPERATION_CLEANUP = 0xC01C0009,
+  MD_NTSTATUS_WIN_STATUS_FLT_INTERNAL_ERROR = 0xC01C000A,
+  MD_NTSTATUS_WIN_STATUS_FLT_DELETING_OBJECT = 0xC01C000B,
+  MD_NTSTATUS_WIN_STATUS_FLT_MUST_BE_NONPAGED_POOL = 0xC01C000C,
+  MD_NTSTATUS_WIN_STATUS_FLT_DUPLICATE_ENTRY = 0xC01C000D,
+  MD_NTSTATUS_WIN_STATUS_FLT_CBDQ_DISABLED = 0xC01C000E,
+  MD_NTSTATUS_WIN_STATUS_FLT_DO_NOT_ATTACH = 0xC01C000F,
+  MD_NTSTATUS_WIN_STATUS_FLT_DO_NOT_DETACH = 0xC01C0010,
+  MD_NTSTATUS_WIN_STATUS_FLT_INSTANCE_ALTITUDE_COLLISION = 0xC01C0011,
+  MD_NTSTATUS_WIN_STATUS_FLT_INSTANCE_NAME_COLLISION = 0xC01C0012,
+  MD_NTSTATUS_WIN_STATUS_FLT_FILTER_NOT_FOUND = 0xC01C0013,
+  MD_NTSTATUS_WIN_STATUS_FLT_VOLUME_NOT_FOUND = 0xC01C0014,
+  MD_NTSTATUS_WIN_STATUS_FLT_INSTANCE_NOT_FOUND = 0xC01C0015,
+  MD_NTSTATUS_WIN_STATUS_FLT_CONTEXT_ALLOCATION_NOT_FOUND = 0xC01C0016,
+  MD_NTSTATUS_WIN_STATUS_FLT_INVALID_CONTEXT_REGISTRATION = 0xC01C0017,
+  MD_NTSTATUS_WIN_STATUS_FLT_NAME_CACHE_MISS = 0xC01C0018,
+  MD_NTSTATUS_WIN_STATUS_FLT_NO_DEVICE_OBJECT = 0xC01C0019,
+  MD_NTSTATUS_WIN_STATUS_FLT_VOLUME_ALREADY_MOUNTED = 0xC01C001A,
+  MD_NTSTATUS_WIN_STATUS_FLT_ALREADY_ENLISTED = 0xC01C001B,
+  MD_NTSTATUS_WIN_STATUS_FLT_CONTEXT_ALREADY_LINKED = 0xC01C001C,
+  MD_NTSTATUS_WIN_STATUS_FLT_NO_WAITER_FOR_REPLY = 0xC01C0020,
+  MD_NTSTATUS_WIN_STATUS_FLT_REGISTRATION_BUSY = 0xC01C0023,
+  MD_NTSTATUS_WIN_STATUS_MONITOR_NO_DESCRIPTOR = 0xC01D0001,
+  MD_NTSTATUS_WIN_STATUS_MONITOR_UNKNOWN_DESCRIPTOR_FORMAT = 0xC01D0002,
+  MD_NTSTATUS_WIN_STATUS_MONITOR_INVALID_DESCRIPTOR_CHECKSUM = 0xC01D0003,
+  MD_NTSTATUS_WIN_STATUS_MONITOR_INVALID_STANDARD_TIMING_BLOCK = 0xC01D0004,
+  MD_NTSTATUS_WIN_STATUS_MONITOR_WMI_DATABLOCK_REGISTRATION_FAILED = 0xC01D0005,
+  MD_NTSTATUS_WIN_STATUS_MONITOR_INVALID_SERIAL_NUMBER_MONDSC_BLOCK = 0xC01D0006,
+  MD_NTSTATUS_WIN_STATUS_MONITOR_INVALID_USER_FRIENDLY_MONDSC_BLOCK = 0xC01D0007,
+  MD_NTSTATUS_WIN_STATUS_MONITOR_NO_MORE_DESCRIPTOR_DATA = 0xC01D0008,
+  MD_NTSTATUS_WIN_STATUS_MONITOR_INVALID_DETAILED_TIMING_BLOCK = 0xC01D0009,
+  MD_NTSTATUS_WIN_STATUS_MONITOR_INVALID_MANUFACTURE_DATE = 0xC01D000A,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_NOT_EXCLUSIVE_MODE_OWNER = 0xC01E0000,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INSUFFICIENT_DMA_BUFFER = 0xC01E0001,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_DISPLAY_ADAPTER = 0xC01E0002,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_ADAPTER_WAS_RESET = 0xC01E0003,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_DRIVER_MODEL = 0xC01E0004,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_PRESENT_MODE_CHANGED = 0xC01E0005,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_PRESENT_OCCLUDED = 0xC01E0006,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_PRESENT_DENIED = 0xC01E0007,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_CANNOTCOLORCONVERT = 0xC01E0008,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_DRIVER_MISMATCH = 0xC01E0009,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_PRESENT_REDIRECTION_DISABLED = 0xC01E000B,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_PRESENT_UNOCCLUDED = 0xC01E000C,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_WINDOWDC_NOT_AVAILABLE = 0xC01E000D,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_WINDOWLESS_PRESENT_DISABLED = 0xC01E000E,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_NO_VIDEO_MEMORY = 0xC01E0100,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_CANT_LOCK_MEMORY = 0xC01E0101,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_ALLOCATION_BUSY = 0xC01E0102,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_TOO_MANY_REFERENCES = 0xC01E0103,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_TRY_AGAIN_LATER = 0xC01E0104,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_TRY_AGAIN_NOW = 0xC01E0105,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_ALLOCATION_INVALID = 0xC01E0106,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_UNSWIZZLING_APERTURE_UNAVAILABLE = 0xC01E0107,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_UNSWIZZLING_APERTURE_UNSUPPORTED = 0xC01E0108,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_CANT_EVICT_PINNED_ALLOCATION = 0xC01E0109,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_ALLOCATION_USAGE = 0xC01E0110,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_CANT_RENDER_LOCKED_ALLOCATION = 0xC01E0111,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_ALLOCATION_CLOSED = 0xC01E0112,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_ALLOCATION_INSTANCE = 0xC01E0113,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_ALLOCATION_HANDLE = 0xC01E0114,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_WRONG_ALLOCATION_DEVICE = 0xC01E0115,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_ALLOCATION_CONTENT_LOST = 0xC01E0116,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_GPU_EXCEPTION_ON_DEVICE = 0xC01E0200,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_VIDPN_TOPOLOGY = 0xC01E0300,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_VIDPN_TOPOLOGY_NOT_SUPPORTED = 0xC01E0301,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_VIDPN_TOPOLOGY_CURRENTLY_NOT_SUPPORTED = 0xC01E0302,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_VIDPN = 0xC01E0303,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_VIDEO_PRESENT_SOURCE = 0xC01E0304,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_VIDEO_PRESENT_TARGET = 0xC01E0305,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_VIDPN_MODALITY_NOT_SUPPORTED = 0xC01E0306,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_VIDPN_SOURCEMODESET = 0xC01E0308,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_VIDPN_TARGETMODESET = 0xC01E0309,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_FREQUENCY = 0xC01E030A,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_ACTIVE_REGION = 0xC01E030B,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_TOTAL_REGION = 0xC01E030C,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_VIDEO_PRESENT_SOURCE_MODE = 0xC01E0310,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_VIDEO_PRESENT_TARGET_MODE = 0xC01E0311,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_PINNED_MODE_MUST_REMAIN_IN_SET = 0xC01E0312,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_PATH_ALREADY_IN_TOPOLOGY = 0xC01E0313,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_MODE_ALREADY_IN_MODESET = 0xC01E0314,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_VIDEOPRESENTSOURCESET = 0xC01E0315,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_VIDEOPRESENTTARGETSET = 0xC01E0316,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_SOURCE_ALREADY_IN_SET = 0xC01E0317,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_TARGET_ALREADY_IN_SET = 0xC01E0318,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_VIDPN_PRESENT_PATH = 0xC01E0319,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_NO_RECOMMENDED_VIDPN_TOPOLOGY = 0xC01E031A,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGESET = 0xC01E031B,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGE = 0xC01E031C,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_FREQUENCYRANGE_NOT_IN_SET = 0xC01E031D,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_FREQUENCYRANGE_ALREADY_IN_SET = 0xC01E031F,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_STALE_MODESET = 0xC01E0320,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_MONITOR_SOURCEMODESET = 0xC01E0321,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_MONITOR_SOURCE_MODE = 0xC01E0322,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_NO_RECOMMENDED_FUNCTIONAL_VIDPN = 0xC01E0323,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_MODE_ID_MUST_BE_UNIQUE = 0xC01E0324,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_EMPTY_ADAPTER_MONITOR_MODE_SUPPORT_INTERSECTION = 0xC01E0325,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_VIDEO_PRESENT_TARGETS_LESS_THAN_SOURCES = 0xC01E0326,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_PATH_NOT_IN_TOPOLOGY = 0xC01E0327,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_ADAPTER_MUST_HAVE_AT_LEAST_ONE_SOURCE = 0xC01E0328,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_ADAPTER_MUST_HAVE_AT_LEAST_ONE_TARGET = 0xC01E0329,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_MONITORDESCRIPTORSET = 0xC01E032A,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_MONITORDESCRIPTOR = 0xC01E032B,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_MONITORDESCRIPTOR_NOT_IN_SET = 0xC01E032C,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_MONITORDESCRIPTOR_ALREADY_IN_SET = 0xC01E032D,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_MONITORDESCRIPTOR_ID_MUST_BE_UNIQUE = 0xC01E032E,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_VIDPN_TARGET_SUBSET_TYPE = 0xC01E032F,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_RESOURCES_NOT_RELATED = 0xC01E0330,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_SOURCE_ID_MUST_BE_UNIQUE = 0xC01E0331,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_TARGET_ID_MUST_BE_UNIQUE = 0xC01E0332,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_NO_AVAILABLE_VIDPN_TARGET = 0xC01E0333,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_MONITOR_COULD_NOT_BE_ASSOCIATED_WITH_ADAPTER = 0xC01E0334,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_NO_VIDPNMGR = 0xC01E0335,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_NO_ACTIVE_VIDPN = 0xC01E0336,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_STALE_VIDPN_TOPOLOGY = 0xC01E0337,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_MONITOR_NOT_CONNECTED = 0xC01E0338,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_SOURCE_NOT_IN_TOPOLOGY = 0xC01E0339,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_PRIMARYSURFACE_SIZE = 0xC01E033A,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_VISIBLEREGION_SIZE = 0xC01E033B,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_STRIDE = 0xC01E033C,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_PIXELFORMAT = 0xC01E033D,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_COLORBASIS = 0xC01E033E,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_PIXELVALUEACCESSMODE = 0xC01E033F,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_TARGET_NOT_IN_TOPOLOGY = 0xC01E0340,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_NO_DISPLAY_MODE_MANAGEMENT_SUPPORT = 0xC01E0341,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_VIDPN_SOURCE_IN_USE = 0xC01E0342,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_CANT_ACCESS_ACTIVE_VIDPN = 0xC01E0343,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_PATH_IMPORTANCE_ORDINAL = 0xC01E0344,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_PATH_CONTENT_GEOMETRY_TRANSFORMATION = 0xC01E0345,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_PATH_CONTENT_GEOMETRY_TRANSFORMATION_NOT_SUPPORTED = 0xC01E0346,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_GAMMA_RAMP = 0xC01E0347,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_GAMMA_RAMP_NOT_SUPPORTED = 0xC01E0348,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_MULTISAMPLING_NOT_SUPPORTED = 0xC01E0349,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_MODE_NOT_IN_MODESET = 0xC01E034A,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_VIDPN_TOPOLOGY_RECOMMENDATION_REASON = 0xC01E034D,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_PATH_CONTENT_TYPE = 0xC01E034E,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_COPYPROTECTION_TYPE = 0xC01E034F,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_UNASSIGNED_MODESET_ALREADY_EXISTS = 0xC01E0350,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_SCANLINE_ORDERING = 0xC01E0352,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_TOPOLOGY_CHANGES_NOT_ALLOWED = 0xC01E0353,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_NO_AVAILABLE_IMPORTANCE_ORDINALS = 0xC01E0354,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INCOMPATIBLE_PRIVATE_FORMAT = 0xC01E0355,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_MODE_PRUNING_ALGORITHM = 0xC01E0356,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_MONITOR_CAPABILITY_ORIGIN = 0xC01E0357,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGE_CONSTRAINT = 0xC01E0358,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_MAX_NUM_PATHS_REACHED = 0xC01E0359,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_CANCEL_VIDPN_TOPOLOGY_AUGMENTATION = 0xC01E035A,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_CLIENT_TYPE = 0xC01E035B,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_CLIENTVIDPN_NOT_SET = 0xC01E035C,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_SPECIFIED_CHILD_ALREADY_CONNECTED = 0xC01E0400,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_CHILD_DESCRIPTOR_NOT_SUPPORTED = 0xC01E0401,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_NOT_A_LINKED_ADAPTER = 0xC01E0430,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_LEADLINK_NOT_ENUMERATED = 0xC01E0431,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_CHAINLINKS_NOT_ENUMERATED = 0xC01E0432,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_ADAPTER_CHAIN_NOT_READY = 0xC01E0433,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_CHAINLINKS_NOT_STARTED = 0xC01E0434,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_CHAINLINKS_NOT_POWERED_ON = 0xC01E0435,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INCONSISTENT_DEVICE_LINK_STATE = 0xC01E0436,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_NOT_POST_DEVICE_DRIVER = 0xC01E0438,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_ADAPTER_ACCESS_NOT_EXCLUDED = 0xC01E043B,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_OPM_NOT_SUPPORTED = 0xC01E0500,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_COPP_NOT_SUPPORTED = 0xC01E0501,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_UAB_NOT_SUPPORTED = 0xC01E0502,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_OPM_INVALID_ENCRYPTED_PARAMETERS = 0xC01E0503,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_OPM_NO_PROTECTED_OUTPUTS_EXIST = 0xC01E0505,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_OPM_INTERNAL_ERROR = 0xC01E050B,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_OPM_INVALID_HANDLE = 0xC01E050C,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_PVP_INVALID_CERTIFICATE_LENGTH = 0xC01E050E,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_OPM_SPANNING_MODE_ENABLED = 0xC01E050F,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_OPM_THEATER_MODE_ENABLED = 0xC01E0510,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_PVP_HFS_FAILED = 0xC01E0511,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_OPM_INVALID_SRM = 0xC01E0512,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_HDCP = 0xC01E0513,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_ACP = 0xC01E0514,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_CGMSA = 0xC01E0515,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_OPM_HDCP_SRM_NEVER_SET = 0xC01E0516,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_OPM_RESOLUTION_TOO_HIGH = 0xC01E0517,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_OPM_ALL_HDCP_HARDWARE_ALREADY_IN_USE = 0xC01E0518,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_OPM_PROTECTED_OUTPUT_NO_LONGER_EXISTS = 0xC01E051A,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_OPM_PROTECTED_OUTPUT_DOES_NOT_HAVE_COPP_SEMANTICS = 0xC01E051C,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_OPM_INVALID_INFORMATION_REQUEST = 0xC01E051D,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_OPM_DRIVER_INTERNAL_ERROR = 0xC01E051E,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_OPM_PROTECTED_OUTPUT_DOES_NOT_HAVE_OPM_SEMANTICS = 0xC01E051F,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_OPM_SIGNALING_NOT_SUPPORTED = 0xC01E0520,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_OPM_INVALID_CONFIGURATION_REQUEST = 0xC01E0521,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_I2C_NOT_SUPPORTED = 0xC01E0580,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_I2C_DEVICE_DOES_NOT_EXIST = 0xC01E0581,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_I2C_ERROR_TRANSMITTING_DATA = 0xC01E0582,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_I2C_ERROR_RECEIVING_DATA = 0xC01E0583,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_DDCCI_VCP_NOT_SUPPORTED = 0xC01E0584,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_DDCCI_INVALID_DATA = 0xC01E0585,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_DDCCI_MONITOR_RETURNED_INVALID_TIMING_STATUS_BYTE = 0xC01E0586,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_DDCCI_INVALID_CAPABILITIES_STRING = 0xC01E0587,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_MCA_INTERNAL_ERROR = 0xC01E0588,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_DDCCI_INVALID_MESSAGE_COMMAND = 0xC01E0589,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_DDCCI_INVALID_MESSAGE_LENGTH = 0xC01E058A,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_DDCCI_INVALID_MESSAGE_CHECKSUM = 0xC01E058B,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_PHYSICAL_MONITOR_HANDLE = 0xC01E058C,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_MONITOR_NO_LONGER_EXISTS = 0xC01E058D,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_ONLY_CONSOLE_SESSION_SUPPORTED = 0xC01E05E0,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_NO_DISPLAY_DEVICE_CORRESPONDS_TO_NAME = 0xC01E05E1,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_DISPLAY_DEVICE_NOT_ATTACHED_TO_DESKTOP = 0xC01E05E2,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_MIRRORING_DEVICES_NOT_SUPPORTED = 0xC01E05E3,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INVALID_POINTER = 0xC01E05E4,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_NO_MONITORS_CORRESPOND_TO_DISPLAY_DEVICE = 0xC01E05E5,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_PARAMETER_ARRAY_TOO_SMALL = 0xC01E05E6,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_INTERNAL_ERROR = 0xC01E05E7,
+  MD_NTSTATUS_WIN_STATUS_GRAPHICS_SESSION_TYPE_CHANGE_IN_PROGRESS = 0xC01E05E8,
+  MD_NTSTATUS_WIN_STATUS_FVE_LOCKED_VOLUME = 0xC0210000,
+  MD_NTSTATUS_WIN_STATUS_FVE_NOT_ENCRYPTED = 0xC0210001,
+  MD_NTSTATUS_WIN_STATUS_FVE_BAD_INFORMATION = 0xC0210002,
+  MD_NTSTATUS_WIN_STATUS_FVE_TOO_SMALL = 0xC0210003,
+  MD_NTSTATUS_WIN_STATUS_FVE_FAILED_WRONG_FS = 0xC0210004,
+  MD_NTSTATUS_WIN_STATUS_FVE_BAD_PARTITION_SIZE = 0xC0210005,
+  MD_NTSTATUS_WIN_STATUS_FVE_FS_NOT_EXTENDED = 0xC0210006,
+  MD_NTSTATUS_WIN_STATUS_FVE_FS_MOUNTED = 0xC0210007,
+  MD_NTSTATUS_WIN_STATUS_FVE_NO_LICENSE = 0xC0210008,
+  MD_NTSTATUS_WIN_STATUS_FVE_ACTION_NOT_ALLOWED = 0xC0210009,
+  MD_NTSTATUS_WIN_STATUS_FVE_BAD_DATA = 0xC021000A,
+  MD_NTSTATUS_WIN_STATUS_FVE_VOLUME_NOT_BOUND = 0xC021000B,
+  MD_NTSTATUS_WIN_STATUS_FVE_NOT_DATA_VOLUME = 0xC021000C,
+  MD_NTSTATUS_WIN_STATUS_FVE_CONV_READ_ERROR = 0xC021000D,
+  MD_NTSTATUS_WIN_STATUS_FVE_CONV_WRITE_ERROR = 0xC021000E,
+  MD_NTSTATUS_WIN_STATUS_FVE_OVERLAPPED_UPDATE = 0xC021000F,
+  MD_NTSTATUS_WIN_STATUS_FVE_FAILED_SECTOR_SIZE = 0xC0210010,
+  MD_NTSTATUS_WIN_STATUS_FVE_FAILED_AUTHENTICATION = 0xC0210011,
+  MD_NTSTATUS_WIN_STATUS_FVE_NOT_OS_VOLUME = 0xC0210012,
+  MD_NTSTATUS_WIN_STATUS_FVE_KEYFILE_NOT_FOUND = 0xC0210013,
+  MD_NTSTATUS_WIN_STATUS_FVE_KEYFILE_INVALID = 0xC0210014,
+  MD_NTSTATUS_WIN_STATUS_FVE_KEYFILE_NO_VMK = 0xC0210015,
+  MD_NTSTATUS_WIN_STATUS_FVE_TPM_DISABLED = 0xC0210016,
+  MD_NTSTATUS_WIN_STATUS_FVE_TPM_SRK_AUTH_NOT_ZERO = 0xC0210017,
+  MD_NTSTATUS_WIN_STATUS_FVE_TPM_INVALID_PCR = 0xC0210018,
+  MD_NTSTATUS_WIN_STATUS_FVE_TPM_NO_VMK = 0xC0210019,
+  MD_NTSTATUS_WIN_STATUS_FVE_PIN_INVALID = 0xC021001A,
+  MD_NTSTATUS_WIN_STATUS_FVE_AUTH_INVALID_APPLICATION = 0xC021001B,
+  MD_NTSTATUS_WIN_STATUS_FVE_AUTH_INVALID_CONFIG = 0xC021001C,
+  MD_NTSTATUS_WIN_STATUS_FVE_DEBUGGER_ENABLED = 0xC021001D,
+  MD_NTSTATUS_WIN_STATUS_FVE_DRY_RUN_FAILED = 0xC021001E,
+  MD_NTSTATUS_WIN_STATUS_FVE_BAD_METADATA_POINTER = 0xC021001F,
+  MD_NTSTATUS_WIN_STATUS_FVE_OLD_METADATA_COPY = 0xC0210020,
+  MD_NTSTATUS_WIN_STATUS_FVE_REBOOT_REQUIRED = 0xC0210021,
+  MD_NTSTATUS_WIN_STATUS_FVE_RAW_ACCESS = 0xC0210022,
+  MD_NTSTATUS_WIN_STATUS_FVE_RAW_BLOCKED = 0xC0210023,
+  MD_NTSTATUS_WIN_STATUS_FVE_NO_AUTOUNLOCK_MASTER_KEY = 0xC0210024,
+  MD_NTSTATUS_WIN_STATUS_FVE_MOR_FAILED = 0xC0210025,
+  MD_NTSTATUS_WIN_STATUS_FVE_NO_FEATURE_LICENSE = 0xC0210026,
+  MD_NTSTATUS_WIN_STATUS_FVE_POLICY_USER_DISABLE_RDV_NOT_ALLOWED = 0xC0210027,
+  MD_NTSTATUS_WIN_STATUS_FVE_CONV_RECOVERY_FAILED = 0xC0210028,
+  MD_NTSTATUS_WIN_STATUS_FVE_VIRTUALIZED_SPACE_TOO_BIG = 0xC0210029,
+  MD_NTSTATUS_WIN_STATUS_FVE_INVALID_DATUM_TYPE = 0xC021002A,
+  MD_NTSTATUS_WIN_STATUS_FVE_VOLUME_TOO_SMALL = 0xC0210030,
+  MD_NTSTATUS_WIN_STATUS_FVE_ENH_PIN_INVALID = 0xC0210031,
+  MD_NTSTATUS_WIN_STATUS_FVE_FULL_ENCRYPTION_NOT_ALLOWED_ON_TP_STORAGE = 0xC0210032,
+  MD_NTSTATUS_WIN_STATUS_FVE_WIPE_NOT_ALLOWED_ON_TP_STORAGE = 0xC0210033,
+  MD_NTSTATUS_WIN_STATUS_FVE_NOT_ALLOWED_ON_CSV_STACK = 0xC0210034,
+  MD_NTSTATUS_WIN_STATUS_FVE_NOT_ALLOWED_ON_CLUSTER = 0xC0210035,
+  MD_NTSTATUS_WIN_STATUS_FVE_NOT_ALLOWED_TO_UPGRADE_WHILE_CONVERTING = 0xC0210036,
+  MD_NTSTATUS_WIN_STATUS_FVE_WIPE_CANCEL_NOT_APPLICABLE = 0xC0210037,
+  MD_NTSTATUS_WIN_STATUS_FVE_EDRIVE_DRY_RUN_FAILED = 0xC0210038,
+  MD_NTSTATUS_WIN_STATUS_FVE_SECUREBOOT_DISABLED = 0xC0210039,
+  MD_NTSTATUS_WIN_STATUS_FVE_SECUREBOOT_CONFIG_CHANGE = 0xC021003A,
+  MD_NTSTATUS_WIN_STATUS_FVE_DEVICE_LOCKEDOUT = 0xC021003B,
+  MD_NTSTATUS_WIN_STATUS_FVE_VOLUME_EXTEND_PREVENTS_EOW_DECRYPT = 0xC021003C,
+  MD_NTSTATUS_WIN_STATUS_FVE_NOT_DE_VOLUME = 0xC021003D,
+  MD_NTSTATUS_WIN_STATUS_FVE_PROTECTION_DISABLED = 0xC021003E,
+  MD_NTSTATUS_WIN_STATUS_FVE_PROTECTION_CANNOT_BE_DISABLED = 0xC021003F,
+  MD_NTSTATUS_WIN_STATUS_FWP_CALLOUT_NOT_FOUND = 0xC0220001,
+  MD_NTSTATUS_WIN_STATUS_FWP_CONDITION_NOT_FOUND = 0xC0220002,
+  MD_NTSTATUS_WIN_STATUS_FWP_FILTER_NOT_FOUND = 0xC0220003,
+  MD_NTSTATUS_WIN_STATUS_FWP_LAYER_NOT_FOUND = 0xC0220004,
+  MD_NTSTATUS_WIN_STATUS_FWP_PROVIDER_NOT_FOUND = 0xC0220005,
+  MD_NTSTATUS_WIN_STATUS_FWP_PROVIDER_CONTEXT_NOT_FOUND = 0xC0220006,
+  MD_NTSTATUS_WIN_STATUS_FWP_SUBLAYER_NOT_FOUND = 0xC0220007,
+  MD_NTSTATUS_WIN_STATUS_FWP_NOT_FOUND = 0xC0220008,
+  MD_NTSTATUS_WIN_STATUS_FWP_ALREADY_EXISTS = 0xC0220009,
+  MD_NTSTATUS_WIN_STATUS_FWP_IN_USE = 0xC022000A,
+  MD_NTSTATUS_WIN_STATUS_FWP_DYNAMIC_SESSION_IN_PROGRESS = 0xC022000B,
+  MD_NTSTATUS_WIN_STATUS_FWP_WRONG_SESSION = 0xC022000C,
+  MD_NTSTATUS_WIN_STATUS_FWP_NO_TXN_IN_PROGRESS = 0xC022000D,
+  MD_NTSTATUS_WIN_STATUS_FWP_TXN_IN_PROGRESS = 0xC022000E,
+  MD_NTSTATUS_WIN_STATUS_FWP_TXN_ABORTED = 0xC022000F,
+  MD_NTSTATUS_WIN_STATUS_FWP_SESSION_ABORTED = 0xC0220010,
+  MD_NTSTATUS_WIN_STATUS_FWP_INCOMPATIBLE_TXN = 0xC0220011,
+  MD_NTSTATUS_WIN_STATUS_FWP_TIMEOUT = 0xC0220012,
+  MD_NTSTATUS_WIN_STATUS_FWP_NET_EVENTS_DISABLED = 0xC0220013,
+  MD_NTSTATUS_WIN_STATUS_FWP_INCOMPATIBLE_LAYER = 0xC0220014,
+  MD_NTSTATUS_WIN_STATUS_FWP_KM_CLIENTS_ONLY = 0xC0220015,
+  MD_NTSTATUS_WIN_STATUS_FWP_LIFETIME_MISMATCH = 0xC0220016,
+  MD_NTSTATUS_WIN_STATUS_FWP_BUILTIN_OBJECT = 0xC0220017,
+  MD_NTSTATUS_WIN_STATUS_FWP_TOO_MANY_CALLOUTS = 0xC0220018,
+  MD_NTSTATUS_WIN_STATUS_FWP_NOTIFICATION_DROPPED = 0xC0220019,
+  MD_NTSTATUS_WIN_STATUS_FWP_TRAFFIC_MISMATCH = 0xC022001A,
+  MD_NTSTATUS_WIN_STATUS_FWP_INCOMPATIBLE_SA_STATE = 0xC022001B,
+  MD_NTSTATUS_WIN_STATUS_FWP_NULL_POINTER = 0xC022001C,
+  MD_NTSTATUS_WIN_STATUS_FWP_INVALID_ENUMERATOR = 0xC022001D,
+  MD_NTSTATUS_WIN_STATUS_FWP_INVALID_FLAGS = 0xC022001E,
+  MD_NTSTATUS_WIN_STATUS_FWP_INVALID_NET_MASK = 0xC022001F,
+  MD_NTSTATUS_WIN_STATUS_FWP_INVALID_RANGE = 0xC0220020,
+  MD_NTSTATUS_WIN_STATUS_FWP_INVALID_INTERVAL = 0xC0220021,
+  MD_NTSTATUS_WIN_STATUS_FWP_ZERO_LENGTH_ARRAY = 0xC0220022,
+  MD_NTSTATUS_WIN_STATUS_FWP_NULL_DISPLAY_NAME = 0xC0220023,
+  MD_NTSTATUS_WIN_STATUS_FWP_INVALID_ACTION_TYPE = 0xC0220024,
+  MD_NTSTATUS_WIN_STATUS_FWP_INVALID_WEIGHT = 0xC0220025,
+  MD_NTSTATUS_WIN_STATUS_FWP_MATCH_TYPE_MISMATCH = 0xC0220026,
+  MD_NTSTATUS_WIN_STATUS_FWP_TYPE_MISMATCH = 0xC0220027,
+  MD_NTSTATUS_WIN_STATUS_FWP_OUT_OF_BOUNDS = 0xC0220028,
+  MD_NTSTATUS_WIN_STATUS_FWP_RESERVED = 0xC0220029,
+  MD_NTSTATUS_WIN_STATUS_FWP_DUPLICATE_CONDITION = 0xC022002A,
+  MD_NTSTATUS_WIN_STATUS_FWP_DUPLICATE_KEYMOD = 0xC022002B,
+  MD_NTSTATUS_WIN_STATUS_FWP_ACTION_INCOMPATIBLE_WITH_LAYER = 0xC022002C,
+  MD_NTSTATUS_WIN_STATUS_FWP_ACTION_INCOMPATIBLE_WITH_SUBLAYER = 0xC022002D,
+  MD_NTSTATUS_WIN_STATUS_FWP_CONTEXT_INCOMPATIBLE_WITH_LAYER = 0xC022002E,
+  MD_NTSTATUS_WIN_STATUS_FWP_CONTEXT_INCOMPATIBLE_WITH_CALLOUT = 0xC022002F,
+  MD_NTSTATUS_WIN_STATUS_FWP_INCOMPATIBLE_AUTH_METHOD = 0xC0220030,
+  MD_NTSTATUS_WIN_STATUS_FWP_INCOMPATIBLE_DH_GROUP = 0xC0220031,
+  MD_NTSTATUS_WIN_STATUS_FWP_EM_NOT_SUPPORTED = 0xC0220032,
+  MD_NTSTATUS_WIN_STATUS_FWP_NEVER_MATCH = 0xC0220033,
+  MD_NTSTATUS_WIN_STATUS_FWP_PROVIDER_CONTEXT_MISMATCH = 0xC0220034,
+  MD_NTSTATUS_WIN_STATUS_FWP_INVALID_PARAMETER = 0xC0220035,
+  MD_NTSTATUS_WIN_STATUS_FWP_TOO_MANY_SUBLAYERS = 0xC0220036,
+  MD_NTSTATUS_WIN_STATUS_FWP_CALLOUT_NOTIFICATION_FAILED = 0xC0220037,
+  MD_NTSTATUS_WIN_STATUS_FWP_INVALID_AUTH_TRANSFORM = 0xC0220038,
+  MD_NTSTATUS_WIN_STATUS_FWP_INVALID_CIPHER_TRANSFORM = 0xC0220039,
+  MD_NTSTATUS_WIN_STATUS_FWP_INCOMPATIBLE_CIPHER_TRANSFORM = 0xC022003A,
+  MD_NTSTATUS_WIN_STATUS_FWP_INVALID_TRANSFORM_COMBINATION = 0xC022003B,
+  MD_NTSTATUS_WIN_STATUS_FWP_DUPLICATE_AUTH_METHOD = 0xC022003C,
+  MD_NTSTATUS_WIN_STATUS_FWP_INVALID_TUNNEL_ENDPOINT = 0xC022003D,
+  MD_NTSTATUS_WIN_STATUS_FWP_L2_DRIVER_NOT_READY = 0xC022003E,
+  MD_NTSTATUS_WIN_STATUS_FWP_KEY_DICTATOR_ALREADY_REGISTERED = 0xC022003F,
+  MD_NTSTATUS_WIN_STATUS_FWP_KEY_DICTATION_INVALID_KEYING_MATERIAL = 0xC0220040,
+  MD_NTSTATUS_WIN_STATUS_FWP_CONNECTIONS_DISABLED = 0xC0220041,
+  MD_NTSTATUS_WIN_STATUS_FWP_INVALID_DNS_NAME = 0xC0220042,
+  MD_NTSTATUS_WIN_STATUS_FWP_STILL_ON = 0xC0220043,
+  MD_NTSTATUS_WIN_STATUS_FWP_IKEEXT_NOT_RUNNING = 0xC0220044,
+  MD_NTSTATUS_WIN_STATUS_FWP_TCPIP_NOT_READY = 0xC0220100,
+  MD_NTSTATUS_WIN_STATUS_FWP_INJECT_HANDLE_CLOSING = 0xC0220101,
+  MD_NTSTATUS_WIN_STATUS_FWP_INJECT_HANDLE_STALE = 0xC0220102,
+  MD_NTSTATUS_WIN_STATUS_FWP_CANNOT_PEND = 0xC0220103,
+  MD_NTSTATUS_WIN_STATUS_FWP_DROP_NOICMP = 0xC0220104,
+  MD_NTSTATUS_WIN_STATUS_NDIS_CLOSING = 0xC0230002,
+  MD_NTSTATUS_WIN_STATUS_NDIS_BAD_VERSION = 0xC0230004,
+  MD_NTSTATUS_WIN_STATUS_NDIS_BAD_CHARACTERISTICS = 0xC0230005,
+  MD_NTSTATUS_WIN_STATUS_NDIS_ADAPTER_NOT_FOUND = 0xC0230006,
+  MD_NTSTATUS_WIN_STATUS_NDIS_OPEN_FAILED = 0xC0230007,
+  MD_NTSTATUS_WIN_STATUS_NDIS_DEVICE_FAILED = 0xC0230008,
+  MD_NTSTATUS_WIN_STATUS_NDIS_MULTICAST_FULL = 0xC0230009,
+  MD_NTSTATUS_WIN_STATUS_NDIS_MULTICAST_EXISTS = 0xC023000A,
+  MD_NTSTATUS_WIN_STATUS_NDIS_MULTICAST_NOT_FOUND = 0xC023000B,
+  MD_NTSTATUS_WIN_STATUS_NDIS_REQUEST_ABORTED = 0xC023000C,
+  MD_NTSTATUS_WIN_STATUS_NDIS_RESET_IN_PROGRESS = 0xC023000D,
+  MD_NTSTATUS_WIN_STATUS_NDIS_INVALID_PACKET = 0xC023000F,
+  MD_NTSTATUS_WIN_STATUS_NDIS_INVALID_DEVICE_REQUEST = 0xC0230010,
+  MD_NTSTATUS_WIN_STATUS_NDIS_ADAPTER_NOT_READY = 0xC0230011,
+  MD_NTSTATUS_WIN_STATUS_NDIS_INVALID_LENGTH = 0xC0230014,
+  MD_NTSTATUS_WIN_STATUS_NDIS_INVALID_DATA = 0xC0230015,
+  MD_NTSTATUS_WIN_STATUS_NDIS_BUFFER_TOO_SHORT = 0xC0230016,
+  MD_NTSTATUS_WIN_STATUS_NDIS_INVALID_OID = 0xC0230017,
+  MD_NTSTATUS_WIN_STATUS_NDIS_ADAPTER_REMOVED = 0xC0230018,
+  MD_NTSTATUS_WIN_STATUS_NDIS_UNSUPPORTED_MEDIA = 0xC0230019,
+  MD_NTSTATUS_WIN_STATUS_NDIS_GROUP_ADDRESS_IN_USE = 0xC023001A,
+  MD_NTSTATUS_WIN_STATUS_NDIS_FILE_NOT_FOUND = 0xC023001B,
+  MD_NTSTATUS_WIN_STATUS_NDIS_ERROR_READING_FILE = 0xC023001C,
+  MD_NTSTATUS_WIN_STATUS_NDIS_ALREADY_MAPPED = 0xC023001D,
+  MD_NTSTATUS_WIN_STATUS_NDIS_RESOURCE_CONFLICT = 0xC023001E,
+  MD_NTSTATUS_WIN_STATUS_NDIS_MEDIA_DISCONNECTED = 0xC023001F,
+  MD_NTSTATUS_WIN_STATUS_NDIS_INVALID_ADDRESS = 0xC0230022,
+  MD_NTSTATUS_WIN_STATUS_NDIS_PAUSED = 0xC023002A,
+  MD_NTSTATUS_WIN_STATUS_NDIS_INTERFACE_NOT_FOUND = 0xC023002B,
+  MD_NTSTATUS_WIN_STATUS_NDIS_UNSUPPORTED_REVISION = 0xC023002C,
+  MD_NTSTATUS_WIN_STATUS_NDIS_INVALID_PORT = 0xC023002D,
+  MD_NTSTATUS_WIN_STATUS_NDIS_INVALID_PORT_STATE = 0xC023002E,
+  MD_NTSTATUS_WIN_STATUS_NDIS_LOW_POWER_STATE = 0xC023002F,
+  MD_NTSTATUS_WIN_STATUS_NDIS_REINIT_REQUIRED = 0xC0230030,
+  MD_NTSTATUS_WIN_STATUS_NDIS_NOT_SUPPORTED = 0xC02300BB,
+  MD_NTSTATUS_WIN_STATUS_NDIS_OFFLOAD_POLICY = 0xC023100F,
+  MD_NTSTATUS_WIN_STATUS_NDIS_OFFLOAD_CONNECTION_REJECTED = 0xC0231012,
+  MD_NTSTATUS_WIN_STATUS_NDIS_OFFLOAD_PATH_REJECTED = 0xC0231013,
+  MD_NTSTATUS_WIN_STATUS_NDIS_DOT11_AUTO_CONFIG_ENABLED = 0xC0232000,
+  MD_NTSTATUS_WIN_STATUS_NDIS_DOT11_MEDIA_IN_USE = 0xC0232001,
+  MD_NTSTATUS_WIN_STATUS_NDIS_DOT11_POWER_STATE_INVALID = 0xC0232002,
+  MD_NTSTATUS_WIN_STATUS_NDIS_PM_WOL_PATTERN_LIST_FULL = 0xC0232003,
+  MD_NTSTATUS_WIN_STATUS_NDIS_PM_PROTOCOL_OFFLOAD_LIST_FULL = 0xC0232004,
+  MD_NTSTATUS_WIN_STATUS_TPM_ERROR_MASK = 0xC0290000,
+  MD_NTSTATUS_WIN_STATUS_TPM_AUTHFAIL = 0xC0290001,
+  MD_NTSTATUS_WIN_STATUS_TPM_BADINDEX = 0xC0290002,
+  MD_NTSTATUS_WIN_STATUS_TPM_BAD_PARAMETER = 0xC0290003,
+  MD_NTSTATUS_WIN_STATUS_TPM_AUDITFAILURE = 0xC0290004,
+  MD_NTSTATUS_WIN_STATUS_TPM_CLEAR_DISABLED = 0xC0290005,
+  MD_NTSTATUS_WIN_STATUS_TPM_DEACTIVATED = 0xC0290006,
+  MD_NTSTATUS_WIN_STATUS_TPM_DISABLED = 0xC0290007,
+  MD_NTSTATUS_WIN_STATUS_TPM_DISABLED_CMD = 0xC0290008,
+  MD_NTSTATUS_WIN_STATUS_TPM_FAIL = 0xC0290009,
+  MD_NTSTATUS_WIN_STATUS_TPM_BAD_ORDINAL = 0xC029000A,
+  MD_NTSTATUS_WIN_STATUS_TPM_INSTALL_DISABLED = 0xC029000B,
+  MD_NTSTATUS_WIN_STATUS_TPM_INVALID_KEYHANDLE = 0xC029000C,
+  MD_NTSTATUS_WIN_STATUS_TPM_KEYNOTFOUND = 0xC029000D,
+  MD_NTSTATUS_WIN_STATUS_TPM_INAPPROPRIATE_ENC = 0xC029000E,
+  MD_NTSTATUS_WIN_STATUS_TPM_MIGRATEFAIL = 0xC029000F,
+  MD_NTSTATUS_WIN_STATUS_TPM_INVALID_PCR_INFO = 0xC0290010,
+  MD_NTSTATUS_WIN_STATUS_TPM_NOSPACE = 0xC0290011,
+  MD_NTSTATUS_WIN_STATUS_TPM_NOSRK = 0xC0290012,
+  MD_NTSTATUS_WIN_STATUS_TPM_NOTSEALED_BLOB = 0xC0290013,
+  MD_NTSTATUS_WIN_STATUS_TPM_OWNER_SET = 0xC0290014,
+  MD_NTSTATUS_WIN_STATUS_TPM_RESOURCES = 0xC0290015,
+  MD_NTSTATUS_WIN_STATUS_TPM_SHORTRANDOM = 0xC0290016,
+  MD_NTSTATUS_WIN_STATUS_TPM_SIZE = 0xC0290017,
+  MD_NTSTATUS_WIN_STATUS_TPM_WRONGPCRVAL = 0xC0290018,
+  MD_NTSTATUS_WIN_STATUS_TPM_BAD_PARAM_SIZE = 0xC0290019,
+  MD_NTSTATUS_WIN_STATUS_TPM_SHA_THREAD = 0xC029001A,
+  MD_NTSTATUS_WIN_STATUS_TPM_SHA_ERROR = 0xC029001B,
+  MD_NTSTATUS_WIN_STATUS_TPM_FAILEDSELFTEST = 0xC029001C,
+  MD_NTSTATUS_WIN_STATUS_TPM_AUTH2FAIL = 0xC029001D,
+  MD_NTSTATUS_WIN_STATUS_TPM_BADTAG = 0xC029001E,
+  MD_NTSTATUS_WIN_STATUS_TPM_IOERROR = 0xC029001F,
+  MD_NTSTATUS_WIN_STATUS_TPM_ENCRYPT_ERROR = 0xC0290020,
+  MD_NTSTATUS_WIN_STATUS_TPM_DECRYPT_ERROR = 0xC0290021,
+  MD_NTSTATUS_WIN_STATUS_TPM_INVALID_AUTHHANDLE = 0xC0290022,
+  MD_NTSTATUS_WIN_STATUS_TPM_NO_ENDORSEMENT = 0xC0290023,
+  MD_NTSTATUS_WIN_STATUS_TPM_INVALID_KEYUSAGE = 0xC0290024,
+  MD_NTSTATUS_WIN_STATUS_TPM_WRONG_ENTITYTYPE = 0xC0290025,
+  MD_NTSTATUS_WIN_STATUS_TPM_INVALID_POSTINIT = 0xC0290026,
+  MD_NTSTATUS_WIN_STATUS_TPM_INAPPROPRIATE_SIG = 0xC0290027,
+  MD_NTSTATUS_WIN_STATUS_TPM_BAD_KEY_PROPERTY = 0xC0290028,
+  MD_NTSTATUS_WIN_STATUS_TPM_BAD_MIGRATION = 0xC0290029,
+  MD_NTSTATUS_WIN_STATUS_TPM_BAD_SCHEME = 0xC029002A,
+  MD_NTSTATUS_WIN_STATUS_TPM_BAD_DATASIZE = 0xC029002B,
+  MD_NTSTATUS_WIN_STATUS_TPM_BAD_MODE = 0xC029002C,
+  MD_NTSTATUS_WIN_STATUS_TPM_BAD_PRESENCE = 0xC029002D,
+  MD_NTSTATUS_WIN_STATUS_TPM_BAD_VERSION = 0xC029002E,
+  MD_NTSTATUS_WIN_STATUS_TPM_NO_WRAP_TRANSPORT = 0xC029002F,
+  MD_NTSTATUS_WIN_STATUS_TPM_AUDITFAIL_UNSUCCESSFUL = 0xC0290030,
+  MD_NTSTATUS_WIN_STATUS_TPM_AUDITFAIL_SUCCESSFUL = 0xC0290031,
+  MD_NTSTATUS_WIN_STATUS_TPM_NOTRESETABLE = 0xC0290032,
+  MD_NTSTATUS_WIN_STATUS_TPM_NOTLOCAL = 0xC0290033,
+  MD_NTSTATUS_WIN_STATUS_TPM_BAD_TYPE = 0xC0290034,
+  MD_NTSTATUS_WIN_STATUS_TPM_INVALID_RESOURCE = 0xC0290035,
+  MD_NTSTATUS_WIN_STATUS_TPM_NOTFIPS = 0xC0290036,
+  MD_NTSTATUS_WIN_STATUS_TPM_INVALID_FAMILY = 0xC0290037,
+  MD_NTSTATUS_WIN_STATUS_TPM_NO_NV_PERMISSION = 0xC0290038,
+  MD_NTSTATUS_WIN_STATUS_TPM_REQUIRES_SIGN = 0xC0290039,
+  MD_NTSTATUS_WIN_STATUS_TPM_KEY_NOTSUPPORTED = 0xC029003A,
+  MD_NTSTATUS_WIN_STATUS_TPM_AUTH_CONFLICT = 0xC029003B,
+  MD_NTSTATUS_WIN_STATUS_TPM_AREA_LOCKED = 0xC029003C,
+  MD_NTSTATUS_WIN_STATUS_TPM_BAD_LOCALITY = 0xC029003D,
+  MD_NTSTATUS_WIN_STATUS_TPM_READ_ONLY = 0xC029003E,
+  MD_NTSTATUS_WIN_STATUS_TPM_PER_NOWRITE = 0xC029003F,
+  MD_NTSTATUS_WIN_STATUS_TPM_FAMILYCOUNT = 0xC0290040,
+  MD_NTSTATUS_WIN_STATUS_TPM_WRITE_LOCKED = 0xC0290041,
+  MD_NTSTATUS_WIN_STATUS_TPM_BAD_ATTRIBUTES = 0xC0290042,
+  MD_NTSTATUS_WIN_STATUS_TPM_INVALID_STRUCTURE = 0xC0290043,
+  MD_NTSTATUS_WIN_STATUS_TPM_KEY_OWNER_CONTROL = 0xC0290044,
+  MD_NTSTATUS_WIN_STATUS_TPM_BAD_COUNTER = 0xC0290045,
+  MD_NTSTATUS_WIN_STATUS_TPM_NOT_FULLWRITE = 0xC0290046,
+  MD_NTSTATUS_WIN_STATUS_TPM_CONTEXT_GAP = 0xC0290047,
+  MD_NTSTATUS_WIN_STATUS_TPM_MAXNVWRITES = 0xC0290048,
+  MD_NTSTATUS_WIN_STATUS_TPM_NOOPERATOR = 0xC0290049,
+  MD_NTSTATUS_WIN_STATUS_TPM_RESOURCEMISSING = 0xC029004A,
+  MD_NTSTATUS_WIN_STATUS_TPM_DELEGATE_LOCK = 0xC029004B,
+  MD_NTSTATUS_WIN_STATUS_TPM_DELEGATE_FAMILY = 0xC029004C,
+  MD_NTSTATUS_WIN_STATUS_TPM_DELEGATE_ADMIN = 0xC029004D,
+  MD_NTSTATUS_WIN_STATUS_TPM_TRANSPORT_NOTEXCLUSIVE = 0xC029004E,
+  MD_NTSTATUS_WIN_STATUS_TPM_OWNER_CONTROL = 0xC029004F,
+  MD_NTSTATUS_WIN_STATUS_TPM_DAA_RESOURCES = 0xC0290050,
+  MD_NTSTATUS_WIN_STATUS_TPM_DAA_INPUT_DATA0 = 0xC0290051,
+  MD_NTSTATUS_WIN_STATUS_TPM_DAA_INPUT_DATA1 = 0xC0290052,
+  MD_NTSTATUS_WIN_STATUS_TPM_DAA_ISSUER_SETTINGS = 0xC0290053,
+  MD_NTSTATUS_WIN_STATUS_TPM_DAA_TPM_SETTINGS = 0xC0290054,
+  MD_NTSTATUS_WIN_STATUS_TPM_DAA_STAGE = 0xC0290055,
+  MD_NTSTATUS_WIN_STATUS_TPM_DAA_ISSUER_VALIDITY = 0xC0290056,
+  MD_NTSTATUS_WIN_STATUS_TPM_DAA_WRONG_W = 0xC0290057,
+  MD_NTSTATUS_WIN_STATUS_TPM_BAD_HANDLE = 0xC0290058,
+  MD_NTSTATUS_WIN_STATUS_TPM_BAD_DELEGATE = 0xC0290059,
+  MD_NTSTATUS_WIN_STATUS_TPM_BADCONTEXT = 0xC029005A,
+  MD_NTSTATUS_WIN_STATUS_TPM_TOOMANYCONTEXTS = 0xC029005B,
+  MD_NTSTATUS_WIN_STATUS_TPM_MA_TICKET_SIGNATURE = 0xC029005C,
+  MD_NTSTATUS_WIN_STATUS_TPM_MA_DESTINATION = 0xC029005D,
+  MD_NTSTATUS_WIN_STATUS_TPM_MA_SOURCE = 0xC029005E,
+  MD_NTSTATUS_WIN_STATUS_TPM_MA_AUTHORITY = 0xC029005F,
+  MD_NTSTATUS_WIN_STATUS_TPM_PERMANENTEK = 0xC0290061,
+  MD_NTSTATUS_WIN_STATUS_TPM_BAD_SIGNATURE = 0xC0290062,
+  MD_NTSTATUS_WIN_STATUS_TPM_NOCONTEXTSPACE = 0xC0290063,
+  MD_NTSTATUS_WIN_STATUS_TPM_COMMAND_BLOCKED = 0xC0290400,
+  MD_NTSTATUS_WIN_STATUS_TPM_INVALID_HANDLE = 0xC0290401,
+  MD_NTSTATUS_WIN_STATUS_TPM_DUPLICATE_VHANDLE = 0xC0290402,
+  MD_NTSTATUS_WIN_STATUS_TPM_EMBEDDED_COMMAND_BLOCKED = 0xC0290403,
+  MD_NTSTATUS_WIN_STATUS_TPM_EMBEDDED_COMMAND_UNSUPPORTED = 0xC0290404,
+  MD_NTSTATUS_WIN_STATUS_TPM_RETRY = 0xC0290800,
+  MD_NTSTATUS_WIN_STATUS_TPM_NEEDS_SELFTEST = 0xC0290801,
+  MD_NTSTATUS_WIN_STATUS_TPM_DOING_SELFTEST = 0xC0290802,
+  MD_NTSTATUS_WIN_STATUS_TPM_DEFEND_LOCK_RUNNING = 0xC0290803,
+  MD_NTSTATUS_WIN_STATUS_TPM_COMMAND_CANCELED = 0xC0291001,
+  MD_NTSTATUS_WIN_STATUS_TPM_TOO_MANY_CONTEXTS = 0xC0291002,
+  MD_NTSTATUS_WIN_STATUS_TPM_NOT_FOUND = 0xC0291003,
+  MD_NTSTATUS_WIN_STATUS_TPM_ACCESS_DENIED = 0xC0291004,
+  MD_NTSTATUS_WIN_STATUS_TPM_INSUFFICIENT_BUFFER = 0xC0291005,
+  MD_NTSTATUS_WIN_STATUS_TPM_PPI_FUNCTION_UNSUPPORTED = 0xC0291006,
+  MD_NTSTATUS_WIN_STATUS_PCP_ERROR_MASK = 0xC0292000,
+  MD_NTSTATUS_WIN_STATUS_PCP_DEVICE_NOT_READY = 0xC0292001,
+  MD_NTSTATUS_WIN_STATUS_PCP_INVALID_HANDLE = 0xC0292002,
+  MD_NTSTATUS_WIN_STATUS_PCP_INVALID_PARAMETER = 0xC0292003,
+  MD_NTSTATUS_WIN_STATUS_PCP_FLAG_NOT_SUPPORTED = 0xC0292004,
+  MD_NTSTATUS_WIN_STATUS_PCP_NOT_SUPPORTED = 0xC0292005,
+  MD_NTSTATUS_WIN_STATUS_PCP_BUFFER_TOO_SMALL = 0xC0292006,
+  MD_NTSTATUS_WIN_STATUS_PCP_INTERNAL_ERROR = 0xC0292007,
+  MD_NTSTATUS_WIN_STATUS_PCP_AUTHENTICATION_FAILED = 0xC0292008,
+  MD_NTSTATUS_WIN_STATUS_PCP_AUTHENTICATION_IGNORED = 0xC0292009,
+  MD_NTSTATUS_WIN_STATUS_PCP_POLICY_NOT_FOUND = 0xC029200A,
+  MD_NTSTATUS_WIN_STATUS_PCP_PROFILE_NOT_FOUND = 0xC029200B,
+  MD_NTSTATUS_WIN_STATUS_PCP_VALIDATION_FAILED = 0xC029200C,
+  MD_NTSTATUS_WIN_STATUS_PCP_DEVICE_NOT_FOUND = 0xC029200D,
+  MD_NTSTATUS_WIN_STATUS_HV_INVALID_HYPERCALL_CODE = 0xC0350002,
+  MD_NTSTATUS_WIN_STATUS_HV_INVALID_HYPERCALL_INPUT = 0xC0350003,
+  MD_NTSTATUS_WIN_STATUS_HV_INVALID_ALIGNMENT = 0xC0350004,
+  MD_NTSTATUS_WIN_STATUS_HV_INVALID_PARAMETER = 0xC0350005,
+  MD_NTSTATUS_WIN_STATUS_HV_ACCESS_DENIED = 0xC0350006,
+  MD_NTSTATUS_WIN_STATUS_HV_INVALID_PARTITION_STATE = 0xC0350007,
+  MD_NTSTATUS_WIN_STATUS_HV_OPERATION_DENIED = 0xC0350008,
+  MD_NTSTATUS_WIN_STATUS_HV_UNKNOWN_PROPERTY = 0xC0350009,
+  MD_NTSTATUS_WIN_STATUS_HV_PROPERTY_VALUE_OUT_OF_RANGE = 0xC035000A,
+  MD_NTSTATUS_WIN_STATUS_HV_INSUFFICIENT_MEMORY = 0xC035000B,
+  MD_NTSTATUS_WIN_STATUS_HV_PARTITION_TOO_DEEP = 0xC035000C,
+  MD_NTSTATUS_WIN_STATUS_HV_INVALID_PARTITION_ID = 0xC035000D,
+  MD_NTSTATUS_WIN_STATUS_HV_INVALID_VP_INDEX = 0xC035000E,
+  MD_NTSTATUS_WIN_STATUS_HV_INVALID_PORT_ID = 0xC0350011,
+  MD_NTSTATUS_WIN_STATUS_HV_INVALID_CONNECTION_ID = 0xC0350012,
+  MD_NTSTATUS_WIN_STATUS_HV_INSUFFICIENT_BUFFERS = 0xC0350013,
+  MD_NTSTATUS_WIN_STATUS_HV_NOT_ACKNOWLEDGED = 0xC0350014,
+  MD_NTSTATUS_WIN_STATUS_HV_ACKNOWLEDGED = 0xC0350016,
+  MD_NTSTATUS_WIN_STATUS_HV_INVALID_SAVE_RESTORE_STATE = 0xC0350017,
+  MD_NTSTATUS_WIN_STATUS_HV_INVALID_SYNIC_STATE = 0xC0350018,
+  MD_NTSTATUS_WIN_STATUS_HV_OBJECT_IN_USE = 0xC0350019,
+  MD_NTSTATUS_WIN_STATUS_HV_INVALID_PROXIMITY_DOMAIN_INFO = 0xC035001A,
+  MD_NTSTATUS_WIN_STATUS_HV_NO_DATA = 0xC035001B,
+  MD_NTSTATUS_WIN_STATUS_HV_INACTIVE = 0xC035001C,
+  MD_NTSTATUS_WIN_STATUS_HV_NO_RESOURCES = 0xC035001D,
+  MD_NTSTATUS_WIN_STATUS_HV_FEATURE_UNAVAILABLE = 0xC035001E,
+  MD_NTSTATUS_WIN_STATUS_HV_INSUFFICIENT_BUFFER = 0xC0350033,
+  MD_NTSTATUS_WIN_STATUS_HV_INSUFFICIENT_DEVICE_DOMAINS = 0xC0350038,
+  MD_NTSTATUS_WIN_STATUS_HV_INVALID_LP_INDEX = 0xC0350041,
+  MD_NTSTATUS_WIN_STATUS_HV_NOT_PRESENT = 0xC0351000,
+  MD_NTSTATUS_WIN_STATUS_IPSEC_BAD_SPI = 0xC0360001,
+  MD_NTSTATUS_WIN_STATUS_IPSEC_SA_LIFETIME_EXPIRED = 0xC0360002,
+  MD_NTSTATUS_WIN_STATUS_IPSEC_WRONG_SA = 0xC0360003,
+  MD_NTSTATUS_WIN_STATUS_IPSEC_REPLAY_CHECK_FAILED = 0xC0360004,
+  MD_NTSTATUS_WIN_STATUS_IPSEC_INVALID_PACKET = 0xC0360005,
+  MD_NTSTATUS_WIN_STATUS_IPSEC_INTEGRITY_CHECK_FAILED = 0xC0360006,
+  MD_NTSTATUS_WIN_STATUS_IPSEC_CLEAR_TEXT_DROP = 0xC0360007,
+  MD_NTSTATUS_WIN_STATUS_IPSEC_AUTH_FIREWALL_DROP = 0xC0360008,
+  MD_NTSTATUS_WIN_STATUS_IPSEC_THROTTLE_DROP = 0xC0360009,
+  MD_NTSTATUS_WIN_STATUS_IPSEC_DOSP_BLOCK = 0xC0368000,
+  MD_NTSTATUS_WIN_STATUS_IPSEC_DOSP_RECEIVED_MULTICAST = 0xC0368001,
+  MD_NTSTATUS_WIN_STATUS_IPSEC_DOSP_INVALID_PACKET = 0xC0368002,
+  MD_NTSTATUS_WIN_STATUS_IPSEC_DOSP_STATE_LOOKUP_FAILED = 0xC0368003,
+  MD_NTSTATUS_WIN_STATUS_IPSEC_DOSP_MAX_ENTRIES = 0xC0368004,
+  MD_NTSTATUS_WIN_STATUS_IPSEC_DOSP_KEYMOD_NOT_ALLOWED = 0xC0368005,
+  MD_NTSTATUS_WIN_STATUS_IPSEC_DOSP_MAX_PER_IP_RATELIMIT_QUEUES = 0xC0368006,
+  MD_NTSTATUS_WIN_STATUS_VID_DUPLICATE_HANDLER = 0xC0370001,
+  MD_NTSTATUS_WIN_STATUS_VID_TOO_MANY_HANDLERS = 0xC0370002,
+  MD_NTSTATUS_WIN_STATUS_VID_QUEUE_FULL = 0xC0370003,
+  MD_NTSTATUS_WIN_STATUS_VID_HANDLER_NOT_PRESENT = 0xC0370004,
+  MD_NTSTATUS_WIN_STATUS_VID_INVALID_OBJECT_NAME = 0xC0370005,
+  MD_NTSTATUS_WIN_STATUS_VID_PARTITION_NAME_TOO_LONG = 0xC0370006,
+  MD_NTSTATUS_WIN_STATUS_VID_MESSAGE_QUEUE_NAME_TOO_LONG = 0xC0370007,
+  MD_NTSTATUS_WIN_STATUS_VID_PARTITION_ALREADY_EXISTS = 0xC0370008,
+  MD_NTSTATUS_WIN_STATUS_VID_PARTITION_DOES_NOT_EXIST = 0xC0370009,
+  MD_NTSTATUS_WIN_STATUS_VID_PARTITION_NAME_NOT_FOUND = 0xC037000A,
+  MD_NTSTATUS_WIN_STATUS_VID_MESSAGE_QUEUE_ALREADY_EXISTS = 0xC037000B,
+  MD_NTSTATUS_WIN_STATUS_VID_EXCEEDED_MBP_ENTRY_MAP_LIMIT = 0xC037000C,
+  MD_NTSTATUS_WIN_STATUS_VID_MB_STILL_REFERENCED = 0xC037000D,
+  MD_NTSTATUS_WIN_STATUS_VID_CHILD_GPA_PAGE_SET_CORRUPTED = 0xC037000E,
+  MD_NTSTATUS_WIN_STATUS_VID_INVALID_NUMA_SETTINGS = 0xC037000F,
+  MD_NTSTATUS_WIN_STATUS_VID_INVALID_NUMA_NODE_INDEX = 0xC0370010,
+  MD_NTSTATUS_WIN_STATUS_VID_NOTIFICATION_QUEUE_ALREADY_ASSOCIATED = 0xC0370011,
+  MD_NTSTATUS_WIN_STATUS_VID_INVALID_MEMORY_BLOCK_HANDLE = 0xC0370012,
+  MD_NTSTATUS_WIN_STATUS_VID_PAGE_RANGE_OVERFLOW = 0xC0370013,
+  MD_NTSTATUS_WIN_STATUS_VID_INVALID_MESSAGE_QUEUE_HANDLE = 0xC0370014,
+  MD_NTSTATUS_WIN_STATUS_VID_INVALID_GPA_RANGE_HANDLE = 0xC0370015,
+  MD_NTSTATUS_WIN_STATUS_VID_NO_MEMORY_BLOCK_NOTIFICATION_QUEUE = 0xC0370016,
+  MD_NTSTATUS_WIN_STATUS_VID_MEMORY_BLOCK_LOCK_COUNT_EXCEEDED = 0xC0370017,
+  MD_NTSTATUS_WIN_STATUS_VID_INVALID_PPM_HANDLE = 0xC0370018,
+  MD_NTSTATUS_WIN_STATUS_VID_MBPS_ARE_LOCKED = 0xC0370019,
+  MD_NTSTATUS_WIN_STATUS_VID_MESSAGE_QUEUE_CLOSED = 0xC037001A,
+  MD_NTSTATUS_WIN_STATUS_VID_VIRTUAL_PROCESSOR_LIMIT_EXCEEDED = 0xC037001B,
+  MD_NTSTATUS_WIN_STATUS_VID_STOP_PENDING = 0xC037001C,
+  MD_NTSTATUS_WIN_STATUS_VID_INVALID_PROCESSOR_STATE = 0xC037001D,
+  MD_NTSTATUS_WIN_STATUS_VID_EXCEEDED_KM_CONTEXT_COUNT_LIMIT = 0xC037001E,
+  MD_NTSTATUS_WIN_STATUS_VID_KM_INTERFACE_ALREADY_INITIALIZED = 0xC037001F,
+  MD_NTSTATUS_WIN_STATUS_VID_MB_PROPERTY_ALREADY_SET_RESET = 0xC0370020,
+  MD_NTSTATUS_WIN_STATUS_VID_MMIO_RANGE_DESTROYED = 0xC0370021,
+  MD_NTSTATUS_WIN_STATUS_VID_INVALID_CHILD_GPA_PAGE_SET = 0xC0370022,
+  MD_NTSTATUS_WIN_STATUS_VID_RESERVE_PAGE_SET_IS_BEING_USED = 0xC0370023,
+  MD_NTSTATUS_WIN_STATUS_VID_RESERVE_PAGE_SET_TOO_SMALL = 0xC0370024,
+  MD_NTSTATUS_WIN_STATUS_VID_MBP_ALREADY_LOCKED_USING_RESERVED_PAGE = 0xC0370025,
+  MD_NTSTATUS_WIN_STATUS_VID_MBP_COUNT_EXCEEDED_LIMIT = 0xC0370026,
+  MD_NTSTATUS_WIN_STATUS_VID_SAVED_STATE_CORRUPT = 0xC0370027,
+  MD_NTSTATUS_WIN_STATUS_VID_SAVED_STATE_UNRECOGNIZED_ITEM = 0xC0370028,
+  MD_NTSTATUS_WIN_STATUS_VID_SAVED_STATE_INCOMPATIBLE = 0xC0370029,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_DATABASE_FULL = 0xC0380001,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_CONFIGURATION_CORRUPTED = 0xC0380002,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_CONFIGURATION_NOT_IN_SYNC = 0xC0380003,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_PACK_CONFIG_UPDATE_FAILED = 0xC0380004,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_CONTAINS_NON_SIMPLE_VOLUME = 0xC0380005,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_DUPLICATE = 0xC0380006,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_DYNAMIC = 0xC0380007,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_ID_INVALID = 0xC0380008,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_INVALID = 0xC0380009,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_LAST_VOTER = 0xC038000A,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_LAYOUT_INVALID = 0xC038000B,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_LAYOUT_NON_BASIC_BETWEEN_BASIC_PARTITIONS = 0xC038000C,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_LAYOUT_NOT_CYLINDER_ALIGNED = 0xC038000D,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_LAYOUT_PARTITIONS_TOO_SMALL = 0xC038000E,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_LAYOUT_PRIMARY_BETWEEN_LOGICAL_PARTITIONS = 0xC038000F,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_LAYOUT_TOO_MANY_PARTITIONS = 0xC0380010,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_MISSING = 0xC0380011,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_NOT_EMPTY = 0xC0380012,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_NOT_ENOUGH_SPACE = 0xC0380013,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_REVECTORING_FAILED = 0xC0380014,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_SECTOR_SIZE_INVALID = 0xC0380015,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_SET_NOT_CONTAINED = 0xC0380016,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_USED_BY_MULTIPLE_MEMBERS = 0xC0380017,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_DISK_USED_BY_MULTIPLE_PLEXES = 0xC0380018,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_DYNAMIC_DISK_NOT_SUPPORTED = 0xC0380019,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_EXTENT_ALREADY_USED = 0xC038001A,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_EXTENT_NOT_CONTIGUOUS = 0xC038001B,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_EXTENT_NOT_IN_PUBLIC_REGION = 0xC038001C,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_EXTENT_NOT_SECTOR_ALIGNED = 0xC038001D,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_EXTENT_OVERLAPS_EBR_PARTITION = 0xC038001E,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_EXTENT_VOLUME_LENGTHS_DO_NOT_MATCH = 0xC038001F,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_FAULT_TOLERANT_NOT_SUPPORTED = 0xC0380020,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_INTERLEAVE_LENGTH_INVALID = 0xC0380021,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_MAXIMUM_REGISTERED_USERS = 0xC0380022,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_MEMBER_IN_SYNC = 0xC0380023,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_MEMBER_INDEX_DUPLICATE = 0xC0380024,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_MEMBER_INDEX_INVALID = 0xC0380025,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_MEMBER_MISSING = 0xC0380026,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_MEMBER_NOT_DETACHED = 0xC0380027,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_MEMBER_REGENERATING = 0xC0380028,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_ALL_DISKS_FAILED = 0xC0380029,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_NO_REGISTERED_USERS = 0xC038002A,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_NO_SUCH_USER = 0xC038002B,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_NOTIFICATION_RESET = 0xC038002C,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_NUMBER_OF_MEMBERS_INVALID = 0xC038002D,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_NUMBER_OF_PLEXES_INVALID = 0xC038002E,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_PACK_DUPLICATE = 0xC038002F,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_PACK_ID_INVALID = 0xC0380030,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_PACK_INVALID = 0xC0380031,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_PACK_NAME_INVALID = 0xC0380032,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_PACK_OFFLINE = 0xC0380033,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_PACK_HAS_QUORUM = 0xC0380034,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_PACK_WITHOUT_QUORUM = 0xC0380035,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_PARTITION_STYLE_INVALID = 0xC0380036,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_PARTITION_UPDATE_FAILED = 0xC0380037,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_PLEX_IN_SYNC = 0xC0380038,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_PLEX_INDEX_DUPLICATE = 0xC0380039,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_PLEX_INDEX_INVALID = 0xC038003A,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_PLEX_LAST_ACTIVE = 0xC038003B,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_PLEX_MISSING = 0xC038003C,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_PLEX_REGENERATING = 0xC038003D,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_PLEX_TYPE_INVALID = 0xC038003E,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_PLEX_NOT_RAID5 = 0xC038003F,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_PLEX_NOT_SIMPLE = 0xC0380040,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_STRUCTURE_SIZE_INVALID = 0xC0380041,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_TOO_MANY_NOTIFICATION_REQUESTS = 0xC0380042,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_TRANSACTION_IN_PROGRESS = 0xC0380043,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_UNEXPECTED_DISK_LAYOUT_CHANGE = 0xC0380044,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_VOLUME_CONTAINS_MISSING_DISK = 0xC0380045,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_VOLUME_ID_INVALID = 0xC0380046,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_VOLUME_LENGTH_INVALID = 0xC0380047,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_VOLUME_LENGTH_NOT_SECTOR_SIZE_MULTIPLE = 0xC0380048,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_VOLUME_NOT_MIRRORED = 0xC0380049,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_VOLUME_NOT_RETAINED = 0xC038004A,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_VOLUME_OFFLINE = 0xC038004B,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_VOLUME_RETAINED = 0xC038004C,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_NUMBER_OF_EXTENTS_INVALID = 0xC038004D,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_DIFFERENT_SECTOR_SIZE = 0xC038004E,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_BAD_BOOT_DISK = 0xC038004F,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_PACK_CONFIG_OFFLINE = 0xC0380050,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_PACK_CONFIG_ONLINE = 0xC0380051,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_NOT_PRIMARY_PACK = 0xC0380052,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_PACK_LOG_UPDATE_FAILED = 0xC0380053,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_NUMBER_OF_DISKS_IN_PLEX_INVALID = 0xC0380054,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_NUMBER_OF_DISKS_IN_MEMBER_INVALID = 0xC0380055,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_VOLUME_MIRRORED = 0xC0380056,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_PLEX_NOT_SIMPLE_SPANNED = 0xC0380057,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_NO_VALID_LOG_COPIES = 0xC0380058,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_PRIMARY_PACK_PRESENT = 0xC0380059,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_NUMBER_OF_DISKS_INVALID = 0xC038005A,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_MIRROR_NOT_SUPPORTED = 0xC038005B,
+  MD_NTSTATUS_WIN_STATUS_VOLMGR_RAID5_NOT_SUPPORTED = 0xC038005C,
+  MD_NTSTATUS_WIN_STATUS_BCD_TOO_MANY_ELEMENTS = 0xC0390002,
+  MD_NTSTATUS_WIN_STATUS_VHD_DRIVE_FOOTER_MISSING = 0xC03A0001,
+  MD_NTSTATUS_WIN_STATUS_VHD_DRIVE_FOOTER_CHECKSUM_MISMATCH = 0xC03A0002,
+  MD_NTSTATUS_WIN_STATUS_VHD_DRIVE_FOOTER_CORRUPT = 0xC03A0003,
+  MD_NTSTATUS_WIN_STATUS_VHD_FORMAT_UNKNOWN = 0xC03A0004,
+  MD_NTSTATUS_WIN_STATUS_VHD_FORMAT_UNSUPPORTED_VERSION = 0xC03A0005,
+  MD_NTSTATUS_WIN_STATUS_VHD_SPARSE_HEADER_CHECKSUM_MISMATCH = 0xC03A0006,
+  MD_NTSTATUS_WIN_STATUS_VHD_SPARSE_HEADER_UNSUPPORTED_VERSION = 0xC03A0007,
+  MD_NTSTATUS_WIN_STATUS_VHD_SPARSE_HEADER_CORRUPT = 0xC03A0008,
+  MD_NTSTATUS_WIN_STATUS_VHD_BLOCK_ALLOCATION_FAILURE = 0xC03A0009,
+  MD_NTSTATUS_WIN_STATUS_VHD_BLOCK_ALLOCATION_TABLE_CORRUPT = 0xC03A000A,
+  MD_NTSTATUS_WIN_STATUS_VHD_INVALID_BLOCK_SIZE = 0xC03A000B,
+  MD_NTSTATUS_WIN_STATUS_VHD_BITMAP_MISMATCH = 0xC03A000C,
+  MD_NTSTATUS_WIN_STATUS_VHD_PARENT_VHD_NOT_FOUND = 0xC03A000D,
+  MD_NTSTATUS_WIN_STATUS_VHD_CHILD_PARENT_ID_MISMATCH = 0xC03A000E,
+  MD_NTSTATUS_WIN_STATUS_VHD_CHILD_PARENT_TIMESTAMP_MISMATCH = 0xC03A000F,
+  MD_NTSTATUS_WIN_STATUS_VHD_METADATA_READ_FAILURE = 0xC03A0010,
+  MD_NTSTATUS_WIN_STATUS_VHD_METADATA_WRITE_FAILURE = 0xC03A0011,
+  MD_NTSTATUS_WIN_STATUS_VHD_INVALID_SIZE = 0xC03A0012,
+  MD_NTSTATUS_WIN_STATUS_VHD_INVALID_FILE_SIZE = 0xC03A0013,
+  MD_NTSTATUS_WIN_STATUS_VIRTDISK_PROVIDER_NOT_FOUND = 0xC03A0014,
+  MD_NTSTATUS_WIN_STATUS_VIRTDISK_NOT_VIRTUAL_DISK = 0xC03A0015,
+  MD_NTSTATUS_WIN_STATUS_VHD_PARENT_VHD_ACCESS_DENIED = 0xC03A0016,
+  MD_NTSTATUS_WIN_STATUS_VHD_CHILD_PARENT_SIZE_MISMATCH = 0xC03A0017,
+  MD_NTSTATUS_WIN_STATUS_VHD_DIFFERENCING_CHAIN_CYCLE_DETECTED = 0xC03A0018,
+  MD_NTSTATUS_WIN_STATUS_VHD_DIFFERENCING_CHAIN_ERROR_IN_PARENT = 0xC03A0019,
+  MD_NTSTATUS_WIN_STATUS_VIRTUAL_DISK_LIMITATION = 0xC03A001A,
+  MD_NTSTATUS_WIN_STATUS_VHD_INVALID_TYPE = 0xC03A001B,
+  MD_NTSTATUS_WIN_STATUS_VHD_INVALID_STATE = 0xC03A001C,
+  MD_NTSTATUS_WIN_STATUS_VIRTDISK_UNSUPPORTED_DISK_SECTOR_SIZE = 0xC03A001D,
+  MD_NTSTATUS_WIN_STATUS_VIRTDISK_DISK_ALREADY_OWNED = 0xC03A001E,
+  MD_NTSTATUS_WIN_STATUS_VIRTDISK_DISK_ONLINE_AND_WRITABLE = 0xC03A001F,
+  MD_NTSTATUS_WIN_STATUS_CTLOG_TRACKING_NOT_INITIALIZED = 0xC03A0020,
+  MD_NTSTATUS_WIN_STATUS_CTLOG_LOGFILE_SIZE_EXCEEDED_MAXSIZE = 0xC03A0021,
+  MD_NTSTATUS_WIN_STATUS_CTLOG_VHD_CHANGED_OFFLINE = 0xC03A0022,
+  MD_NTSTATUS_WIN_STATUS_CTLOG_INVALID_TRACKING_STATE = 0xC03A0023,
+  MD_NTSTATUS_WIN_STATUS_CTLOG_INCONSISTENT_TRACKING_FILE = 0xC03A0024,
+  MD_NTSTATUS_WIN_STATUS_VHD_METADATA_FULL = 0xC03A0028,
+  MD_NTSTATUS_WIN_STATUS_RKF_KEY_NOT_FOUND = 0xC0400001,
+  MD_NTSTATUS_WIN_STATUS_RKF_DUPLICATE_KEY = 0xC0400002,
+  MD_NTSTATUS_WIN_STATUS_RKF_BLOB_FULL = 0xC0400003,
+  MD_NTSTATUS_WIN_STATUS_RKF_STORE_FULL = 0xC0400004,
+  MD_NTSTATUS_WIN_STATUS_RKF_FILE_BLOCKED = 0xC0400005,
+  MD_NTSTATUS_WIN_STATUS_RKF_ACTIVE_KEY = 0xC0400006,
+  MD_NTSTATUS_WIN_STATUS_RDBSS_RESTART_OPERATION = 0xC0410001,
+  MD_NTSTATUS_WIN_STATUS_RDBSS_CONTINUE_OPERATION = 0xC0410002,
+  MD_NTSTATUS_WIN_STATUS_RDBSS_POST_OPERATION = 0xC0410003,
+  MD_NTSTATUS_WIN_STATUS_BTH_ATT_INVALID_HANDLE = 0xC0420001,
+  MD_NTSTATUS_WIN_STATUS_BTH_ATT_READ_NOT_PERMITTED = 0xC0420002,
+  MD_NTSTATUS_WIN_STATUS_BTH_ATT_WRITE_NOT_PERMITTED = 0xC0420003,
+  MD_NTSTATUS_WIN_STATUS_BTH_ATT_INVALID_PDU = 0xC0420004,
+  MD_NTSTATUS_WIN_STATUS_BTH_ATT_INSUFFICIENT_AUTHENTICATION = 0xC0420005,
+  MD_NTSTATUS_WIN_STATUS_BTH_ATT_REQUEST_NOT_SUPPORTED = 0xC0420006,
+  MD_NTSTATUS_WIN_STATUS_BTH_ATT_INVALID_OFFSET = 0xC0420007,
+  MD_NTSTATUS_WIN_STATUS_BTH_ATT_INSUFFICIENT_AUTHORIZATION = 0xC0420008,
+  MD_NTSTATUS_WIN_STATUS_BTH_ATT_PREPARE_QUEUE_FULL = 0xC0420009,
+  MD_NTSTATUS_WIN_STATUS_BTH_ATT_ATTRIBUTE_NOT_FOUND = 0xC042000A,
+  MD_NTSTATUS_WIN_STATUS_BTH_ATT_ATTRIBUTE_NOT_LONG = 0xC042000B,
+  MD_NTSTATUS_WIN_STATUS_BTH_ATT_INSUFFICIENT_ENCRYPTION_KEY_SIZE = 0xC042000C,
+  MD_NTSTATUS_WIN_STATUS_BTH_ATT_INVALID_ATTRIBUTE_VALUE_LENGTH = 0xC042000D,
+  MD_NTSTATUS_WIN_STATUS_BTH_ATT_UNLIKELY = 0xC042000E,
+  MD_NTSTATUS_WIN_STATUS_BTH_ATT_INSUFFICIENT_ENCRYPTION = 0xC042000F,
+  MD_NTSTATUS_WIN_STATUS_BTH_ATT_UNSUPPORTED_GROUP_TYPE = 0xC0420010,
+  MD_NTSTATUS_WIN_STATUS_BTH_ATT_INSUFFICIENT_RESOURCES = 0xC0420011,
+  MD_NTSTATUS_WIN_STATUS_BTH_ATT_UNKNOWN_ERROR = 0xC0421000,
+  MD_NTSTATUS_WIN_STATUS_SECUREBOOT_ROLLBACK_DETECTED = 0xC0430001,
+  MD_NTSTATUS_WIN_STATUS_SECUREBOOT_POLICY_VIOLATION = 0xC0430002,
+  MD_NTSTATUS_WIN_STATUS_SECUREBOOT_INVALID_POLICY = 0xC0430003,
+  MD_NTSTATUS_WIN_STATUS_SECUREBOOT_POLICY_PUBLISHER_NOT_FOUND = 0xC0430004,
+  MD_NTSTATUS_WIN_STATUS_SECUREBOOT_POLICY_NOT_SIGNED = 0xC0430005,
+  MD_NTSTATUS_WIN_STATUS_SECUREBOOT_FILE_REPLACED = 0xC0430007,
+  MD_NTSTATUS_WIN_STATUS_AUDIO_ENGINE_NODE_NOT_FOUND = 0xC0440001,
+  MD_NTSTATUS_WIN_STATUS_HDAUDIO_EMPTY_CONNECTION_LIST = 0xC0440002,
+  MD_NTSTATUS_WIN_STATUS_HDAUDIO_CONNECTION_LIST_NOT_SUPPORTED = 0xC0440003,
+  MD_NTSTATUS_WIN_STATUS_HDAUDIO_NO_LOGICAL_DEVICES_CREATED = 0xC0440004,
+  MD_NTSTATUS_WIN_STATUS_HDAUDIO_NULL_LINKED_LIST_ENTRY = 0xC0440005,
+  MD_NTSTATUS_WIN_STATUS_VOLSNAP_BOOTFILE_NOT_VALID = 0xC0500003,
+  MD_NTSTATUS_WIN_STATUS_IO_PREEMPTED = 0xC0510001,
+  MD_NTSTATUS_WIN_STATUS_SVHDX_ERROR_STORED = 0xC05C0000,
+  MD_NTSTATUS_WIN_STATUS_SVHDX_ERROR_NOT_AVAILABLE = 0xC05CFF00,
+  MD_NTSTATUS_WIN_STATUS_SVHDX_UNIT_ATTENTION_AVAILABLE = 0xC05CFF01,
+  MD_NTSTATUS_WIN_STATUS_SVHDX_UNIT_ATTENTION_CAPACITY_DATA_CHANGED = 0xC05CFF02,
+  MD_NTSTATUS_WIN_STATUS_SVHDX_UNIT_ATTENTION_RESERVATIONS_PREEMPTED = 0xC05CFF03,
+  MD_NTSTATUS_WIN_STATUS_SVHDX_UNIT_ATTENTION_RESERVATIONS_RELEASED = 0xC05CFF04,
+  MD_NTSTATUS_WIN_STATUS_SVHDX_UNIT_ATTENTION_REGISTRATIONS_PREEMPTED = 0xC05CFF05,
+  MD_NTSTATUS_WIN_STATUS_SVHDX_UNIT_ATTENTION_OPERATING_DEFINITION_CHANGED = 0xC05CFF06,
+  MD_NTSTATUS_WIN_STATUS_SVHDX_RESERVATION_CONFLICT = 0xC05CFF07,
+  MD_NTSTATUS_WIN_STATUS_SVHDX_WRONG_FILE_TYPE = 0xC05CFF08,
+  MD_NTSTATUS_WIN_STATUS_SVHDX_VERSION_MISMATCH = 0xC05CFF09,
+  MD_NTSTATUS_WIN_STATUS_VHD_SHARED = 0xC05CFF0A,
+  MD_NTSTATUS_WIN_STATUS_SPACES_RESILIENCY_TYPE_INVALID = 0xC0E70003,
+  MD_NTSTATUS_WIN_STATUS_SPACES_DRIVE_SECTOR_SIZE_INVALID = 0xC0E70004,
+  MD_NTSTATUS_WIN_STATUS_SPACES_INTERLEAVE_LENGTH_INVALID = 0xC0E70009,
+  MD_NTSTATUS_WIN_STATUS_SPACES_NUMBER_OF_COLUMNS_INVALID = 0xC0E7000A,
+  MD_NTSTATUS_WIN_STATUS_SPACES_NOT_ENOUGH_DRIVES = 0xC0E7000B
+} MDNTStatusCodeWin;
+
 // These constants are defined in the MSDN documentation of
 // the EXCEPTION_RECORD structure.
 typedef enum {
@@ -113,4 +2258,12 @@ typedef enum {
   MD_ACCESS_VIOLATION_WIN_EXEC  = 8
 } MDAccessViolationTypeWin;
 
+// These constants are defined in the MSDN documentation of
+// the EXCEPTION_RECORD structure.
+typedef enum {
+  MD_IN_PAGE_ERROR_WIN_READ  = 0,
+  MD_IN_PAGE_ERROR_WIN_WRITE = 1,
+  MD_IN_PAGE_ERROR_WIN_EXEC  = 8
+} MDInPageErrorTypeWin;
+
 #endif  /* GOOGLE_BREAKPAD_COMMON_MINIDUMP_EXCEPTION_WIN32_H__ */
diff --git a/src/MEGASync/google_breakpad/google_breakpad/common/minidump_format.h b/src/MEGASync/google_breakpad/google_breakpad/common/minidump_format.h
index b7ad7bda..7b36d112 100644
--- a/src/MEGASync/google_breakpad/google_breakpad/common/minidump_format.h
+++ b/src/MEGASync/google_breakpad/google_breakpad/common/minidump_format.h
@@ -328,6 +328,10 @@ typedef enum {
   MD_MEMORY_INFO_LIST_STREAM     = 16,  /* MDRawMemoryInfoList */
   MD_THREAD_INFO_LIST_STREAM     = 17,
   MD_HANDLE_OPERATION_LIST_STREAM = 18,
+  MD_TOKEN_STREAM                = 19,
+  MD_JAVASCRIPT_DATA_STREAM      = 20,
+  MD_SYSTEM_MEMORY_INFO_STREAM   = 21,
+  MD_PROCESS_VM_COUNTERS_STREAM  = 22,
   MD_LAST_RESERVED_STREAM        = 0x0000ffff,
 
   /* Breakpad extension types.  0x4767 = "Gg" */
@@ -342,7 +346,11 @@ typedef enum {
   MD_LINUX_ENVIRON               = 0x47670007,  /* /proc/$x/environ   */
   MD_LINUX_AUXV                  = 0x47670008,  /* /proc/$x/auxv      */
   MD_LINUX_MAPS                  = 0x47670009,  /* /proc/$x/maps      */
-  MD_LINUX_DSO_DEBUG             = 0x4767000A   /* MDRawDebug         */
+  MD_LINUX_DSO_DEBUG             = 0x4767000A,  /* MDRawDebug{32,64}  */
+
+  /* Crashpad extension types. 0x4350 = "CP"
+   * See Crashpad's minidump/minidump_extensions.h. */
+  MD_CRASHPAD_INFO_STREAM        = 0x43500001,  /* MDRawCrashpadInfo  */
 } MDStreamType;  /* MINIDUMP_STREAM_TYPE */
 
 
@@ -449,15 +457,26 @@ static const size_t MDCVInfoPDB70_minsize = offsetof(MDCVInfoPDB70,
 
 #define MD_CVINFOPDB70_SIGNATURE 0x53445352  /* cvSignature = 'SDSR' */
 
+/*
+ * Modern ELF toolchains insert a "build id" into the ELF headers that
+ * usually contains a hash of some ELF headers + sections to uniquely
+ * identify a binary.
+ *
+ * https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Developer_Guide/compiling-build-id.html
+ * https://sourceware.org/binutils/docs-2.26/ld/Options.html#index-g_t_002d_002dbuild_002did-292
+ */
 typedef struct {
-  uint32_t data1[2];
-  uint32_t data2;
-  uint32_t data3;
-  uint32_t data4;
-  uint32_t data5[3];
-  uint8_t  extra[2];
+  uint32_t cv_signature;
+  uint8_t  build_id[1];  /* Bytes of build id from GNU_BUILD_ID ELF note.
+                          * This is variable-length, but usually 20 bytes
+                          * as the binutils ld default is a SHA-1 hash. */
 } MDCVInfoELF;
 
+static const size_t MDCVInfoELF_minsize = offsetof(MDCVInfoELF,
+                                                   build_id[0]);
+
+#define MD_CVINFOELF_SIGNATURE 0x4270454c  /* cvSignature = 'BpEL' */
+
 /* In addition to the two CodeView record formats above, used for linking
  * to external pdb files, it is possible for debugging data to be carried
  * directly in the CodeView record itself.  These signature values will
@@ -510,7 +529,7 @@ static const size_t MDRawMemoryList_minsize = offsetof(MDRawMemoryList,
                                                        memory_ranges[0]);
 
 
-#define MD_EXCEPTION_MAXIMUM_PARAMETERS 15
+#define MD_EXCEPTION_MAXIMUM_PARAMETERS 15u
 
 typedef struct {
   uint32_t  exception_code;     /* Windows: MDExceptionCodeWin,
@@ -530,6 +549,7 @@ typedef struct {
   uint64_t  exception_information[MD_EXCEPTION_MAXIMUM_PARAMETERS];
 } MDException;  /* MINIDUMP_EXCEPTION */
 
+#include "minidump_exception_fuchsia.h"
 #include "minidump_exception_linux.h"
 #include "minidump_exception_mac.h"
 #include "minidump_exception_ps3.h"
@@ -635,9 +655,11 @@ typedef enum {
   MD_CPU_ARCHITECTURE_AMD64     =  9,  /* PROCESSOR_ARCHITECTURE_AMD64 */
   MD_CPU_ARCHITECTURE_X86_WIN64 = 10,
       /* PROCESSOR_ARCHITECTURE_IA32_ON_WIN64 (WoW64) */
+  MD_CPU_ARCHITECTURE_ARM64     = 12,  /* PROCESSOR_ARCHITECTURE_ARM64 */
   MD_CPU_ARCHITECTURE_SPARC     = 0x8001, /* Breakpad-defined value for SPARC */
   MD_CPU_ARCHITECTURE_PPC64     = 0x8002, /* Breakpad-defined value for PPC64 */
-  MD_CPU_ARCHITECTURE_ARM64     = 0x8003, /* Breakpad-defined value for ARM64 */
+  MD_CPU_ARCHITECTURE_ARM64_OLD = 0x8003, /* Breakpad-defined value for ARM64 */
+  MD_CPU_ARCHITECTURE_MIPS64    = 0x8004, /* Breakpad-defined value for MIPS64 */
   MD_CPU_ARCHITECTURE_UNKNOWN   = 0xffff  /* PROCESSOR_ARCHITECTURE_UNKNOWN */
 } MDCPUArchitecture;
 
@@ -657,9 +679,24 @@ typedef enum {
   MD_OS_SOLARIS       = 0x8202,  /* Solaris */
   MD_OS_ANDROID       = 0x8203,  /* Android */
   MD_OS_PS3           = 0x8204,  /* PS3 */
-  MD_OS_NACL          = 0x8205   /* Native Client (NaCl) */
+  MD_OS_NACL          = 0x8205,  /* Native Client (NaCl) */
+  MD_OS_FUCHSIA       = 0x8206   /* Fuchsia */
 } MDOSPlatform;
 
+typedef struct {
+  uint64_t base_of_image;
+  uint32_t size_of_image;
+  uint32_t checksum;
+  uint32_t time_date_stamp;
+  MDRVA module_name_rva;
+} MDRawUnloadedModule;
+
+typedef struct {
+  uint32_t size_of_header;
+  uint32_t size_of_entry;
+  uint32_t number_of_entries;
+} MDRawUnloadedModuleList;  /* MINIDUMP_UNLOADED_MODULE_LIST */
+
 typedef struct {
   uint16_t year;
   uint16_t month;
@@ -705,6 +742,41 @@ typedef struct {
 /* MAX_PATH from windef.h */
 #define MD_MAX_PATH 260
 
+/* For MDXStateConfigFeatureMscInfo.features */
+typedef struct {
+  uint32_t offset;
+  uint32_t size;
+} MDXStateFeature;
+
+/* For MDXStateConfigFeatureMscInfo.enabled_features from winnt.h */
+typedef enum {
+  MD_XSTATE_LEGACY_FLOATING_POINT = 0, /* XSTATE_LEGACY_FLOATING_POINT */
+  MD_XSTATE_LEGACY_SSE            = 1, /* XSTATE_LEGACY_SSE */
+  MD_XSTATE_GSSE                  = 2, /* XSTATE_GSSE */
+  MD_XSTATE_AVX                   = MD_XSTATE_GSSE, /* XSTATE_AVX */
+  MD_XSTATE_MPX_BNDREGS           = 3, /* XSTATE_MPX_BNDREGS */
+  MD_XSTATE_MPX_BNDCSR            = 4, /* XSTATE_MPX_BNDCSR */
+  MD_XSTATE_AVX512_KMASK          = 5, /* XSTATE_AVX512_KMASK */
+  MD_XSTATE_AVX512_ZMM_H          = 6, /* XSTATE_AVX512_ZMM_H */
+  MD_XSTATE_AVX512_ZMM            = 7, /* XSTATE_AVX512_ZMM */
+  MD_XSTATE_IPT                   = 8, /* XSTATE_IPT */
+  MD_XSTATE_LWP                   = 62 /* XSTATE_LWP */
+} MDXStateFeatureFlag;
+
+/* MAXIMUM_XSTATE_FEATURES from winnt.h */
+#define MD_MAXIMUM_XSTATE_FEATURES 64
+
+/* For MDRawMiscInfo.xstate_data */
+typedef struct {
+  uint32_t size_of_info;
+  uint32_t context_size;
+  /* An entry in the features array is valid only if the corresponding bit in
+   * the enabled_features flag is set. */
+  uint64_t enabled_features;
+  MDXStateFeature features[MD_MAXIMUM_XSTATE_FEATURES];
+} MDXStateConfigFeatureMscInfo;
+
+
 /* The miscellaneous information stream contains a variety
  * of small pieces of information.  A member is valid if
  * it's within the available size and its corresponding
@@ -724,8 +796,8 @@ typedef struct {
   uint32_t process_kernel_time;  /* seconds of kernel CPU time */
 
   /* The following fields are not present in MINIDUMP_MISC_INFO but are
-   * in MINIDUMP_MISC_INFO_2.  When this struct is populated, these value
-   * may not be set.  Use flags1 or size_of_info to determine whether these
+   * in MINIDUMP_MISC_INFO_2.  When this struct is populated, these values
+   * may not be set.  Use flags1 and size_of_info to determine whether these
    * values are present.  These are only valid when flags1 contains
    * MD_MISCINFO_FLAGS1_PROCESSOR_POWER_INFO. */
   uint32_t processor_max_mhz;
@@ -735,8 +807,8 @@ typedef struct {
   uint32_t processor_current_idle_state;
 
   /* The following fields are not present in MINIDUMP_MISC_INFO_2 but are
-   * in MINIDUMP_MISC_INFO_3.  When this struct is populated, these value
-   * may not be set.  Use flags1 or size_of_info to determine whether these
+   * in MINIDUMP_MISC_INFO_3.  When this struct is populated, these values
+   * may not be set.  Use flags1 and size_of_info to determine whether these
    * values are present. */
    
   /* The following field is only valid if flags1 contains
@@ -757,16 +829,30 @@ typedef struct {
   MDTimeZoneInformation time_zone;
 
   /* The following fields are not present in MINIDUMP_MISC_INFO_3 but are
-   * in MINIDUMP_MISC_INFO_4.  When this struct is populated, these value
-   * may not be set.  Use size_of_info to determine whether these values are 
-   * present. */
+   * in MINIDUMP_MISC_INFO_4.  When this struct is populated, these values
+   * may not be set.  Use flags1 and size_of_info to determine whether these
+   * values are present. */
 
-  /* The following 2 fields are only valid if
-   * size_of_info is >= MD_MISCINFO4_SIZE */
+  /* The following 2 fields are only valid if flags1 contains
+   * MD_MISCINFO_FLAGS1_BUILDSTRING. */
   uint16_t build_string[MD_MAX_PATH];  /* UTF-16-encoded, 0-terminated */
   uint16_t dbg_bld_str[40];            /* UTF-16-encoded, 0-terminated */
-} MDRawMiscInfo;  /* MINIDUMP_MISC_INFO, MINIDUMP_MISC_INFO2,
-                   * MINIDUMP_MISC_INFO3, MINIDUMP_MISC_INFO4 */
+
+  /* The following fields are not present in MINIDUMP_MISC_INFO_4 but are
+   * in MINIDUMP_MISC_INFO_5.  When this struct is populated, these values
+   * may not be set.  Use flags1 and size_of_info to determine whether these
+   * values are present. */
+
+  /* The following field has its own flags for establishing the validity of
+   * the structure's contents.*/
+  MDXStateConfigFeatureMscInfo xstate_data;
+
+  /* The following field is only valid if flags1 contains
+   * MD_MISCINFO_FLAGS1_PROCESS_COOKIE. */
+  uint32_t process_cookie;
+} MDRawMiscInfo;  /* MINIDUMP_MISC_INFO, MINIDUMP_MISC_INFO_2,
+                   * MINIDUMP_MISC_INFO_3, MINIDUMP_MISC_INFO_4,
+                   * MINIDUMP_MISC_INFO_5, MINIDUMP_MISC_INFO_N */
 
 static const size_t MD_MISCINFO_SIZE =
     offsetof(MDRawMiscInfo, processor_max_mhz);
@@ -774,7 +860,14 @@ static const size_t MD_MISCINFO2_SIZE =
     offsetof(MDRawMiscInfo, process_integrity_level);
 static const size_t MD_MISCINFO3_SIZE =
     offsetof(MDRawMiscInfo, build_string[0]);
-static const size_t MD_MISCINFO4_SIZE = sizeof(MDRawMiscInfo);
+static const size_t MD_MISCINFO4_SIZE =
+    offsetof(MDRawMiscInfo, xstate_data);
+/* Version 5 of the MDRawMiscInfo structure is not a multiple of 8 in size and
+ * yet it contains some 8-bytes sized fields. This causes many compilers to
+ * round the structure size up to a multiple of 8 by adding padding at the end.
+ * The following hack is thus required for matching the proper on-disk size. */
+static const size_t MD_MISCINFO5_SIZE =
+    offsetof(MDRawMiscInfo, process_cookie) + sizeof(uint32_t);
 
 /* For (MDRawMiscInfo).flags1.  These values indicate which fields in the
  * MDRawMiscInfoStructure are valid. */
@@ -793,6 +886,10 @@ typedef enum {
       /* MINIDUMP_MISC3_TIMEZONE */
   MD_MISCINFO_FLAGS1_PROTECTED_PROCESS     = 0x00000080,
       /* MINIDUMP_MISC3_PROTECTED_PROCESS */
+  MD_MISCINFO_FLAGS1_BUILDSTRING           = 0x00000100,
+      /* MINIDUMP_MISC4_BUILDSTRING */
+  MD_MISCINFO_FLAGS1_PROCESS_COOKIE        = 0x00000200,
+      /* MINIDUMP_MISC5_PROCESS_COOKIE */
 } MDMiscInfoFlags1;
 
 /*
@@ -927,21 +1024,75 @@ typedef enum {
 } MDAssertionInfoData;
 
 /* These structs are used to store the DSO debug data in Linux minidumps,
- * which is necessary for converting minidumps to usable coredumps. */
+ * which is necessary for converting minidumps to usable coredumps.
+ * Because of a historical accident, several fields are variably encoded
+ * according to client word size, so tools potentially need to support both. */
+
 typedef struct {
-  void*     addr;
+  uint32_t  addr;
   MDRVA     name;
-  void*     ld;
-} MDRawLinkMap;
+  uint32_t  ld;
+} MDRawLinkMap32;
 
 typedef struct {
   uint32_t  version;
-  MDRVA     map;
+  MDRVA     map;  /* array of MDRawLinkMap32 */
   uint32_t  dso_count;
-  void*     brk;
-  void*     ldbase;
-  void*     dynamic;
-} MDRawDebug;
+  uint32_t  brk;
+  uint32_t  ldbase;
+  uint32_t  dynamic;
+} MDRawDebug32;
+
+typedef struct {
+  uint64_t  addr;
+  MDRVA     name;
+  uint64_t  ld;
+} MDRawLinkMap64;
+
+typedef struct {
+  uint32_t  version;
+  MDRVA     map;  /* array of MDRawLinkMap64 */
+  uint32_t  dso_count;
+  uint64_t  brk;
+  uint64_t  ldbase;
+  uint64_t  dynamic;
+} MDRawDebug64;
+
+/* Crashpad extension types. See Crashpad's minidump/minidump_extensions.h. */
+
+typedef struct {
+  MDRVA key;
+  MDRVA value;
+} MDRawSimpleStringDictionaryEntry;
+
+typedef struct {
+  uint32_t count;
+  MDRawSimpleStringDictionaryEntry entries[0];
+} MDRawSimpleStringDictionary;
+
+typedef struct {
+  uint32_t version;
+  MDLocationDescriptor list_annotations;
+  MDLocationDescriptor simple_annotations;  /* MDRawSimpleStringDictionary */
+} MDRawModuleCrashpadInfo;
+
+typedef struct {
+  uint32_t minidump_module_list_index;
+  MDLocationDescriptor location;  /* MDRawModuleCrashpadInfo */
+} MDRawModuleCrashpadInfoLink;
+
+typedef struct {
+  uint32_t count;
+  MDLocationDescriptor modules[0];  /* MDRawModuleCrashpadInfoLink */
+} MDRawModuleCrashpadInfoList;
+
+typedef struct {
+  uint32_t version;
+  MDGUID report_id;
+  MDGUID client_id;
+  MDLocationDescriptor simple_annotations;  /* MDRawSimpleStringDictionary */
+  MDLocationDescriptor module_list;  /* MDRawModuleCrashpadInfoList */
+} MDRawCrashpadInfo;
 
 #if defined(_MSC_VER)
 #pragma warning(pop)
diff --git a/src/MEGASync/google_breakpad/google_breakpad/common/minidump_size.h b/src/MEGASync/google_breakpad/google_breakpad/common/minidump_size.h
index 918544b6..fae57923 100644
--- a/src/MEGASync/google_breakpad/google_breakpad/common/minidump_size.h
+++ b/src/MEGASync/google_breakpad/google_breakpad/common/minidump_size.h
@@ -75,6 +75,12 @@ class minidump_size<MDCVInfoPDB70> {
   static size_t size() { return MDCVInfoPDB70_minsize; }
 };
 
+template<>
+class minidump_size<MDCVInfoELF> {
+ public:
+  static size_t size() { return MDCVInfoELF_minsize; }
+};
+
 template<>
 class minidump_size<MDImageDebugMisc> {
  public:
diff --git a/src/MEGASync/google_breakpad/google_breakpad/processor/basic_source_line_resolver.h b/src/MEGASync/google_breakpad/google_breakpad/processor/basic_source_line_resolver.h
index 6bb6d863..1c7bf465 100644
--- a/src/MEGASync/google_breakpad/google_breakpad/processor/basic_source_line_resolver.h
+++ b/src/MEGASync/google_breakpad/google_breakpad/processor/basic_source_line_resolver.h
@@ -90,21 +90,23 @@ class SymbolParseHelper {
   // can't be const.  On success, <id>, and <filename> are stored in |*index|,
   // and |*filename|.  No allocation is done, |*filename| simply points inside
   // |file_line|.
-  static bool ParseFile(char *file_line,   // in
-                        long *index,       // out
-                        char **filename);  // out
+  static bool ParseFile(char* file_line,   // in
+                        long* index,       // out
+                        char** filename);  // out
 
   // Parses a |function_line| declaration.  Returns true on success.
-  // Format:  FUNC <address> <size> <stack_param_size> <name>.
+  // Format:  FUNC [<multiple>] <address> <size> <stack_param_size> <name>.
   // Notice, that this method modifies the input |function_line| which is why it
-  // can't be const.  On success, <address>, <size>, <stack_param_size>, and
-  // <name> are stored in |*address|, |*size|, |*stack_param_size|, and |*name|.
-  // No allocation is done, |*name| simply points inside |function_line|.
-  static bool ParseFunction(char *function_line,     // in
-                            uint64_t *address,       // out
-                            uint64_t *size,          // out
-                            long *stack_param_size,  // out
-                            char **name);            // out
+  // can't be const.  On success, the presence of <multiple>, <address>, <size>,
+  // <stack_param_size>, and <name> are stored in |*is_multiple|, |*address|,
+  // |*size|, |*stack_param_size|, and |*name|.  No allocation is done, |*name|
+  // simply points inside |function_line|.
+  static bool ParseFunction(char* function_line,     // in
+                            bool* is_multiple,       // out
+                            uint64_t* address,       // out
+                            uint64_t* size,          // out
+                            long* stack_param_size,  // out
+                            char** name);            // out
 
   // Parses a |line| declaration.  Returns true on success.
   // Format:  <address> <size> <line number> <source file id>
@@ -112,26 +114,28 @@ class SymbolParseHelper {
   // it can't be const.  On success, <address>, <size>, <line number>, and
   // <source file id> are stored in |*address|, |*size|, |*line_number|, and
   // |*source_file|.
-  static bool ParseLine(char *line_line,     // in
-                        uint64_t *address,   // out
-                        uint64_t *size,      // out
-                        long *line_number,   // out
-                        long *source_file);  // out
+  static bool ParseLine(char* line_line,     // in
+                        uint64_t* address,   // out
+                        uint64_t* size,      // out
+                        long* line_number,   // out
+                        long* source_file);  // out
 
   // Parses a |public_line| declaration.  Returns true on success.
-  // Format:  PUBLIC <address> <stack_param_size> <name>
+  // Format:  PUBLIC [<multiple>] <address> <stack_param_size> <name>
   // Notice, that this method modifies the input |function_line| which is why
-  // it can't be const.  On success, <address>, <stack_param_size>, <name>
-  // are stored in |*address|, |*stack_param_size|, and |*name|.
-  // No allocation is done, |*name| simply points inside |public_line|.
-  static bool ParsePublicSymbol(char *public_line,       // in
-                                uint64_t *address,       // out
-                                long *stack_param_size,  // out
-                                char **name);            // out
+  // it can't be const.  On success, the presence of <multiple>, <address>,
+  // <stack_param_size>, <name> are stored in |*is_multiple|, |*address|,
+  // |*stack_param_size|, and |*name|.  No allocation is done, |*name| simply
+  // points inside |public_line|.
+  static bool ParsePublicSymbol(char* public_line,       // in
+                                bool* is_multiple,       // out
+                                uint64_t* address,       // out
+                                long* stack_param_size,  // out
+                                char** name);            // out
 
  private:
   // Used for success checks after strtoull and strtol.
-  static bool IsValidAfterNumber(char *after_number);
+  static bool IsValidAfterNumber(char* after_number);
 
   // Only allow static methods.
   SymbolParseHelper();
diff --git a/src/MEGASync/google_breakpad/google_breakpad/processor/call_stack.h b/src/MEGASync/google_breakpad/google_breakpad/processor/call_stack.h
index 21f595e7..c5914231 100644
--- a/src/MEGASync/google_breakpad/google_breakpad/processor/call_stack.h
+++ b/src/MEGASync/google_breakpad/google_breakpad/processor/call_stack.h
@@ -45,6 +45,7 @@
 #ifndef GOOGLE_BREAKPAD_PROCESSOR_CALL_STACK_H__
 #define GOOGLE_BREAKPAD_PROCESSOR_CALL_STACK_H__
 
+#include <cstdint>
 #include <vector>
 
 namespace google_breakpad {
@@ -61,15 +62,24 @@ class CallStack {
 
   // Resets the CallStack to its initial empty state
   void Clear();
-  
+
   const vector<StackFrame*>* frames() const { return &frames_; }
 
+  // Set the TID associated with this call stack.
+  void set_tid(uint32_t tid) { tid_ = tid; }
+
+  uint32_t tid() const { return tid_; }
+
  private:
   // Stackwalker is responsible for building the frames_ vector.
   friend class Stackwalker;
 
   // Storage for pushed frames.
   vector<StackFrame*> frames_;
+
+  // The TID associated with this call stack. Default to 0 if it's not
+  // available.
+  uint32_t tid_;
 };
 
 }  // namespace google_breakpad
diff --git a/src/MEGASync/google_breakpad/google_breakpad/processor/code_module.h b/src/MEGASync/google_breakpad/google_breakpad/processor/code_module.h
index 4e892824..29b8d9c9 100644
--- a/src/MEGASync/google_breakpad/google_breakpad/processor/code_module.h
+++ b/src/MEGASync/google_breakpad/google_breakpad/processor/code_module.h
@@ -86,7 +86,17 @@ class CodeModule {
   // ownership of.  The new CodeModule may be of a different concrete class
   // than the CodeModule being copied, but will behave identically to the
   // copied CodeModule as far as the CodeModule interface is concerned.
-  virtual const CodeModule* Copy() const = 0;
+  virtual CodeModule* Copy() const = 0;
+
+  // Getter and setter for shrink_down_delta.  This is used when the address
+  // range for a module is shrunk down due to address range conflicts with
+  // other modules.  The base_address and size fields are not updated and they
+  // should always reflect the original values (reported in the minidump).
+  virtual uint64_t shrink_down_delta() const = 0;
+  virtual void SetShrinkDownDelta(uint64_t shrink_down_delta) = 0;
+
+  // Whether the module was unloaded from memory.
+  virtual bool is_unloaded() const = 0;
 };
 
 }  // namespace google_breakpad
diff --git a/src/MEGASync/google_breakpad/google_breakpad/processor/code_modules.h b/src/MEGASync/google_breakpad/google_breakpad/processor/code_modules.h
index a38579af..74f113c1 100644
--- a/src/MEGASync/google_breakpad/google_breakpad/processor/code_modules.h
+++ b/src/MEGASync/google_breakpad/google_breakpad/processor/code_modules.h
@@ -35,7 +35,12 @@
 #ifndef GOOGLE_BREAKPAD_PROCESSOR_CODE_MODULES_H__
 #define GOOGLE_BREAKPAD_PROCESSOR_CODE_MODULES_H__
 
+#include <stddef.h>
+
+#include <vector>
+
 #include "google_breakpad/common/breakpad_types.h"
+#include "processor/linked_ptr.h"
 
 namespace google_breakpad {
 
@@ -91,6 +96,11 @@ class CodeModules {
   // returns objects in may differ between a copy and the original CodeModules
   // object.
   virtual const CodeModules* Copy() const = 0;
+
+  // Returns a vector of all modules which address ranges needed to be shrunk
+  // down due to address range conflicts with other modules.
+  virtual std::vector<linked_ptr<const CodeModule> >
+  GetShrunkRangeModules() const = 0;
 };
 
 }  // namespace google_breakpad
diff --git a/src/MEGASync/google_breakpad/google_breakpad/processor/dump_context.h b/src/MEGASync/google_breakpad/google_breakpad/processor/dump_context.h
new file mode 100644
index 00000000..df80bf7e
--- /dev/null
+++ b/src/MEGASync/google_breakpad/google_breakpad/processor/dump_context.h
@@ -0,0 +1,116 @@
+// Copyright (c) 2014 Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// dump_context.h: A (mini/micro) dump CPU-specific context.
+
+#ifndef GOOGLE_BREAKPAD_PROCESSOR_DUMP_CONTEXT_H__
+#define GOOGLE_BREAKPAD_PROCESSOR_DUMP_CONTEXT_H__
+
+#include "google_breakpad/common/minidump_format.h"
+#include "google_breakpad/processor/dump_object.h"
+
+namespace google_breakpad {
+
+// DumpContext carries a CPU-specific MDRawContext structure, which contains CPU
+// context such as register states.
+class DumpContext : public DumpObject {
+ public:
+  virtual ~DumpContext();
+
+  // Returns an MD_CONTEXT_* value such as MD_CONTEXT_X86 or MD_CONTEXT_PPC
+  // identifying the CPU type that the context was collected from.  The
+  // returned value will identify the CPU only, and will have any other
+  // MD_CONTEXT_* bits masked out.  Returns 0 on failure.
+  uint32_t GetContextCPU() const;
+
+  // Return the raw value of |context_flags_|
+  uint32_t GetContextFlags() const;
+
+  // Returns raw CPU-specific context data for the named CPU type.  If the
+  // context data does not match the CPU type or does not exist, returns NULL.
+  const MDRawContextAMD64* GetContextAMD64() const;
+  const MDRawContextARM*   GetContextARM() const;
+  const MDRawContextARM64* GetContextARM64() const;
+  const MDRawContextMIPS*  GetContextMIPS() const;
+  const MDRawContextPPC*   GetContextPPC() const;
+  const MDRawContextPPC64* GetContextPPC64() const;
+  const MDRawContextSPARC* GetContextSPARC() const;
+  const MDRawContextX86*   GetContextX86() const;
+
+  // A convenience method to get the instruction pointer out of the
+  // MDRawContext, since it varies per-CPU architecture.
+  bool GetInstructionPointer(uint64_t* ip) const;
+
+  // Similar to the GetInstructionPointer method, this method gets the stack
+  // pointer for all CPU architectures.
+  bool GetStackPointer(uint64_t* sp) const;
+
+  // Print a human-readable representation of the object to stdout.
+  void Print();
+
+ protected:
+  DumpContext();
+
+  // Sets row CPU-specific context data for the names CPU type.
+  void SetContextFlags(uint32_t context_flags);
+  void SetContextX86(MDRawContextX86* x86);
+  void SetContextPPC(MDRawContextPPC* ppc);
+  void SetContextPPC64(MDRawContextPPC64* ppc64);
+  void SetContextAMD64(MDRawContextAMD64* amd64);
+  void SetContextSPARC(MDRawContextSPARC* ctx_sparc);
+  void SetContextARM(MDRawContextARM* arm);
+  void SetContextARM64(MDRawContextARM64* arm64);
+  void SetContextMIPS(MDRawContextMIPS* ctx_mips);
+
+  // Free the CPU-specific context structure.
+  void FreeContext();
+
+ private:
+  // The CPU-specific context structure.
+  union {
+    MDRawContextBase*  base;
+    MDRawContextX86*   x86;
+    MDRawContextPPC*   ppc;
+    MDRawContextPPC64* ppc64;
+    MDRawContextAMD64* amd64;
+    // on Solaris SPARC, sparc is defined as a numeric constant,
+    // so variables can NOT be named as sparc
+    MDRawContextSPARC* ctx_sparc;
+    MDRawContextARM*   arm;
+    MDRawContextARM64* arm64;
+    MDRawContextMIPS*  ctx_mips;
+  } context_;
+
+  // Store this separately because of the weirdo AMD64 context
+  uint32_t context_flags_;
+};
+
+}  // namespace google_breakpad
+
+#endif  // GOOGLE_BREAKPAD_PROCESSOR_DUMP_CONTEXT_H__
diff --git a/src/MEGASync/google_breakpad/google_breakpad/processor/dump_object.h b/src/MEGASync/google_breakpad/google_breakpad/processor/dump_object.h
new file mode 100644
index 00000000..112f687f
--- /dev/null
+++ b/src/MEGASync/google_breakpad/google_breakpad/processor/dump_object.h
@@ -0,0 +1,53 @@
+// Copyright (c) 2014 Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// dump_object.h: A base class for all mini/micro dump object.
+
+#ifndef GOOGLE_BREAKPAD_PROCESSOR_DUMP_OBJECT_H__
+#define GOOGLE_BREAKPAD_PROCESSOR_DUMP_OBJECT_H__
+
+namespace google_breakpad {
+
+// DumpObject is the base of various mini/micro dump's objects.
+class DumpObject {
+ public:
+  DumpObject();
+
+  bool valid() const { return valid_; }
+
+ protected:
+  // DumpObjects are not valid when created.  When a subclass populates its own
+  // fields, it can set valid_ to true.  Accessors and mutators may wish to
+  // consider or alter the valid_ state as they interact with objects.
+  bool valid_;
+};
+
+}  // namespace google_breakpad
+
+#endif  // GOOGLE_BREAKPAD_PROCESSOR_DUMP_OBJECT_H__
diff --git a/src/MEGASync/google_breakpad/google_breakpad/processor/exception_record.h b/src/MEGASync/google_breakpad/google_breakpad/processor/exception_record.h
new file mode 100644
index 00000000..eac6c90a
--- /dev/null
+++ b/src/MEGASync/google_breakpad/google_breakpad/processor/exception_record.h
@@ -0,0 +1,124 @@
+// Copyright (c) 2019 Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// exception_record.h: A snapshot of an exception record.
+//
+// Author: Ivan Penkov
+
+#ifndef THIRD_PARTY_BREAKPAD_SRC_GOOGLE_BREAKPAD_PROCESSOR_EXCEPTION_RECORD_H_
+#define THIRD_PARTY_BREAKPAD_SRC_GOOGLE_BREAKPAD_PROCESSOR_EXCEPTION_RECORD_H_
+
+#include <vector>
+
+namespace google_breakpad {
+
+// Additional argument that describes the exception.
+class ExceptionParameter {
+ public:
+  ExceptionParameter(uint64_t value, const string& description)
+      : value_(value), description_(description) {}
+  // Accessors. See the data declarations below.
+  uint64_t value() const { return value_; }
+  void set_value(uint64_t value) { value_ = value; }
+  const string& description() const { return description_; }
+  void set_description(const string& description) {
+    description_ = description;
+  }
+
+ private:
+  // Parameter value.
+  uint64_t value_;
+  // Human readable description/interpretation of the above value.
+  string description_;
+};
+
+// A snapshot of an exception record. Contains exception record details: code,
+// flags, address, parameters.
+class ExceptionRecord {
+ public:
+  // Accessors. See the data declarations below.
+  uint32_t code() const { return code_; }
+  const string& code_description() const { return code_description_; }
+  void set_code(uint32_t code, const string& description) {
+    code_ = code;
+    code_description_ = description;
+  }
+
+  uint32_t flags() const { return flags_; }
+  const string& flags_description() const { return flags_description_; }
+  void set_flags(uint32_t flags, const string& description) {
+    flags_ = flags;
+    flags_description_ = description;
+  }
+
+  uint64_t nested_exception_record_address() const {
+    return nested_exception_record_address_;
+  }
+  void set_nested_exception_record_address(
+      uint64_t nested_exception_record_address) {
+    nested_exception_record_address_ = nested_exception_record_address;
+  }
+
+  uint64_t address() const { return address_; }
+  void set_address(uint64_t address) { address_ = address; }
+
+  const std::vector<ExceptionParameter>* parameters() const {
+    return &parameters_;
+  }
+  void add_parameter(uint64_t value, const string& description) {
+    parameters_.push_back(ExceptionParameter(value, description));
+  }
+
+ private:
+  // Exception code.
+  uint32_t code_;
+  string code_description_;
+
+  // Exception flags.
+  uint32_t flags_;
+  string flags_description_;
+
+  // The address of an associated MDException structure. Exception records can
+  // be chained together to provide additional information when nested
+  // exceptions occur.
+  uint64_t nested_exception_record_address_;
+
+  // The memory address that caused the exception.  For data access errors,
+  // this will be the data address that caused the fault.  For code errors,
+  // this will be the address of the instruction that caused the fault.
+  uint64_t address_;
+
+  // An array of additional arguments that describe the exception.
+  std::vector<ExceptionParameter> parameters_;
+};
+
+}  // namespace google_breakpad
+
+
+#endif  // THIRD_PARTY_BREAKPAD_SRC_GOOGLE_BREAKPAD_PROCESSOR_EXCEPTION_RECORD_H_
diff --git a/src/MEGASync/google_breakpad/google_breakpad/processor/exploitability.h b/src/MEGASync/google_breakpad/google_breakpad/processor/exploitability.h
index 67255a3a..014413c9 100644
--- a/src/MEGASync/google_breakpad/google_breakpad/processor/exploitability.h
+++ b/src/MEGASync/google_breakpad/google_breakpad/processor/exploitability.h
@@ -53,6 +53,15 @@ class Exploitability {
   static Exploitability *ExploitabilityForPlatform(Minidump *dump,
                                                    ProcessState *process_state);
 
+  // The boolean parameter signals whether the exploitability engine is
+  // enabled to call out to objdump for disassembly. This is disabled by
+  // default. It is used to check the identity of the instruction that
+  // caused the program to crash. This should not be enabled if there are
+  // portability concerns.
+  static Exploitability *ExploitabilityForPlatform(Minidump *dump,
+                                                   ProcessState *process_state,
+                                                   bool enable_objdump);
+
   ExploitabilityRating CheckExploitability();
   bool AddressIsAscii(uint64_t);
 
diff --git a/src/MEGASync/google_breakpad/google_breakpad/processor/memory_region.h b/src/MEGASync/google_breakpad/google_breakpad/processor/memory_region.h
index bd9755f5..30f88df4 100644
--- a/src/MEGASync/google_breakpad/google_breakpad/processor/memory_region.h
+++ b/src/MEGASync/google_breakpad/google_breakpad/processor/memory_region.h
@@ -67,6 +67,9 @@ class MemoryRegion {
   virtual bool GetMemoryAtAddress(uint64_t address, uint16_t* value) const = 0;
   virtual bool GetMemoryAtAddress(uint64_t address, uint32_t* value) const = 0;
   virtual bool GetMemoryAtAddress(uint64_t address, uint64_t* value) const = 0;
+
+  // Print a human-readable representation of the object to stdout.
+  virtual void Print() const = 0;
 };
 
 
diff --git a/src/MEGASync/google_breakpad/google_breakpad/processor/microdump.h b/src/MEGASync/google_breakpad/google_breakpad/processor/microdump.h
new file mode 100644
index 00000000..02ebdcd7
--- /dev/null
+++ b/src/MEGASync/google_breakpad/google_breakpad/processor/microdump.h
@@ -0,0 +1,135 @@
+// Copyright (c) 2014 Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// microdump.h: A microdump reader.  Microdump is a minified variant of a
+// minidump (see minidump.h for documentation) which contains the minimum
+// amount of information required to get a stack trace for the crashing thread.
+// The information contained in a microdump is:
+// - the crashing thread stack
+// - system information (os type / version)
+// - cpu context (state of the registers)
+// - list of mmaps
+
+#ifndef GOOGLE_BREAKPAD_PROCESSOR_MICRODUMP_H__
+#define GOOGLE_BREAKPAD_PROCESSOR_MICRODUMP_H__
+
+#include <string>
+#include <vector>
+
+#include "common/scoped_ptr.h"
+#include "common/using_std_string.h"
+#include "google_breakpad/processor/dump_context.h"
+#include "google_breakpad/processor/memory_region.h"
+#include "google_breakpad/processor/system_info.h"
+#include "processor/basic_code_modules.h"
+
+namespace google_breakpad {
+
+// MicrodumpModuleList contains all of the loaded code modules for a process
+// in the form of MicrodumpModules.  It maintains a vector of these modules
+// and provides access to a code module corresponding to a specific address.
+class MicrodumpModules : public BasicCodeModules {
+ public:
+  // Takes over ownership of |module|.
+  void Add(const CodeModule* module);
+
+  // Enables/disables module address range shrink.
+  void SetEnableModuleShrink(bool is_enabled);
+};
+
+// MicrodumpContext carries a CPU-specific context.
+// See dump_context.h for documentation.
+class MicrodumpContext : public DumpContext {
+ public:
+  virtual void SetContextARM(MDRawContextARM* arm);
+  virtual void SetContextARM64(MDRawContextARM64* arm64);
+  virtual void SetContextX86(MDRawContextX86* x86);
+  virtual void SetContextMIPS(MDRawContextMIPS* mips32);
+  virtual void SetContextMIPS64(MDRawContextMIPS* mips64);
+};
+
+// This class provides access to microdump memory regions.
+// See memory_region.h for documentation.
+class MicrodumpMemoryRegion : public MemoryRegion {
+ public:
+  MicrodumpMemoryRegion();
+  virtual ~MicrodumpMemoryRegion() {}
+
+  // Set this region's address and contents. If we have placed an
+  // instance of this class in a test fixture class, individual tests
+  // can use this to provide the region's contents.
+  void Init(uint64_t base_address, const std::vector<uint8_t>& contents);
+
+  virtual uint64_t GetBase() const;
+  virtual uint32_t GetSize() const;
+
+  virtual bool GetMemoryAtAddress(uint64_t address, uint8_t* value) const;
+  virtual bool GetMemoryAtAddress(uint64_t address, uint16_t* value) const;
+  virtual bool GetMemoryAtAddress(uint64_t address, uint32_t* value) const;
+  virtual bool GetMemoryAtAddress(uint64_t address, uint64_t* value) const;
+
+  // Print a human-readable representation of the object to stdout.
+  virtual void Print() const;
+
+ private:
+  // Fetch a little-endian value from ADDRESS in contents_ whose size
+  // is BYTES, and store it in *VALUE.  Returns true on success.
+  template<typename ValueType>
+  bool GetMemoryLittleEndian(uint64_t address, ValueType* value) const;
+
+  uint64_t base_address_;
+  std::vector<uint8_t> contents_;
+};
+
+// Microdump is the user's interface to a microdump file.  It provides access to
+// the microdump's context, memory regions and modules.
+class Microdump {
+ public:
+  explicit Microdump(const string& contents);
+  virtual ~Microdump() {}
+
+  DumpContext* GetContext() { return context_.get(); }
+  MicrodumpMemoryRegion* GetMemory() { return stack_region_.get(); }
+  MicrodumpModules* GetModules() { return modules_.get(); }
+  SystemInfo* GetSystemInfo() { return system_info_.get(); }
+
+  string GetCrashReason() { return crash_reason_; }
+  uint64_t GetCrashAddress() { return crash_address_; }
+ private:
+  scoped_ptr<MicrodumpContext> context_;
+  scoped_ptr<MicrodumpMemoryRegion> stack_region_;
+  scoped_ptr<MicrodumpModules> modules_;
+  scoped_ptr<SystemInfo> system_info_;
+  string crash_reason_;
+  uint64_t crash_address_;
+};
+
+}  // namespace google_breakpad
+
+#endif  // GOOGLE_BREAKPAD_PROCESSOR_MICRODUMP_H__
diff --git a/src/MEGASync/google_breakpad/google_breakpad/processor/microdump_processor.h b/src/MEGASync/google_breakpad/google_breakpad/processor/microdump_processor.h
new file mode 100644
index 00000000..60d14a54
--- /dev/null
+++ b/src/MEGASync/google_breakpad/google_breakpad/processor/microdump_processor.h
@@ -0,0 +1,64 @@
+// Copyright (c) 2014, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// The processor for microdump (a reduced dump containing only the state of the
+// crashing thread). See crbug.com/410294 for more info and design docs.
+
+#ifndef GOOGLE_BREAKPAD_PROCESSOR_MICRODUMP_PROCESSOR_H__
+#define GOOGLE_BREAKPAD_PROCESSOR_MICRODUMP_PROCESSOR_H__
+
+#include <string>
+
+#include "common/using_std_string.h"
+#include "google_breakpad/processor/process_result.h"
+
+namespace google_breakpad {
+
+class Microdump;
+class ProcessState;
+class StackFrameSymbolizer;
+
+class MicrodumpProcessor {
+ public:
+  // Initializes the MicrodumpProcessor with a stack frame symbolizer.
+  // Does not take ownership of frame_symbolizer, which must NOT be NULL.
+  explicit MicrodumpProcessor(StackFrameSymbolizer* frame_symbolizer);
+
+  virtual ~MicrodumpProcessor();
+
+  // Processes the microdump contents and fills process_state with the result.
+  google_breakpad::ProcessResult Process(Microdump* microdump,
+                                         ProcessState* process_state);
+ private:
+  StackFrameSymbolizer* frame_symbolizer_;
+};
+
+}  // namespace google_breakpad
+
+#endif  // GOOGLE_BREAKPAD_PROCESSOR_MICRODUMP_PROCESSOR_H__
diff --git a/src/MEGASync/google_breakpad/google_breakpad/processor/minidump.h b/src/MEGASync/google_breakpad/google_breakpad/processor/minidump.h
index 3eaabfe0..1c40a821 100644
--- a/src/MEGASync/google_breakpad/google_breakpad/processor/minidump.h
+++ b/src/MEGASync/google_breakpad/google_breakpad/processor/minidump.h
@@ -79,6 +79,8 @@
 #ifndef GOOGLE_BREAKPAD_PROCESSOR_MINIDUMP_H__
 #define GOOGLE_BREAKPAD_PROCESSOR_MINIDUMP_H__
 
+#include <stdint.h>
+
 #ifndef _WIN32
 #include <unistd.h>
 #endif
@@ -88,11 +90,14 @@
 #include <string>
 #include <vector>
 
+#include "common/basictypes.h"
 #include "common/using_std_string.h"
-#include "google_breakpad/common/minidump_format.h"
 #include "google_breakpad/processor/code_module.h"
 #include "google_breakpad/processor/code_modules.h"
+#include "google_breakpad/processor/dump_context.h"
+#include "google_breakpad/processor/dump_object.h"
 #include "google_breakpad/processor/memory_region.h"
+#include "google_breakpad/processor/proc_maps_linux.h"
 
 
 namespace google_breakpad {
@@ -108,12 +113,10 @@ template<typename AddressType, typename EntryType> class RangeMap;
 
 // MinidumpObject is the base of all Minidump* objects except for Minidump
 // itself.
-class MinidumpObject {
+class MinidumpObject : public DumpObject {
  public:
   virtual ~MinidumpObject() {}
 
-  bool valid() const { return valid_; }
-
  protected:
   explicit MinidumpObject(Minidump* minidump);
 
@@ -124,21 +127,14 @@ class MinidumpObject {
   // for access to data about the minidump file itself, such as whether
   // it should be byte-swapped.
   Minidump* minidump_;
-
-  // MinidumpObjects are not valid when created.  When a subclass populates
-  // its own fields, it can set valid_ to true.  Accessors and mutators may
-  // wish to consider or alter the valid_ state as they interact with
-  // objects.
-  bool      valid_;
 };
 
 
 // This class exists primarily to provide a virtual destructor in a base
 // class common to all objects that might be stored in
-// Minidump::mStreamObjects.  Some object types (MinidumpContext) will
-// never be stored in Minidump::mStreamObjects, but are represented as
-// streams and adhere to the same interface, and may be derived from
-// this class.
+// Minidump::mStreamObjects.  Some object types will never be stored in
+// Minidump::mStreamObjects, but are represented as streams and adhere to the
+// same interface, and may be derived from this class.
 class MinidumpStream : public MinidumpObject {
  public:
   virtual ~MinidumpStream() {}
@@ -155,6 +151,8 @@ class MinidumpStream : public MinidumpObject {
   // that implements MinidumpStream can compare expected_size to a
   // known size as an integrity check.
   virtual bool Read(uint32_t expected_size) = 0;
+
+  DISALLOW_COPY_AND_ASSIGN(MinidumpStream);
 };
 
 
@@ -168,71 +166,35 @@ class MinidumpStream : public MinidumpObject {
 // context for the exception handler (which performs minidump generation),
 // and not the context that caused the exception (which is probably what the
 // user wants).
-class MinidumpContext : public MinidumpStream {
+class MinidumpContext : public DumpContext {
  public:
   virtual ~MinidumpContext();
 
-  // Returns an MD_CONTEXT_* value such as MD_CONTEXT_X86 or MD_CONTEXT_PPC
-  // identifying the CPU type that the context was collected from.  The
-  // returned value will identify the CPU only, and will have any other
-  // MD_CONTEXT_* bits masked out.  Returns 0 on failure.
-  uint32_t GetContextCPU() const;
-
-  // A convenience method to get the instruction pointer out of the
-  // MDRawContext, since it varies per-CPU architecture.
-  bool GetInstructionPointer(uint64_t* ip) const;
-
-  // Returns raw CPU-specific context data for the named CPU type.  If the
-  // context data does not match the CPU type or does not exist, returns
-  // NULL.
-  const MDRawContextAMD64* GetContextAMD64() const;
-  const MDRawContextARM*   GetContextARM() const;
-  const MDRawContextARM64* GetContextARM64() const;
-  const MDRawContextMIPS*  GetContextMIPS() const;
-  const MDRawContextPPC*   GetContextPPC() const;
-  const MDRawContextPPC64* GetContextPPC64() const;
-  const MDRawContextSPARC* GetContextSPARC() const;
-  const MDRawContextX86*   GetContextX86() const;
-
-  // Print a human-readable representation of the object to stdout.
-  void Print();
-
  protected:
   explicit MinidumpContext(Minidump* minidump);
 
-  // The CPU-specific context structure.
-  union {
-    MDRawContextBase*  base;
-    MDRawContextX86*   x86;
-    MDRawContextPPC*   ppc;
-    MDRawContextPPC64* ppc64;
-    MDRawContextAMD64* amd64;
-    // on Solaris SPARC, sparc is defined as a numeric constant,
-    // so variables can NOT be named as sparc
-    MDRawContextSPARC* ctx_sparc;
-    MDRawContextARM*   arm;
-    MDRawContextARM64* arm64;
-    MDRawContextMIPS*  ctx_mips;
-  } context_;
-
-  // Store this separately because of the weirdo AMD64 context
-  uint32_t context_flags_;
-
  private:
   friend class MinidumpThread;
   friend class MinidumpException;
 
   bool Read(uint32_t expected_size);
 
-  // Free the CPU-specific context structure.
-  void FreeContext();
-
   // If the minidump contains a SYSTEM_INFO_STREAM, makes sure that the
   // system info stream gives an appropriate CPU type matching the context
   // CPU type in context_cpu_type.  Returns false if the CPU type does not
   // match.  Returns true if the CPU type matches or if the minidump does
   // not contain a system info stream.
   bool CheckAgainstSystemInfo(uint32_t context_cpu_type);
+
+  // Refers to the Minidump object that is the ultimate parent of this
+  // Some MinidumpObjects are owned by other MinidumpObjects, but at the
+  // root of the ownership tree is always a Minidump.  The Minidump object
+  // is kept here for access to its seeking and reading facilities, and
+  // for access to data about the minidump file itself, such as whether
+  // it should be byte-swapped.
+  Minidump* minidump_;
+
+  DISALLOW_COPY_AND_ASSIGN(MinidumpContext);
 };
 
 
@@ -273,7 +235,8 @@ class MinidumpMemoryRegion : public MinidumpObject,
   bool GetMemoryAtAddress(uint64_t address, uint64_t* value) const;
 
   // Print a human-readable representation of the object to stdout.
-  void Print();
+  void Print() const;
+  void SetPrintMode(bool hexdump, unsigned int width);
 
  protected:
   explicit MinidumpMemoryRegion(Minidump* minidump);
@@ -290,8 +253,11 @@ class MinidumpMemoryRegion : public MinidumpObject,
   template<typename T> bool GetMemoryAtAddressInternal(uint64_t address,
                                                        T*        value) const;
 
-  // The largest memory region that will be read from a minidump.  The
-  // default is 1MB.
+  // Knobs for controlling display of memory printing.
+  bool hexdump_;
+  unsigned int hexdump_width_;
+
+  // The largest memory region that will be read from a minidump.
   static uint32_t max_bytes_;
 
   // Base address and size of the memory region, and its position in the
@@ -325,7 +291,7 @@ class MinidumpThread : public MinidumpObject {
   // so a special getter is provided to retrieve this data from the
   // MDRawThread structure.  Returns false if the thread ID cannot be
   // determined.
-  virtual bool GetThreadID(uint32_t *thread_id) const;
+  virtual bool GetThreadID(uint32_t* thread_id) const;
 
   // Print a human-readable representation of the object to stdout.
   void Print();
@@ -388,7 +354,7 @@ class MinidumpThreadList : public MinidumpStream {
 
   static const uint32_t kStreamType = MD_THREAD_LIST_STREAM;
 
-  bool Read(uint32_t aExpectedSize);
+  bool Read(uint32_t aExpectedSize) override;
 
   // The largest number of threads that will be read from a minidump.  The
   // default is 256.
@@ -400,6 +366,8 @@ class MinidumpThreadList : public MinidumpStream {
   // The list of threads.
   MinidumpThreads* threads_;
   uint32_t        thread_count_;
+
+  DISALLOW_COPY_AND_ASSIGN(MinidumpThreadList);
 };
 
 
@@ -434,7 +402,15 @@ class MinidumpModule : public MinidumpObject,
   virtual string debug_file() const;
   virtual string debug_identifier() const;
   virtual string version() const;
-  virtual const CodeModule* Copy() const;
+  virtual CodeModule* Copy() const;
+  virtual bool is_unloaded() const { return false; }
+
+  // Getter and setter for shrink_down_delta.  This is used when the address
+  // range for a module is shrunk down due to address range conflicts with
+  // other modules.  The base_address and size fields are not updated and they
+  // should always reflect the original values (reported in the minidump).
+  virtual uint64_t shrink_down_delta() const;
+  virtual void SetShrinkDownDelta(uint64_t shrink_down_delta);
 
   // The CodeView record, which contains information to locate the module's
   // debugging information (pdb).  This is returned as uint8_t* because
@@ -543,6 +519,10 @@ class MinidumpModuleList : public MinidumpStream,
   virtual const MinidumpModule* GetModuleAtIndex(unsigned int index) const;
   virtual const CodeModules* Copy() const;
 
+  // Returns a vector of all modules which address ranges needed to be shrunk
+  // down due to address range conflicts with other modules.
+  virtual vector<linked_ptr<const CodeModule> > GetShrunkRangeModules() const;
+
   // Print a human-readable representation of the object to stdout.
   void Print();
 
@@ -558,15 +538,23 @@ class MinidumpModuleList : public MinidumpStream,
 
   bool Read(uint32_t expected_size);
 
+  bool StoreRange(const MinidumpModule& module,
+                  uint64_t base_address,
+                  uint32_t module_index,
+                  uint32_t module_count,
+                  bool is_android);
+
   // The largest number of modules that will be read from a minidump.  The
   // default is 1024.
   static uint32_t max_modules_;
 
   // Access to modules using addresses as the key.
-  RangeMap<uint64_t, unsigned int> *range_map_;
+  RangeMap<uint64_t, unsigned int>* range_map_;
 
-  MinidumpModules *modules_;
+  MinidumpModules* modules_;
   uint32_t module_count_;
+
+  DISALLOW_COPY_AND_ASSIGN(MinidumpModuleList);
 };
 
 
@@ -611,33 +599,35 @@ class MinidumpMemoryList : public MinidumpStream {
 
   explicit MinidumpMemoryList(Minidump* minidump);
 
-  bool Read(uint32_t expected_size);
+  bool Read(uint32_t expected_size) override;
 
   // The largest number of memory regions that will be read from a minidump.
   // The default is 256.
   static uint32_t max_regions_;
 
   // Access to memory regions using addresses as the key.
-  RangeMap<uint64_t, unsigned int> *range_map_;
+  RangeMap<uint64_t, unsigned int>* range_map_;
 
   // The list of descriptors.  This is maintained separately from the list
   // of regions, because MemoryRegion doesn't own its MemoryDescriptor, it
   // maintains a pointer to it.  descriptors_ provides the storage for this
   // purpose.
-  MemoryDescriptors *descriptors_;
+  MemoryDescriptors* descriptors_;
 
   // The list of regions.
-  MemoryRegions *regions_;
+  MemoryRegions* regions_;
   uint32_t region_count_;
+
+  DISALLOW_COPY_AND_ASSIGN(MinidumpMemoryList);
 };
 
 
 // MinidumpException wraps MDRawExceptionStream, which contains information
 // about the exception that caused the minidump to be generated, if the
-// minidump was generated in an exception handler called as a result of
-// an exception.  It also provides access to a MinidumpContext object,
-// which contains the CPU context for the exception thread at the time
-// the exception occurred.
+// minidump was generated in an exception handler called as a result of an
+// exception.  It also provides access to a MinidumpContext object, which
+// contains the CPU context for the exception thread at the time the exception
+// occurred.
 class MinidumpException : public MinidumpStream {
  public:
   virtual ~MinidumpException();
@@ -650,7 +640,7 @@ class MinidumpException : public MinidumpStream {
   // so a special getter is provided to retrieve this data from the
   // MDRawExceptionStream structure.  Returns false if the thread ID cannot
   // be determined.
-  bool GetThreadID(uint32_t *thread_id) const;
+  bool GetThreadID(uint32_t* thread_id) const;
 
   MinidumpContext* GetContext();
 
@@ -664,10 +654,12 @@ class MinidumpException : public MinidumpStream {
 
   explicit MinidumpException(Minidump* minidump);
 
-  bool Read(uint32_t expected_size);
+  bool Read(uint32_t expected_size) override;
 
   MDRawExceptionStream exception_;
   MinidumpContext*     context_;
+
+  DISALLOW_COPY_AND_ASSIGN(MinidumpException);
 };
 
 // MinidumpAssertion wraps MDRawAssertionInfo, which contains information
@@ -702,12 +694,14 @@ class MinidumpAssertion : public MinidumpStream {
 
   explicit MinidumpAssertion(Minidump* minidump);
 
-  bool Read(uint32_t expected_size);
+  bool Read(uint32_t expected_size) override;
 
   MDRawAssertionInfo assertion_;
   string expression_;
   string function_;
   string file_;
+
+  DISALLOW_COPY_AND_ASSIGN(MinidumpAssertion);
 };
 
 
@@ -757,10 +751,123 @@ class MinidumpSystemInfo : public MinidumpStream {
 
   static const uint32_t kStreamType = MD_SYSTEM_INFO_STREAM;
 
-  bool Read(uint32_t expected_size);
+  bool Read(uint32_t expected_size) override;
 
   // A string identifying the CPU vendor, if known.
   const string* cpu_vendor_;
+
+  DISALLOW_COPY_AND_ASSIGN(MinidumpSystemInfo);
+};
+
+
+// MinidumpUnloadedModule wraps MDRawUnloadedModule
+class MinidumpUnloadedModule : public MinidumpObject,
+                               public CodeModule {
+ public:
+  ~MinidumpUnloadedModule() override;
+
+  const MDRawUnloadedModule* module() const {
+    return valid_ ? &unloaded_module_ : NULL;
+  }
+
+  // CodeModule implementation
+  uint64_t base_address() const override {
+    return valid_ ? unloaded_module_.base_of_image : 0;
+  }
+  uint64_t size() const override {
+    return valid_ ? unloaded_module_.size_of_image : 0;
+  }
+  string code_file() const override;
+  string code_identifier() const override;
+  string debug_file() const override;
+  string debug_identifier() const override;
+  string version() const override;
+  CodeModule* Copy() const override;
+  bool is_unloaded() const override { return true; }
+  uint64_t shrink_down_delta() const override;
+  void SetShrinkDownDelta(uint64_t shrink_down_delta) override;
+
+ protected:
+  explicit MinidumpUnloadedModule(Minidump* minidump);
+
+ private:
+  // These objects are managed by MinidumpUnloadedModuleList
+  friend class MinidumpUnloadedModuleList;
+
+  // This works like MinidumpStream::Read, but is driven by
+  // MinidumpUnloadedModuleList.
+  bool Read(uint32_t expected_size);
+
+  // Reads the module name. This is done separately from Read to
+  // allow contiguous reading of code modules by MinidumpUnloadedModuleList.
+  bool ReadAuxiliaryData();
+
+  // True after a successful Read. This is different from valid_, which
+  // is not set true until ReadAuxiliaryData also completes successfully.
+  // module_valid_ is only used by ReadAuxiliaryData and the functions it
+  // calls to determine whether the object is ready for auxiliary data to
+  // be read.
+  bool module_valid_;
+
+  MDRawUnloadedModule unloaded_module_;
+
+  // Cached module name
+  const string* name_;
+};
+
+
+// MinidumpUnloadedModuleList contains all the unloaded code modules for a
+// process in the form of MinidumpUnloadedModules. It maintains a map of
+// these modules so that it may easily provide a code module corresponding
+// to a specific address. If multiple modules in the list have identical
+// ranges, only the first module encountered is recorded in the range map.
+class MinidumpUnloadedModuleList : public MinidumpStream,
+                                   public CodeModules {
+ public:
+  ~MinidumpUnloadedModuleList() override;
+
+  static void set_max_modules(uint32_t max_modules) {
+    max_modules_ = max_modules;
+  }
+  static uint32_t max_modules() { return max_modules_; }
+
+  // CodeModules implementation.
+  unsigned int module_count() const override {
+    return valid_ ? module_count_ : 0;
+  }
+  const MinidumpUnloadedModule*
+      GetModuleForAddress(uint64_t address) const override;
+  const MinidumpUnloadedModule* GetMainModule() const override;
+  const MinidumpUnloadedModule*
+      GetModuleAtSequence(unsigned int sequence) const override;
+  const MinidumpUnloadedModule*
+      GetModuleAtIndex(unsigned int index) const override;
+  const CodeModules* Copy() const override;
+  vector<linked_ptr<const CodeModule>> GetShrunkRangeModules() const override;
+
+ protected:
+  explicit MinidumpUnloadedModuleList(Minidump* minidump_);
+
+ private:
+  friend class Minidump;
+
+  typedef vector<MinidumpUnloadedModule> MinidumpUnloadedModules;
+
+  static const uint32_t kStreamType = MD_UNLOADED_MODULE_LIST_STREAM;
+
+  bool Read(uint32_t expected_size_) override;
+
+  // The largest number of modules that will be read from a minidump.  The
+  // default is 1024.
+  static uint32_t max_modules_;
+
+  // Access to module indices using addresses as the key.
+  RangeMap<uint64_t, unsigned int>* range_map_;
+
+  MinidumpUnloadedModules* unloaded_modules_;
+  uint32_t module_count_;
+
+  DISALLOW_COPY_AND_ASSIGN(MinidumpUnloadedModuleList);
 };
 
 
@@ -778,12 +885,13 @@ class MinidumpMiscInfo : public MinidumpStream {
 
  private:
   friend class Minidump;
+  friend class TestMinidumpMiscInfo;
 
   static const uint32_t kStreamType = MD_MISC_INFO_STREAM;
 
   explicit MinidumpMiscInfo(Minidump* minidump_);
 
-  bool Read(uint32_t expected_size_);
+  bool Read(uint32_t expected_size_) override;
 
   MDRawMiscInfo misc_info_;
 
@@ -793,6 +901,8 @@ class MinidumpMiscInfo : public MinidumpStream {
   string daylight_name_;
   string build_string_;
   string dbg_bld_str_;
+
+  DISALLOW_COPY_AND_ASSIGN(MinidumpMiscInfo);
 };
 
 
@@ -809,8 +919,8 @@ class MinidumpBreakpadInfo : public MinidumpStream {
   // treatment, so special getters are provided to retrieve this data from
   // the MDRawBreakpadInfo structure.  The getters return false if the thread
   // IDs cannot be determined.
-  bool GetDumpThreadID(uint32_t *thread_id) const;
-  bool GetRequestingThreadID(uint32_t *thread_id) const;
+  bool GetDumpThreadID(uint32_t* thread_id) const;
+  bool GetRequestingThreadID(uint32_t* thread_id) const;
 
   // Print a human-readable representation of the object to stdout.
   void Print();
@@ -822,9 +932,11 @@ class MinidumpBreakpadInfo : public MinidumpStream {
 
   explicit MinidumpBreakpadInfo(Minidump* minidump_);
 
-  bool Read(uint32_t expected_size_);
+  bool Read(uint32_t expected_size_) override;
 
   MDRawBreakpadInfo breakpad_info_;
+
+  DISALLOW_COPY_AND_ASSIGN(MinidumpBreakpadInfo);
 };
 
 // MinidumpMemoryInfo wraps MDRawMemoryInfo, which provides information
@@ -853,7 +965,7 @@ class MinidumpMemoryInfo : public MinidumpObject {
   // These objects are managed by MinidumpMemoryInfoList.
   friend class MinidumpMemoryInfoList;
 
-  explicit MinidumpMemoryInfo(Minidump* minidump);
+  explicit MinidumpMemoryInfo(Minidump* minidump_);
 
   // This works like MinidumpStream::Read, but is driven by
   // MinidumpMemoryInfoList.  No size checking is done, because
@@ -886,15 +998,141 @@ class MinidumpMemoryInfoList : public MinidumpStream {
 
   static const uint32_t kStreamType = MD_MEMORY_INFO_LIST_STREAM;
 
-  explicit MinidumpMemoryInfoList(Minidump* minidump);
+  explicit MinidumpMemoryInfoList(Minidump* minidump_);
 
-  bool Read(uint32_t expected_size);
+  bool Read(uint32_t expected_size) override;
 
   // Access to memory info using addresses as the key.
-  RangeMap<uint64_t, unsigned int> *range_map_;
+  RangeMap<uint64_t, unsigned int>* range_map_;
 
   MinidumpMemoryInfos* infos_;
   uint32_t info_count_;
+
+  DISALLOW_COPY_AND_ASSIGN(MinidumpMemoryInfoList);
+};
+
+// MinidumpLinuxMaps wraps information about a single mapped memory region
+// from /proc/self/maps.
+class MinidumpLinuxMaps : public MinidumpObject {
+ public:
+  // The memory address of the base of the mapped region.
+  uint64_t GetBase() const { return valid_ ? region_.start : 0; }
+  // The size of the mapped region.
+  uint64_t GetSize() const { return valid_ ? region_.end - region_.start : 0; }
+
+  // The permissions of the mapped region.
+  bool IsReadable() const {
+    return valid_ ? region_.permissions & MappedMemoryRegion::READ : false;
+  }
+  bool IsWriteable() const {
+    return valid_ ? region_.permissions & MappedMemoryRegion::WRITE : false;
+  }
+  bool IsExecutable() const {
+    return valid_ ? region_.permissions & MappedMemoryRegion::EXECUTE : false;
+  }
+  bool IsPrivate() const {
+    return valid_ ? region_.permissions & MappedMemoryRegion::PRIVATE : false;
+  }
+
+  // The offset of the mapped region.
+  uint64_t GetOffset() const { return valid_ ? region_.offset : 0; }
+
+  // The major device number.
+  uint8_t GetMajorDevice() const { return valid_ ? region_.major_device : 0; }
+  // The minor device number.
+  uint8_t GetMinorDevice() const { return valid_ ? region_.minor_device : 0; }
+
+  // The inode of the mapped region.
+  uint64_t GetInode() const { return valid_ ? region_.inode : 0; }
+
+  // The pathname of the mapped region.
+  const string GetPathname() const { return valid_ ? region_.path : ""; }
+
+  // Print the contents of this mapping.
+  void Print() const;
+
+ private:
+  // These objects are managed by MinidumpLinuxMapsList.
+  friend class MinidumpLinuxMapsList;
+
+  // This caller owns the pointer.
+  explicit MinidumpLinuxMaps(Minidump* minidump);
+
+  // The memory region struct that this class wraps.
+  MappedMemoryRegion region_;
+
+  DISALLOW_COPY_AND_ASSIGN(MinidumpLinuxMaps);
+};
+
+// MinidumpLinuxMapsList corresponds to the Linux-exclusive MD_LINUX_MAPS
+// stream, which contains the contents of /prod/self/maps, which contains
+// the mapped memory regions and their access permissions.
+class MinidumpLinuxMapsList : public MinidumpStream {
+ public:
+  virtual ~MinidumpLinuxMapsList();
+
+  // Get number of mappings.
+  unsigned int get_maps_count() const { return valid_ ? maps_count_ : 0; }
+
+  // Get mapping at the given memory address. The caller owns the pointer.
+  const MinidumpLinuxMaps* GetLinuxMapsForAddress(uint64_t address) const;
+  // Get mapping at the given index. The caller owns the pointer.
+  const MinidumpLinuxMaps* GetLinuxMapsAtIndex(unsigned int index) const;
+
+  // Print the contents of /proc/self/maps to stdout.
+  void Print() const;
+
+ private:
+  friend class Minidump;
+
+  typedef vector<MinidumpLinuxMaps*> MinidumpLinuxMappings;
+
+  static const uint32_t kStreamType = MD_LINUX_MAPS;
+
+  // The caller owns the pointer.
+  explicit MinidumpLinuxMapsList(Minidump* minidump);
+
+  // Read and load the contents of the process mapping data.
+  // The stream should have data in the form of /proc/self/maps.
+  // This method returns whether the stream was read successfully.
+  bool Read(uint32_t expected_size) override;
+
+  // The list of individual mappings.
+  MinidumpLinuxMappings* maps_;
+  // The number of mappings.
+  uint32_t maps_count_;
+
+  DISALLOW_COPY_AND_ASSIGN(MinidumpLinuxMapsList);
+};
+
+// MinidumpCrashpadInfo wraps MDRawCrashpadInfo, which is an optional stream in
+// a minidump that provides additional information about the process state
+// at the time the minidump was generated.
+class MinidumpCrashpadInfo : public MinidumpStream {
+ public:
+  const MDRawCrashpadInfo* crashpad_info() const {
+    return valid_ ? &crashpad_info_ : NULL;
+  }
+
+  // Print a human-readable representation of the object to stdout.
+  void Print();
+
+ private:
+  friend class Minidump;
+
+  static const uint32_t kStreamType = MD_CRASHPAD_INFO_STREAM;
+
+  explicit MinidumpCrashpadInfo(Minidump* minidump_);
+
+  bool Read(uint32_t expected_size);
+
+  MDRawCrashpadInfo crashpad_info_;
+  std::vector<uint32_t> module_crashpad_info_links_;
+  std::vector<MDRawModuleCrashpadInfo> module_crashpad_info_;
+  std::vector<std::vector<std::string>> module_crashpad_info_list_annotations_;
+  std::vector<std::map<std::string, std::string>>
+      module_crashpad_info_simple_annotations_;
+  std::map<std::string, std::string> simple_annotations_;
 };
 
 
@@ -903,7 +1141,9 @@ class MinidumpMemoryInfoList : public MinidumpStream {
 class Minidump {
  public:
   // path is the pathname of a file containing the minidump.
-  explicit Minidump(const string& path);
+  explicit Minidump(const string& path,
+                    bool hexdump=false,
+                    unsigned int hexdump_width=16);
   // input is an istream wrapping minidump data. Minidump holds a
   // weak pointer to input, and the caller must ensure that the stream
   // is valid as long as the Minidump object is.
@@ -948,14 +1188,19 @@ class Minidump {
   // to avoid exposing an ugly API (GetStream needs to accept a garbage
   // parameter).
   virtual MinidumpThreadList* GetThreadList();
-  MinidumpModuleList* GetModuleList();
+  virtual MinidumpModuleList* GetModuleList();
   virtual MinidumpMemoryList* GetMemoryList();
-  MinidumpException* GetException();
-  MinidumpAssertion* GetAssertion();
+  virtual MinidumpException* GetException();
+  virtual MinidumpAssertion* GetAssertion();
   virtual MinidumpSystemInfo* GetSystemInfo();
-  MinidumpMiscInfo* GetMiscInfo();
-  MinidumpBreakpadInfo* GetBreakpadInfo();
-  MinidumpMemoryInfoList* GetMemoryInfoList();
+  virtual MinidumpUnloadedModuleList* GetUnloadedModuleList();
+  virtual MinidumpMiscInfo* GetMiscInfo();
+  virtual MinidumpBreakpadInfo* GetBreakpadInfo();
+  virtual MinidumpMemoryInfoList* GetMemoryInfoList();
+  MinidumpCrashpadInfo* GetCrashpadInfo();
+
+  // The next method also calls GetStream, but is exclusive for Linux dumps.
+  virtual MinidumpLinuxMapsList* GetLinuxMapsList();
 
   // The next set of methods are provided for users who wish to access
   // data in minidump files directly, while leveraging the rest of
@@ -980,13 +1225,21 @@ class Minidump {
   // Returns the current position of the minidump file.
   off_t Tell();
 
-  // The next 2 methods are medium-level I/O routines.
+  // Medium-level I/O routines.
 
   // ReadString returns a string which is owned by the caller!  offset
   // specifies the offset that a length-encoded string is stored at in the
   // minidump file.
   string* ReadString(off_t offset);
 
+  bool ReadUTF8String(off_t offset, string* string_utf8);
+
+  bool ReadStringList(off_t offset, std::vector<std::string>* string_list);
+
+  bool ReadSimpleStringDictionary(
+      off_t offset,
+      std::map<std::string, std::string>* simple_string_dictionary);
+
   // SeekToStreamType positions the file at the beginning of a stream
   // identified by stream_type, and informs the caller of the stream's
   // length by setting *stream_length.  Because stream_map maps each stream
@@ -1003,9 +1256,21 @@ class Minidump {
 
   bool swap() const { return valid_ ? swap_ : false; }
 
+  bool is_big_endian() const { return valid_ ? is_big_endian_ : false; }
+
   // Print a human-readable representation of the object to stdout.
   void Print();
 
+  // Is the OS Android.
+  bool IsAndroid();
+
+  // Determines the platform where the minidump was produced. |platform| is
+  // valid iff this method returns true.
+  bool GetPlatform(MDOSPlatform* platform);
+
+  // Get current hexdump display settings.
+  unsigned int HexdumpMode() const { return hexdump_ ? hexdump_width_ : 0; }
+
  private:
   // MinidumpStreamInfo is used in the MinidumpStreamMap.  It lets
   // the Minidump object locate interesting streams quickly, and
@@ -1062,10 +1327,19 @@ class Minidump {
   // same-endian, this will be false.
   bool                      swap_;
 
+  // true if the minidump was produced by a big-endian cpu.
+  bool                      is_big_endian_;
+
   // Validity of the Minidump structure, false immediately after
   // construction or after a failed Read(); true following a successful
   // Read().
   bool                      valid_;
+
+  // Knobs for controlling display of memory printing.
+  bool                      hexdump_;
+  unsigned int              hexdump_width_;
+
+  DISALLOW_COPY_AND_ASSIGN(Minidump);
 };
 
 
diff --git a/src/MEGASync/google_breakpad/google_breakpad/processor/minidump_processor.h b/src/MEGASync/google_breakpad/google_breakpad/processor/minidump_processor.h
index 33cd0206..414050e9 100644
--- a/src/MEGASync/google_breakpad/google_breakpad/processor/minidump_processor.h
+++ b/src/MEGASync/google_breakpad/google_breakpad/processor/minidump_processor.h
@@ -35,6 +35,7 @@
 
 #include "common/using_std_string.h"
 #include "google_breakpad/common/breakpad_types.h"
+#include "google_breakpad/processor/process_result.h"
 
 namespace google_breakpad {
 
@@ -44,41 +45,6 @@ class StackFrameSymbolizer;
 class SourceLineResolverInterface;
 class SymbolSupplier;
 struct SystemInfo;
-// Return type for Process()
-enum ProcessResult {
-  PROCESS_OK,                                 // The minidump was
-                                              // processed
-                                              // successfully.
-
-  PROCESS_ERROR_MINIDUMP_NOT_FOUND,           // The minidump file
-                                              // was not found.
-
-  PROCESS_ERROR_NO_MINIDUMP_HEADER,           // The minidump file
-                                              // had no header
-
-  PROCESS_ERROR_NO_THREAD_LIST,               // The minidump file
-                                              // had no thread list.
-
-  PROCESS_ERROR_GETTING_THREAD,               // There was an error
-                                              // getting one
-                                              // thread's data from
-                                              // the minidump.
-
-  PROCESS_ERROR_GETTING_THREAD_ID,            // There was an error
-                                              // getting a thread id
-                                              // from the thread's
-                                              // data.
-
-  PROCESS_ERROR_DUPLICATE_REQUESTING_THREADS, // There was more than
-                                              // one requesting
-                                              // thread.
-
-  PROCESS_SYMBOL_SUPPLIER_INTERRUPTED         // The minidump
-                                              // processing was
-                                              // interrupted by the
-                                              // SymbolSupplier(not
-                                              // fatal)
-};
 
 class MinidumpProcessor {
  public:
@@ -104,7 +70,7 @@ class MinidumpProcessor {
   ~MinidumpProcessor();
 
   // Processes the minidump file and fills process_state with the result.
-  ProcessResult Process(const string &minidump_file,
+  ProcessResult Process(const string& minidump_file,
                         ProcessState* process_state);
 
   // Processes the minidump structure and fills process_state with the
@@ -123,6 +89,12 @@ class MinidumpProcessor {
   // the minidump.
   static bool GetOSInfo(Minidump* dump, SystemInfo* info);
 
+  // Populates the |process_create_time| parameter with the create time of the
+  // crashed process.  Returns false if this information is not available in
+  // the minidump |dump|.
+  static bool GetProcessCreateTime(Minidump* dump,
+                                   uint32_t* process_create_time);
+
   // Returns a textual representation of the reason that a crash occurred,
   // if the minidump in dump was produced as a result of a crash.  Returns
   // an empty string if this information cannot be determined.  If address
@@ -153,6 +125,8 @@ class MinidumpProcessor {
   // does not exist or cannot be determined.
   static string GetAssertion(Minidump* dump);
 
+  void set_enable_objdump(bool enabled) { enable_objdump_ = enabled; }
+
  private:
   StackFrameSymbolizer* frame_symbolizer_;
   // Indicate whether resolver_helper_ is owned by this instance.
@@ -162,6 +136,10 @@ class MinidumpProcessor {
   // guess how likely it is that the crash represents an exploitable
   // memory corruption issue.
   bool enable_exploitability_;
+
+  // This flag permits the exploitability scanner to shell out to objdump
+  // for purposes of disassembly.
+  bool enable_objdump_;
 };
 
 }  // namespace google_breakpad
diff --git a/src/MEGASync/google_breakpad/google_breakpad/processor/proc_maps_linux.h b/src/MEGASync/google_breakpad/google_breakpad/processor/proc_maps_linux.h
new file mode 100644
index 00000000..3045daa5
--- /dev/null
+++ b/src/MEGASync/google_breakpad/google_breakpad/processor/proc_maps_linux.h
@@ -0,0 +1,60 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef BASE_DEBUG_PROC_MAPS_LINUX_H_
+#define BASE_DEBUG_PROC_MAPS_LINUX_H_
+
+#include <string>
+#include <vector>
+
+#include "common/using_std_string.h"
+#include "google_breakpad/common/breakpad_types.h"
+
+namespace google_breakpad {
+
+// Describes a region of mapped memory and the path of the file mapped.
+struct MappedMemoryRegion {
+  enum Permission {
+    READ = 1 << 0,
+    WRITE = 1 << 1,
+    EXECUTE = 1 << 2,
+    PRIVATE = 1 << 3,  // If set, region is private, otherwise it is shared.
+  };
+
+  // The address range [start,end) of mapped memory.
+  uint64_t start;
+  uint64_t end;
+
+  // Byte offset into |path| of the range mapped into memory.
+  uint64_t offset;
+
+  // Bitmask of read/write/execute/private/shared permissions.
+  uint8_t permissions;
+
+  // Major and minor devices.
+  uint8_t major_device;
+  uint8_t minor_device;
+
+  // Value of the inode.
+  uint64_t inode;
+
+  // Name of the file mapped into memory.
+  //
+  // NOTE: path names aren't guaranteed to point at valid files. For example,
+  // "[heap]" and "[stack]" are used to represent the location of the process'
+  // heap and stack, respectively.
+  string path;
+
+  // The line from /proc/<pid>/maps that this struct represents.
+  string line;
+};
+
+// Parses /proc/<pid>/maps input data and stores in |regions|. Returns true
+// and updates |regions| if and only if all of |input| was successfully parsed.
+bool ParseProcMaps(const string& input,
+                   std::vector<MappedMemoryRegion>* regions);
+
+}  // namespace google_breakpad
+
+#endif  // BASE_DEBUG_PROC_MAPS_LINUX_H_
diff --git a/src/MEGASync/google_breakpad/google_breakpad/processor/process_result.h b/src/MEGASync/google_breakpad/google_breakpad/processor/process_result.h
new file mode 100644
index 00000000..15c7213e
--- /dev/null
+++ b/src/MEGASync/google_breakpad/google_breakpad/processor/process_result.h
@@ -0,0 +1,66 @@
+// Copyright (c) 2014, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef GOOGLE_BREAKPAD_PROCESSOR_PROCESS_RESULT_H__
+#define GOOGLE_BREAKPAD_PROCESSOR_PROCESS_RESULT_H__
+
+namespace google_breakpad {
+
+// Return type for MinidumpProcessor or MicrodumpProcessor's Process()
+enum ProcessResult {
+  PROCESS_OK,                                  // The dump was processed
+                                               // successfully.
+
+  PROCESS_ERROR_MINIDUMP_NOT_FOUND,            // The minidump file was not
+                                               // found.
+
+  PROCESS_ERROR_NO_MINIDUMP_HEADER,            // The minidump file had no
+                                               // header.
+
+  PROCESS_ERROR_NO_THREAD_LIST,                // The minidump file has no
+                                               // thread list.
+
+  PROCESS_ERROR_GETTING_THREAD,                // There was an error getting one
+                                               // thread's data from th dump.
+
+  PROCESS_ERROR_GETTING_THREAD_ID,             // There was an error getting a
+                                               // thread id from the thread's
+                                               // data.
+
+  PROCESS_ERROR_DUPLICATE_REQUESTING_THREADS,  // There was more than one
+                                               // requesting thread.
+
+  PROCESS_SYMBOL_SUPPLIER_INTERRUPTED          // The dump processing was
+                                               // interrupted by the
+                                               // SymbolSupplier(not fatal).
+};
+
+}  // namespace google_breakpad
+
+#endif  // GOOGLE_BREAKPAD_PROCESSOR_PROCESS_RESULT_H__
diff --git a/src/MEGASync/google_breakpad/google_breakpad/processor/process_state.h b/src/MEGASync/google_breakpad/google_breakpad/processor/process_state.h
index ab15b147..9bc44c45 100644
--- a/src/MEGASync/google_breakpad/google_breakpad/processor/process_state.h
+++ b/src/MEGASync/google_breakpad/google_breakpad/processor/process_state.h
@@ -39,8 +39,11 @@
 
 #include "common/using_std_string.h"
 #include "google_breakpad/common/breakpad_types.h"
-#include "google_breakpad/processor/system_info.h"
+#include "google_breakpad/processor/code_modules.h"
+#include "google_breakpad/processor/exception_record.h"
 #include "google_breakpad/processor/minidump.h"
+#include "google_breakpad/processor/system_info.h"
+#include "processor/linked_ptr.h"
 
 namespace google_breakpad {
 
@@ -89,7 +92,7 @@ enum ExploitabilityRating {
 
 class ProcessState {
  public:
-  ProcessState() : modules_(NULL) { Clear(); }
+  ProcessState() : modules_(NULL), unloaded_modules_(NULL) { Clear(); }
   ~ProcessState();
 
   // Resets the ProcessState to its default values
@@ -97,17 +100,23 @@ class ProcessState {
 
   // Accessors.  See the data declarations below.
   uint32_t time_date_stamp() const { return time_date_stamp_; }
+  uint32_t process_create_time() const { return process_create_time_; }
   bool crashed() const { return crashed_; }
   string crash_reason() const { return crash_reason_; }
   uint64_t crash_address() const { return crash_address_; }
   string assertion() const { return assertion_; }
   int requesting_thread() const { return requesting_thread_; }
+  const ExceptionRecord* exception_record() const { return &exception_record_; }
   const vector<CallStack*>* threads() const { return &threads_; }
-  const vector<MinidumpMemoryRegion*>* thread_memory_regions() const {
+  const vector<MemoryRegion*>* thread_memory_regions() const {
     return &thread_memory_regions_;
   }
   const SystemInfo* system_info() const { return &system_info_; }
   const CodeModules* modules() const { return modules_; }
+  const CodeModules* unloaded_modules() const { return unloaded_modules_; }
+  const vector<linked_ptr<const CodeModule> >* shrunk_range_modules() const {
+    return &shrunk_range_modules_;
+  }
   const vector<const CodeModule*>* modules_without_symbols() const {
     return &modules_without_symbols_;
   }
@@ -117,12 +126,17 @@ class ProcessState {
   ExploitabilityRating exploitability() const { return exploitability_; }
 
  private:
-  // MinidumpProcessor is responsible for building ProcessState objects.
+  // MinidumpProcessor and MicrodumpProcessor are responsible for building
+  // ProcessState objects.
   friend class MinidumpProcessor;
+  friend class MicrodumpProcessor;
 
   // The time-date stamp of the minidump (time_t format)
   uint32_t time_date_stamp_;
 
+  // The time-date stamp when the process was created (time_t format)
+  uint32_t process_create_time_;
+
   // True if the process crashed, false if the dump was produced outside
   // of an exception handler.
   bool crashed_;
@@ -154,10 +168,13 @@ class ProcessState {
   // indicating that the dump thread is not available.
   int requesting_thread_;
 
+  // Exception record details: code, flags, address, parameters.
+  ExceptionRecord exception_record_;
+
   // Stacks for each thread (except possibly the exception handler
   // thread) at the time of the crash.
   vector<CallStack*> threads_;
-  vector<MinidumpMemoryRegion*> thread_memory_regions_;
+  vector<MemoryRegion*> thread_memory_regions_;
 
   // OS and CPU information.
   SystemInfo system_info_;
@@ -166,6 +183,14 @@ class ProcessState {
   // ProcessState.
   const CodeModules *modules_;
 
+  // The modules that have been unloaded from the process represented by the
+  // ProcessState.
+  const CodeModules *unloaded_modules_;
+
+  // The modules which virtual address ranges were shrunk down due to
+  // virtual address conflicts.
+  vector<linked_ptr<const CodeModule> > shrunk_range_modules_;
+
   // The modules that didn't have symbols when the report was processed.
   vector<const CodeModule*> modules_without_symbols_;
 
@@ -174,7 +199,7 @@ class ProcessState {
 
   // The exploitability rating as determined by the exploitability
   // engine. When the exploitability engine is not enabled this
-  // defaults to EXPLOITABILITY_NONE.
+  // defaults to EXPLOITABILITY_NOT_ANALYZED.
   ExploitabilityRating exploitability_;
 };
 
diff --git a/src/MEGASync/google_breakpad/google_breakpad/processor/source_line_resolver_base.h b/src/MEGASync/google_breakpad/google_breakpad/processor/source_line_resolver_base.h
index c720b0c3..fea1657c 100644
--- a/src/MEGASync/google_breakpad/google_breakpad/processor/source_line_resolver_base.h
+++ b/src/MEGASync/google_breakpad/google_breakpad/processor/source_line_resolver_base.h
@@ -64,36 +64,36 @@ class SourceLineResolverBase : public SourceLineResolverInterface {
   // LoadMap() method.
   // Place dynamically allocated heap buffer in symbol_data. Caller has the
   // ownership of the buffer, and should call delete [] to free the buffer.
-  static bool ReadSymbolFile(const string &file_name,
-                             char **symbol_data,
-                             size_t *symbol_data_size);
+  static bool ReadSymbolFile(const string& file_name,
+                             char** symbol_data,
+                             size_t* symbol_data_size);
 
  protected:
   // Users are not allowed create SourceLineResolverBase instance directly.
-  SourceLineResolverBase(ModuleFactory *module_factory);
+  SourceLineResolverBase(ModuleFactory* module_factory);
   virtual ~SourceLineResolverBase();
 
   // Virtual methods inherited from SourceLineResolverInterface.
-  virtual bool LoadModule(const CodeModule *module, const string &map_file);
-  virtual bool LoadModuleUsingMapBuffer(const CodeModule *module,
-                                        const string &map_buffer);
-  virtual bool LoadModuleUsingMemoryBuffer(const CodeModule *module,
-                                           char *memory_buffer,
+  virtual bool LoadModule(const CodeModule* module, const string& map_file);
+  virtual bool LoadModuleUsingMapBuffer(const CodeModule* module,
+                                        const string& map_buffer);
+  virtual bool LoadModuleUsingMemoryBuffer(const CodeModule* module,
+                                           char* memory_buffer,
                                            size_t memory_buffer_size);
   virtual bool ShouldDeleteMemoryBufferAfterLoadModule();
-  virtual void UnloadModule(const CodeModule *module);
-  virtual bool HasModule(const CodeModule *module);
-  virtual bool IsModuleCorrupt(const CodeModule *module);
-  virtual void FillSourceLineInfo(StackFrame *frame);
-  virtual WindowsFrameInfo *FindWindowsFrameInfo(const StackFrame *frame);
-  virtual CFIFrameInfo *FindCFIFrameInfo(const StackFrame *frame);
+  virtual void UnloadModule(const CodeModule* module);
+  virtual bool HasModule(const CodeModule* module);
+  virtual bool IsModuleCorrupt(const CodeModule* module);
+  virtual void FillSourceLineInfo(StackFrame* frame);
+  virtual WindowsFrameInfo* FindWindowsFrameInfo(const StackFrame* frame);
+  virtual CFIFrameInfo* FindCFIFrameInfo(const StackFrame* frame);
 
   // Nested structs and classes.
   struct Line;
   struct Function;
   struct PublicSymbol;
   struct CompareString {
-    bool operator()(const string &s1, const string &s2) const;
+    bool operator()(const string& s1, const string& s2) const;
   };
   // Module is an interface for an in-memory symbol file.
   class Module;
@@ -101,18 +101,18 @@ class SourceLineResolverBase : public SourceLineResolverInterface {
 
   // All of the modules that are loaded.
   typedef map<string, Module*, CompareString> ModuleMap;
-  ModuleMap *modules_;
+  ModuleMap* modules_;
 
   // The loaded modules that were detecting to be corrupt during load.
   typedef set<string, CompareString> ModuleSet;
-  ModuleSet *corrupt_modules_;
+  ModuleSet* corrupt_modules_;
 
   // All of heap-allocated buffers that are owned locally by resolver.
   typedef std::map<string, char*, CompareString> MemoryMap;
-  MemoryMap *memory_buffers_;
+  MemoryMap* memory_buffers_;
 
   // Creates a concrete module at run-time.
-  ModuleFactory *module_factory_;
+  ModuleFactory* module_factory_;
 
  private:
   // ModuleFactory needs to have access to protected type Module.
diff --git a/src/MEGASync/google_breakpad/google_breakpad/processor/source_line_resolver_interface.h b/src/MEGASync/google_breakpad/google_breakpad/processor/source_line_resolver_interface.h
index a694bf2e..99011404 100644
--- a/src/MEGASync/google_breakpad/google_breakpad/processor/source_line_resolver_interface.h
+++ b/src/MEGASync/google_breakpad/google_breakpad/processor/source_line_resolver_interface.h
@@ -58,11 +58,11 @@ class SourceLineResolverInterface {
   // and debug_identifier members populated.
   //
   // map_file should contain line/address mappings for this module.
-  virtual bool LoadModule(const CodeModule *module,
-                          const string &map_file) = 0;
+  virtual bool LoadModule(const CodeModule* module,
+                          const string& map_file) = 0;
   // Same as above, but takes the contents of a pre-read map buffer
-  virtual bool LoadModuleUsingMapBuffer(const CodeModule *module,
-                                        const string &map_buffer) = 0;
+  virtual bool LoadModuleUsingMapBuffer(const CodeModule* module,
+                                        const string& map_buffer) = 0;
 
   // Add an interface to load symbol using C-String data instead of string.
   // This is useful in the optimization design for avoiding unnecessary copying
@@ -70,8 +70,8 @@ class SourceLineResolverInterface {
   // LoadModuleUsingMemoryBuffer() does NOT take ownership of memory_buffer.
   // LoadModuleUsingMemoryBuffer() null terminates the passed in buffer, if
   // the last character is not a null terminator.
-  virtual bool LoadModuleUsingMemoryBuffer(const CodeModule *module,
-                                           char *memory_buffer,
+  virtual bool LoadModuleUsingMemoryBuffer(const CodeModule* module,
+                                           char* memory_buffer,
                                            size_t memory_buffer_size) = 0;
 
   // Return true if the memory buffer should be deleted immediately after
@@ -81,31 +81,31 @@ class SourceLineResolverInterface {
 
   // Request that the specified module be unloaded from this resolver.
   // A resolver may choose to ignore such a request.
-  virtual void UnloadModule(const CodeModule *module) = 0;
+  virtual void UnloadModule(const CodeModule* module) = 0;
 
   // Returns true if the module has been loaded.
-  virtual bool HasModule(const CodeModule *module) = 0;
+  virtual bool HasModule(const CodeModule* module) = 0;
 
   // Returns true if the module has been loaded and it is corrupt.
-  virtual bool IsModuleCorrupt(const CodeModule *module) = 0;
+  virtual bool IsModuleCorrupt(const CodeModule* module) = 0;
 
   // Fills in the function_base, function_name, source_file_name,
   // and source_line fields of the StackFrame.  The instruction and
   // module_name fields must already be filled in.
-  virtual void FillSourceLineInfo(StackFrame *frame) = 0;
+  virtual void FillSourceLineInfo(StackFrame* frame) = 0;
 
   // If Windows stack walking information is available covering
   // FRAME's instruction address, return a WindowsFrameInfo structure
   // describing it. If the information is not available, returns NULL.
   // A NULL return value does not indicate an error. The caller takes
   // ownership of any returned WindowsFrameInfo object.
-  virtual WindowsFrameInfo *FindWindowsFrameInfo(const StackFrame *frame) = 0;
+  virtual WindowsFrameInfo* FindWindowsFrameInfo(const StackFrame* frame) = 0;
 
   // If CFI stack walking information is available covering ADDRESS,
   // return a CFIFrameInfo structure describing it. If the information
   // is not available, return NULL. The caller takes ownership of any
   // returned CFIFrameInfo object.
-  virtual CFIFrameInfo *FindCFIFrameInfo(const StackFrame *frame) = 0;
+  virtual CFIFrameInfo* FindCFIFrameInfo(const StackFrame* frame) = 0;
 
  protected:
   // SourceLineResolverInterface cannot be instantiated except by subclasses
diff --git a/src/MEGASync/google_breakpad/google_breakpad/processor/stack_frame.h b/src/MEGASync/google_breakpad/google_breakpad/processor/stack_frame.h
index b55eb9c7..1491d788 100644
--- a/src/MEGASync/google_breakpad/google_breakpad/processor/stack_frame.h
+++ b/src/MEGASync/google_breakpad/google_breakpad/processor/stack_frame.h
@@ -84,7 +84,7 @@ struct StackFrame {
       default:
         return "unknown";
     }
-  };
+  }
 
   // Return the actual return address, as saved on the stack or in a
   // register. See the comments for 'instruction', below, for details.
diff --git a/src/MEGASync/google_breakpad/google_breakpad/processor/stack_frame_symbolizer.h b/src/MEGASync/google_breakpad/google_breakpad/processor/stack_frame_symbolizer.h
index 074907cb..0bbaae0a 100644
--- a/src/MEGASync/google_breakpad/google_breakpad/processor/stack_frame_symbolizer.h
+++ b/src/MEGASync/google_breakpad/google_breakpad/processor/stack_frame_symbolizer.h
@@ -75,9 +75,11 @@ class StackFrameSymbolizer {
 
   // Encapsulate the step of resolving source line info for a stack frame.
   // "frame" must not be NULL.
-  virtual SymbolizerResult FillSourceLineInfo(const CodeModules* modules,
-                                              const SystemInfo* system_info,
-                                              StackFrame* stack_frame);
+  virtual SymbolizerResult FillSourceLineInfo(
+      const CodeModules* modules,
+      const CodeModules* unloaded_modules,
+      const SystemInfo* system_info,
+      StackFrame* stack_frame);
 
   virtual WindowsFrameInfo* FindWindowsFrameInfo(const StackFrame* frame);
 
diff --git a/src/MEGASync/google_breakpad/google_breakpad/processor/stackwalker.h b/src/MEGASync/google_breakpad/google_breakpad/processor/stackwalker.h
index 81ef6557..daa5039a 100644
--- a/src/MEGASync/google_breakpad/google_breakpad/processor/stackwalker.h
+++ b/src/MEGASync/google_breakpad/google_breakpad/processor/stackwalker.h
@@ -54,7 +54,7 @@
 namespace google_breakpad {
 
 class CallStack;
-class MinidumpContext;
+class DumpContext;
 class StackFrameSymbolizer;
 
 using std::set;
@@ -86,11 +86,13 @@ class Stackwalker {
   // argument.  If no suitable concrete subclass exists, returns NULL.
   static Stackwalker* StackwalkerForCPU(
      const SystemInfo* system_info,
-     MinidumpContext* context,
+     DumpContext* context,
      MemoryRegion* memory,
      const CodeModules* modules,
+     const CodeModules* unloaded_modules,
      StackFrameSymbolizer* resolver_helper);
 
+
   static void set_max_frames(uint32_t max_frames) {
     max_frames_ = max_frames;
     max_frames_set_ = true;
@@ -124,7 +126,15 @@ class Stackwalker {
   // * This address is within a loaded module for which we have symbols,
   //   and falls inside a function in that module.
   // Returns false otherwise.
-  bool InstructionAddressSeemsValid(uint64_t address);
+  bool InstructionAddressSeemsValid(uint64_t address) const;
+
+  // Checks whether we should stop the stack trace.
+  // (either we reached the end-of-stack or we detected a
+  //  broken callstack invariant)
+  bool TerminateWalk(uint64_t caller_ip,
+                     uint64_t caller_sp,
+                     uint64_t callee_sp,
+                     bool first_unwind) const;
 
   // The default number of words to search through on the stack
   // for a return address.
@@ -166,8 +176,12 @@ class Stackwalker {
       if (!memory_->GetMemoryAtAddress(location, &ip))
         break;
 
-      if (modules_ && modules_->GetModuleForAddress(ip) &&
-          InstructionAddressSeemsValid(ip)) {
+      // The return address points to the instruction after a call. If the
+      // caller was a no return function, this might point past the end of the
+      // function. Subtract one from the instruction pointer so it points into
+      // the call instruction instead.
+      if (modules_ && modules_->GetModuleForAddress(ip  - 1) &&
+          InstructionAddressSeemsValid(ip - 1)) {
         *ip_found = ip;
         *location_found = location;
         return true;
@@ -189,6 +203,11 @@ class Stackwalker {
   // This field is optional and may be NULL.
   const CodeModules* modules_;
 
+  // A list of unloaded modules, for populating frames which aren't matched
+  // to any loaded modules.
+  // This field is optional and may be NULL.
+  const CodeModules* unloaded_modules_;
+
  protected:
   // The StackFrameSymbolizer implementation.
   StackFrameSymbolizer* frame_symbolizer_;
@@ -210,6 +229,13 @@ class Stackwalker {
   // the caller.  |stack_scan_allowed| controls whether stack scanning is
   // an allowable frame-recovery method, since it is desirable to be able to
   // disable stack scanning in performance-critical use cases.
+  //
+  // CONSIDER: a way to differentiate between:
+  //  - full stack traces
+  //  - explicitly truncated traces (max_frames_)
+  //  - stopping after max scanned frames
+  //  - failed stack walk (breaking one of the stack walk invariants)
+  //
   virtual StackFrame* GetCallerFrame(const CallStack* stack,
                                      bool stack_scan_allowed) = 0;
 
diff --git a/src/MEGASync/google_breakpad/google_breakpad/processor/symbol_supplier.h b/src/MEGASync/google_breakpad/google_breakpad/processor/symbol_supplier.h
index a042081f..6ec01766 100644
--- a/src/MEGASync/google_breakpad/google_breakpad/processor/symbol_supplier.h
+++ b/src/MEGASync/google_breakpad/google_breakpad/processor/symbol_supplier.h
@@ -63,35 +63,35 @@ class SymbolSupplier {
   // to help locate the symbol file.  system_info may be NULL or its
   // fields may be empty if these values are unknown.  symbol_file
   // must be a pointer to a valid string
-  virtual SymbolResult GetSymbolFile(const CodeModule *module,
-                                     const SystemInfo *system_info,
-                                     string *symbol_file) = 0;
+  virtual SymbolResult GetSymbolFile(const CodeModule* module,
+                                     const SystemInfo* system_info,
+                                     string* symbol_file) = 0;
   // Same as above, except also places symbol data into symbol_data.
   // If symbol_data is NULL, the data is not returned.
   // TODO(nealsid) Once we have symbol data caching behavior implemented
   // investigate making all symbol suppliers implement all methods,
   // and make this pure virtual
-  virtual SymbolResult GetSymbolFile(const CodeModule *module,
-                                     const SystemInfo *system_info,
-                                     string *symbol_file,
-                                     string *symbol_data) = 0;
+  virtual SymbolResult GetSymbolFile(const CodeModule* module,
+                                     const SystemInfo* system_info,
+                                     string* symbol_file,
+                                     string* symbol_data) = 0;
 
   // Same as above, except allocates data buffer on heap and then places the
   // symbol data into the buffer as C-string.
   // SymbolSupplier is responsible for deleting the data buffer. After the call
   // to GetCStringSymbolData(), the caller should call FreeSymbolData(const
-  // Module *module) once the data buffer is no longer needed.
+  // Module* module) once the data buffer is no longer needed.
   // If symbol_data is not NULL, symbol supplier won't return FOUND unless it
   // returns a valid buffer in symbol_data, e.g., returns INTERRUPT on memory
   // allocation failure.
-  virtual SymbolResult GetCStringSymbolData(const CodeModule *module,
-                                            const SystemInfo *system_info,
-                                            string *symbol_file,
-                                            char **symbol_data,
-                                            size_t *symbol_data_size) = 0;
+  virtual SymbolResult GetCStringSymbolData(const CodeModule* module,
+                                            const SystemInfo* system_info,
+                                            string* symbol_file,
+                                            char** symbol_data,
+                                            size_t* symbol_data_size) = 0;
 
   // Frees the data buffer allocated for the module in GetCStringSymbolData.
-  virtual void FreeSymbolData(const CodeModule *module) = 0;
+  virtual void FreeSymbolData(const CodeModule* module) = 0;
 };
 
 }  // namespace google_breakpad
diff --git a/src/MEGASync/google_breakpad/google_breakpad/processor/system_info.h b/src/MEGASync/google_breakpad/google_breakpad/processor/system_info.h
index 9583d9e8..8d2f60be 100644
--- a/src/MEGASync/google_breakpad/google_breakpad/processor/system_info.h
+++ b/src/MEGASync/google_breakpad/google_breakpad/processor/system_info.h
@@ -44,7 +44,7 @@ namespace google_breakpad {
 struct SystemInfo {
  public:
   SystemInfo() : os(), os_short(), os_version(), cpu(), cpu_info(),
-    cpu_count(0) {}
+    cpu_count(0), gl_version(), gl_vendor(), gl_renderer() {}
 
   // Resets the SystemInfo object to its default values.
   void Clear() {
@@ -54,6 +54,9 @@ struct SystemInfo {
     cpu.clear();
     cpu_info.clear();
     cpu_count = 0;
+    gl_version.clear();
+    gl_vendor.clear();
+    gl_renderer.clear();
   }
 
   // A string identifying the operating system, such as "Windows NT",
@@ -91,6 +94,11 @@ struct SystemInfo {
   // The number of processors in the system.  Will be greater than one for
   // multi-core systems.
   int cpu_count;
+
+  // The GPU information. Currently only populated in microdumps.
+  string gl_version;
+  string gl_vendor;
+  string gl_renderer;
 };
 
 }  // namespace google_breakpad
diff --git a/src/MEGASync/google_breakpad/third_party/lss/linux_syscall_support.h b/src/MEGASync/google_breakpad/third_party/lss/linux_syscall_support.h
index d04901db..e4ac2264 100644
--- a/src/MEGASync/google_breakpad/third_party/lss/linux_syscall_support.h
+++ b/src/MEGASync/google_breakpad/third_party/lss/linux_syscall_support.h
@@ -82,11 +82,13 @@
 #ifndef SYS_LINUX_SYSCALL_SUPPORT_H
 #define SYS_LINUX_SYSCALL_SUPPORT_H
 
-/* We currently only support x86-32, x86-64, ARM, MIPS, and PPC on Linux.
+/* We currently only support x86-32, x86-64, ARM, MIPS, PPC, s390 and s390x
+ * on Linux.
  * Porting to other related platforms should not be difficult.
  */
 #if (defined(__i386__) || defined(__x86_64__) || defined(__ARM_ARCH_3__) ||   \
-     defined(__mips__) || defined(__PPC__) || defined(__ARM_EABI__)) \
+     defined(__mips__) || defined(__PPC__) || defined(__ARM_EABI__) || \
+     defined(__aarch64__) || defined(__s390__)) \
   && (defined(__linux) || defined(__ANDROID__))
 
 #ifndef SYS_CPLUSPLUS
@@ -100,6 +102,7 @@ extern "C" {
 
 #include <errno.h>
 #include <fcntl.h>
+#include <sched.h>
 #include <signal.h>
 #include <stdarg.h>
 #include <stddef.h>
@@ -116,21 +119,58 @@ extern "C" {
 
 #ifdef __mips__
 /* Include definitions of the ABI currently in use.                          */
+#ifdef __ANDROID__
+/* Android doesn't have sgidefs.h, but does have asm/sgidefs.h,
+ * which has the definitions we need.
+ */
+#include <asm/sgidefs.h>
+#else
 #include <sgidefs.h>
 #endif
 #endif
+#endif
 
-/* The Android NDK's <sys/stat.h> #defines these macros as aliases
- * to their non-64 counterparts. To avoid naming conflict, remove them. */
-#ifdef __ANDROID__
-  /* These are restored by the corresponding #pragma pop_macro near
-   * the end of this file. */
-# pragma push_macro("stat64")
-# pragma push_macro("fstat64")
-# pragma push_macro("lstat64")
-# undef stat64
-# undef fstat64
-# undef lstat64
+/* Some libcs, for example Android NDK and musl, #define these
+ * macros as aliases to their non-64 counterparts. To avoid naming
+ * conflict, remove them.
+ *
+ * These are restored by the corresponding #pragma pop_macro near
+ * the end of this file.
+ */
+#pragma push_macro("stat64")
+#pragma push_macro("fstat64")
+#pragma push_macro("lstat64")
+#pragma push_macro("pread64")
+#pragma push_macro("pwrite64")
+#pragma push_macro("getdents64")
+#undef stat64
+#undef fstat64
+#undef lstat64
+#undef pread64
+#undef pwrite64
+#undef getdents64
+
+#if defined(__ANDROID__) && defined(__x86_64__)
+// A number of x86_64 syscalls are blocked by seccomp on recent Android;
+// undefine them so that modern alternatives will be used instead where
+// possible.
+// The alternative syscalls have been sanity checked against linux-3.4+;
+// older versions might not work.
+# undef __NR_getdents
+# undef __NR_dup2
+# undef __NR_fork
+# undef __NR_getpgrp
+# undef __NR_open
+# undef __NR_poll
+# undef __NR_readlink
+# undef __NR_stat
+# undef __NR_unlink
+# undef __NR_pipe
+#endif
+
+#if defined(__ANDROID__)
+// waitpid is blocked by seccomp on all architectures on recent Android.
+# undef __NR_waitpid
 #endif
 
 /* As glibc often provides subtly incompatible data structures (and implicit
@@ -172,12 +212,17 @@ struct kernel_dirent64 {
 };
 
 /* include/linux/dirent.h                                                    */
+#if !defined(__NR_getdents)
+// when getdents is not available, getdents64 is used for both.
+#define kernel_dirent kernel_dirent64
+#else
 struct kernel_dirent {
   long               d_ino;
   long               d_off;
   unsigned short     d_reclen;
   char               d_name[256];
 };
+#endif
 
 /* include/linux/uio.h                                                       */
 struct kernel_iovec {
@@ -242,7 +287,7 @@ struct kernel_rusage {
 };
 
 #if defined(__i386__) || defined(__ARM_EABI__) || defined(__ARM_ARCH_3__) \
-  || defined(__PPC__)
+  || defined(__PPC__) || (defined(__s390__) && !defined(__s390x__))
 
 /* include/asm-{arm,i386,mips,ppc}/signal.h                                  */
 struct kernel_old_sigaction {
@@ -256,6 +301,8 @@ struct kernel_old_sigaction {
 } __attribute__((packed,aligned(4)));
 #elif (defined(__mips__) && _MIPS_SIM == _MIPS_SIM_ABI32)
   #define kernel_old_sigaction kernel_sigaction
+#elif defined(__aarch64__)
+  // No kernel_old_sigaction defined for arm64.
 #endif
 
 /* Some kernel functions (e.g. sigaction() in 2.6.23) require that the
@@ -273,7 +320,7 @@ struct kernel_old_sigaction {
 #define KERNEL_NSIG  64
 #endif
 
-/* include/asm-{arm,i386,mips,x86_64}/signal.h                               */
+/* include/asm-{arm,aarch64,i386,mips,x86_64}/signal.h                       */
 struct kernel_sigset_t {
   unsigned long sig[(KERNEL_NSIG + 8*sizeof(unsigned long) - 1)/
                     (8*sizeof(unsigned long))];
@@ -305,7 +352,7 @@ struct kernel_sockaddr {
   char               sa_data[14];
 };
 
-/* include/asm-{arm,i386,mips,ppc}/stat.h                                    */
+/* include/asm-{arm,aarch64,i386,mips,ppc,s390}/stat.h                       */
 #ifdef __mips__
 #if _MIPS_SIM == _MIPS_SIM_ABI64
 struct kernel_stat {
@@ -378,7 +425,7 @@ struct kernel_stat64 {
 };
 #endif
 
-/* include/asm-{arm,i386,mips,x86_64,ppc}/stat.h                             */
+/* include/asm-{arm,aarch64,i386,mips,x86_64,ppc,s390}/stat.h                */
 #if defined(__i386__) || defined(__ARM_ARCH_3__) || defined(__ARM_EABI__)
 struct kernel_stat {
   /* The kernel headers suggest that st_dev and st_rdev should be 32bit
@@ -426,7 +473,7 @@ struct kernel_stat {
   uint64_t           st_mtime_nsec_;
   uint64_t           st_ctime_;
   uint64_t           st_ctime_nsec_;
-  int64_t            __unused[3];
+  int64_t            __unused4[3];
 };
 #elif defined(__PPC__)
 struct kernel_stat {
@@ -472,9 +519,76 @@ struct kernel_stat {
   int                st_blocks;
   int                st_pad4[14];
 };
+#elif defined(__aarch64__)
+struct kernel_stat {
+  unsigned long      st_dev;
+  unsigned long      st_ino;
+  unsigned int       st_mode;
+  unsigned int       st_nlink;
+  unsigned int       st_uid;
+  unsigned int       st_gid;
+  unsigned long      st_rdev;
+  unsigned long      __pad1;
+  long               st_size;
+  int                st_blksize;
+  int                __pad2;
+  long               st_blocks;
+  long               st_atime_;
+  unsigned long      st_atime_nsec_;
+  long               st_mtime_;
+  unsigned long      st_mtime_nsec_;
+  long               st_ctime_;
+  unsigned long      st_ctime_nsec_;
+  unsigned int       __unused4;
+  unsigned int       __unused5;
+};
+#elif defined(__s390x__)
+struct kernel_stat {
+  unsigned long      st_dev;
+  unsigned long      st_ino;
+  unsigned long      st_nlink;
+  unsigned int       st_mode;
+  unsigned int       st_uid;
+  unsigned int       st_gid;
+  unsigned int       __pad1;
+  unsigned long      st_rdev;
+  unsigned long      st_size;
+  unsigned long      st_atime_;
+  unsigned long      st_atime_nsec_;
+  unsigned long      st_mtime_;
+  unsigned long      st_mtime_nsec_;
+  unsigned long      st_ctime_;
+  unsigned long      st_ctime_nsec_;
+  unsigned long      st_blksize;
+  long               st_blocks;
+  unsigned long      __unused[3];
+};
+#elif defined(__s390__)
+struct kernel_stat {
+  unsigned short     st_dev;
+  unsigned short     __pad1;
+  unsigned long      st_ino;
+  unsigned short     st_mode;
+  unsigned short     st_nlink;
+  unsigned short     st_uid;
+  unsigned short     st_gid;
+  unsigned short     st_rdev;
+  unsigned short     __pad2;
+  unsigned long      st_size;
+  unsigned long      st_blksize;
+  unsigned long      st_blocks;
+  unsigned long      st_atime_;
+  unsigned long      st_atime_nsec_;
+  unsigned long      st_mtime_;
+  unsigned long      st_mtime_nsec_;
+  unsigned long      st_ctime_;
+  unsigned long      st_ctime_nsec_;
+  unsigned long      __unused4;
+  unsigned long      __unused5;
+};
 #endif
 
-/* include/asm-{arm,i386,mips,x86_64,ppc}/statfs.h                           */
+/* include/asm-{arm,aarch64,i386,mips,x86_64,ppc,s390}/statfs.h              */
 #ifdef __mips__
 #if _MIPS_SIM != _MIPS_SIM_ABI64
 struct kernel_statfs64 {
@@ -492,6 +606,22 @@ struct kernel_statfs64 {
   unsigned long      f_spare[6];
 };
 #endif
+#elif defined(__s390__)
+/* See also arch/s390/include/asm/compat.h                                   */
+struct kernel_statfs64 {
+  unsigned int       f_type;
+  unsigned int       f_bsize;
+  unsigned long long f_blocks;
+  unsigned long long f_bfree;
+  unsigned long long f_bavail;
+  unsigned long long f_files;
+  unsigned long long f_ffree;
+  struct { int val[2]; } f_fsid;
+  unsigned int       f_namelen;
+  unsigned int       f_frsize;
+  unsigned int       f_flags;
+  unsigned int       f_spare[4];
+};
 #elif !defined(__x86_64__)
 struct kernel_statfs64 {
   unsigned long      f_type;
@@ -508,7 +638,7 @@ struct kernel_statfs64 {
 };
 #endif
 
-/* include/asm-{arm,i386,mips,x86_64,ppc,generic}/statfs.h                   */
+/* include/asm-{arm,i386,mips,x86_64,ppc,generic,s390}/statfs.h              */
 #ifdef __mips__
 struct kernel_statfs {
   long               f_type;
@@ -540,6 +670,21 @@ struct kernel_statfs {
   uint64_t           f_frsize;
   uint64_t           f_spare[5];
 };
+#elif defined(__s390__)
+struct kernel_statfs {
+  unsigned int       f_type;
+  unsigned int       f_bsize;
+  unsigned long      f_blocks;
+  unsigned long      f_bfree;
+  unsigned long      f_bavail;
+  unsigned long      f_files;
+  unsigned long      f_ffree;
+  struct { int val[2]; } f_fsid;
+  unsigned int       f_namelen;
+  unsigned int       f_frsize;
+  unsigned int       f_flags;
+  unsigned int       f_spare[4];
+};
 #else
 struct kernel_statfs {
   unsigned long      f_type;
@@ -559,7 +704,7 @@ struct kernel_statfs {
 
 /* Definitions missing from the standard header files                        */
 #ifndef O_DIRECTORY
-#if defined(__ARM_ARCH_3__) || defined(__ARM_EABI__)
+#if defined(__ARM_ARCH_3__) || defined(__ARM_EABI__) || defined(__aarch64__)
 #define O_DIRECTORY             0040000
 #else
 #define O_DIRECTORY             0200000
@@ -612,11 +757,12 @@ struct kernel_statfs {
 #endif
 #ifndef MAKE_PROCESS_CPUCLOCK
 #define MAKE_PROCESS_CPUCLOCK(pid, clock)                                     \
-        ((~(int)(pid) << 3) | (int)(clock))
+        ((int)(~(unsigned)(pid) << 3) | (int)(clock))
 #endif
 #ifndef MAKE_THREAD_CPUCLOCK
 #define MAKE_THREAD_CPUCLOCK(tid, clock)                                      \
-        ((~(int)(tid) << 3) | (int)((clock) | CPUCLOCK_PERTHREAD_MASK))
+        ((int)(~(unsigned)(tid) << 3) |                                       \
+         (int)((clock) | CPUCLOCK_PERTHREAD_MASK))
 #endif
 
 #ifndef FUTEX_WAIT
@@ -808,6 +954,9 @@ struct kernel_statfs {
 #ifndef __NR_fallocate
 #define __NR_fallocate          324
 #endif
+#ifndef __NR_getrandom
+#define __NR_getrandom          355
+#endif
 /* End of i386 definitions                                                   */
 #elif defined(__ARM_ARCH_3__) || defined(__ARM_EABI__)
 #ifndef __NR_setresuid
@@ -912,7 +1061,110 @@ struct kernel_statfs {
 #ifndef __NR_getcpu
 #define __NR_getcpu             (__NR_SYSCALL_BASE + 345)
 #endif
-/* End of ARM 3/EABI definitions                                                */
+#ifndef __NR_getrandom
+#define __NR_getrandom          (__NR_SYSCALL_BASE + 384)
+#endif
+/* End of ARM 3/EABI definitions                                             */
+#elif defined(__aarch64__)
+#ifndef __NR_setxattr
+#define __NR_setxattr             5
+#endif
+#ifndef __NR_lsetxattr
+#define __NR_lsetxattr            6
+#endif
+#ifndef __NR_getxattr
+#define __NR_getxattr             8
+#endif
+#ifndef __NR_lgetxattr
+#define __NR_lgetxattr            9
+#endif
+#ifndef __NR_listxattr
+#define __NR_listxattr           11
+#endif
+#ifndef __NR_llistxattr
+#define __NR_llistxattr          12
+#endif
+#ifndef __NR_ioprio_set
+#define __NR_ioprio_set          30
+#endif
+#ifndef __NR_ioprio_get
+#define __NR_ioprio_get          31
+#endif
+#ifndef __NR_unlinkat
+#define __NR_unlinkat            35
+#endif
+#ifndef __NR_fallocate
+#define __NR_fallocate           47
+#endif
+#ifndef __NR_openat
+#define __NR_openat              56
+#endif
+#ifndef __NR_quotactl
+#define __NR_quotactl            60
+#endif
+#ifndef __NR_getdents64
+#define __NR_getdents64          61
+#endif
+#ifndef __NR_getdents
+// when getdents is not available, getdents64 is used for both.
+#define __NR_getdents            __NR_getdents64
+#endif
+#ifndef __NR_pread64
+#define __NR_pread64             67
+#endif
+#ifndef __NR_pwrite64
+#define __NR_pwrite64            68
+#endif
+#ifndef __NR_ppoll
+#define __NR_ppoll               73
+#endif
+#ifndef __NR_readlinkat
+#define __NR_readlinkat          78
+#endif
+#ifndef __NR_newfstatat
+#define __NR_newfstatat          79
+#endif
+#ifndef __NR_set_tid_address
+#define __NR_set_tid_address     96
+#endif
+#ifndef __NR_futex
+#define __NR_futex               98
+#endif
+#ifndef __NR_clock_gettime
+#define __NR_clock_gettime      113
+#endif
+#ifndef __NR_clock_getres
+#define __NR_clock_getres       114
+#endif
+#ifndef __NR_sched_setaffinity
+#define __NR_sched_setaffinity  122
+#define __NR_sched_getaffinity  123
+#endif
+#ifndef __NR_tkill
+#define __NR_tkill              130
+#endif
+#ifndef __NR_setresuid
+#define __NR_setresuid          147
+#define __NR_getresuid          148
+#define __NR_setresgid          149
+#define __NR_getresgid          150
+#endif
+#ifndef __NR_gettid
+#define __NR_gettid             178
+#endif
+#ifndef __NR_readahead
+#define __NR_readahead          213
+#endif
+#ifndef __NR_fadvise64
+#define __NR_fadvise64          223
+#endif
+#ifndef __NR_move_pages
+#define __NR_move_pages         239
+#endif
+#ifndef __NR_getrandom
+#define __NR_getrandom          278
+#endif
+/* End of aarch64 definitions                                                */
 #elif defined(__x86_64__)
 #ifndef __NR_pread64
 #define __NR_pread64             17
@@ -966,6 +1218,10 @@ struct kernel_statfs {
 #ifndef __NR_getdents64
 #define __NR_getdents64         217
 #endif
+#ifndef __NR_getdents
+// when getdents is not available, getdents64 is used for both.
+#define __NR_getdents           __NR_getdents64
+#endif
 #ifndef __NR_set_tid_address
 #define __NR_set_tid_address    218
 #endif
@@ -999,6 +1255,9 @@ struct kernel_statfs {
 #ifndef __NR_fallocate
 #define __NR_fallocate          285
 #endif
+#ifndef __NR_getrandom
+#define __NR_getrandom          318
+#endif
 /* End of x86-64 definitions                                                 */
 #elif defined(__mips__)
 #if _MIPS_SIM == _MIPS_SIM_ABI32
@@ -1100,6 +1359,9 @@ struct kernel_statfs {
 #ifndef __NR_ioprio_get
 #define __NR_ioprio_get         (__NR_Linux + 315)
 #endif
+#ifndef __NR_getrandom
+#define __NR_getrandom          (__NR_Linux + 353)
+#endif
 /* End of MIPS (old 32bit API) definitions */
 #elif  _MIPS_SIM == _MIPS_SIM_ABI64
 #ifndef __NR_pread64
@@ -1178,6 +1440,9 @@ struct kernel_statfs {
 #ifndef __NR_ioprio_get
 #define __NR_ioprio_get         (__NR_Linux + 274)
 #endif
+#ifndef __NT_getrandom
+#define                         (__NR_Linux + 313)
+#endif
 /* End of MIPS (64bit API) definitions */
 #else
 #ifndef __NR_setresuid
@@ -1369,6 +1634,189 @@ struct kernel_statfs {
 #define __NR_getcpu             302
 #endif
 /* End of powerpc defininitions                                              */
+#elif defined(__s390__)
+#ifndef __NR_quotactl
+#define __NR_quotactl           131
+#endif
+#ifndef __NR_rt_sigreturn
+#define __NR_rt_sigreturn       173
+#endif
+#ifndef __NR_rt_sigaction
+#define __NR_rt_sigaction       174
+#endif
+#ifndef __NR_rt_sigprocmask
+#define __NR_rt_sigprocmask     175
+#endif
+#ifndef __NR_rt_sigpending
+#define __NR_rt_sigpending      176
+#endif
+#ifndef __NR_rt_sigsuspend
+#define __NR_rt_sigsuspend      179
+#endif
+#ifndef __NR_pread64
+#define __NR_pread64            180
+#endif
+#ifndef __NR_pwrite64
+#define __NR_pwrite64           181
+#endif
+#ifndef __NR_getdents64
+#define __NR_getdents64         220
+#endif
+#ifndef __NR_readahead
+#define __NR_readahead          222
+#endif
+#ifndef __NR_setxattr
+#define __NR_setxattr           224
+#endif
+#ifndef __NR_lsetxattr
+#define __NR_lsetxattr          225
+#endif
+#ifndef __NR_getxattr
+#define __NR_getxattr           227
+#endif
+#ifndef __NR_lgetxattr
+#define __NR_lgetxattr          228
+#endif
+#ifndef __NR_listxattr
+#define __NR_listxattr          230
+#endif
+#ifndef __NR_llistxattr
+#define __NR_llistxattr         231
+#endif
+#ifndef __NR_gettid
+#define __NR_gettid             236
+#endif
+#ifndef __NR_tkill
+#define __NR_tkill              237
+#endif
+#ifndef __NR_futex
+#define __NR_futex              238
+#endif
+#ifndef __NR_sched_setaffinity
+#define __NR_sched_setaffinity  239
+#endif
+#ifndef __NR_sched_getaffinity
+#define __NR_sched_getaffinity  240
+#endif
+#ifndef __NR_set_tid_address
+#define __NR_set_tid_address    252
+#endif
+#ifndef __NR_clock_gettime
+#define __NR_clock_gettime      260
+#endif
+#ifndef __NR_clock_getres
+#define __NR_clock_getres       261
+#endif
+#ifndef __NR_statfs64
+#define __NR_statfs64           265
+#endif
+#ifndef __NR_fstatfs64
+#define __NR_fstatfs64          266
+#endif
+#ifndef __NR_ioprio_set
+#define __NR_ioprio_set         282
+#endif
+#ifndef __NR_ioprio_get
+#define __NR_ioprio_get         283
+#endif
+#ifndef __NR_openat
+#define __NR_openat             288
+#endif
+#ifndef __NR_unlinkat
+#define __NR_unlinkat           294
+#endif
+#ifndef __NR_move_pages
+#define __NR_move_pages         310
+#endif
+#ifndef __NR_getcpu
+#define __NR_getcpu             311
+#endif
+#ifndef __NR_fallocate
+#define __NR_fallocate          314
+#endif
+/* Some syscalls are named/numbered differently between s390 and s390x. */
+#ifdef __s390x__
+# ifndef __NR_getrlimit
+# define __NR_getrlimit          191
+# endif
+# ifndef __NR_setresuid
+# define __NR_setresuid          208
+# endif
+# ifndef __NR_getresuid
+# define __NR_getresuid          209
+# endif
+# ifndef __NR_setresgid
+# define __NR_setresgid          210
+# endif
+# ifndef __NR_getresgid
+# define __NR_getresgid          211
+# endif
+# ifndef __NR_setfsuid
+# define __NR_setfsuid           215
+# endif
+# ifndef __NR_setfsgid
+# define __NR_setfsgid           216
+# endif
+# ifndef __NR_fadvise64
+# define __NR_fadvise64          253
+# endif
+# ifndef __NR_newfstatat
+# define __NR_newfstatat         293
+# endif
+#else /* __s390x__ */
+# ifndef __NR_getrlimit
+# define __NR_getrlimit          76
+# endif
+# ifndef __NR_setfsuid
+# define __NR_setfsuid           138
+# endif
+# ifndef __NR_setfsgid
+# define __NR_setfsgid           139
+# endif
+# ifndef __NR_setresuid
+# define __NR_setresuid          164
+# endif
+# ifndef __NR_getresuid
+# define __NR_getresuid          165
+# endif
+# ifndef __NR_setresgid
+# define __NR_setresgid          170
+# endif
+# ifndef __NR_getresgid
+# define __NR_getresgid          171
+# endif
+# ifndef __NR_ugetrlimit
+# define __NR_ugetrlimit         191
+# endif
+# ifndef __NR_mmap2
+# define __NR_mmap2              192
+# endif
+# ifndef __NR_setresuid32
+# define __NR_setresuid32        208
+# endif
+# ifndef __NR_getresuid32
+# define __NR_getresuid32        209
+# endif
+# ifndef __NR_setresgid32
+# define __NR_setresgid32        210
+# endif
+# ifndef __NR_getresgid32
+# define __NR_getresgid32        211
+# endif
+# ifndef __NR_setfsuid32
+# define __NR_setfsuid32         215
+# endif
+# ifndef __NR_setfsgid32
+# define __NR_setfsgid32         216
+# endif
+# ifndef __NR_fadvise64_64
+# define __NR_fadvise64_64       264
+# endif
+# ifndef __NR_fstatat64
+# define __NR_fstatat64          293
+# endif
+#endif /* __s390__ */
+/* End of s390/s390x definitions                                             */
 #endif
 
 
@@ -1432,7 +1880,7 @@ struct kernel_statfs {
 
   #undef  LSS_RETURN
   #if (defined(__i386__) || defined(__x86_64__) || defined(__ARM_ARCH_3__) \
-       || defined(__ARM_EABI__))
+       || defined(__ARM_EABI__) || defined(__aarch64__) || defined(__s390__))
   /* Failing system calls return a negative result in the range of
    * -1..-4095. These are "errno" values with the sign inverted.
    */
@@ -1485,29 +1933,30 @@ struct kernel_statfs {
       void (**entrypoint)(void);
       asm volatile(".bss\n"
                    ".align 8\n"
-                   ".globl "SYS_SYSCALL_ENTRYPOINT"\n"
-                   ".common "SYS_SYSCALL_ENTRYPOINT",8,8\n"
+                   ".globl " SYS_SYSCALL_ENTRYPOINT "\n"
+                   ".common " SYS_SYSCALL_ENTRYPOINT ",8,8\n"
                    ".previous\n"
                    /* This logically does 'lea "SYS_SYSCALL_ENTRYPOINT", %0' */
                    "call 0f\n"
                  "0:pop  %0\n"
                    "add  $_GLOBAL_OFFSET_TABLE_+[.-0b], %0\n"
-                   "mov  "SYS_SYSCALL_ENTRYPOINT"@GOT(%0), %0\n"
+                   "mov  " SYS_SYSCALL_ENTRYPOINT "@GOT(%0), %0\n"
                    : "=r"(entrypoint));
       return entrypoint;
     }
 
     #define LSS_ENTRYPOINT ".bss\n"                                           \
                            ".align 8\n"                                       \
-                           ".globl "SYS_SYSCALL_ENTRYPOINT"\n"                \
-                           ".common "SYS_SYSCALL_ENTRYPOINT",8,8\n"           \
+                           ".globl " SYS_SYSCALL_ENTRYPOINT "\n"              \
+                           ".common " SYS_SYSCALL_ENTRYPOINT ",8,8\n"         \
                            ".previous\n"                                      \
                            /* Check the SYS_SYSCALL_ENTRYPOINT vector      */ \
                            "push %%eax\n"                                     \
                            "call 10000f\n"                                    \
                      "10000:pop  %%eax\n"                                     \
                            "add  $_GLOBAL_OFFSET_TABLE_+[.-10000b], %%eax\n"  \
-                           "mov  "SYS_SYSCALL_ENTRYPOINT"@GOT(%%eax), %%eax\n"\
+                           "mov  " SYS_SYSCALL_ENTRYPOINT                     \
+                                 "@GOT(%%eax), %%eax\n"                       \
                            "mov  0(%%eax), %%eax\n"                           \
                            "test %%eax, %%eax\n"                              \
                            "jz   10002f\n"                                    \
@@ -1531,7 +1980,7 @@ struct kernel_statfs {
                            LSS_ENTRYPOINT                                     \
                            "pop %%ebx"                                        \
                            args                                               \
-                           : "esp", "memory");                                \
+                           : "memory");                                       \
       LSS_RETURN(type,__res)
     #undef  _syscall0
     #define _syscall0(type,name)                                              \
@@ -1540,7 +1989,7 @@ struct kernel_statfs {
         __asm__ volatile(LSS_ENTRYPOINT                                       \
                          : "=a" (__res)                                       \
                          : "0" (__NR_##name)                                  \
-                         : "esp", "memory");                                  \
+                         : "memory");                                         \
         LSS_RETURN(type,__res);                                               \
       }
     #undef  _syscall1
@@ -1588,7 +2037,7 @@ struct kernel_statfs {
                              : "i" (__NR_##name), "ri" ((long)(arg1)),        \
                                "c" ((long)(arg2)), "d" ((long)(arg3)),        \
                                "S" ((long)(arg4)), "D" ((long)(arg5))         \
-                             : "esp", "memory");                              \
+                             : "memory");                                     \
         LSS_RETURN(type,__res);                                               \
       }
     #undef  _syscall6
@@ -1610,7 +2059,7 @@ struct kernel_statfs {
                              : "i" (__NR_##name),  "0" ((long)(&__s)),        \
                                "c" ((long)(arg2)), "d" ((long)(arg3)),        \
                                "S" ((long)(arg4)), "D" ((long)(arg5))         \
-                             : "esp", "memory");                              \
+                             : "memory");                                     \
         LSS_RETURN(type,__res);                                               \
       }
     LSS_INLINE int LSS_NAME(clone)(int (*fn)(void *), void *child_stack,
@@ -1696,36 +2145,10 @@ struct kernel_statfs {
                            : "0"(-EINVAL), "i"(__NR_clone),
                              "m"(fn), "m"(child_stack), "m"(flags), "m"(arg),
                              "m"(parent_tidptr), "m"(newtls), "m"(child_tidptr)
-                           : "esp", "memory", "ecx", "edx", "esi", "edi");
+                           : "memory", "ecx", "edx", "esi", "edi");
       LSS_RETURN(int, __res);
     }
 
-    #define __NR__fadvise64_64 __NR_fadvise64_64
-    LSS_INLINE _syscall6(int, _fadvise64_64, int, fd,
-                         unsigned, offset_lo, unsigned, offset_hi,
-                         unsigned, len_lo, unsigned, len_hi,
-                         int, advice)
-
-    LSS_INLINE int LSS_NAME(fadvise64)(int fd, loff_t offset,
-                                       loff_t len, int advice) {
-      return LSS_NAME(_fadvise64_64)(fd,
-                                     (unsigned)offset, (unsigned)(offset >>32),
-                                     (unsigned)len, (unsigned)(len >> 32),
-                                     advice);
-    }
-
-    #define __NR__fallocate __NR_fallocate
-    LSS_INLINE _syscall6(int, _fallocate, int, fd,
-                         int, mode,
-                         unsigned, offset_lo, unsigned, offset_hi,
-                         unsigned, len_lo, unsigned, len_hi)
-
-    LSS_INLINE int LSS_NAME(fallocate)(int fd, int mode,
-                                       loff_t offset, loff_t len) {
-      union { loff_t off; unsigned w[2]; } o = { offset }, l = { len };
-      return LSS_NAME(_fallocate)(fd, mode, o.w[0], o.w[1], l.w[0], l.w[1]);
-    }
-
     LSS_INLINE _syscall1(int, set_thread_area, void *, u)
     LSS_INLINE _syscall1(int, get_thread_area, void *, u)
 
@@ -1779,10 +2202,10 @@ struct kernel_statfs {
       void (**entrypoint)(void);
       asm volatile(".bss\n"
                    ".align 8\n"
-                   ".globl "SYS_SYSCALL_ENTRYPOINT"\n"
-                   ".common "SYS_SYSCALL_ENTRYPOINT",8,8\n"
+                   ".globl " SYS_SYSCALL_ENTRYPOINT "\n"
+                   ".common " SYS_SYSCALL_ENTRYPOINT ",8,8\n"
                    ".previous\n"
-                   "mov "SYS_SYSCALL_ENTRYPOINT"@GOTPCREL(%%rip), %0\n"
+                   "mov " SYS_SYSCALL_ENTRYPOINT "@GOTPCREL(%%rip), %0\n"
                    : "=r"(entrypoint));
       return entrypoint;
     }
@@ -1790,10 +2213,10 @@ struct kernel_statfs {
     #define LSS_ENTRYPOINT                                                    \
               ".bss\n"                                                        \
               ".align 8\n"                                                    \
-              ".globl "SYS_SYSCALL_ENTRYPOINT"\n"                             \
-              ".common "SYS_SYSCALL_ENTRYPOINT",8,8\n"                        \
+              ".globl " SYS_SYSCALL_ENTRYPOINT "\n"                           \
+              ".common " SYS_SYSCALL_ENTRYPOINT ",8,8\n"                      \
               ".previous\n"                                                   \
-              "mov "SYS_SYSCALL_ENTRYPOINT"@GOTPCREL(%%rip), %%rcx\n"         \
+              "mov " SYS_SYSCALL_ENTRYPOINT "@GOTPCREL(%%rip), %%rcx\n"       \
               "mov  0(%%rcx), %%rcx\n"                                        \
               "test %%rcx, %%rcx\n"                                           \
               "jz   10001f\n"                                                 \
@@ -2007,19 +2430,12 @@ struct kernel_statfs {
                                "d"(LSS_SYSCALL_ARG(parent_tidptr)),
                                "r"(LSS_SYSCALL_ARG(newtls)),
                                "r"(LSS_SYSCALL_ARG(child_tidptr))
-                             : "rsp", "memory", "r8", "r10", "r11", "rcx");
+                             : "memory", "r8", "r10", "r11", "rcx");
       }
       LSS_RETURN(int, __res);
     }
     LSS_INLINE _syscall2(int, arch_prctl, int, c, void *, a)
 
-    /* Need to make sure loff_t isn't truncated to 32-bits under x32.  */
-    LSS_INLINE int LSS_NAME(fadvise64)(int fd, loff_t offset, loff_t len,
-                                       int advice) {
-      LSS_BODY(4, int, fadvise64, LSS_SYSCALL_ARG(fd), (uint64_t)(offset),
-                                  (uint64_t)(len), LSS_SYSCALL_ARG(advice));
-    }
-
     LSS_INLINE void (*LSS_NAME(restore_rt)(void))(void) {
       /* On x86-64, the kernel does not know how to return from
        * a signal handler. Instead, it relies on user space to provide a
@@ -2232,86 +2648,188 @@ struct kernel_statfs {
                                    int flags, void *arg, int *parent_tidptr,
                                    void *newtls, int *child_tidptr) {
       long __res;
+      if (fn == NULL || child_stack == NULL) {
+        __res = -EINVAL;
+        LSS_RETURN(int, __res);
+      }
+
+      /* Push "arg" and "fn" onto the stack that will be
+       * used by the child.
+       */
+      {
+        uintptr_t* cstack = (uintptr_t*)child_stack - 2;
+        cstack[0] = (uintptr_t)fn;
+        cstack[1] = (uintptr_t)arg;
+        child_stack = cstack;
+      }
       {
         register int   __flags __asm__("r0") = flags;
         register void *__stack __asm__("r1") = child_stack;
         register void *__ptid  __asm__("r2") = parent_tidptr;
         register void *__tls   __asm__("r3") = newtls;
         register int  *__ctid  __asm__("r4") = child_tidptr;
-        __asm__ __volatile__(/* if (fn == NULL || child_stack == NULL)
-                              *   return -EINVAL;
-                              */
-#ifdef __thumb2__			     
-			     "push  {r7}\n"
-#endif			     
-                             "cmp   %2,#0\n"
-                             "it    ne\n"
-                             "cmpne %3,#0\n"
-                             "it    eq\n"
-                             "moveq %0,%1\n"
-                             "beq   1f\n"
+        __asm__ __volatile__(
+#ifdef __thumb2__
+            "push {r7}\n"
+#endif
+            /* %r0 = syscall(%r0 = flags,
+             *               %r1 = child_stack,
+             *               %r2 = parent_tidptr,
+             *               %r3 = newtls,
+             *               %r4 = child_tidptr)
+             */
+            "mov r7, %6\n"
+            "swi 0x0\n"
 
-                             /* Push "arg" and "fn" onto the stack that will be
-                              * used by the child.
-                              */
-                             "str   %5,[%3,#-4]!\n"
-                             "str   %2,[%3,#-4]!\n"
+            /* if (%r0 != 0)
+             *   return %r0;
+             */
+            "cmp   r0, #0\n"
+            "bne   1f\n"
 
-                             /* %r0 = syscall(%r0 = flags,
-                              *               %r1 = child_stack,
-                              *               %r2 = parent_tidptr,
-                              *               %r3 = newtls,
-                              *               %r4 = child_tidptr)
-                              */
-                             "mov r7, %9\n"
-                             "swi 0x0\n"
+            /* In the child, now. Call "fn(arg)".
+             */
+            "ldr   r0,[sp, #4]\n"
+
+            "ldr   lr,[sp]\n"
+            "blx   lr\n"
+
+            /* Call _exit(%r0).
+             */
+            "mov r7, %7\n"
+            "swi 0x0\n"
+            /* Unreachable */
+            "bkpt #0\n"
+         "1:\n"
+#ifdef __thumb2__
+            "pop {r7}\n"
+#endif
+            "movs  %0,r0\n"
+            : "=r"(__res)
+            : "r"(__stack), "r"(__flags), "r"(__ptid), "r"(__tls), "r"(__ctid),
+              "i"(__NR_clone), "i"(__NR_exit)
+            : "cc", "lr", "memory"
+#ifndef __thumb2__
+            , "r7"
+#endif
+            );
+      }
+      LSS_RETURN(int, __res);
+    }
+  #elif defined(__aarch64__)
+    /* Most definitions of _syscallX() neglect to mark "memory" as being
+     * clobbered. This causes problems with compilers, that do a better job
+     * at optimizing across __asm__ calls.
+     * So, we just have to redefine all of the _syscallX() macros.
+     */
+    #undef LSS_REG
+    #define LSS_REG(r,a) register int64_t __r##r __asm__("x"#r) = (int64_t)a
+    #undef  LSS_BODY
+    #define LSS_BODY(type,name,args...)                                       \
+          register int64_t __res_x0 __asm__("x0");                            \
+          int64_t __res;                                                      \
+          __asm__ __volatile__ ("mov x8, %1\n"                                \
+                                "svc 0x0\n"                                   \
+                                : "=r"(__res_x0)                              \
+                                : "i"(__NR_##name) , ## args                  \
+                                : "x8", "memory");                            \
+          __res = __res_x0;                                                   \
+          LSS_RETURN(type, __res)
+    #undef _syscall0
+    #define _syscall0(type, name)                                             \
+      type LSS_NAME(name)(void) {                                             \
+        LSS_BODY(type, name);                                                 \
+      }
+    #undef _syscall1
+    #define _syscall1(type, name, type1, arg1)                                \
+      type LSS_NAME(name)(type1 arg1) {                                       \
+        LSS_REG(0, arg1); LSS_BODY(type, name, "r"(__r0));                    \
+      }
+    #undef _syscall2
+    #define _syscall2(type, name, type1, arg1, type2, arg2)                   \
+      type LSS_NAME(name)(type1 arg1, type2 arg2) {                           \
+        LSS_REG(0, arg1); LSS_REG(1, arg2);                                   \
+        LSS_BODY(type, name, "r"(__r0), "r"(__r1));                           \
+      }
+    #undef _syscall3
+    #define _syscall3(type, name, type1, arg1, type2, arg2, type3, arg3)      \
+      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3) {               \
+        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
+        LSS_BODY(type, name, "r"(__r0), "r"(__r1), "r"(__r2));                \
+      }
+    #undef _syscall4
+    #define _syscall4(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4)  \
+      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4) {   \
+        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
+        LSS_REG(3, arg4);                                                     \
+        LSS_BODY(type, name, "r"(__r0), "r"(__r1), "r"(__r2), "r"(__r3));     \
+      }
+    #undef _syscall5
+    #define _syscall5(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,  \
+                      type5,arg5)                                             \
+      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4,     \
+                          type5 arg5) {                                       \
+        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
+        LSS_REG(3, arg4); LSS_REG(4, arg5);                                   \
+        LSS_BODY(type, name, "r"(__r0), "r"(__r1), "r"(__r2), "r"(__r3),      \
+                             "r"(__r4));                                      \
+      }
+    #undef _syscall6
+    #define _syscall6(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,  \
+                      type5,arg5,type6,arg6)                                  \
+      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4,     \
+                          type5 arg5, type6 arg6) {                           \
+        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
+        LSS_REG(3, arg4); LSS_REG(4, arg5); LSS_REG(5, arg6);                 \
+        LSS_BODY(type, name, "r"(__r0), "r"(__r1), "r"(__r2), "r"(__r3),      \
+                             "r"(__r4), "r"(__r5));                           \
+      }
+
+    LSS_INLINE int LSS_NAME(clone)(int (*fn)(void *), void *child_stack,
+                                   int flags, void *arg, int *parent_tidptr,
+                                   void *newtls, int *child_tidptr) {
+      int64_t __res;
+      {
+        register uint64_t __flags __asm__("x0") = flags;
+        register void *__stack __asm__("x1") = child_stack;
+        register void *__ptid  __asm__("x2") = parent_tidptr;
+        register void *__tls   __asm__("x3") = newtls;
+        register int  *__ctid  __asm__("x4") = child_tidptr;
+        __asm__ __volatile__(/* Push "arg" and "fn" onto the stack that will be
+                              * used by the child.
+                              */
+                             "stp     %1, %4, [%2, #-16]!\n"
+
+                             /* %x0 = syscall(%x0 = flags,
+                              *               %x1 = child_stack,
+                              *               %x2 = parent_tidptr,
+                              *               %x3 = newtls,
+                              *               %x4 = child_tidptr)
+                              */
+                             "mov     x8, %8\n"
+                             "svc     0x0\n"
 
                              /* if (%r0 != 0)
                               *   return %r0;
                               */
-                             "movs  %0,r0\n"
-                             "bne   1f\n"
+                             "mov     %0, x0\n"
+                             "cbnz    x0, 1f\n"
 
                              /* In the child, now. Call "fn(arg)".
                               */
-                             "ldr   r0,[sp, #4]\n"
-
-                             /* When compiling for Thumb-2 the "MOV LR,PC" here
-                              * won't work because it loads PC+4 into LR,
-                              * whereas the LDR is a 4-byte instruction.
-                              * This results in the child thread always
-                              * crashing with an "Illegal Instruction" when it
-                              * returned into the middle of the LDR instruction
-                              * The instruction sequence used instead was
-                              * recommended by
-                              * "https://wiki.edubuntu.org/ARM/Thumb2PortingHowto#Quick_Reference".
-                              */
-                           #ifdef __thumb2__
-                             "ldr   r7,[sp]\n"
-                             "blx   r7\n"
-                           #else
-                             "mov   lr,pc\n"
-                             "ldr   pc,[sp]\n"
-                           #endif
+                             "ldp     x1, x0, [sp], #16\n"
+                             "blr     x1\n"
 
                              /* Call _exit(%r0).
                               */
-                             "mov r7, %10\n"
-                             "swi 0x0\n"
+                             "mov     x8, %9\n"
+                             "svc     0x0\n"
                            "1:\n"
-#ifdef __thumb2__
-			     "pop {r7}"
-#endif			     
                              : "=r" (__res)
-                             : "i"(-EINVAL),
-                               "r"(fn), "r"(__stack), "r"(__flags), "r"(arg),
+                             : "r"(fn), "r"(__stack), "r"(__flags), "r"(arg),
                                "r"(__ptid), "r"(__tls), "r"(__ctid),
                                "i"(__NR_clone), "i"(__NR_exit)
-#ifdef __thumb2__
-			     : "cc", "lr", "memory");
-#else
-                             : "cc", "r7", "lr", "memory");
-#endif
+                             : "cc", "x8", "memory");
       }
       LSS_RETURN(int, __res);
     }
@@ -2320,14 +2838,22 @@ struct kernel_statfs {
     #define LSS_REG(r,a) register unsigned long __r##r __asm__("$"#r) =       \
                                  (unsigned long)(a)
     #undef  LSS_BODY
+    #undef LSS_SYSCALL_CLOBBERS
+    #if _MIPS_SIM == _MIPS_SIM_ABI32
+    #define LSS_SYSCALL_CLOBBERS "$1", "$3", "$8", "$9", "$10",               \
+                                 "$11", "$12", "$13", "$14", "$15",           \
+                                 "$24", "$25", "hi", "lo", "memory"
+    #else
+    #define LSS_SYSCALL_CLOBBERS "$1", "$3", "$10", "$11", "$12",             \
+                                 "$13", "$14", "$15", "$24", "$25",           \
+                                 "hi", "lo", "memory"
+    #endif
     #define LSS_BODY(type,name,r7,...)                                        \
           register unsigned long __v0 __asm__("$2") = __NR_##name;            \
           __asm__ __volatile__ ("syscall\n"                                   \
-                                : "+r"(__v0), r7 (__r7)                       \
+                                : "=r"(__v0), r7 (__r7)                       \
                                 : "0"(__v0), ##__VA_ARGS__                    \
-                                : "$8", "$9", "$10", "$11", "$12",            \
-                                  "$13", "$14", "$15", "$24", "$25",          \
-                                  "memory");                                  \
+                                : LSS_SYSCALL_CLOBBERS);                      \
           LSS_RETURN(type, __v0, __r7)
     #undef _syscall0
     #define _syscall0(type, name)                                             \
@@ -2441,7 +2967,7 @@ struct kernel_statfs {
     LSS_INLINE int LSS_NAME(clone)(int (*fn)(void *), void *child_stack,
                                    int flags, void *arg, int *parent_tidptr,
                                    void *newtls, int *child_tidptr) {
-      register unsigned long __v0 __asm__("$2");
+      register unsigned long __v0 __asm__("$2") = -EINVAL;
       register unsigned long __r7 __asm__("$7") = (unsigned long)newtls;
       {
         register int   __flags __asm__("$4") = flags;
@@ -2460,25 +2986,24 @@ struct kernel_statfs {
                              /* if (fn == NULL || child_stack == NULL)
                               *   return -EINVAL;
                               */
-                             "li    %0,%2\n"
+                             "beqz  %4,1f\n"
                              "beqz  %5,1f\n"
-                             "beqz  %6,1f\n"
 
                              /* Push "arg" and "fn" onto the stack that will be
                               * used by the child.
                               */
           #if _MIPS_SIM == _MIPS_SIM_ABI32 && _MIPS_SZPTR == 32
-                             "subu  %6,32\n"
-                             "sw    %5,0(%6)\n"
-                             "sw    %8,4(%6)\n"
+                             "subu  %5,32\n"
+                             "sw    %4,0(%5)\n"
+                             "sw    %7,4(%5)\n"
           #elif _MIPS_SIM == _MIPS_SIM_NABI32
-                             "sub   %6,32\n"
-                             "sw    %5,0(%6)\n"
-                             "sw    %8,8(%6)\n"
+                             "sub   %5,32\n"
+                             "sw    %4,0(%5)\n"
+                             "sw    %7,8(%5)\n"
           #else
-                             "dsubu %6,32\n"
-                             "sd    %5,0(%6)\n"
-                             "sd    %8,8(%6)\n"
+                             "dsubu %5,32\n"
+                             "sd    %4,0(%5)\n"
+                             "sd    %7,8(%5)\n"
           #endif
 
                              /* $7 = syscall($4 = flags,
@@ -2487,7 +3012,7 @@ struct kernel_statfs {
                               *              $7 = newtls,
                               *              $8 = child_tidptr)
                               */
-                             "li    $2,%3\n"
+                             "li    $2,%2\n"
                              "syscall\n"
 
                              /* if ($7 != 0)
@@ -2513,7 +3038,7 @@ struct kernel_statfs {
                              /* Call _exit($2)
                               */
                             "move  $4,$2\n"
-                            "li    $2,%4\n"
+                            "li    $2,%3\n"
                             "syscall\n"
 
                            "1:\n"
@@ -2525,9 +3050,9 @@ struct kernel_statfs {
                              "daddu $29,16\n"
           #endif
                              : "+r" (__v0), "+r" (__r7)
-                             : "i"(-EINVAL), "i"(__NR_clone), "i"(__NR_exit),
-                               "r"(fn), "r"(__stack), "r"(__flags), "r"(arg),
-                               "r"(__ptid), "r"(__r7), "r"(__ctid)
+                             : "i"(__NR_clone), "i"(__NR_exit), "r"(fn),
+                               "r"(__stack), "r"(__flags), "r"(arg),
+                               "r"(__ptid), "r"(__ctid)
                              : "$9", "$10", "$11", "$12", "$13", "$14", "$15",
                                "$24", "$25", "memory");
       }
@@ -2716,6 +3241,138 @@ struct kernel_statfs {
       }
       LSS_RETURN(int, __ret, __err);
     }
+  #elif defined(__s390__)
+    #undef  LSS_REG
+    #define LSS_REG(r, a) register unsigned long __r##r __asm__("r"#r) = (unsigned long) a
+    #undef  LSS_BODY
+    #define LSS_BODY(type, name, args...)                                     \
+        register unsigned long __nr __asm__("r1")                             \
+            = (unsigned long)(__NR_##name);                                   \
+        register long __res_r2 __asm__("r2");                                 \
+        long __res;                                                           \
+        __asm__ __volatile__                                                  \
+            ("svc 0\n\t"                                                      \
+             : "=d"(__res_r2)                                                 \
+             : "d"(__nr), ## args                                             \
+             : "memory");                                                     \
+        __res = __res_r2;                                                     \
+        LSS_RETURN(type, __res)
+    #undef _syscall0
+    #define _syscall0(type, name)                                             \
+       type LSS_NAME(name)(void) {                                            \
+          LSS_BODY(type, name);                                               \
+       }
+    #undef _syscall1
+    #define _syscall1(type, name, type1, arg1)                                \
+       type LSS_NAME(name)(type1 arg1) {                                      \
+          LSS_REG(2, arg1);                                                   \
+          LSS_BODY(type, name, "0"(__r2));                                    \
+       }
+    #undef _syscall2
+    #define _syscall2(type, name, type1, arg1, type2, arg2)                   \
+       type LSS_NAME(name)(type1 arg1, type2 arg2) {                          \
+          LSS_REG(2, arg1); LSS_REG(3, arg2);                                 \
+          LSS_BODY(type, name, "0"(__r2), "d"(__r3));                         \
+       }
+    #undef _syscall3
+    #define _syscall3(type, name, type1, arg1, type2, arg2, type3, arg3)      \
+       type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3) {              \
+          LSS_REG(2, arg1); LSS_REG(3, arg2); LSS_REG(4, arg3);               \
+          LSS_BODY(type, name, "0"(__r2), "d"(__r3), "d"(__r4));              \
+       }
+    #undef _syscall4
+    #define _syscall4(type, name, type1, arg1, type2, arg2, type3, arg3,      \
+                                  type4, arg4)                                \
+       type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3,                \
+                           type4 arg4) {                                      \
+          LSS_REG(2, arg1); LSS_REG(3, arg2); LSS_REG(4, arg3);               \
+          LSS_REG(5, arg4);                                                   \
+          LSS_BODY(type, name, "0"(__r2), "d"(__r3), "d"(__r4),               \
+                               "d"(__r5));                                    \
+       }
+    #undef _syscall5
+    #define _syscall5(type, name, type1, arg1, type2, arg2, type3, arg3,      \
+                                  type4, arg4, type5, arg5)                   \
+       type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3,                \
+                           type4 arg4, type5 arg5) {                          \
+          LSS_REG(2, arg1); LSS_REG(3, arg2); LSS_REG(4, arg3);               \
+          LSS_REG(5, arg4); LSS_REG(6, arg5);                                 \
+          LSS_BODY(type, name, "0"(__r2), "d"(__r3), "d"(__r4),               \
+                               "d"(__r5), "d"(__r6));                         \
+       }
+    #undef _syscall6
+    #define _syscall6(type, name, type1, arg1, type2, arg2, type3, arg3,      \
+                                  type4, arg4, type5, arg5, type6, arg6)      \
+       type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3,                \
+                           type4 arg4, type5 arg5, type6 arg6) {              \
+          LSS_REG(2, arg1); LSS_REG(3, arg2); LSS_REG(4, arg3);               \
+          LSS_REG(5, arg4); LSS_REG(6, arg5); LSS_REG(7, arg6);               \
+          LSS_BODY(type, name, "0"(__r2), "d"(__r3), "d"(__r4),               \
+                               "d"(__r5), "d"(__r6), "d"(__r7));              \
+       }
+    LSS_INLINE int LSS_NAME(clone)(int (*fn)(void *), void *child_stack,
+                                   int flags, void *arg, int *parent_tidptr,
+                                   void *newtls, int *child_tidptr) {
+      long __ret;
+      {
+        register int  (*__fn)(void *)    __asm__ ("r1")  = fn;
+        register void  *__cstack         __asm__ ("r2")  = child_stack;
+        register int    __flags          __asm__ ("r3")  = flags;
+        register void  *__arg            __asm__ ("r0")  = arg;
+        register int   *__ptidptr        __asm__ ("r4")  = parent_tidptr;
+        register void  *__newtls         __asm__ ("r6")  = newtls;
+        register int   *__ctidptr        __asm__ ("r5")  = child_tidptr;
+        __asm__ __volatile__ (
+    #ifndef __s390x__
+                                  /* arg already in r0 */
+          "ltr %4, %4\n\t"        /* check fn, which is already in r1 */
+          "jz 1f\n\t"             /* NULL function pointer, return -EINVAL */
+          "ltr %5, %5\n\t"        /* check child_stack, which is already in r2 */
+          "jz 1f\n\t"             /* NULL stack pointer, return -EINVAL */
+                                  /* flags already in r3 */
+                                  /* parent_tidptr already in r4 */
+                                  /* child_tidptr already in r5 */
+                                  /* newtls already in r6 */
+          "svc %2\n\t"            /* invoke clone syscall */
+          "ltr %0,%%r2\n\t"       /* load return code into __ret and test */
+          "jnz 1f\n\t"            /* return to parent if non-zero */
+                                  /* start child thread */
+          "lr %%r2, %7\n\t"       /* set first parameter to void *arg */
+          "ahi %%r15, -96\n\t"    /* make room on the stack for the save area */
+          "xc 0(4,%%r15), 0(%%r15)\n\t"
+          "basr %%r14, %4\n\t"    /* jump to fn */
+          "svc %3\n"              /* invoke exit syscall */
+          "1:\n"
+    #else
+                                  /* arg already in r0 */
+          "ltgr %4, %4\n\t"       /* check fn, which is already in r1 */
+          "jz 1f\n\t"             /* NULL function pointer, return -EINVAL */
+          "ltgr %5, %5\n\t"       /* check child_stack, which is already in r2 */
+          "jz 1f\n\t"             /* NULL stack pointer, return -EINVAL */
+                                  /* flags already in r3 */
+                                  /* parent_tidptr already in r4 */
+                                  /* child_tidptr already in r5 */
+                                  /* newtls already in r6 */
+          "svc %2\n\t"            /* invoke clone syscall */
+          "ltgr %0, %%r2\n\t"     /* load return code into __ret and test */
+          "jnz 1f\n\t"            /* return to parent if non-zero */
+                                  /* start child thread */
+          "lgr %%r2, %7\n\t"      /* set first parameter to void *arg */
+          "aghi %%r15, -160\n\t"  /* make room on the stack for the save area */
+          "xc 0(8,%%r15), 0(%%r15)\n\t"
+          "basr %%r14, %4\n\t"    /* jump to fn */
+          "svc %3\n"              /* invoke exit syscall */
+          "1:\n"
+    #endif
+          : "=r" (__ret)
+          : "0" (-EINVAL), "i" (__NR_clone), "i" (__NR_exit),
+            "d" (__fn), "d" (__cstack), "d" (__flags), "d" (__arg),
+            "d" (__ptidptr), "d" (__newtls), "d" (__ctidptr)
+          : "cc", "r14", "memory"
+        );
+      }
+      LSS_RETURN(int, __ret);
+    }
   #endif
   #define __NR__exit   __NR_exit
   #define __NR__gettid __NR_gettid
@@ -2728,15 +3385,24 @@ struct kernel_statfs {
   LSS_INLINE _syscall2(int,     clock_gettime,   int,         c,
                        struct kernel_timespec*, t)
   LSS_INLINE _syscall1(int,     dup,             int,         f)
-  LSS_INLINE _syscall2(int,     dup2,            int,         s,
-                       int,            d)
+  #if defined(__NR_dup2)
+    // dup2 is polyfilled below when not available.
+    LSS_INLINE _syscall2(int,     dup2,            int,         s,
+                         int,            d)
+  #endif
+  #if defined(__NR_dup3)
+    LSS_INLINE _syscall3(int, dup3,  int, s, int, d, int, f)
+  #endif
   LSS_INLINE _syscall3(int,     execve,          const char*, f,
                        const char*const*,a,const char*const*, e)
   LSS_INLINE _syscall1(int,     _exit,           int,         e)
   LSS_INLINE _syscall1(int,     exit_group,      int,         e)
   LSS_INLINE _syscall3(int,     fcntl,           int,         f,
                        int,            c, long,   a)
-  LSS_INLINE _syscall0(pid_t,   fork)
+  #if defined(__NR_fork)
+    // fork is polyfilled below when not available.
+    LSS_INLINE _syscall0(pid_t,   fork)
+  #endif
   LSS_INLINE _syscall2(int,     fstat,           int,         f,
                       struct kernel_stat*,   b)
   LSS_INLINE _syscall2(int,     fstatfs,         int,         f,
@@ -2750,16 +3416,19 @@ struct kernel_statfs {
     LSS_INLINE _syscall2(int, ftruncate,           int,         f,
                          off_t,          l)
   #endif
-  LSS_INLINE _syscall4(int,     futex,           int*,        a,
-                       int,            o, int,    v,
-                      struct kernel_timespec*, t)
+  LSS_INLINE _syscall6(int,     futex,          int*,        u,
+                       int,     o,              int,         v,
+                       struct kernel_timespec*, t,
+                       int*,    u2,             int,         v2)
   LSS_INLINE _syscall3(int,     getdents,        int,         f,
-                      struct kernel_dirent*, d, int,    c)
+                       struct kernel_dirent*, d, int,    c)
   LSS_INLINE _syscall3(int,     getdents64,      int,         f,
                       struct kernel_dirent64*, d, int,    c)
   LSS_INLINE _syscall0(gid_t,   getegid)
   LSS_INLINE _syscall0(uid_t,   geteuid)
-  LSS_INLINE _syscall0(pid_t,   getpgrp)
+  #if defined(__NR_getpgrp)
+    LSS_INLINE _syscall0(pid_t,   getpgrp)
+  #endif
   LSS_INLINE _syscall0(pid_t,   getpid)
   LSS_INLINE _syscall0(pid_t,   getppid)
   LSS_INLINE _syscall2(int,     getpriority,     int,         a,
@@ -2818,10 +3487,21 @@ struct kernel_statfs {
   LSS_INLINE _syscall5(void*,   _mremap,         void*,       o,
                        size_t,         os,       size_t,      ns,
                        unsigned long,  f, void *, a)
-  LSS_INLINE _syscall3(int,     open,            const char*, p,
-                       int,            f, int,    m)
-  LSS_INLINE _syscall3(int,     poll,           struct kernel_pollfd*, u,
-                       unsigned int,   n, int,    t)
+  #if defined(__NR_open)
+    // open is polyfilled below when not available.
+    LSS_INLINE _syscall3(int,     open,            const char*, p,
+                         int,            f, int,    m)
+  #endif
+  #if defined(__NR_poll)
+    // poll is polyfilled below when not available.
+    LSS_INLINE _syscall3(int,     poll,           struct kernel_pollfd*, u,
+                         unsigned int,   n, int,    t)
+  #endif
+  #if defined(__NR_ppoll)
+    LSS_INLINE _syscall5(int, ppoll, struct kernel_pollfd *, u,
+                         unsigned int, n, const struct kernel_timespec *, t,
+                         const struct kernel_sigset_t *, sigmask, size_t, s)
+  #endif
   LSS_INLINE _syscall5(int,     prctl,           int,         option,
                        unsigned long,  arg2,
                        unsigned long,  arg3,
@@ -2836,8 +3516,15 @@ struct kernel_statfs {
   #endif
   LSS_INLINE _syscall3(ssize_t, read,            int,         f,
                        void *,         b, size_t, c)
-  LSS_INLINE _syscall3(int,     readlink,        const char*, p,
-                       char*,          b, size_t, s)
+  #if defined(__NR_readlink)
+    // readlink is polyfilled below when not available.
+    LSS_INLINE _syscall3(int,     readlink,        const char*, p,
+                         char*,          b, size_t, s)
+  #endif
+  #if defined(__NR_readlinkat)
+    LSS_INLINE _syscall4(int, readlinkat, int, d, const char *, p, char *, b,
+                         size_t, s)
+  #endif
   LSS_INLINE _syscall4(int,     rt_sigaction,    int,         s,
                        const struct kernel_sigaction*, a,
                        struct kernel_sigaction*, o, size_t,   c)
@@ -2848,6 +3535,8 @@ struct kernel_statfs {
                        struct kernel_sigset_t*,        o, size_t, c)
   LSS_INLINE _syscall2(int, rt_sigsuspend,
                        const struct kernel_sigset_t*, s,  size_t, c)
+  LSS_INLINE _syscall4(int, rt_sigtimedwait, const struct kernel_sigset_t*, s,
+                       siginfo_t*, i, const struct timespec*, t, size_t, c)
   LSS_INLINE _syscall3(int,     sched_getaffinity,pid_t,      p,
                        unsigned int,   l, unsigned long *, m)
   LSS_INLINE _syscall3(int,     sched_setaffinity,pid_t,      p,
@@ -2872,17 +3561,23 @@ struct kernel_statfs {
   LSS_INLINE _syscall2(int,     sigaltstack,     const stack_t*, s,
                        const stack_t*, o)
   #if defined(__NR_sigreturn)
-  LSS_INLINE _syscall1(int,     sigreturn,       unsigned long, u)
+    LSS_INLINE _syscall1(int,     sigreturn,       unsigned long, u)
+  #endif
+  #if defined(__NR_stat)
+    // stat is polyfilled below when not available.
+    LSS_INLINE _syscall2(int,     stat,            const char*, f,
+                        struct kernel_stat*,   b)
   #endif
-  LSS_INLINE _syscall2(int,     stat,            const char*, f,
-                      struct kernel_stat*,   b)
   LSS_INLINE _syscall2(int,     statfs,          const char*, f,
                       struct kernel_statfs*, b)
   LSS_INLINE _syscall3(int,     tgkill,          pid_t,       p,
                        pid_t,          t, int,            s)
   LSS_INLINE _syscall2(int,     tkill,           pid_t,       p,
                        int,            s)
-  LSS_INLINE _syscall1(int,     unlink,           const char*, f)
+  #if defined(__NR_unlink)
+    // unlink is polyfilled below when not available.
+    LSS_INLINE _syscall1(int,     unlink,           const char*, f)
+  #endif
   LSS_INLINE _syscall3(ssize_t, write,            int,        f,
                        const void *,   b, size_t, c)
   LSS_INLINE _syscall3(ssize_t, writev,           int,        f,
@@ -2908,14 +3603,89 @@ struct kernel_statfs {
     LSS_INLINE _syscall4(int, socketpair,         int,   d,
                          int,                     t, int,       p, int*, s)
   #endif
-  #if defined(__x86_64__)
+  #if defined(__NR_fadvise64)
+    #if defined(__x86_64__)
+    /* Need to make sure loff_t isn't truncated to 32-bits under x32.  */
+    LSS_INLINE int LSS_NAME(fadvise64)(int fd, loff_t offset, loff_t len,
+                                       int advice) {
+      LSS_BODY(4, int, fadvise64, LSS_SYSCALL_ARG(fd), (uint64_t)(offset),
+                                  (uint64_t)(len), LSS_SYSCALL_ARG(advice));
+    }
+    #else
+    LSS_INLINE _syscall4(int, fadvise64,
+                         int, fd, loff_t, offset, loff_t, len, int, advice)
+    #endif
+  #elif defined(__i386__)
+    #define __NR__fadvise64_64 __NR_fadvise64_64
+    LSS_INLINE _syscall6(int, _fadvise64_64, int, fd,
+                         unsigned, offset_lo, unsigned, offset_hi,
+                         unsigned, len_lo, unsigned, len_hi,
+                         int, advice)
+
+    LSS_INLINE int LSS_NAME(fadvise64)(int fd, loff_t offset,
+                                       loff_t len, int advice) {
+      return LSS_NAME(_fadvise64_64)(fd,
+                                     (unsigned)offset, (unsigned)(offset >>32),
+                                     (unsigned)len, (unsigned)(len >> 32),
+                                     advice);
+    }
+
+  #elif defined(__s390__) && !defined(__s390x__)
+    #define __NR__fadvise64_64 __NR_fadvise64_64
+    struct kernel_fadvise64_64_args {
+      int fd;
+      long long offset;
+      long long len;
+      int advice;
+    };
+
+    LSS_INLINE _syscall1(int, _fadvise64_64,
+                         struct kernel_fadvise64_64_args *args)
+
+    LSS_INLINE int LSS_NAME(fadvise64)(int fd, loff_t offset,
+                                       loff_t len, int advice) {
+      struct kernel_fadvise64_64_args args = { fd, offset, len, advice };
+      return LSS_NAME(_fadvise64_64)(&args);
+    }
+  #endif
+  #if defined(__NR_fallocate)
+    #if defined(__x86_64__)
     /* Need to make sure loff_t isn't truncated to 32-bits under x32.  */
     LSS_INLINE int LSS_NAME(fallocate)(int f, int mode, loff_t offset,
                                        loff_t len) {
       LSS_BODY(4, int, fallocate, LSS_SYSCALL_ARG(f), LSS_SYSCALL_ARG(mode),
                                   (uint64_t)(offset), (uint64_t)(len));
     }
+    #elif (defined(__i386__) || (defined(__s390__) && !defined(__s390x__)) \
+           || defined(__ARM_ARCH_3__) || defined(__ARM_EABI__) \
+           || (defined(__mips__) && _MIPS_SIM == _MIPS_SIM_ABI32) \
+           || defined(__PPC__))
+    #define __NR__fallocate __NR_fallocate
+    LSS_INLINE _syscall6(int, _fallocate, int, fd,
+                         int, mode,
+                         unsigned, offset_lo, unsigned, offset_hi,
+                         unsigned, len_lo, unsigned, len_hi)
 
+    LSS_INLINE int LSS_NAME(fallocate)(int fd, int mode,
+                                       loff_t offset, loff_t len) {
+      union { loff_t off; unsigned w[2]; } o = { offset }, l = { len };
+      return LSS_NAME(_fallocate)(fd, mode, o.w[0], o.w[1], l.w[0], l.w[1]);
+    }
+    #else
+    LSS_INLINE _syscall4(int, fallocate,
+                         int, f, int, mode, loff_t, offset, loff_t, len)
+    #endif
+  #endif
+  #if defined(__NR_getrandom)
+    LSS_INLINE _syscall3(ssize_t, getrandom, void*, buffer, size_t, length,
+                         unsigned int, flags)
+  #endif
+  #if defined(__NR_newfstatat)
+    LSS_INLINE _syscall4(int, newfstatat,         int,   d,
+                         const char *,            p,
+                         struct kernel_stat*,     b, int, f)
+  #endif
+  #if defined(__x86_64__) || defined(__s390x__)
     LSS_INLINE int LSS_NAME(getresgid32)(gid_t *rgid,
                                          gid_t *egid,
                                          gid_t *sgid) {
@@ -2928,18 +3698,6 @@ struct kernel_statfs {
       return LSS_NAME(getresuid)(ruid, euid, suid);
     }
 
-    /* Need to make sure __off64_t isn't truncated to 32-bits under x32.  */
-    LSS_INLINE void* LSS_NAME(mmap)(void *s, size_t l, int p, int f, int d,
-                                    __off64_t o) {
-      LSS_BODY(6, void*, mmap, LSS_SYSCALL_ARG(s), LSS_SYSCALL_ARG(l),
-                               LSS_SYSCALL_ARG(p), LSS_SYSCALL_ARG(f),
-                               LSS_SYSCALL_ARG(d), (uint64_t)(o));
-    }
-
-    LSS_INLINE _syscall4(int, newfstatat,         int,   d,
-                         const char *,            p,
-                        struct kernel_stat*,       b, int, f)
-
     LSS_INLINE int LSS_NAME(setfsgid32)(gid_t gid) {
       return LSS_NAME(setfsgid)(gid);
     }
@@ -2959,6 +3717,7 @@ struct kernel_statfs {
     LSS_INLINE int LSS_NAME(sigaction)(int signum,
                                        const struct kernel_sigaction *act,
                                        struct kernel_sigaction *oldact) {
+      #if defined(__x86_64__)
       /* On x86_64, the kernel requires us to always set our own
        * SA_RESTORER in order to be able to return from a signal handler.
        * This function must have a "magic" signature that the "gdb"
@@ -2970,42 +3729,47 @@ struct kernel_statfs {
         a.sa_restorer = LSS_NAME(restore_rt)();
         return LSS_NAME(rt_sigaction)(signum, &a, oldact,
                                       (KERNEL_NSIG+7)/8);
-      } else {
+      } else
+      #endif
         return LSS_NAME(rt_sigaction)(signum, act, oldact,
                                       (KERNEL_NSIG+7)/8);
-      }
     }
 
     LSS_INLINE int LSS_NAME(sigpending)(struct kernel_sigset_t *set) {
       return LSS_NAME(rt_sigpending)(set, (KERNEL_NSIG+7)/8);
     }
 
+    LSS_INLINE int LSS_NAME(sigsuspend)(const struct kernel_sigset_t *set) {
+      return LSS_NAME(rt_sigsuspend)(set, (KERNEL_NSIG+7)/8);
+    }
+  #endif
+  #if defined(__NR_rt_sigprocmask)
     LSS_INLINE int LSS_NAME(sigprocmask)(int how,
                                          const struct kernel_sigset_t *set,
                                          struct kernel_sigset_t *oldset) {
       return LSS_NAME(rt_sigprocmask)(how, set, oldset, (KERNEL_NSIG+7)/8);
     }
-
-    LSS_INLINE int LSS_NAME(sigsuspend)(const struct kernel_sigset_t *set) {
-      return LSS_NAME(rt_sigsuspend)(set, (KERNEL_NSIG+7)/8);
+  #endif
+  #if defined(__NR_rt_sigtimedwait)
+    LSS_INLINE int LSS_NAME(sigtimedwait)(const struct kernel_sigset_t *set,
+                                          siginfo_t *info,
+                                          const struct timespec *timeout) {
+      return LSS_NAME(rt_sigtimedwait)(set, info, timeout, (KERNEL_NSIG+7)/8);
     }
   #endif
-  #if defined(__x86_64__) || defined(__ARM_ARCH_3__) ||                       \
-      defined(__ARM_EABI__) ||                                             \
-     (defined(__mips__) && _MIPS_SIM != _MIPS_SIM_ABI32)
+  #if defined(__NR_wait4)
     LSS_INLINE _syscall4(pid_t, wait4,            pid_t, p,
                          int*,                    s, int,       o,
                         struct kernel_rusage*,     r)
-
-    LSS_INLINE pid_t LSS_NAME(waitpid)(pid_t pid, int *status, int options){
-      return LSS_NAME(wait4)(pid, status, options, 0);
-    }
   #endif
-  #if defined(__i386__) || defined(__x86_64__)
+  #if defined(__NR_openat)
     LSS_INLINE _syscall4(int, openat, int, d, const char *, p, int, f, int, m)
+  #endif
+  #if defined(__NR_unlinkat)
     LSS_INLINE _syscall3(int, unlinkat, int, d, const char *, p, int, f)
   #endif
-  #if defined(__i386__) || defined(__ARM_ARCH_3__) || defined(__ARM_EABI__)
+  #if defined(__i386__) || defined(__ARM_ARCH_3__) || defined(__ARM_EABI__) || \
+      (defined(__s390__) && !defined(__s390x__))
     #define __NR__getresgid32 __NR_getresgid32
     #define __NR__getresuid32 __NR_getresuid32
     #define __NR__setfsgid32  __NR_setfsgid32
@@ -3159,12 +3923,13 @@ struct kernel_statfs {
                 (1UL << ((signum - 1) % (8*sizeof(set->sig[0])))));
     }
   }
-  #if defined(__i386__) || defined(__ARM_ARCH_3__) ||                         \
-      defined(__ARM_EABI__) ||                                             \
-     (defined(__mips__) && _MIPS_SIM == _MIPS_SIM_ABI32) || defined(__PPC__)
+  #if defined(__i386__) ||                                                    \
+      defined(__ARM_ARCH_3__) || defined(__ARM_EABI__) ||                     \
+     (defined(__mips__) && _MIPS_SIM == _MIPS_SIM_ABI32) ||                   \
+      defined(__PPC__) ||                                                     \
+     (defined(__s390__) && !defined(__s390x__))
     #define __NR__sigaction   __NR_sigaction
     #define __NR__sigpending  __NR_sigpending
-    #define __NR__sigprocmask __NR_sigprocmask
     #define __NR__sigsuspend  __NR_sigsuspend
     #define __NR__socketcall  __NR_socketcall
     LSS_INLINE _syscall2(int, fstat64,             int, f,
@@ -3172,20 +3937,27 @@ struct kernel_statfs {
     LSS_INLINE _syscall5(int, _llseek,     uint, fd,
                          unsigned long, hi, unsigned long, lo,
                          loff_t *, res, uint, wh)
-#if !defined(__ARM_EABI__)
-    LSS_INLINE _syscall1(void*, mmap,              void*, a)
-#endif
-    LSS_INLINE _syscall6(void*, mmap2,             void*, s,
+#if defined(__s390__) && !defined(__s390x__)
+    /* On s390, mmap2() arguments are passed in memory. */
+    LSS_INLINE void* LSS_NAME(_mmap2)(void *s, size_t l, int p, int f, int d,
+                                      off_t o) {
+      unsigned long buf[6] = { (unsigned long) s, (unsigned long) l,
+                               (unsigned long) p, (unsigned long) f,
+                               (unsigned long) d, (unsigned long) o };
+      LSS_REG(2, buf);
+      LSS_BODY(void*, mmap2, "0"(__r2));
+    }
+#else
+    #define __NR__mmap2 __NR_mmap2
+    LSS_INLINE _syscall6(void*, _mmap2,            void*, s,
                          size_t,                   l, int,               p,
                          int,                      f, int,               d,
-                         off_t,                o)
+                         off_t,                    o)
+#endif
     LSS_INLINE _syscall3(int,   _sigaction,        int,   s,
                          const struct kernel_old_sigaction*,  a,
                          struct kernel_old_sigaction*,        o)
     LSS_INLINE _syscall1(int,   _sigpending, unsigned long*, s)
-    LSS_INLINE _syscall3(int,   _sigprocmask,      int,   h,
-                         const unsigned long*,     s,
-                         unsigned long*,           o)
     #ifdef __PPC__
     LSS_INLINE _syscall1(int, _sigsuspend,         unsigned long, s)
     #else
@@ -3269,23 +4041,6 @@ struct kernel_statfs {
       return rc;
     }
 
-    LSS_INLINE int LSS_NAME(sigprocmask)(int how,
-                                         const struct kernel_sigset_t *set,
-                                         struct kernel_sigset_t *oldset) {
-      int olderrno = LSS_ERRNO;
-      int rc = LSS_NAME(rt_sigprocmask)(how, set, oldset, (KERNEL_NSIG+7)/8);
-      if (rc < 0 && LSS_ERRNO == ENOSYS) {
-        LSS_ERRNO = olderrno;
-        if (oldset) {
-          LSS_NAME(sigemptyset)(oldset);
-        }
-        rc = LSS_NAME(_sigprocmask)(how,
-                                    set ? &set->sig[0] : NULL,
-                                    oldset ? &oldset->sig[0] : NULL);
-      }
-      return rc;
-    }
-
     LSS_INLINE int LSS_NAME(sigsuspend)(const struct kernel_sigset_t *set) {
       int olderrno = LSS_ERRNO;
       int rc = LSS_NAME(rt_sigsuspend)(set, (KERNEL_NSIG+7)/8);
@@ -3300,6 +4055,43 @@ struct kernel_statfs {
       return rc;
     }
   #endif
+  #if defined(__i386__) ||                                                    \
+      defined(__ARM_ARCH_3__) || defined(__ARM_EABI__) ||                     \
+     (defined(__mips__) && _MIPS_SIM == _MIPS_SIM_ABI32) ||                   \
+      defined(__PPC__) ||                                                     \
+     (defined(__s390__) && !defined(__s390x__))
+    /* On these architectures, implement mmap() with mmap2(). */
+    LSS_INLINE void* LSS_NAME(mmap)(void *s, size_t l, int p, int f, int d,
+                                    int64_t o) {
+      if (o % 4096) {
+        LSS_ERRNO = EINVAL;
+        return (void *) -1;
+      }
+      return LSS_NAME(_mmap2)(s, l, p, f, d, (o / 4096));
+    }
+  #elif defined(__s390x__)
+    /* On s390x, mmap() arguments are passed in memory. */
+    LSS_INLINE void* LSS_NAME(mmap)(void *s, size_t l, int p, int f, int d,
+                                    int64_t o) {
+      unsigned long buf[6] = { (unsigned long) s, (unsigned long) l,
+                               (unsigned long) p, (unsigned long) f,
+                               (unsigned long) d, (unsigned long) o };
+      LSS_REG(2, buf);
+      LSS_BODY(void*, mmap, "0"(__r2));
+    }
+  #elif defined(__x86_64__)
+    /* Need to make sure __off64_t isn't truncated to 32-bits under x32.  */
+    LSS_INLINE void* LSS_NAME(mmap)(void *s, size_t l, int p, int f, int d,
+                                    int64_t o) {
+      LSS_BODY(6, void*, mmap, LSS_SYSCALL_ARG(s), LSS_SYSCALL_ARG(l),
+                               LSS_SYSCALL_ARG(p), LSS_SYSCALL_ARG(f),
+                               LSS_SYSCALL_ARG(d), (uint64_t)(o));
+    }
+  #else
+    /* Remaining 64-bit architectures. */
+    LSS_INLINE _syscall6(void*, mmap, void*, addr, size_t, length, int, prot,
+                         int, flags, int, fd, int64_t, offset)
+  #endif
   #if defined(__PPC__)
     #undef LSS_SC_LOADARGS_0
     #define LSS_SC_LOADARGS_0(dummy...)
@@ -3389,7 +4181,7 @@ struct kernel_statfs {
       LSS_SC_BODY(4, int, 8, d, type, protocol, sv);
     }
   #endif
-  #if defined(__ARM_EABI__)
+  #if defined(__ARM_EABI__) || defined (__aarch64__)
     LSS_INLINE _syscall3(ssize_t, recvmsg, int, s, struct kernel_msghdr*, msg,
                          int, flags)
     LSS_INLINE _syscall3(ssize_t, sendmsg, int, s, const struct kernel_msghdr*,
@@ -3403,7 +4195,8 @@ struct kernel_statfs {
                          int*, sv)
   #endif
   #if defined(__i386__) || defined(__ARM_ARCH_3__) ||                         \
-      (defined(__mips__) && _MIPS_SIM == _MIPS_SIM_ABI32)
+      (defined(__mips__) && _MIPS_SIM == _MIPS_SIM_ABI32) ||                  \
+      defined(__s390__)
     #define __NR__socketcall  __NR_socketcall
     LSS_INLINE _syscall2(int,      _socketcall,    int,   c,
                          va_list,                  a)
@@ -3447,13 +4240,13 @@ struct kernel_statfs {
       return LSS_NAME(socketcall)(8, d, type, protocol, sv);
     }
   #endif
-  #if defined(__i386__) || defined(__PPC__)
+  #if defined(__NR_fstatat64)
     LSS_INLINE _syscall4(int,   fstatat64,        int,   d,
                          const char *,      p,
                          struct kernel_stat64 *,   b,    int,   f)
   #endif
-  #if defined(__i386__) || defined(__PPC__) ||                                \
-     (defined(__mips__) && _MIPS_SIM == _MIPS_SIM_ABI32)
+  #if defined(__NR_waitpid)
+    // waitpid is polyfilled below when not available.
     LSS_INLINE _syscall3(pid_t, waitpid,          pid_t, p,
                          int*,              s,    int,   o)
   #endif
@@ -3466,7 +4259,7 @@ struct kernel_statfs {
       register unsigned long __v1 __asm__("$3");
       register unsigned long __r7 __asm__("$7");
       __asm__ __volatile__ ("syscall\n"
-                            : "+r"(__v0), "=r"(__v1), "=r" (__r7)
+                            : "=r"(__v0), "=r"(__v1), "=r" (__r7)
                             : "0"(__v0)
                             : "$8", "$9", "$10", "$11", "$12",
                               "$13", "$14", "$15", "$24", "$25", "memory");
@@ -3480,13 +4273,18 @@ struct kernel_statfs {
         return 0;
       }
     }
-  #else
+  #elif defined(__NR_pipe)
+    // pipe is polyfilled below when not available.
     LSS_INLINE _syscall1(int,     pipe,           int *, p)
   #endif
+  #if defined(__NR_pipe2)
+    LSS_INLINE _syscall2(int, pipe2, int *, pipefd, int, flags)
+  #endif
   /* TODO(csilvers): see if ppc can/should support this as well              */
   #if defined(__i386__) || defined(__ARM_ARCH_3__) ||                         \
-      defined(__ARM_EABI__) ||                                             \
-     (defined(__mips__) && _MIPS_SIM != _MIPS_SIM_ABI64)
+      defined(__ARM_EABI__) ||                                                \
+     (defined(__mips__) && _MIPS_SIM != _MIPS_SIM_ABI64) ||                   \
+     (defined(__s390__) && !defined(__s390x__))
     #define __NR__statfs64  __NR_statfs64
     #define __NR__fstatfs64 __NR_fstatfs64
     LSS_INLINE _syscall3(int, _statfs64,     const char*, p,
@@ -3558,26 +4356,6 @@ struct kernel_statfs {
     return LSS_NAME(setpgid)(0, 0);
   }
 
-  LSS_INLINE int LSS_NAME(sysconf)(int name) {
-    extern int __getpagesize(void);
-    switch (name) {
-      case _SC_OPEN_MAX: {
-        struct kernel_rlimit limit;
-#if defined(__ARM_EABI__)
-        return LSS_NAME(ugetrlimit)(RLIMIT_NOFILE, &limit) < 0
-            ? 8192 : limit.rlim_cur;
-#else
-        return LSS_NAME(getrlimit)(RLIMIT_NOFILE, &limit) < 0
-            ? 8192 : limit.rlim_cur;
-#endif
-      }
-      case _SC_PAGESIZE:
-        return __getpagesize();
-      default:
-        LSS_ERRNO = ENOSYS;
-        return -1;
-    }
-  }
   #if defined(__x86_64__)
     /* Need to make sure loff_t isn't truncated to 32-bits under x32.  */
     LSS_INLINE ssize_t LSS_NAME(pread64)(int f, void *b, size_t c, loff_t o) {
@@ -3658,14 +4436,120 @@ struct kernel_statfs {
   #endif
 #endif
 
-#ifdef __ANDROID__
-  /* These restore the original values of these macros saved by the
-   * corresponding #pragma push_macro near the top of this file. */
-# pragma pop_macro("stat64")
-# pragma pop_macro("fstat64")
-# pragma pop_macro("lstat64")
+/*
+ * Polyfills for deprecated syscalls.
+ */
+
+#if !defined(__NR_dup2)
+  LSS_INLINE int LSS_NAME(dup2)(int s, int d) {
+    return LSS_NAME(dup3)(s, d, 0);
+  }
+#endif
+
+#if !defined(__NR_open)
+  LSS_INLINE int LSS_NAME(open)(const char *pathname, int flags, int mode) {
+    return LSS_NAME(openat)(AT_FDCWD, pathname, flags, mode);
+  }
+#endif
+
+#if !defined(__NR_unlink)
+  LSS_INLINE int LSS_NAME(unlink)(const char *pathname) {
+    return LSS_NAME(unlinkat)(AT_FDCWD, pathname, 0);
+  }
+#endif
+
+#if !defined(__NR_readlink)
+  LSS_INLINE int LSS_NAME(readlink)(const char *pathname, char *buffer,
+                                    size_t size) {
+    return LSS_NAME(readlinkat)(AT_FDCWD, pathname, buffer, size);
+  }
 #endif
 
+#if !defined(__NR_pipe)
+  LSS_INLINE int LSS_NAME(pipe)(int *pipefd) {
+    return LSS_NAME(pipe2)(pipefd, 0);
+  }
+#endif
+
+#if !defined(__NR_poll)
+  LSS_INLINE int LSS_NAME(poll)(struct kernel_pollfd *fds, unsigned int nfds,
+                                int timeout) {
+   struct kernel_timespec timeout_ts;
+   struct kernel_timespec *timeout_ts_p = NULL;
+
+    if (timeout >= 0) {
+      timeout_ts.tv_sec = timeout / 1000;
+      timeout_ts.tv_nsec = (timeout % 1000) * 1000000;
+      timeout_ts_p = &timeout_ts;
+    }
+    return LSS_NAME(ppoll)(fds, nfds, timeout_ts_p, NULL, 0);
+  }
+#endif
+
+#if !defined(__NR_stat)
+  LSS_INLINE int LSS_NAME(stat)(const char *pathname,
+                                struct kernel_stat *buf) {
+    return LSS_NAME(newfstatat)(AT_FDCWD, pathname, buf, 0);
+  }
+#endif
+
+#if !defined(__NR_waitpid)
+  LSS_INLINE pid_t LSS_NAME(waitpid)(pid_t pid, int *status, int options) {
+    return LSS_NAME(wait4)(pid, status, options, 0);
+  }
+#endif
+
+#if !defined(__NR_fork)
+// TODO: define this in an arch-independant way instead of inlining the clone
+//       syscall body.
+
+# if defined(__aarch64__)
+  LSS_INLINE pid_t LSS_NAME(fork)(void) {
+    // No fork syscall on aarch64 - implement by means of the clone syscall.
+    // Note that this does not reset glibc's cached view of the PID/TID, so
+    // some glibc interfaces might go wrong in the forked subprocess.
+    int flags = SIGCHLD;
+    void *child_stack = NULL;
+    void *parent_tidptr = NULL;
+    void *newtls = NULL;
+    void *child_tidptr = NULL;
+
+    LSS_REG(0, flags);
+    LSS_REG(1, child_stack);
+    LSS_REG(2, parent_tidptr);
+    LSS_REG(3, newtls);
+    LSS_REG(4, child_tidptr);
+    LSS_BODY(pid_t, clone, "r"(__r0), "r"(__r1), "r"(__r2), "r"(__r3),
+             "r"(__r4));
+  }
+# elif defined(__x86_64__)
+  LSS_INLINE pid_t LSS_NAME(fork)(void) {
+    // Android disallows the fork syscall on x86_64 - implement by means of the
+    // clone syscall as above for aarch64.
+    int flags = SIGCHLD;
+    void *child_stack = NULL;
+    void *parent_tidptr = NULL;
+    void *newtls = NULL;
+    void *child_tidptr = NULL;
+
+    LSS_BODY(5, pid_t, clone, LSS_SYSCALL_ARG(flags),
+             LSS_SYSCALL_ARG(child_stack), LSS_SYSCALL_ARG(parent_tidptr),
+             LSS_SYSCALL_ARG(newtls), LSS_SYSCALL_ARG(child_tidptr));
+  }
+# else
+#  error missing fork polyfill for this architecture
+# endif
+#endif
+
+/* These restore the original values of these macros saved by the
+ * corresponding #pragma push_macro near the top of this file. */
+#pragma pop_macro("stat64")
+#pragma pop_macro("fstat64")
+#pragma pop_macro("lstat64")
+#pragma pop_macro("pread64")
+#pragma pop_macro("pwrite64")
+#pragma pop_macro("getdents64")
+
 #if defined(__cplusplus) && !defined(SYS_CPLUSPLUS)
 }
 #endif
-- 
2.31.1.windows.1

